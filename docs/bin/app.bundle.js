/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var eslint = __webpack_require__(1);
	var googlejsPlugin = __webpack_require__(394);
	var googlejsBase = __webpack_require__(401);
	var googlejsEs5 = __webpack_require__(400);
	var googlejsEs6 = __webpack_require__(400);
	
	console.log('googlejsES6', googlejsEs6);
	console.log('googlejsES5', googlejsEs5);
	console.log('googlejsBase', googlejsBase);
	
	var EDITOR_TEXT_AREA_ELEMENT = document.getElementById('editor');
	var EDITOR = CodeMirror.fromTextArea(EDITOR_TEXT_AREA_ELEMENT, {
	  mode: 'javascript'
	});
	
	var CSS_CLASS_WARNING = 'editor-warning';
	var CSS_CLASS_ERROR = 'editor-error';
	
	// Expose the EDITOR for easy access.
	window.EDITOR = EDITOR;
	
	// TODO: Manually merge es5 and es6 configs with base.  ESLint only seems to do
	// it for files.
	
	var OPTIONS = googlejsBase;
	
	window.eslint = eslint;
	
	function debounce(func, wait, immediate) {
	  var timeout = void 0;
	  return function () {
	    var context = this;
	    var args = arguments;
	    var later = function later() {
	      timeout = null;
	      if (!immediate) func.apply(context, args);
	    };
	    var callNow = immediate && !timeout;
	    clearTimeout(timeout);
	    timeout = setTimeout(later, wait);
	    if (callNow) func.apply(context, args);
	  };
	}
	
	function makeResultNode(options) {
	  var result = document.createElement('div');
	  var classList = result.classList;
	
	  classList.add('alert');
	
	  if (options.fatal) {
	    classList.add('alert-danger');
	  }
	
	  if (options.hasOwnProperty('severity')) {
	    if (options.severity === 1) {
	      classList.add('alert-warning');
	    } else if (options.severity === 2) {
	      classList.add('alert-danger');
	    }
	  } else {
	    classList.add('alert-success');
	  }
	
	  if (options.hasOwnProperty('column') && options.hasOwnProperty('line') && options.hasOwnProperty('message')) {
	
	    // TODO: Add goto error
	    result.onclick = null;
	    // (function(EDITOR, options) {
	    //   EDITOR.onGotoLine(
	    //       options.line - 1, options.column - 1, options.column - 1);
	    // }).bind(null, EDITOR, options);
	
	    result.innerHTML = options.line + ':' + options.column + ' - ' + options.message + ' (<a href="http://eslint.org/docs/rules/' + options.ruleId + '">' + options.ruleId + '</a>)';
	    result.setAttribute('title', options.message);
	  } else if (options.hasOwnProperty('message')) {
	    result.textContent = 'Lint-free!';
	  }
	
	  return result;
	}
	
	function saveConfig() {
	  var environments = {};
	  var rules = {};
	  var ecmaFeatures = {};
	  $('.ecmaFeatures input').each(function () {
	    var name = $(this).attr('id');
	    var value = $(this).is(':checked');
	    ecmaFeatures[name] = value;
	  });
	  $('.environments input').each(function () {
	    var name = $(this).attr('id');
	    var value = $(this).is(':checked');
	    environments[name] = value;
	  });
	  $('.rules input').each(function () {
	    var name = $(this).attr('id');
	    var value = $(this).is(':checked') ? 2 : 0;
	    rules[name] = value;
	  });
	
	  OPTIONS.rules = rules;
	  OPTIONS.env = environments;
	  OPTIONS.ecmaFeatures = ecmaFeatures;
	  localStorage.rules = JSON.stringify(rules);
	  localStorage.ecmaFeatures = JSON.stringify(ecmaFeatures);
	  localStorage.env = JSON.stringify(environments);
	  verify();
	}
	
	function saveConfigAndClose() {
	  saveConfig();
	  $('#configuration').collapse('hide');
	}
	
	function removeWarningsErrors() {
	  EDITOR.getAllMarks().forEach(function (mark) {
	    mark.clear();
	  });
	}
	
	function messageSeverityCssClass(eslintMessage) {
	  if (eslintMessage.severty == 2) {
	    return CSS_CLASS_ERROR;
	  } else {
	    return CSS_CLASS_WARNING;
	  }
	}
	
	function addWarningsErrors(eslintMessages) {
	  eslintMessages.forEach(function (message) {
	    // ESLint is 1 based, CodeMirror is 0 based.
	    // TODO: handle cases wh
	    var line = message.line - 1;
	    var startColumn = message.column - 1;
	    var endColumn = startColumn + 1;
	    var className = messageSeverityCssClass(message);
	    // TODO: add description on hover
	    var description = message.message + ' (' + message.ruleId + ')';
	
	    var markStart = { line: line, ch: startColumn };
	    var markEnd = { line: line, ch: endColumn };
	    var markOptions = { className: className };
	
	    EDITOR.markText(markStart, markEnd, markOptions);
	  });
	}
	
	function displayResults(results) {
	  var resultsNode = document.getElementById('results');
	
	  var nodes = Array.from(resultsNode.childNodes);
	  nodes.forEach(resultsNode.removeChild.bind(resultsNode));
	
	  if (results.length === 0) {
	    var resultNode = makeResultNode({ message: 'Lint-free!' });
	    resultsNode.appendChild(resultNode);
	  } else {
	    results.forEach(function (result) {
	      var resultNode = makeResultNode(result);
	      resultsNode.appendChild(resultNode);
	    });
	  }
	
	  removeWarningsErrors();
	  addWarningsErrors(results);
	}
	
	function addPopover(checkbox, rule) {
	  // checkbox.popover({
	  //   title: rule,
	  //   content() {
	  //     const me = $(this);
	  //     if (me.data('content')) {
	  //       return me.data('content');
	  //     } else {
	  //       $.ajax({
	  //         url: '/docs/rules/' + me.text() + '.html',
	  //         method: 'GET',
	  //         success(data) {
	  //           const html = $(data);
	  //           const firstParagraph = html.find('p:first');
	  //           $('.popover-content').html(firstParagraph);
	  //           me.data('content', firstParagraph);
	  //         },
	  //       });
	  //       return 'Loading...';
	  //     }
	  //   },
	  //   placement(popover, checkbox) {
	  //     return $(checkbox).offset().left < 270 ? 'right' : 'left';
	  //   },
	  //   html: true,
	  // });
	  // checkbox.on('mouseenter', function() { $(this).popover('show'); });
	  // checkbox.on('mouseleave', function() { $(this).popover('hide'); });
	}
	
	function populateConfiguration(rules, environments, ecmaFeatures) {
	  var checkbox = void 0;
	  var parent = void 0;
	
	  // ecmaFeatures
	  for (var feature in ecmaFeatures) {
	    checkbox = $('<div class="checkbox-inline"><label><input class="feature" type="checkbox" />' + feature + '</label></div>');
	    $('input', checkbox).attr('id', feature).prop('checked', ecmaFeatures[feature]);
	    $('.ecmaFeatures .list').append(checkbox);
	  }
	
	  // environments
	  for (var env in environments) {
	    checkbox = $('<div class="checkbox-inline"><label><input type="checkbox" />' + env + '</label></div>');
	    $('input', checkbox).attr('id', env).prop('checked', environments[env]);
	    $('.environments .list').append(checkbox);
	  }
	
	  // rules
	  Object.keys(rules).forEach(function (rule, i, keys) {
	    var limit = Math.ceil(keys.length / 3);
	    if (i % limit === 0) {
	      parent = $('<div class="col-md-4"></div>');
	      $('.rules').append(parent);
	    }
	    checkbox = $('<div class="checkbox"><label><input type="checkbox" />' + rule + '</label></div>');
	    addPopover(checkbox, rule);
	    $('input', checkbox).attr('id', rule).prop('checked', rules[rule] !== 0);
	    parent.append(checkbox);
	  });
	
	  $('#configuration').on('change', 'input[type=checkbox]', saveConfig);
	  $('#configuration .btn').click(saveConfigAndClose);
	}
	
	// if (localStorage.rules) {
	//   OPTIONS.rules = JSON.parse(localStorage.rules);
	// }
	// if (localStorage.env) {
	//   OPTIONS.env = JSON.parse(localStorage.env);
	// }
	// if (localStorage.ecmaFeatures) {
	//   OPTIONS.ecmaFeatures = JSON.parse(localStorage.ecmaFeatures);
	// }
	
	// ensure certain environments are available
	OPTIONS.env = OPTIONS.env || {};
	OPTIONS.env.node = OPTIONS.env.node || false;
	OPTIONS.env.browser = OPTIONS.env.browser || false;
	OPTIONS.env.amd = OPTIONS.env.amd || false;
	OPTIONS.env.mocha = OPTIONS.env.mocha || false;
	OPTIONS.env.jasmine = OPTIONS.env.jasmine || false;
	OPTIONS.env.phantomjs = OPTIONS.env.phantomjs || false;
	OPTIONS.env.qunit = OPTIONS.env.qunit || false;
	OPTIONS.env.jquery = OPTIONS.env.jquery || false;
	OPTIONS.env.prototypejs = OPTIONS.env.prototypejs || false;
	OPTIONS.env.shelljs = OPTIONS.env.shelljs || false;
	OPTIONS.env.meteor = OPTIONS.env.meteor || false;
	OPTIONS.env.mongo = OPTIONS.env.mongo || false;
	OPTIONS.env.applescript = OPTIONS.env.applescript || false;
	OPTIONS.env.serviceworker = OPTIONS.env.serviceworker || false;
	OPTIONS.env.embertest = OPTIONS.env.embertest || false;
	OPTIONS.env.es6 = OPTIONS.env.es6 || false;
	
	// include certain ecma features
	OPTIONS.ecmaFeatures = OPTIONS.ecmaFeatures || {};
	OPTIONS.ecmaFeatures.modules = OPTIONS.ecmaFeatures.module || false;
	
	populateConfiguration(OPTIONS.rules, OPTIONS.env, OPTIONS.ecmaFeatures);
	
	console.log(googlejsPlugin.rules);
	var prefixedKeys = Object.keys(googlejsPlugin.rules).reduce(function (newObj, key) {
	  var prefixedKey = 'googlejs/' + key;
	  newObj[prefixedKey] = googlejsPlugin.rules[key];
	  return newObj;
	}, {});
	eslint.linter.defineRules(prefixedKeys);
	console.log(prefixedKeys);
	
	console.log('OPTIONS', OPTIONS);
	
	var verify = debounce(function () {
	  var content = EDITOR.getValue();
	  removeWarningsErrors();
	  console.log('verifying', content);
	  var results = eslint.linter.verify(content, OPTIONS);
	  console.log(results);
	  displayResults(results);
	}, 500);
	
	verify();
	
	EDITOR.on('change', verify);

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Expose out ESLint and CLI to require.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	module.exports = {
	    linter: __webpack_require__(2),
	    CLIEngine: __webpack_require__(390),
	    RuleTester: __webpack_require__(391),
	    SourceCode: __webpack_require__(385)
	};


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Main ESLint object.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const assert = __webpack_require__(3),
	    EventEmitter = __webpack_require__(8).EventEmitter,
	    escope = __webpack_require__(9),
	    levn = __webpack_require__(84),
	    blankScriptAST = __webpack_require__(96),
	    DEFAULT_PARSER = __webpack_require__(97).parser,
	    replacements = __webpack_require__(98),
	    CodePathAnalyzer = __webpack_require__(99),
	    ConfigOps = __webpack_require__(114),
	    validator = __webpack_require__(119),
	    Environments = __webpack_require__(115),
	    CommentEventGenerator = __webpack_require__(383),
	    NodeEventGenerator = __webpack_require__(384),
	    SourceCode = __webpack_require__(385),
	    Traverser = __webpack_require__(303),
	    RuleContext = __webpack_require__(387),
	    rules = __webpack_require__(120),
	    timing = __webpack_require__(389);
	
	//------------------------------------------------------------------------------
	// Typedefs
	//------------------------------------------------------------------------------
	
	/**
	 * The result of a parsing operation from parseForESLint()
	 * @typedef {Object} CustomParseResult
	 * @property {ASTNode} ast The ESTree AST Program node.
	 * @property {Object} services An object containing additional services related
	 *      to the parser.
	 */
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Parses a list of "name:boolean_value" or/and "name" options divided by comma or
	 * whitespace.
	 * @param {string} string The string to parse.
	 * @param {Comment} comment The comment node which has the string.
	 * @returns {Object} Result map object of names and boolean values
	 */
	function parseBooleanConfig(string, comment) {
	    const items = {};
	
	    // Collapse whitespace around `:` and `,` to make parsing easier
	    string = string.replace(/\s*([:,])\s*/g, "$1");
	
	    string.split(/\s|,+/).forEach(function(name) {
	        if (!name) {
	            return;
	        }
	        const pos = name.indexOf(":");
	        let value;
	
	        if (pos !== -1) {
	            value = name.substring(pos + 1, name.length);
	            name = name.substring(0, pos);
	        }
	
	        items[name] = {
	            value: (value === "true"),
	            comment
	        };
	
	    });
	    return items;
	}
	
	/**
	 * Parses a JSON-like config.
	 * @param {string} string The string to parse.
	 * @param {Object} location Start line and column of comments for potential error message.
	 * @param {Object[]} messages The messages queue for potential error message.
	 * @returns {Object} Result map object
	 */
	function parseJsonConfig(string, location, messages) {
	    let items = {};
	
	    // Parses a JSON-like comment by the same way as parsing CLI option.
	    try {
	        items = levn.parse("Object", string) || {};
	
	        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.
	        // Also, commaless notations have invalid severity:
	        //     "no-alert: 2 no-console: 2" --> {"no-alert": "2 no-console: 2"}
	        // Should ignore that case as well.
	        if (ConfigOps.isEverySeverityValid(items)) {
	            return items;
	        }
	    } catch (ex) {
	
	        // ignore to parse the string by a fallback.
	    }
	
	    // Optionator cannot parse commaless notations.
	    // But we are supporting that. So this is a fallback for that.
	    items = {};
	    string = string.replace(/([a-zA-Z0-9\-/]+):/g, "\"$1\":").replace(/(]|[0-9])\s+(?=")/, "$1,");
	    try {
	        items = JSON.parse(`{${string}}`);
	    } catch (ex) {
	
	        messages.push({
	            ruleId: null,
	            fatal: true,
	            severity: 2,
	            source: null,
	            message: `Failed to parse JSON from '${string}': ${ex.message}`,
	            line: location.start.line,
	            column: location.start.column + 1
	        });
	
	    }
	
	    return items;
	}
	
	/**
	 * Parses a config of values separated by comma.
	 * @param {string} string The string to parse.
	 * @returns {Object} Result map of values and true values
	 */
	function parseListConfig(string) {
	    const items = {};
	
	    // Collapse whitespace around ,
	    string = string.replace(/\s*,\s*/g, ",");
	
	    string.split(/,+/).forEach(function(name) {
	        name = name.trim();
	        if (!name) {
	            return;
	        }
	        items[name] = true;
	    });
	    return items;
	}
	
	/**
	 * Ensures that variables representing built-in properties of the Global Object,
	 * and any globals declared by special block comments, are present in the global
	 * scope.
	 * @param {ASTNode} program The top node of the AST.
	 * @param {Scope} globalScope The global scope.
	 * @param {Object} config The existing configuration data.
	 * @returns {void}
	 */
	function addDeclaredGlobals(program, globalScope, config) {
	    const declaredGlobals = {},
	        exportedGlobals = {},
	        explicitGlobals = {},
	        builtin = Environments.get("builtin");
	
	    Object.assign(declaredGlobals, builtin);
	
	    Object.keys(config.env).forEach(function(name) {
	        if (config.env[name]) {
	            const env = Environments.get(name),
	                environmentGlobals = env && env.globals;
	
	            if (environmentGlobals) {
	                Object.assign(declaredGlobals, environmentGlobals);
	            }
	        }
	    });
	
	    Object.assign(exportedGlobals, config.exported);
	    Object.assign(declaredGlobals, config.globals);
	    Object.assign(explicitGlobals, config.astGlobals);
	
	    Object.keys(declaredGlobals).forEach(function(name) {
	        let variable = globalScope.set.get(name);
	
	        if (!variable) {
	            variable = new escope.Variable(name, globalScope);
	            variable.eslintExplicitGlobal = false;
	            globalScope.variables.push(variable);
	            globalScope.set.set(name, variable);
	        }
	        variable.writeable = declaredGlobals[name];
	    });
	
	    Object.keys(explicitGlobals).forEach(function(name) {
	        let variable = globalScope.set.get(name);
	
	        if (!variable) {
	            variable = new escope.Variable(name, globalScope);
	            variable.eslintExplicitGlobal = true;
	            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;
	            globalScope.variables.push(variable);
	            globalScope.set.set(name, variable);
	        }
	        variable.writeable = explicitGlobals[name].value;
	    });
	
	    // mark all exported variables as such
	    Object.keys(exportedGlobals).forEach(function(name) {
	        const variable = globalScope.set.get(name);
	
	        if (variable) {
	            variable.eslintUsed = true;
	        }
	    });
	
	    /*
	     * "through" contains all references which definitions cannot be found.
	     * Since we augment the global scope using configuration, we need to update
	     * references and remove the ones that were added by configuration.
	     */
	    globalScope.through = globalScope.through.filter(function(reference) {
	        const name = reference.identifier.name;
	        const variable = globalScope.set.get(name);
	
	        if (variable) {
	
	            /*
	             * Links the variable and the reference.
	             * And this reference is removed from `Scope#through`.
	             */
	            reference.resolved = variable;
	            variable.references.push(reference);
	
	            return false;
	        }
	
	        return true;
	    });
	}
	
	/**
	 * Add data to reporting configuration to disable reporting for list of rules
	 * starting from start location
	 * @param  {Object[]} reportingConfig Current reporting configuration
	 * @param  {Object} start Position to start
	 * @param  {string[]} rulesToDisable List of rules
	 * @returns {void}
	 */
	function disableReporting(reportingConfig, start, rulesToDisable) {
	
	    if (rulesToDisable.length) {
	        rulesToDisable.forEach(function(rule) {
	            reportingConfig.push({
	                start,
	                end: null,
	                rule
	            });
	        });
	    } else {
	        reportingConfig.push({
	            start,
	            end: null,
	            rule: null
	        });
	    }
	}
	
	/**
	 * Add data to reporting configuration to enable reporting for list of rules
	 * starting from start location
	 * @param  {Object[]} reportingConfig Current reporting configuration
	 * @param  {Object} start Position to start
	 * @param  {string[]} rulesToEnable List of rules
	 * @returns {void}
	 */
	function enableReporting(reportingConfig, start, rulesToEnable) {
	    let i;
	
	    if (rulesToEnable.length) {
	        rulesToEnable.forEach(function(rule) {
	            for (i = reportingConfig.length - 1; i >= 0; i--) {
	                if (!reportingConfig[i].end && reportingConfig[i].rule === rule) {
	                    reportingConfig[i].end = start;
	                    break;
	                }
	            }
	        });
	    } else {
	
	        // find all previous disabled locations if they was started as list of rules
	        let prevStart;
	
	        for (i = reportingConfig.length - 1; i >= 0; i--) {
	            if (prevStart && prevStart !== reportingConfig[i].start) {
	                break;
	            }
	
	            if (!reportingConfig[i].end) {
	                reportingConfig[i].end = start;
	                prevStart = reportingConfig[i].start;
	            }
	        }
	    }
	}
	
	/**
	 * Parses comments in file to extract file-specific config of rules, globals
	 * and environments and merges them with global config; also code blocks
	 * where reporting is disabled or enabled and merges them with reporting config.
	 * @param {string} filename The file being checked.
	 * @param {ASTNode} ast The top node of the AST.
	 * @param {Object} config The existing configuration data.
	 * @param {Object[]} reportingConfig The existing reporting configuration data.
	 * @param {Object[]} messages The messages queue.
	 * @returns {Object} Modified config object
	 */
	function modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {
	
	    let commentConfig = {
	        exported: {},
	        astGlobals: {},
	        rules: {},
	        env: {}
	    };
	    const commentRules = {};
	
	    ast.comments.forEach(function(comment) {
	
	        let value = comment.value.trim();
	        const match = /^(eslint(-\w+){0,3}|exported|globals?)(\s|$)/.exec(value);
	
	        if (match) {
	            value = value.substring(match.index + match[1].length);
	
	            if (comment.type === "Block") {
	                switch (match[1]) {
	                    case "exported":
	                        Object.assign(commentConfig.exported, parseBooleanConfig(value, comment));
	                        break;
	
	                    case "globals":
	                    case "global":
	                        Object.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));
	                        break;
	
	                    case "eslint-env":
	                        Object.assign(commentConfig.env, parseListConfig(value));
	                        break;
	
	                    case "eslint-disable":
	                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
	                        break;
	
	                    case "eslint-enable":
	                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
	                        break;
	
	                    case "eslint": {
	                        const items = parseJsonConfig(value, comment.loc, messages);
	
	                        Object.keys(items).forEach(function(name) {
	                            const ruleValue = items[name];
	
	                            validator.validateRuleOptions(name, ruleValue, `${filename} line ${comment.loc.start.line}`);
	                            commentRules[name] = ruleValue;
	                        });
	                        break;
	                    }
	
	                    // no default
	                }
	            } else {        // comment.type === "Line"
	                if (match[1] === "eslint-disable-line") {
	                    disableReporting(reportingConfig, { line: comment.loc.start.line, column: 0 }, Object.keys(parseListConfig(value)));
	                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));
	                } else if (match[1] === "eslint-disable-next-line") {
	                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));
	                    enableReporting(reportingConfig, { line: comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));
	                }
	            }
	        }
	    });
	
	    // apply environment configs
	    Object.keys(commentConfig.env).forEach(function(name) {
	        const env = Environments.get(name);
	
	        if (env) {
	            commentConfig = ConfigOps.merge(commentConfig, env);
	        }
	    });
	    Object.assign(commentConfig.rules, commentRules);
	
	    return ConfigOps.merge(config, commentConfig);
	}
	
	/**
	 * Check if message of rule with ruleId should be ignored in location
	 * @param  {Object[]} reportingConfig  Collection of ignore records
	 * @param  {string} ruleId   Id of rule
	 * @param  {Object} location Location of message
	 * @returns {boolean}          True if message should be ignored, false otherwise
	 */
	function isDisabledByReportingConfig(reportingConfig, ruleId, location) {
	
	    for (let i = 0, c = reportingConfig.length; i < c; i++) {
	
	        const ignore = reportingConfig[i];
	
	        if ((!ignore.rule || ignore.rule === ruleId) &&
	            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&
	            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {
	            return true;
	        }
	    }
	
	    return false;
	}
	
	/**
	 * Normalize ECMAScript version from the initial config
	 * @param  {number} ecmaVersion ECMAScript version from the initial config
	 * @param  {boolean} isModule Whether the source type is module or not
	 * @returns {number} normalized ECMAScript version
	 */
	function normalizeEcmaVersion(ecmaVersion, isModule) {
	
	    // Need at least ES6 for modules
	    if (isModule && (!ecmaVersion || ecmaVersion < 6)) {
	        ecmaVersion = 6;
	    }
	
	    // Calculate ECMAScript edition number from official year version starting with
	    // ES2015, which corresponds with ES6 (or a difference of 2009).
	    if (ecmaVersion >= 2015) {
	        ecmaVersion -= 2009;
	    }
	
	    return ecmaVersion;
	}
	
	/**
	 * Process initial config to make it safe to extend by file comment config
	 * @param  {Object} config Initial config
	 * @returns {Object}        Processed config
	 */
	function prepareConfig(config) {
	
	    config.globals = config.globals || config.global || {};
	    delete config.global;
	
	    const copiedRules = {};
	    let parserOptions = {};
	
	    if (typeof config.rules === "object") {
	        Object.keys(config.rules).forEach(function(k) {
	            const rule = config.rules[k];
	
	            if (rule === null) {
	                throw new Error(`Invalid config for rule '${k}'.`);
	            }
	            if (Array.isArray(rule)) {
	                copiedRules[k] = rule.slice();
	            } else {
	                copiedRules[k] = rule;
	            }
	        });
	    }
	
	    // merge in environment parserOptions
	    if (typeof config.env === "object") {
	        Object.keys(config.env).forEach(function(envName) {
	            const env = Environments.get(envName);
	
	            if (config.env[envName] && env && env.parserOptions) {
	                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);
	            }
	        });
	    }
	
	    const preparedConfig = {
	        rules: copiedRules,
	        parser: config.parser || DEFAULT_PARSER,
	        globals: ConfigOps.merge({}, config.globals),
	        env: ConfigOps.merge({}, config.env || {}),
	        settings: ConfigOps.merge({}, config.settings || {}),
	        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})
	    };
	    const isModule = preparedConfig.parserOptions.sourceType === "module";
	
	    if (isModule) {
	        if (!preparedConfig.parserOptions.ecmaFeatures) {
	            preparedConfig.parserOptions.ecmaFeatures = {};
	        }
	
	        // can't have global return inside of modules
	        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;
	    }
	
	    preparedConfig.parserOptions.ecmaVersion = normalizeEcmaVersion(preparedConfig.parserOptions.ecmaVersion, isModule);
	
	    return preparedConfig;
	}
	
	/**
	 * Provide a stub rule with a given message
	 * @param  {string} message The message to be displayed for the rule
	 * @returns {Function}      Stub rule function
	 */
	function createStubRule(message) {
	
	    /**
	     * Creates a fake rule object
	     * @param {Object} context context object for each rule
	     * @returns {Object} collection of node to listen on
	     */
	    function createRuleModule(context) {
	        return {
	            Program(node) {
	                context.report(node, message);
	            }
	        };
	    }
	
	    if (message) {
	        return createRuleModule;
	    } else {
	        throw new Error("No message passed to stub rule");
	    }
	}
	
	/**
	 * Provide a rule replacement message
	 * @param  {string} ruleId Name of the rule
	 * @returns {string}       Message detailing rule replacement
	 */
	function getRuleReplacementMessage(ruleId) {
	    if (ruleId in replacements.rules) {
	        const newRules = replacements.rules[ruleId];
	
	        return `Rule '${ruleId}' was removed and replaced by: ${newRules.join(", ")}`;
	    }
	
	    return null;
	}
	
	const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//g;
	
	/**
	 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
	 * @param {string} text - A source code text to check.
	 * @returns {Object|null} A result of parseListConfig() with "eslint-env *" comment.
	 */
	function findEslintEnv(text) {
	    let match, retv;
	
	    eslintEnvPattern.lastIndex = 0;
	
	    while ((match = eslintEnvPattern.exec(text))) {
	        retv = Object.assign(retv || {}, parseListConfig(match[1]));
	    }
	
	    return retv;
	}
	
	/**
	 * Strips Unicode BOM from a given text.
	 *
	 * @param {string} text - A text to strip.
	 * @returns {string} The stripped text.
	 */
	function stripUnicodeBOM(text) {
	
	    /*
	     * Check Unicode BOM.
	     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.
	     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters
	     */
	    if (text.charCodeAt(0) === 0xFEFF) {
	        return text.slice(1);
	    }
	    return text;
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Object that is responsible for verifying JavaScript text
	 * @name eslint
	 */
	module.exports = (function() {
	
	    const api = Object.create(new EventEmitter());
	    let messages = [],
	        currentConfig = null,
	        currentScopes = null,
	        scopeManager = null,
	        currentFilename = null,
	        traverser = null,
	        reportingConfig = [],
	        sourceCode = null;
	
	    /**
	     * Parses text into an AST. Moved out here because the try-catch prevents
	     * optimization of functions, so it's best to keep the try-catch as isolated
	     * as possible
	     * @param {string} text The text to parse.
	     * @param {Object} config The ESLint configuration object.
	     * @param {string} filePath The path to the file being parsed.
	     * @returns {ASTNode|CustomParseResult} The AST or parse result if successful,
	     *      or null if not.
	     * @private
	     */
	    function parse(text, config, filePath) {
	
	        let parser,
	            parserOptions = {
	                loc: true,
	                range: true,
	                raw: true,
	                tokens: true,
	                comment: true,
	                attachComment: true,
	                filePath
	            };
	
	        try {
	            parser = __webpack_require__(230);
	        } catch (ex) {
	            messages.push({
	                ruleId: null,
	                fatal: true,
	                severity: 2,
	                source: null,
	                message: ex.message,
	                line: 0,
	                column: 0
	            });
	
	            return null;
	        }
	
	        // merge in any additional parser options
	        if (config.parserOptions) {
	            parserOptions = Object.assign({}, config.parserOptions, parserOptions);
	        }
	
	        /*
	         * Check for parsing errors first. If there's a parsing error, nothing
	         * else can happen. However, a parsing error does not throw an error
	         * from this method - it's just considered a fatal error message, a
	         * problem that ESLint identified just like any other.
	         */
	        try {
	            if (typeof parser.parseForESLint === "function") {
	                return parser.parseForESLint(text, parserOptions);
	            } else {
	                return parser.parse(text, parserOptions);
	            }
	        } catch (ex) {
	
	            // If the message includes a leading line number, strip it:
	            const message = ex.message.replace(/^line \d+:/i, "").trim();
	            const source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;
	
	            messages.push({
	                ruleId: null,
	                fatal: true,
	                severity: 2,
	                source,
	                message: `Parsing error: ${message}`,
	
	                line: ex.lineNumber,
	                column: ex.column
	            });
	
	            return null;
	        }
	    }
	
	    /**
	     * Get the severity level of a rule (0 - none, 1 - warning, 2 - error)
	     * Returns 0 if the rule config is not valid (an Array or a number)
	     * @param {Array|number} ruleConfig rule configuration
	     * @returns {number} 0, 1, or 2, indicating rule severity
	     */
	    function getRuleSeverity(ruleConfig) {
	        if (typeof ruleConfig === "number") {
	            return ruleConfig;
	        } else if (Array.isArray(ruleConfig)) {
	            return ruleConfig[0];
	        } else {
	            return 0;
	        }
	    }
	
	    /**
	     * Get the options for a rule (not including severity), if any
	     * @param {Array|number} ruleConfig rule configuration
	     * @returns {Array} of rule options, empty Array if none
	     */
	    function getRuleOptions(ruleConfig) {
	        if (Array.isArray(ruleConfig)) {
	            return ruleConfig.slice(1);
	        } else {
	            return [];
	        }
	    }
	
	    // set unlimited listeners (see https://github.com/eslint/eslint/issues/524)
	    api.setMaxListeners(0);
	
	    /**
	     * Resets the internal state of the object.
	     * @returns {void}
	     */
	    api.reset = function() {
	        this.removeAllListeners();
	        messages = [];
	        currentConfig = null;
	        currentScopes = null;
	        scopeManager = null;
	        traverser = null;
	        reportingConfig = [];
	        sourceCode = null;
	    };
	
	    /**
	     * Configuration object for the `verify` API. A JS representation of the eslintrc files.
	     * @typedef {Object} ESLintConfig
	     * @property {Object} rules The rule configuration to verify against.
	     * @property {string} [parser] Parser to use when generatig the AST.
	     * @property {Object} [parserOptions] Options for the parsed used.
	     * @property {Object} [settings] Global settings passed to each rule.
	     * @property {Object} [env] The environment to verify in.
	     * @property {Object} [globals] Available globalsto the code.
	     */
	
	    /**
	     * Verifies the text against the rules specified by the second argument.
	     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.
	     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.
	     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.
	     *      If this is not set, the filename will default to '<input>' in the rule context. If
	     *      an object, then it has "filename", "saveState", and "allowInlineConfig" properties.
	     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.
	     *      Mostly useful for testing purposes.
	     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.
	     *      Useful if you want to validate JS without comments overriding rules.
	     * @returns {Object[]} The results as an array of messages or null if no messages.
	     */
	    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {
	        const text = (typeof textOrSourceCode === "string") ? textOrSourceCode : null;
	        let ast,
	            parseResult,
	            shebang,
	            allowInlineConfig;
	
	        // evaluate arguments
	        if (typeof filenameOrOptions === "object") {
	            currentFilename = filenameOrOptions.filename;
	            allowInlineConfig = filenameOrOptions.allowInlineConfig;
	            saveState = filenameOrOptions.saveState;
	        } else {
	            currentFilename = filenameOrOptions;
	        }
	
	        if (!saveState) {
	            this.reset();
	        }
	
	        // search and apply "eslint-env *".
	        const envInFile = findEslintEnv(text || textOrSourceCode.text);
	
	        if (envInFile) {
	            if (!config || !config.env) {
	                config = Object.assign({}, config || {}, {env: envInFile});
	            } else {
	                config = Object.assign({}, config);
	                config.env = Object.assign({}, config.env, envInFile);
	            }
	        }
	
	        // process initial config to make it safe to extend
	        config = prepareConfig(config || {});
	
	        // only do this for text
	        if (text !== null) {
	
	            // there's no input, just exit here
	            if (text.trim().length === 0) {
	                sourceCode = new SourceCode(text, blankScriptAST);
	                return messages;
	            }
	
	            parseResult = parse(
	                stripUnicodeBOM(text).replace(/^#!([^\r\n]+)/, function(match, captured) {
	                    shebang = captured;
	                    return `//${captured}`;
	                }),
	                config,
	                currentFilename
	            );
	
	            // if this result is from a parseForESLint() method, normalize
	            if (parseResult && parseResult.ast) {
	                ast = parseResult.ast;
	            } else {
	                ast = parseResult;
	                parseResult = null;
	            }
	
	            if (ast) {
	                sourceCode = new SourceCode(text, ast);
	            }
	
	        } else {
	            sourceCode = textOrSourceCode;
	            ast = sourceCode.ast;
	        }
	
	        // if espree failed to parse the file, there's no sense in setting up rules
	        if (ast) {
	
	            // parse global comments and modify config
	            if (allowInlineConfig !== false) {
	                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);
	            }
	
	            // ensure that severities are normalized in the config
	            ConfigOps.normalize(config);
	
	            // enable appropriate rules
	            Object.keys(config.rules).filter(function(key) {
	                return getRuleSeverity(config.rules[key]) > 0;
	            }).forEach(function(key) {
	                let ruleCreator;
	
	                ruleCreator = rules.get(key);
	
	                if (!ruleCreator) {
	                    const replacementMsg = getRuleReplacementMessage(key);
	
	                    if (replacementMsg) {
	                        ruleCreator = createStubRule(replacementMsg);
	                    } else {
	                        ruleCreator = createStubRule(`Definition for rule '${key}' was not found`);
	                    }
	                    rules.define(key, ruleCreator);
	                }
	
	                const severity = getRuleSeverity(config.rules[key]);
	                const options = getRuleOptions(config.rules[key]);
	
	                try {
	                    const ruleContext = new RuleContext(
	                        key, api, severity, options,
	                        config.settings, config.parserOptions, config.parser,
	                        ruleCreator.meta,
	                        (parseResult && parseResult.services ? parseResult.services : {})
	                    );
	
	                    const rule = ruleCreator.create ? ruleCreator.create(ruleContext) :
	                        ruleCreator(ruleContext);
	
	                    // add all the node types as listeners
	                    Object.keys(rule).forEach(function(nodeType) {
	                        api.on(nodeType, timing.enabled
	                            ? timing.time(key, rule[nodeType])
	                            : rule[nodeType]
	                        );
	                    });
	                } catch (ex) {
	                    ex.message = `Error while loading rule '${key}': ${ex.message}`;
	                    throw ex;
	                }
	            });
	
	            // save config so rules can access as necessary
	            currentConfig = config;
	            traverser = new Traverser();
	
	            const ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};
	            const ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;
	
	            // gather scope data that may be needed by the rules
	            scopeManager = escope.analyze(ast, {
	                ignoreEval: true,
	                nodejsScope: ecmaFeatures.globalReturn,
	                impliedStrict: ecmaFeatures.impliedStrict,
	                ecmaVersion,
	                sourceType: currentConfig.parserOptions.sourceType || "script",
	                fallback: Traverser.getKeys
	            });
	
	            currentScopes = scopeManager.scopes;
	
	            // augment global scope with declared global variables
	            addDeclaredGlobals(ast, currentScopes[0], currentConfig);
	
	            // remove shebang comments
	            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {
	                ast.comments.splice(0, 1);
	
	                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {
	                    ast.body[0].leadingComments.splice(0, 1);
	                }
	            }
	
	            let eventGenerator = new NodeEventGenerator(api);
	
	            eventGenerator = new CodePathAnalyzer(eventGenerator);
	            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);
	
	            /*
	             * Each node has a type property. Whenever a particular type of
	             * node is found, an event is fired. This allows any listeners to
	             * automatically be informed that this type of node has been found
	             * and react accordingly.
	             */
	            traverser.traverse(ast, {
	                enter(node, parent) {
	                    node.parent = parent;
	                    eventGenerator.enterNode(node);
	                },
	                leave(node) {
	                    eventGenerator.leaveNode(node);
	                }
	            });
	        }
	
	        // sort by line and column
	        messages.sort(function(a, b) {
	            const lineDiff = a.line - b.line;
	
	            if (lineDiff === 0) {
	                return a.column - b.column;
	            } else {
	                return lineDiff;
	            }
	        });
	
	        return messages;
	    };
	
	    /**
	     * Reports a message from one of the rules.
	     * @param {string} ruleId The ID of the rule causing the message.
	     * @param {number} severity The severity level of the rule as configured.
	     * @param {ASTNode} node The AST node that the message relates to.
	     * @param {Object=} location An object containing the error line and column
	     *      numbers. If location is not provided the node's start location will
	     *      be used.
	     * @param {string} message The actual message.
	     * @param {Object} opts Optional template data which produces a formatted message
	     *     with symbols being replaced by this object's values.
	     * @param {Object} fix A fix command description.
	     * @param {Object} meta Metadata of the rule
	     * @returns {void}
	     */
	    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {
	        if (node) {
	            assert.strictEqual(typeof node, "object", "Node must be an object");
	        }
	
	        if (typeof location === "string") {
	            assert.ok(node, "Node must be provided when reporting error if location is not provided");
	
	            meta = fix;
	            fix = opts;
	            opts = message;
	            message = location;
	            location = node.loc.start;
	        }
	
	        // Store end location.
	        const endLocation = location.end;
	
	        location = location.start || location;
	
	        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {
	            return;
	        }
	
	        if (opts) {
	            message = message.replace(/\{\{\s*([^{}]+?)\s*\}\}/g, function(fullMatch, term) {
	                if (term in opts) {
	                    return opts[term];
	                }
	
	                // Preserve old behavior: If parameter name not provided, don't replace it.
	                return fullMatch;
	            });
	        }
	
	        const problem = {
	            ruleId,
	            severity,
	            message,
	            line: location.line,
	            column: location.column + 1,   // switch to 1-base instead of 0-base
	            nodeType: node && node.type,
	            source: sourceCode.lines[location.line - 1] || ""
	        };
	
	        // Define endLine and endColumn if exists.
	        if (endLocation) {
	            problem.endLine = endLocation.line;
	            problem.endColumn = endLocation.column + 1;   // switch to 1-base instead of 0-base
	        }
	
	        // ensure there's range and text properties, otherwise it's not a valid fix
	        if (fix && Array.isArray(fix.range) && (typeof fix.text === "string")) {
	
	            // If rule uses fix, has metadata, but has no metadata.fixable, we should throw
	            if (meta && !meta.fixable) {
	                throw new Error("Fixable rules should export a `meta.fixable` property.");
	            }
	
	            problem.fix = fix;
	        }
	
	        messages.push(problem);
	    };
	
	    /**
	     * Gets the SourceCode object representing the parsed source.
	     * @returns {SourceCode} The SourceCode object.
	     */
	    api.getSourceCode = function() {
	        return sourceCode;
	    };
	
	    // methods that exist on SourceCode object
	    const externalMethods = {
	        getSource: "getText",
	        getSourceLines: "getLines",
	        getAllComments: "getAllComments",
	        getNodeByRangeIndex: "getNodeByRangeIndex",
	        getComments: "getComments",
	        getJSDocComment: "getJSDocComment",
	        getFirstToken: "getFirstToken",
	        getFirstTokens: "getFirstTokens",
	        getLastToken: "getLastToken",
	        getLastTokens: "getLastTokens",
	        getTokenAfter: "getTokenAfter",
	        getTokenBefore: "getTokenBefore",
	        getTokenByRangeStart: "getTokenByRangeStart",
	        getTokens: "getTokens",
	        getTokensAfter: "getTokensAfter",
	        getTokensBefore: "getTokensBefore",
	        getTokensBetween: "getTokensBetween"
	    };
	
	    // copy over methods
	    Object.keys(externalMethods).forEach(function(methodName) {
	        const exMethodName = externalMethods[methodName];
	
	        // All functions expected to have less arguments than 5.
	        api[methodName] = function(a, b, c, d, e) {
	            if (sourceCode) {
	                return sourceCode[exMethodName](a, b, c, d, e);
	            }
	            return null;
	        };
	    });
	
	    /**
	     * Gets nodes that are ancestors of current node.
	     * @returns {ASTNode[]} Array of objects representing ancestors.
	     */
	    api.getAncestors = function() {
	        return traverser.parents();
	    };
	
	    /**
	     * Gets the scope for the current node.
	     * @returns {Object} An object representing the current node's scope.
	     */
	    api.getScope = function() {
	        const parents = traverser.parents();
	
	        // Don't do this for Program nodes - they have no parents
	        if (parents.length) {
	
	            // if current node introduces a scope, add it to the list
	            const current = traverser.current();
	
	            if (currentConfig.parserOptions.ecmaVersion >= 6) {
	                if (["BlockStatement", "SwitchStatement", "CatchClause", "FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
	                    parents.push(current);
	                }
	            } else {
	                if (["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"].indexOf(current.type) >= 0) {
	                    parents.push(current);
	                }
	            }
	
	            // Ascend the current node's parents
	            for (let i = parents.length - 1; i >= 0; --i) {
	
	                // Get the innermost scope
	                const scope = scopeManager.acquire(parents[i], true);
	
	                if (scope) {
	                    if (scope.type === "function-expression-name") {
	                        return scope.childScopes[0];
	                    } else {
	                        return scope;
	                    }
	                }
	
	            }
	
	        }
	
	        return currentScopes[0];
	    };
	
	    /**
	     * Record that a particular variable has been used in code
	     * @param {string} name The name of the variable to mark as used
	     * @returns {boolean} True if the variable was found and marked as used,
	     *      false if not.
	     */
	    api.markVariableAsUsed = function(name) {
	        const hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,
	            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === "module";
	        let scope = this.getScope(),
	            i,
	            len;
	
	        // Special Node.js scope means we need to start one level deeper
	        if (scope.type === "global" && specialScope) {
	            scope = scope.childScopes[0];
	        }
	
	        do {
	            const variables = scope.variables;
	
	            for (i = 0, len = variables.length; i < len; i++) {
	                if (variables[i].name === name) {
	                    variables[i].eslintUsed = true;
	                    return true;
	                }
	            }
	        } while ((scope = scope.upper));
	
	        return false;
	    };
	
	    /**
	     * Gets the filename for the currently parsed source.
	     * @returns {string} The filename associated with the source being parsed.
	     *     Defaults to "<input>" if no filename info is present.
	     */
	    api.getFilename = function() {
	        if (typeof currentFilename === "string") {
	            return currentFilename;
	        } else {
	            return "<input>";
	        }
	    };
	
	    /**
	     * Defines a new linting rule.
	     * @param {string} ruleId A unique rule identifier
	     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers
	     * @returns {void}
	     */
	    const defineRule = api.defineRule = function(ruleId, ruleModule) {
	        rules.define(ruleId, ruleModule);
	    };
	
	    /**
	     * Defines many new linting rules.
	     * @param {Object} rulesToDefine map from unique rule identifier to rule
	     * @returns {void}
	     */
	    api.defineRules = function(rulesToDefine) {
	        Object.getOwnPropertyNames(rulesToDefine).forEach(function(ruleId) {
	            defineRule(ruleId, rulesToDefine[ruleId]);
	        });
	    };
	
	    /**
	     * Gets the default eslint configuration.
	     * @returns {Object} Object mapping rule IDs to their default configurations
	     */
	    api.defaults = function() {
	        return __webpack_require__(97);
	    };
	
	    /**
	     * Gets variables that are declared by a specified node.
	     *
	     * The variables are its `defs[].node` or `defs[].parent` is same as the specified node.
	     * Specifically, below:
	     *
	     * - `VariableDeclaration` - variables of its all declarators.
	     * - `VariableDeclarator` - variables.
	     * - `FunctionDeclaration`/`FunctionExpression` - its function name and parameters.
	     * - `ArrowFunctionExpression` - its parameters.
	     * - `ClassDeclaration`/`ClassExpression` - its class name.
	     * - `CatchClause` - variables of its exception.
	     * - `ImportDeclaration` - variables of  its all specifiers.
	     * - `ImportSpecifier`/`ImportDefaultSpecifier`/`ImportNamespaceSpecifier` - a variable.
	     * - others - always an empty array.
	     *
	     * @param {ASTNode} node A node to get.
	     * @returns {escope.Variable[]} Variables that are declared by the node.
	     */
	    api.getDeclaredVariables = function(node) {
	        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];
	    };
	
	    return api;
	
	}());


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';
	
	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:
	
	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }
	
	  var x = a.length;
	  var y = b.length;
	
	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }
	
	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}
	
	// based on node assert, original notice:
	
	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var util = __webpack_require__(4);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.
	
	var assert = module.exports = ok;
	
	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })
	
	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;
	
	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }
	
	      this.stack = out;
	    }
	  }
	};
	
	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);
	
	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}
	
	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.
	
	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.
	
	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}
	
	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;
	
	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.
	
	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;
	
	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);
	
	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};
	
	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);
	
	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};
	
	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);
	
	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};
	
	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};
	
	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;
	
	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();
	
	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;
	
	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;
	
	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;
	
	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};
	
	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }
	
	    memos.actual.push(actual);
	    memos.expected.push(expected);
	
	    return objEquiv(actual, expected, strict, memos);
	  }
	}
	
	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}
	
	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}
	
	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);
	
	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};
	
	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}
	
	
	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);
	
	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};
	
	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
	
	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};
	
	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }
	
	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }
	
	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }
	
	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }
	
	  return expected.call({}, actual) === true;
	}
	
	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}
	
	function _throws(shouldThrow, block, expected, message) {
	  var actual;
	
	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }
	
	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }
	
	  actual = _tryBlock(block);
	
	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');
	
	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }
	
	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;
	
	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }
	
	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}
	
	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);
	
	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};
	
	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};
	
	assert.ifError = function(err) { if (err) throw err; };
	
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(6);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(7);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(5)))

/***/ },
/* 5 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 6 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 7 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};
	
	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;
	
	  if (!this._events)
	    this._events = {};
	
	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }
	
	  handler = this._events[type];
	
	  if (isUndefined(handler))
	    return false;
	
	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }
	
	  return true;
	};
	
	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events)
	    this._events = {};
	
	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);
	
	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];
	
	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }
	
	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  var fired = false;
	
	  function g() {
	    this.removeListener(type, g);
	
	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }
	
	  g.listener = listener;
	  this.on(type, g);
	
	  return this;
	};
	
	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;
	
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');
	
	  if (!this._events || !this._events[type])
	    return this;
	
	  list = this._events[type];
	  length = list.length;
	  position = -1;
	
	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	
	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }
	
	    if (position < 0)
	      return this;
	
	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }
	
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }
	
	  return this;
	};
	
	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;
	
	  if (!this._events)
	    return this;
	
	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }
	
	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }
	
	  listeners = this._events[type];
	
	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];
	
	  return this;
	};
	
	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};
	
	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];
	
	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	
	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ScopeManager = exports.Scope = exports.Variable = exports.Reference = exports.version = undefined;
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; }; /*
	                                                                                                                                                                                                                                                    Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                                                                                                                    Copyright (C) 2013 Alex Seville <hi@alexanderseville.com>
	                                                                                                                                                                                                                                                    Copyright (C) 2014 Thiago de Arruda <tpadilha84@gmail.com>
	                                                                                                                                                                                                                                                  
	                                                                                                                                                                                                                                                    Redistribution and use in source and binary forms, with or without
	                                                                                                                                                                                                                                                    modification, are permitted provided that the following conditions are met:
	                                                                                                                                                                                                                                                  
	                                                                                                                                                                                                                                                      * Redistributions of source code must retain the above copyright
	                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer.
	                                                                                                                                                                                                                                                      * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                                                                                                        notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                                                                                                        documentation and/or other materials provided with the distribution.
	                                                                                                                                                                                                                                                  
	                                                                                                                                                                                                                                                    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                                                                                                                    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                                                                                                                    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                                                                                                                    ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                                                                                                                    DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                                                                                                                    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                                                                                                                    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                                                                                                                    ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                                                                                                                    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                                                                                                                    THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                                                                                                                  */
	
	/**
	 * Escope (<a href="http://github.com/estools/escope">escope</a>) is an <a
	 * href="http://www.ecma-international.org/publications/standards/Ecma-262.htm">ECMAScript</a>
	 * scope analyzer extracted from the <a
	 * href="http://github.com/estools/esmangle">esmangle project</a/>.
	 * <p>
	 * <em>escope</em> finds lexical scopes in a source program, i.e. areas of that
	 * program where different occurrences of the same identifier refer to the same
	 * variable. With each scope the contained variables are collected, and each
	 * identifier reference in code is linked to its corresponding variable (if
	 * possible).
	 * <p>
	 * <em>escope</em> works on a syntax tree of the parsed source code which has
	 * to adhere to the <a
	 * href="https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API">
	 * Mozilla Parser API</a>. E.g. <a href="http://esprima.org">esprima</a> is a parser
	 * that produces such syntax trees.
	 * <p>
	 * The main interface is the {@link analyze} function.
	 * @module escope
	 */
	
	/*jslint bitwise:true */
	
	exports.analyze = analyze;
	
	var _assert = __webpack_require__(3);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	var _scopeManager = __webpack_require__(10);
	
	var _scopeManager2 = _interopRequireDefault(_scopeManager);
	
	var _referencer = __webpack_require__(76);
	
	var _referencer2 = _interopRequireDefault(_referencer);
	
	var _reference = __webpack_require__(73);
	
	var _reference2 = _interopRequireDefault(_reference);
	
	var _variable = __webpack_require__(74);
	
	var _variable2 = _interopRequireDefault(_variable);
	
	var _scope = __webpack_require__(56);
	
	var _scope2 = _interopRequireDefault(_scope);
	
	var _package = __webpack_require__(83);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function defaultOptions() {
	    return {
	        optimistic: false,
	        directive: false,
	        nodejsScope: false,
	        impliedStrict: false,
	        sourceType: 'script', // one of ['script', 'module']
	        ecmaVersion: 5,
	        childVisitorKeys: null,
	        fallback: 'iteration'
	    };
	}
	
	function updateDeeply(target, override) {
	    var key, val;
	
	    function isHashObject(target) {
	        return (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target instanceof Object && !(target instanceof Array) && !(target instanceof RegExp);
	    }
	
	    for (key in override) {
	        if (override.hasOwnProperty(key)) {
	            val = override[key];
	            if (isHashObject(val)) {
	                if (isHashObject(target[key])) {
	                    updateDeeply(target[key], val);
	                } else {
	                    target[key] = updateDeeply({}, val);
	                }
	            } else {
	                target[key] = val;
	            }
	        }
	    }
	    return target;
	}
	
	/**
	 * Main interface function. Takes an Esprima syntax tree and returns the
	 * analyzed scopes.
	 * @function analyze
	 * @param {esprima.Tree} tree
	 * @param {Object} providedOptions - Options that tailor the scope analysis
	 * @param {boolean} [providedOptions.optimistic=false] - the optimistic flag
	 * @param {boolean} [providedOptions.directive=false]- the directive flag
	 * @param {boolean} [providedOptions.ignoreEval=false]- whether to check 'eval()' calls
	 * @param {boolean} [providedOptions.nodejsScope=false]- whether the whole
	 * script is executed under node.js environment. When enabled, escope adds
	 * a function scope immediately following the global scope.
	 * @param {boolean} [providedOptions.impliedStrict=false]- implied strict mode
	 * (if ecmaVersion >= 5).
	 * @param {string} [providedOptions.sourceType='script']- the source type of the script. one of 'script' and 'module'
	 * @param {number} [providedOptions.ecmaVersion=5]- which ECMAScript version is considered
	 * @param {Object} [providedOptions.childVisitorKeys=null] - Additional known visitor keys. See [esrecurse](https://github.com/estools/esrecurse)'s the `childVisitorKeys` option.
	 * @param {string} [providedOptions.fallback='iteration'] - A kind of the fallback in order to encounter with unknown node. See [esrecurse](https://github.com/estools/esrecurse)'s the `fallback` option.
	 * @return {ScopeManager}
	 */
	function analyze(tree, providedOptions) {
	    var scopeManager, referencer, options;
	
	    options = updateDeeply(defaultOptions(), providedOptions);
	
	    scopeManager = new _scopeManager2.default(options);
	
	    referencer = new _referencer2.default(options, scopeManager);
	    referencer.visit(tree);
	
	    (0, _assert2.default)(scopeManager.__currentScope === null, 'currentScope should be null.');
	
	    return scopeManager;
	}
	
	exports.
	/** @name module:escope.version */
	version = _package.version;
	exports.
	/** @name module:escope.Reference */
	Reference = _reference2.default;
	exports.
	/** @name module:escope.Variable */
	Variable = _variable2.default;
	exports.
	/** @name module:escope.Scope */
	Scope = _scope2.default;
	exports.
	/** @name module:escope.ScopeManager */
	ScopeManager = _scopeManager2.default;
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQW9IZ0I7O0FBbEVoQjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLFNBQVMsY0FBVCxHQUEwQjtBQUN0QixXQUFPO0FBQ0gsb0JBQVksS0FBWjtBQUNBLG1CQUFXLEtBQVg7QUFDQSxxQkFBYSxLQUFiO0FBQ0EsdUJBQWUsS0FBZjtBQUNBLG9CQUFZLFFBQVo7QUFDQSxxQkFBYSxDQUFiO0FBQ0EsMEJBQWtCLElBQWxCO0FBQ0Esa0JBQVUsV0FBVjtLQVJKLENBRHNCO0NBQTFCOztBQWFBLFNBQVMsWUFBVCxDQUFzQixNQUF0QixFQUE4QixRQUE5QixFQUF3QztBQUNwQyxRQUFJLEdBQUosRUFBUyxHQUFULENBRG9DOztBQUdwQyxhQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEI7QUFDMUIsZUFBTyxRQUFPLHVEQUFQLEtBQWtCLFFBQWxCLElBQThCLGtCQUFrQixNQUFsQixJQUE0QixFQUFFLGtCQUFrQixLQUFsQixDQUFGLElBQThCLEVBQUUsa0JBQWtCLE1BQWxCLENBQUYsQ0FEckU7S0FBOUI7O0FBSUEsU0FBSyxHQUFMLElBQVksUUFBWixFQUFzQjtBQUNsQixZQUFJLFNBQVMsY0FBVCxDQUF3QixHQUF4QixDQUFKLEVBQWtDO0FBQzlCLGtCQUFNLFNBQVMsR0FBVCxDQUFOLENBRDhCO0FBRTlCLGdCQUFJLGFBQWEsR0FBYixDQUFKLEVBQXVCO0FBQ25CLG9CQUFJLGFBQWEsT0FBTyxHQUFQLENBQWIsQ0FBSixFQUErQjtBQUMzQixpQ0FBYSxPQUFPLEdBQVAsQ0FBYixFQUEwQixHQUExQixFQUQyQjtpQkFBL0IsTUFFTztBQUNILDJCQUFPLEdBQVAsSUFBYyxhQUFhLEVBQWIsRUFBaUIsR0FBakIsQ0FBZCxDQURHO2lCQUZQO2FBREosTUFNTztBQUNILHVCQUFPLEdBQVAsSUFBYyxHQUFkLENBREc7YUFOUDtTQUZKO0tBREo7QUFjQSxXQUFPLE1BQVAsQ0FyQm9DO0NBQXhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNENPLFNBQVMsT0FBVCxDQUFpQixJQUFqQixFQUF1QixlQUF2QixFQUF3QztBQUMzQyxRQUFJLFlBQUosRUFBa0IsVUFBbEIsRUFBOEIsT0FBOUIsQ0FEMkM7O0FBRzNDLGNBQVUsYUFBYSxnQkFBYixFQUErQixlQUEvQixDQUFWLENBSDJDOztBQUszQyxtQkFBZSwyQkFBaUIsT0FBakIsQ0FBZixDQUwyQzs7QUFPM0MsaUJBQWEseUJBQWUsT0FBZixFQUF3QixZQUF4QixDQUFiLENBUDJDO0FBUTNDLGVBQVcsS0FBWCxDQUFpQixJQUFqQixFQVIyQzs7QUFVM0MsMEJBQU8sYUFBYSxjQUFiLEtBQWdDLElBQWhDLEVBQXNDLDhCQUE3QyxFQVYyQzs7QUFZM0MsV0FBTyxZQUFQLENBWjJDO0NBQXhDOzs7O0FBaUJIOzs7QUFFQTs7O0FBRUE7OztBQUVBOzs7QUFFQSIsImZpbGUiOiJpbmRleC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIENvcHlyaWdodCAoQykgMjAxMi0yMDE0IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFsZXggU2V2aWxsZSA8aGlAYWxleGFuZGVyc2V2aWxsZS5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxNCBUaGlhZ28gZGUgQXJydWRhIDx0cGFkaWxoYTg0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vKipcbiAqIEVzY29wZSAoPGEgaHJlZj1cImh0dHA6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb3BlXCI+ZXNjb3BlPC9hPikgaXMgYW4gPGFcbiAqIGhyZWY9XCJodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvcHVibGljYXRpb25zL3N0YW5kYXJkcy9FY21hLTI2Mi5odG1cIj5FQ01BU2NyaXB0PC9hPlxuICogc2NvcGUgYW5hbHl6ZXIgZXh0cmFjdGVkIGZyb20gdGhlIDxhXG4gKiBocmVmPVwiaHR0cDovL2dpdGh1Yi5jb20vZXN0b29scy9lc21hbmdsZVwiPmVzbWFuZ2xlIHByb2plY3Q8L2EvPi5cbiAqIDxwPlxuICogPGVtPmVzY29wZTwvZW0+IGZpbmRzIGxleGljYWwgc2NvcGVzIGluIGEgc291cmNlIHByb2dyYW0sIGkuZS4gYXJlYXMgb2YgdGhhdFxuICogcHJvZ3JhbSB3aGVyZSBkaWZmZXJlbnQgb2NjdXJyZW5jZXMgb2YgdGhlIHNhbWUgaWRlbnRpZmllciByZWZlciB0byB0aGUgc2FtZVxuICogdmFyaWFibGUuIFdpdGggZWFjaCBzY29wZSB0aGUgY29udGFpbmVkIHZhcmlhYmxlcyBhcmUgY29sbGVjdGVkLCBhbmQgZWFjaFxuICogaWRlbnRpZmllciByZWZlcmVuY2UgaW4gY29kZSBpcyBsaW5rZWQgdG8gaXRzIGNvcnJlc3BvbmRpbmcgdmFyaWFibGUgKGlmXG4gKiBwb3NzaWJsZSkuXG4gKiA8cD5cbiAqIDxlbT5lc2NvcGU8L2VtPiB3b3JrcyBvbiBhIHN5bnRheCB0cmVlIG9mIHRoZSBwYXJzZWQgc291cmNlIGNvZGUgd2hpY2ggaGFzXG4gKiB0byBhZGhlcmUgdG8gdGhlIDxhXG4gKiBocmVmPVwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9TcGlkZXJNb25rZXkvUGFyc2VyX0FQSVwiPlxuICogTW96aWxsYSBQYXJzZXIgQVBJPC9hPi4gRS5nLiA8YSBocmVmPVwiaHR0cDovL2VzcHJpbWEub3JnXCI+ZXNwcmltYTwvYT4gaXMgYSBwYXJzZXJcbiAqIHRoYXQgcHJvZHVjZXMgc3VjaCBzeW50YXggdHJlZXMuXG4gKiA8cD5cbiAqIFRoZSBtYWluIGludGVyZmFjZSBpcyB0aGUge0BsaW5rIGFuYWx5emV9IGZ1bmN0aW9uLlxuICogQG1vZHVsZSBlc2NvcGVcbiAqL1xuXG4vKmpzbGludCBiaXR3aXNlOnRydWUgKi9cblxuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5pbXBvcnQgU2NvcGVNYW5hZ2VyIGZyb20gJy4vc2NvcGUtbWFuYWdlcic7XG5pbXBvcnQgUmVmZXJlbmNlciBmcm9tICcuL3JlZmVyZW5jZXInO1xuaW1wb3J0IFJlZmVyZW5jZSBmcm9tICcuL3JlZmVyZW5jZSc7XG5pbXBvcnQgVmFyaWFibGUgZnJvbSAnLi92YXJpYWJsZSc7XG5pbXBvcnQgU2NvcGUgZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSAnLi4vcGFja2FnZS5qc29uJztcblxuZnVuY3Rpb24gZGVmYXVsdE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgb3B0aW1pc3RpYzogZmFsc2UsXG4gICAgICAgIGRpcmVjdGl2ZTogZmFsc2UsXG4gICAgICAgIG5vZGVqc1Njb3BlOiBmYWxzZSxcbiAgICAgICAgaW1wbGllZFN0cmljdDogZmFsc2UsXG4gICAgICAgIHNvdXJjZVR5cGU6ICdzY3JpcHQnLCAgLy8gb25lIG9mIFsnc2NyaXB0JywgJ21vZHVsZSddXG4gICAgICAgIGVjbWFWZXJzaW9uOiA1LFxuICAgICAgICBjaGlsZFZpc2l0b3JLZXlzOiBudWxsLFxuICAgICAgICBmYWxsYmFjazogJ2l0ZXJhdGlvbidcbiAgICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWVwbHkodGFyZ2V0LCBvdmVycmlkZSkge1xuICAgIHZhciBrZXksIHZhbDtcblxuICAgIGZ1bmN0aW9uIGlzSGFzaE9iamVjdCh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0YXJnZXQgPT09ICdvYmplY3QnICYmIHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIEFycmF5KSAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFJlZ0V4cCk7XG4gICAgfVxuXG4gICAgZm9yIChrZXkgaW4gb3ZlcnJpZGUpIHtcbiAgICAgICAgaWYgKG92ZXJyaWRlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIHZhbCA9IG92ZXJyaWRlW2tleV07XG4gICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNIYXNoT2JqZWN0KHRhcmdldFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVEZWVwbHkodGFyZ2V0W2tleV0sIHZhbCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB1cGRhdGVEZWVwbHkoe30sIHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vKipcbiAqIE1haW4gaW50ZXJmYWNlIGZ1bmN0aW9uLiBUYWtlcyBhbiBFc3ByaW1hIHN5bnRheCB0cmVlIGFuZCByZXR1cm5zIHRoZVxuICogYW5hbHl6ZWQgc2NvcGVzLlxuICogQGZ1bmN0aW9uIGFuYWx5emVcbiAqIEBwYXJhbSB7ZXNwcmltYS5UcmVlfSB0cmVlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdmlkZWRPcHRpb25zIC0gT3B0aW9ucyB0aGF0IHRhaWxvciB0aGUgc2NvcGUgYW5hbHlzaXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5vcHRpbWlzdGljPWZhbHNlXSAtIHRoZSBvcHRpbWlzdGljIGZsYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5kaXJlY3RpdmU9ZmFsc2VdLSB0aGUgZGlyZWN0aXZlIGZsYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Byb3ZpZGVkT3B0aW9ucy5pZ25vcmVFdmFsPWZhbHNlXS0gd2hldGhlciB0byBjaGVjayAnZXZhbCgpJyBjYWxsc1xuICogQHBhcmFtIHtib29sZWFufSBbcHJvdmlkZWRPcHRpb25zLm5vZGVqc1Njb3BlPWZhbHNlXS0gd2hldGhlciB0aGUgd2hvbGVcbiAqIHNjcmlwdCBpcyBleGVjdXRlZCB1bmRlciBub2RlLmpzIGVudmlyb25tZW50LiBXaGVuIGVuYWJsZWQsIGVzY29wZSBhZGRzXG4gKiBhIGZ1bmN0aW9uIHNjb3BlIGltbWVkaWF0ZWx5IGZvbGxvd2luZyB0aGUgZ2xvYmFsIHNjb3BlLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJvdmlkZWRPcHRpb25zLmltcGxpZWRTdHJpY3Q9ZmFsc2VdLSBpbXBsaWVkIHN0cmljdCBtb2RlXG4gKiAoaWYgZWNtYVZlcnNpb24gPj0gNSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkT3B0aW9ucy5zb3VyY2VUeXBlPSdzY3JpcHQnXS0gdGhlIHNvdXJjZSB0eXBlIG9mIHRoZSBzY3JpcHQuIG9uZSBvZiAnc2NyaXB0JyBhbmQgJ21vZHVsZSdcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJvdmlkZWRPcHRpb25zLmVjbWFWZXJzaW9uPTVdLSB3aGljaCBFQ01BU2NyaXB0IHZlcnNpb24gaXMgY29uc2lkZXJlZFxuICogQHBhcmFtIHtPYmplY3R9IFtwcm92aWRlZE9wdGlvbnMuY2hpbGRWaXNpdG9yS2V5cz1udWxsXSAtIEFkZGl0aW9uYWwga25vd24gdmlzaXRvciBrZXlzLiBTZWUgW2VzcmVjdXJzZV0oaHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNyZWN1cnNlKSdzIHRoZSBgY2hpbGRWaXNpdG9yS2V5c2Agb3B0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm92aWRlZE9wdGlvbnMuZmFsbGJhY2s9J2l0ZXJhdGlvbiddIC0gQSBraW5kIG9mIHRoZSBmYWxsYmFjayBpbiBvcmRlciB0byBlbmNvdW50ZXIgd2l0aCB1bmtub3duIG5vZGUuIFNlZSBbZXNyZWN1cnNlXShodHRwczovL2dpdGh1Yi5jb20vZXN0b29scy9lc3JlY3Vyc2UpJ3MgdGhlIGBmYWxsYmFja2Agb3B0aW9uLlxuICogQHJldHVybiB7U2NvcGVNYW5hZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZSh0cmVlLCBwcm92aWRlZE9wdGlvbnMpIHtcbiAgICB2YXIgc2NvcGVNYW5hZ2VyLCByZWZlcmVuY2VyLCBvcHRpb25zO1xuXG4gICAgb3B0aW9ucyA9IHVwZGF0ZURlZXBseShkZWZhdWx0T3B0aW9ucygpLCBwcm92aWRlZE9wdGlvbnMpO1xuXG4gICAgc2NvcGVNYW5hZ2VyID0gbmV3IFNjb3BlTWFuYWdlcihvcHRpb25zKTtcblxuICAgIHJlZmVyZW5jZXIgPSBuZXcgUmVmZXJlbmNlcihvcHRpb25zLCBzY29wZU1hbmFnZXIpO1xuICAgIHJlZmVyZW5jZXIudmlzaXQodHJlZSk7XG5cbiAgICBhc3NlcnQoc2NvcGVNYW5hZ2VyLl9fY3VycmVudFNjb3BlID09PSBudWxsLCAnY3VycmVudFNjb3BlIHNob3VsZCBiZSBudWxsLicpO1xuXG4gICAgcmV0dXJuIHNjb3BlTWFuYWdlcjtcbn1cblxuZXhwb3J0IHtcbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS52ZXJzaW9uICovXG4gICAgdmVyc2lvbixcbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS5SZWZlcmVuY2UgKi9cbiAgICBSZWZlcmVuY2UsXG4gICAgLyoqIEBuYW1lIG1vZHVsZTplc2NvcGUuVmFyaWFibGUgKi9cbiAgICBWYXJpYWJsZSxcbiAgICAvKiogQG5hbWUgbW9kdWxlOmVzY29wZS5TY29wZSAqL1xuICAgIFNjb3BlLFxuICAgIC8qKiBAbmFtZSBtb2R1bGU6ZXNjb3BlLlNjb3BlTWFuYWdlciAqL1xuICAgIFNjb3BlTWFuYWdlclxufTtcblxuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */
	
	var _es6WeakMap = __webpack_require__(11);
	
	var _es6WeakMap2 = _interopRequireDefault(_es6WeakMap);
	
	var _scope = __webpack_require__(56);
	
	var _scope2 = _interopRequireDefault(_scope);
	
	var _assert = __webpack_require__(3);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class ScopeManager
	 */
	
	var ScopeManager = function () {
	    function ScopeManager(options) {
	        _classCallCheck(this, ScopeManager);
	
	        this.scopes = [];
	        this.globalScope = null;
	        this.__nodeToScope = new _es6WeakMap2.default();
	        this.__currentScope = null;
	        this.__options = options;
	        this.__declaredVariables = new _es6WeakMap2.default();
	    }
	
	    _createClass(ScopeManager, [{
	        key: '__useDirective',
	        value: function __useDirective() {
	            return this.__options.directive;
	        }
	    }, {
	        key: '__isOptimistic',
	        value: function __isOptimistic() {
	            return this.__options.optimistic;
	        }
	    }, {
	        key: '__ignoreEval',
	        value: function __ignoreEval() {
	            return this.__options.ignoreEval;
	        }
	    }, {
	        key: '__isNodejsScope',
	        value: function __isNodejsScope() {
	            return this.__options.nodejsScope;
	        }
	    }, {
	        key: 'isModule',
	        value: function isModule() {
	            return this.__options.sourceType === 'module';
	        }
	    }, {
	        key: 'isImpliedStrict',
	        value: function isImpliedStrict() {
	            return this.__options.impliedStrict;
	        }
	    }, {
	        key: 'isStrictModeSupported',
	        value: function isStrictModeSupported() {
	            return this.__options.ecmaVersion >= 5;
	        }
	
	        // Returns appropriate scope for this node.
	
	    }, {
	        key: '__get',
	        value: function __get(node) {
	            return this.__nodeToScope.get(node);
	        }
	
	        /**
	         * Get variables that are declared by the node.
	         *
	         * "are declared by the node" means the node is same as `Variable.defs[].node` or `Variable.defs[].parent`.
	         * If the node declares nothing, this method returns an empty array.
	         * CAUTION: This API is experimental. See https://github.com/estools/escope/pull/69 for more details.
	         *
	         * @param {Esprima.Node} node - a node to get.
	         * @returns {Variable[]} variables that declared by the node.
	         */
	
	    }, {
	        key: 'getDeclaredVariables',
	        value: function getDeclaredVariables(node) {
	            return this.__declaredVariables.get(node) || [];
	        }
	
	        /**
	         * acquire scope from node.
	         * @method ScopeManager#acquire
	         * @param {Esprima.Node} node - node for the acquired scope.
	         * @param {boolean=} inner - look up the most inner scope, default value is false.
	         * @return {Scope?}
	         */
	
	    }, {
	        key: 'acquire',
	        value: function acquire(node, inner) {
	            var scopes, scope, i, iz;
	
	            function predicate(scope) {
	                if (scope.type === 'function' && scope.functionExpressionScope) {
	                    return false;
	                }
	                if (scope.type === 'TDZ') {
	                    return false;
	                }
	                return true;
	            }
	
	            scopes = this.__get(node);
	            if (!scopes || scopes.length === 0) {
	                return null;
	            }
	
	            // Heuristic selection from all scopes.
	            // If you would like to get all scopes, please use ScopeManager#acquireAll.
	            if (scopes.length === 1) {
	                return scopes[0];
	            }
	
	            if (inner) {
	                for (i = scopes.length - 1; i >= 0; --i) {
	                    scope = scopes[i];
	                    if (predicate(scope)) {
	                        return scope;
	                    }
	                }
	            } else {
	                for (i = 0, iz = scopes.length; i < iz; ++i) {
	                    scope = scopes[i];
	                    if (predicate(scope)) {
	                        return scope;
	                    }
	                }
	            }
	
	            return null;
	        }
	
	        /**
	         * acquire all scopes from node.
	         * @method ScopeManager#acquireAll
	         * @param {Esprima.Node} node - node for the acquired scope.
	         * @return {Scope[]?}
	         */
	
	    }, {
	        key: 'acquireAll',
	        value: function acquireAll(node) {
	            return this.__get(node);
	        }
	
	        /**
	         * release the node.
	         * @method ScopeManager#release
	         * @param {Esprima.Node} node - releasing node.
	         * @param {boolean=} inner - look up the most inner scope, default value is false.
	         * @return {Scope?} upper scope for the node.
	         */
	
	    }, {
	        key: 'release',
	        value: function release(node, inner) {
	            var scopes, scope;
	            scopes = this.__get(node);
	            if (scopes && scopes.length) {
	                scope = scopes[0].upper;
	                if (!scope) {
	                    return null;
	                }
	                return this.acquire(scope.block, inner);
	            }
	            return null;
	        }
	    }, {
	        key: 'attach',
	        value: function attach() {}
	    }, {
	        key: 'detach',
	        value: function detach() {}
	    }, {
	        key: '__nestScope',
	        value: function __nestScope(scope) {
	            if (scope instanceof _scope.GlobalScope) {
	                (0, _assert2.default)(this.__currentScope === null);
	                this.globalScope = scope;
	            }
	            this.__currentScope = scope;
	            return scope;
	        }
	    }, {
	        key: '__nestGlobalScope',
	        value: function __nestGlobalScope(node) {
	            return this.__nestScope(new _scope.GlobalScope(this, node));
	        }
	    }, {
	        key: '__nestBlockScope',
	        value: function __nestBlockScope(node, isMethodDefinition) {
	            return this.__nestScope(new _scope.BlockScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestFunctionScope',
	        value: function __nestFunctionScope(node, isMethodDefinition) {
	            return this.__nestScope(new _scope.FunctionScope(this, this.__currentScope, node, isMethodDefinition));
	        }
	    }, {
	        key: '__nestForScope',
	        value: function __nestForScope(node) {
	            return this.__nestScope(new _scope.ForScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestCatchScope',
	        value: function __nestCatchScope(node) {
	            return this.__nestScope(new _scope.CatchScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestWithScope',
	        value: function __nestWithScope(node) {
	            return this.__nestScope(new _scope.WithScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestClassScope',
	        value: function __nestClassScope(node) {
	            return this.__nestScope(new _scope.ClassScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestSwitchScope',
	        value: function __nestSwitchScope(node) {
	            return this.__nestScope(new _scope.SwitchScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestModuleScope',
	        value: function __nestModuleScope(node) {
	            return this.__nestScope(new _scope.ModuleScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestTDZScope',
	        value: function __nestTDZScope(node) {
	            return this.__nestScope(new _scope.TDZScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__nestFunctionExpressionNameScope',
	        value: function __nestFunctionExpressionNameScope(node) {
	            return this.__nestScope(new _scope.FunctionExpressionNameScope(this, this.__currentScope, node));
	        }
	    }, {
	        key: '__isES6',
	        value: function __isES6() {
	            return this.__options.ecmaVersion >= 6;
	        }
	    }]);
	
	    return ScopeManager;
	}();
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	
	
	exports.default = ScopeManager;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjb3BlLW1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7Ozs7Ozs7O0lBbUJxQjtBQUNqQixhQURpQixZQUNqQixDQUFZLE9BQVosRUFBcUI7OEJBREosY0FDSTs7QUFDakIsYUFBSyxNQUFMLEdBQWMsRUFBZCxDQURpQjtBQUVqQixhQUFLLFdBQUwsR0FBbUIsSUFBbkIsQ0FGaUI7QUFHakIsYUFBSyxhQUFMLEdBQXFCLDBCQUFyQixDQUhpQjtBQUlqQixhQUFLLGNBQUwsR0FBc0IsSUFBdEIsQ0FKaUI7QUFLakIsYUFBSyxTQUFMLEdBQWlCLE9BQWpCLENBTGlCO0FBTWpCLGFBQUssbUJBQUwsR0FBMkIsMEJBQTNCLENBTmlCO0tBQXJCOztpQkFEaUI7O3lDQVVBO0FBQ2IsbUJBQU8sS0FBSyxTQUFMLENBQWUsU0FBZixDQURNOzs7O3lDQUlBO0FBQ2IsbUJBQU8sS0FBSyxTQUFMLENBQWUsVUFBZixDQURNOzs7O3VDQUlGO0FBQ1gsbUJBQU8sS0FBSyxTQUFMLENBQWUsVUFBZixDQURJOzs7OzBDQUlHO0FBQ2QsbUJBQU8sS0FBSyxTQUFMLENBQWUsV0FBZixDQURPOzs7O21DQUlQO0FBQ1AsbUJBQU8sS0FBSyxTQUFMLENBQWUsVUFBZixLQUE4QixRQUE5QixDQURBOzs7OzBDQUlPO0FBQ2QsbUJBQU8sS0FBSyxTQUFMLENBQWUsYUFBZixDQURPOzs7O2dEQUlNO0FBQ3BCLG1CQUFPLEtBQUssU0FBTCxDQUFlLFdBQWYsSUFBOEIsQ0FBOUIsQ0FEYTs7Ozs7Ozs4QkFLbEIsTUFBTTtBQUNSLG1CQUFPLEtBQUssYUFBTCxDQUFtQixHQUFuQixDQUF1QixJQUF2QixDQUFQLENBRFE7Ozs7Ozs7Ozs7Ozs7Ozs7NkNBY1MsTUFBTTtBQUN2QixtQkFBTyxLQUFLLG1CQUFMLENBQXlCLEdBQXpCLENBQTZCLElBQTdCLEtBQXNDLEVBQXRDLENBRGdCOzs7Ozs7Ozs7Ozs7O2dDQVduQixNQUFNLE9BQU87QUFDakIsZ0JBQUksTUFBSixFQUFZLEtBQVosRUFBbUIsQ0FBbkIsRUFBc0IsRUFBdEIsQ0FEaUI7O0FBR2pCLHFCQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEI7QUFDdEIsb0JBQUksTUFBTSxJQUFOLEtBQWUsVUFBZixJQUE2QixNQUFNLHVCQUFOLEVBQStCO0FBQzVELDJCQUFPLEtBQVAsQ0FENEQ7aUJBQWhFO0FBR0Esb0JBQUksTUFBTSxJQUFOLEtBQWUsS0FBZixFQUFzQjtBQUN0QiwyQkFBTyxLQUFQLENBRHNCO2lCQUExQjtBQUdBLHVCQUFPLElBQVAsQ0FQc0I7YUFBMUI7O0FBVUEscUJBQVMsS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFULENBYmlCO0FBY2pCLGdCQUFJLENBQUMsTUFBRCxJQUFXLE9BQU8sTUFBUCxLQUFrQixDQUFsQixFQUFxQjtBQUNoQyx1QkFBTyxJQUFQLENBRGdDO2FBQXBDOzs7O0FBZGlCLGdCQW9CYixPQUFPLE1BQVAsS0FBa0IsQ0FBbEIsRUFBcUI7QUFDckIsdUJBQU8sT0FBTyxDQUFQLENBQVAsQ0FEcUI7YUFBekI7O0FBSUEsZ0JBQUksS0FBSixFQUFXO0FBQ1AscUJBQUssSUFBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBaEIsRUFBbUIsS0FBSyxDQUFMLEVBQVEsRUFBRSxDQUFGLEVBQUs7QUFDckMsNEJBQVEsT0FBTyxDQUFQLENBQVIsQ0FEcUM7QUFFckMsd0JBQUksVUFBVSxLQUFWLENBQUosRUFBc0I7QUFDbEIsK0JBQU8sS0FBUCxDQURrQjtxQkFBdEI7aUJBRko7YUFESixNQU9PO0FBQ0gscUJBQUssSUFBSSxDQUFKLEVBQU8sS0FBSyxPQUFPLE1BQVAsRUFBZSxJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUN6Qyw0QkFBUSxPQUFPLENBQVAsQ0FBUixDQUR5QztBQUV6Qyx3QkFBSSxVQUFVLEtBQVYsQ0FBSixFQUFzQjtBQUNsQiwrQkFBTyxLQUFQLENBRGtCO3FCQUF0QjtpQkFGSjthQVJKOztBQWdCQSxtQkFBTyxJQUFQLENBeENpQjs7Ozs7Ozs7Ozs7O21DQWlEVixNQUFNO0FBQ2IsbUJBQU8sS0FBSyxLQUFMLENBQVcsSUFBWCxDQUFQLENBRGE7Ozs7Ozs7Ozs7Ozs7Z0NBV1QsTUFBTSxPQUFPO0FBQ2pCLGdCQUFJLE1BQUosRUFBWSxLQUFaLENBRGlCO0FBRWpCLHFCQUFTLEtBQUssS0FBTCxDQUFXLElBQVgsQ0FBVCxDQUZpQjtBQUdqQixnQkFBSSxVQUFVLE9BQU8sTUFBUCxFQUFlO0FBQ3pCLHdCQUFRLE9BQU8sQ0FBUCxFQUFVLEtBQVYsQ0FEaUI7QUFFekIsb0JBQUksQ0FBQyxLQUFELEVBQVE7QUFDUiwyQkFBTyxJQUFQLENBRFE7aUJBQVo7QUFHQSx1QkFBTyxLQUFLLE9BQUwsQ0FBYSxNQUFNLEtBQU4sRUFBYSxLQUExQixDQUFQLENBTHlCO2FBQTdCO0FBT0EsbUJBQU8sSUFBUCxDQVZpQjs7OztpQ0FhWjs7O2lDQUVBOzs7b0NBRUcsT0FBTztBQUNmLGdCQUFJLG1DQUFKLEVBQWtDO0FBQzlCLHNDQUFPLEtBQUssY0FBTCxLQUF3QixJQUF4QixDQUFQLENBRDhCO0FBRTlCLHFCQUFLLFdBQUwsR0FBbUIsS0FBbkIsQ0FGOEI7YUFBbEM7QUFJQSxpQkFBSyxjQUFMLEdBQXNCLEtBQXRCLENBTGU7QUFNZixtQkFBTyxLQUFQLENBTmU7Ozs7MENBU0QsTUFBTTtBQUNwQixtQkFBTyxLQUFLLFdBQUwsQ0FBaUIsdUJBQWdCLElBQWhCLEVBQXNCLElBQXRCLENBQWpCLENBQVAsQ0FEb0I7Ozs7eUNBSVAsTUFBTSxvQkFBb0I7QUFDdkMsbUJBQU8sS0FBSyxXQUFMLENBQWlCLHNCQUFlLElBQWYsRUFBcUIsS0FBSyxjQUFMLEVBQXFCLElBQTFDLENBQWpCLENBQVAsQ0FEdUM7Ozs7NENBSXZCLE1BQU0sb0JBQW9CO0FBQzFDLG1CQUFPLEtBQUssV0FBTCxDQUFpQix5QkFBa0IsSUFBbEIsRUFBd0IsS0FBSyxjQUFMLEVBQXFCLElBQTdDLEVBQW1ELGtCQUFuRCxDQUFqQixDQUFQLENBRDBDOzs7O3VDQUkvQixNQUFNO0FBQ2pCLG1CQUFPLEtBQUssV0FBTCxDQUFpQixvQkFBYSxJQUFiLEVBQW1CLEtBQUssY0FBTCxFQUFxQixJQUF4QyxDQUFqQixDQUFQLENBRGlCOzs7O3lDQUlKLE1BQU07QUFDbkIsbUJBQU8sS0FBSyxXQUFMLENBQWlCLHNCQUFlLElBQWYsRUFBcUIsS0FBSyxjQUFMLEVBQXFCLElBQTFDLENBQWpCLENBQVAsQ0FEbUI7Ozs7d0NBSVAsTUFBTTtBQUNsQixtQkFBTyxLQUFLLFdBQUwsQ0FBaUIscUJBQWMsSUFBZCxFQUFvQixLQUFLLGNBQUwsRUFBcUIsSUFBekMsQ0FBakIsQ0FBUCxDQURrQjs7Ozt5Q0FJTCxNQUFNO0FBQ25CLG1CQUFPLEtBQUssV0FBTCxDQUFpQixzQkFBZSxJQUFmLEVBQXFCLEtBQUssY0FBTCxFQUFxQixJQUExQyxDQUFqQixDQUFQLENBRG1COzs7OzBDQUlMLE1BQU07QUFDcEIsbUJBQU8sS0FBSyxXQUFMLENBQWlCLHVCQUFnQixJQUFoQixFQUFzQixLQUFLLGNBQUwsRUFBcUIsSUFBM0MsQ0FBakIsQ0FBUCxDQURvQjs7OzswQ0FJTixNQUFNO0FBQ3BCLG1CQUFPLEtBQUssV0FBTCxDQUFpQix1QkFBZ0IsSUFBaEIsRUFBc0IsS0FBSyxjQUFMLEVBQXFCLElBQTNDLENBQWpCLENBQVAsQ0FEb0I7Ozs7dUNBSVQsTUFBTTtBQUNqQixtQkFBTyxLQUFLLFdBQUwsQ0FBaUIsb0JBQWEsSUFBYixFQUFtQixLQUFLLGNBQUwsRUFBcUIsSUFBeEMsQ0FBakIsQ0FBUCxDQURpQjs7OzswREFJYSxNQUFNO0FBQ3BDLG1CQUFPLEtBQUssV0FBTCxDQUFpQix1Q0FBZ0MsSUFBaEMsRUFBc0MsS0FBSyxjQUFMLEVBQXFCLElBQTNELENBQWpCLENBQVAsQ0FEb0M7Ozs7a0NBSTlCO0FBQ04sbUJBQU8sS0FBSyxTQUFMLENBQWUsV0FBZixJQUE4QixDQUE5QixDQUREOzs7O1dBbE1PIiwiZmlsZSI6InNjb3BlLW1hbmFnZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCBXZWFrTWFwIGZyb20gJ2VzNi13ZWFrLW1hcCc7XG5pbXBvcnQgU2NvcGUgZnJvbSAnLi9zY29wZSc7XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5cbmltcG9ydCB7XG4gICAgR2xvYmFsU2NvcGUsXG4gICAgQ2F0Y2hTY29wZSxcbiAgICBXaXRoU2NvcGUsXG4gICAgTW9kdWxlU2NvcGUsXG4gICAgQ2xhc3NTY29wZSxcbiAgICBTd2l0Y2hTY29wZSxcbiAgICBGdW5jdGlvblNjb3BlLFxuICAgIEZvclNjb3BlLFxuICAgIFREWlNjb3BlLFxuICAgIEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZSxcbiAgICBCbG9ja1Njb3BlXG59IGZyb20gJy4vc2NvcGUnO1xuXG4vKipcbiAqIEBjbGFzcyBTY29wZU1hbmFnZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2NvcGVNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzID0gW107XG4gICAgICAgIHRoaXMuZ2xvYmFsU2NvcGUgPSBudWxsO1xuICAgICAgICB0aGlzLl9fbm9kZVRvU2NvcGUgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9fY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9fZGVjbGFyZWRWYXJpYWJsZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cblxuICAgIF9fdXNlRGlyZWN0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIF9faXNPcHRpbWlzdGljKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMub3B0aW1pc3RpYztcbiAgICB9XG5cbiAgICBfX2lnbm9yZUV2YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5pZ25vcmVFdmFsO1xuICAgIH1cblxuICAgIF9faXNOb2RlanNTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vcHRpb25zLm5vZGVqc1Njb3BlO1xuICAgIH1cblxuICAgIGlzTW9kdWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuc291cmNlVHlwZSA9PT0gJ21vZHVsZSc7XG4gICAgfVxuXG4gICAgaXNJbXBsaWVkU3RyaWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29wdGlvbnMuaW1wbGllZFN0cmljdDtcbiAgICB9XG5cbiAgICBpc1N0cmljdE1vZGVTdXBwb3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1O1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgYXBwcm9wcmlhdGUgc2NvcGUgZm9yIHRoaXMgbm9kZS5cbiAgICBfX2dldChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbm9kZVRvU2NvcGUuZ2V0KG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB2YXJpYWJsZXMgdGhhdCBhcmUgZGVjbGFyZWQgYnkgdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBcImFyZSBkZWNsYXJlZCBieSB0aGUgbm9kZVwiIG1lYW5zIHRoZSBub2RlIGlzIHNhbWUgYXMgYFZhcmlhYmxlLmRlZnNbXS5ub2RlYCBvciBgVmFyaWFibGUuZGVmc1tdLnBhcmVudGAuXG4gICAgICogSWYgdGhlIG5vZGUgZGVjbGFyZXMgbm90aGluZywgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBlbXB0eSBhcnJheS5cbiAgICAgKiBDQVVUSU9OOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXN0b29scy9lc2NvcGUvcHVsbC82OSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFc3ByaW1hLk5vZGV9IG5vZGUgLSBhIG5vZGUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtWYXJpYWJsZVtdfSB2YXJpYWJsZXMgdGhhdCBkZWNsYXJlZCBieSB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBnZXREZWNsYXJlZFZhcmlhYmxlcyhub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZGVjbGFyZWRWYXJpYWJsZXMuZ2V0KG5vZGUpIHx8IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFjcXVpcmUgc2NvcGUgZnJvbSBub2RlLlxuICAgICAqIEBtZXRob2QgU2NvcGVNYW5hZ2VyI2FjcXVpcmVcbiAgICAgKiBAcGFyYW0ge0VzcHJpbWEuTm9kZX0gbm9kZSAtIG5vZGUgZm9yIHRoZSBhY3F1aXJlZCBzY29wZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpbm5lciAtIGxvb2sgdXAgdGhlIG1vc3QgaW5uZXIgc2NvcGUsIGRlZmF1bHQgdmFsdWUgaXMgZmFsc2UuXG4gICAgICogQHJldHVybiB7U2NvcGU/fVxuICAgICAqL1xuICAgIGFjcXVpcmUobm9kZSwgaW5uZXIpIHtcbiAgICAgICAgdmFyIHNjb3Blcywgc2NvcGUsIGksIGl6O1xuXG4gICAgICAgIGZ1bmN0aW9uIHByZWRpY2F0ZShzY29wZSkge1xuICAgICAgICAgICAgaWYgKHNjb3BlLnR5cGUgPT09ICdmdW5jdGlvbicgJiYgc2NvcGUuZnVuY3Rpb25FeHByZXNzaW9uU2NvcGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NvcGUudHlwZSA9PT0gJ1REWicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlcyA9IHRoaXMuX19nZXQobm9kZSk7XG4gICAgICAgIGlmICghc2NvcGVzIHx8IHNjb3Blcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGV1cmlzdGljIHNlbGVjdGlvbiBmcm9tIGFsbCBzY29wZXMuXG4gICAgICAgIC8vIElmIHlvdSB3b3VsZCBsaWtlIHRvIGdldCBhbGwgc2NvcGVzLCBwbGVhc2UgdXNlIFNjb3BlTWFuYWdlciNhY3F1aXJlQWxsLlxuICAgICAgICBpZiAoc2NvcGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjb3Blc1swXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbm5lcikge1xuICAgICAgICAgICAgZm9yIChpID0gc2NvcGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShzY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGl6ID0gc2NvcGVzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgICAgICBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlKHNjb3BlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWNxdWlyZSBhbGwgc2NvcGVzIGZyb20gbm9kZS5cbiAgICAgKiBAbWV0aG9kIFNjb3BlTWFuYWdlciNhY3F1aXJlQWxsXG4gICAgICogQHBhcmFtIHtFc3ByaW1hLk5vZGV9IG5vZGUgLSBub2RlIGZvciB0aGUgYWNxdWlyZWQgc2NvcGUuXG4gICAgICogQHJldHVybiB7U2NvcGVbXT99XG4gICAgICovXG4gICAgYWNxdWlyZUFsbChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZ2V0KG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJlbGVhc2UgdGhlIG5vZGUuXG4gICAgICogQG1ldGhvZCBTY29wZU1hbmFnZXIjcmVsZWFzZVxuICAgICAqIEBwYXJhbSB7RXNwcmltYS5Ob2RlfSBub2RlIC0gcmVsZWFzaW5nIG5vZGUuXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5uZXIgLSBsb29rIHVwIHRoZSBtb3N0IGlubmVyIHNjb3BlLCBkZWZhdWx0IHZhbHVlIGlzIGZhbHNlLlxuICAgICAqIEByZXR1cm4ge1Njb3BlP30gdXBwZXIgc2NvcGUgZm9yIHRoZSBub2RlLlxuICAgICAqL1xuICAgIHJlbGVhc2Uobm9kZSwgaW5uZXIpIHtcbiAgICAgICAgdmFyIHNjb3Blcywgc2NvcGU7XG4gICAgICAgIHNjb3BlcyA9IHRoaXMuX19nZXQobm9kZSk7XG4gICAgICAgIGlmIChzY29wZXMgJiYgc2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc2NvcGUgPSBzY29wZXNbMF0udXBwZXI7XG4gICAgICAgICAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hY3F1aXJlKHNjb3BlLmJsb2NrLCBpbm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYXR0YWNoKCkgeyB9XG5cbiAgICBkZXRhY2goKSB7IH1cblxuICAgIF9fbmVzdFNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGlmIChzY29wZSBpbnN0YW5jZW9mIEdsb2JhbFNjb3BlKSB7XG4gICAgICAgICAgICBhc3NlcnQodGhpcy5fX2N1cnJlbnRTY29wZSA9PT0gbnVsbCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbFNjb3BlID0gc2NvcGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N1cnJlbnRTY29wZSA9IHNjb3BlO1xuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfVxuXG4gICAgX19uZXN0R2xvYmFsU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgR2xvYmFsU2NvcGUodGhpcywgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdEJsb2NrU2NvcGUobm9kZSwgaXNNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBCbG9ja1Njb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RGdW5jdGlvblNjb3BlKG5vZGUsIGlzTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgRnVuY3Rpb25TY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlLCBpc01ldGhvZERlZmluaXRpb24pKTtcbiAgICB9XG5cbiAgICBfX25lc3RGb3JTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBGb3JTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0Q2F0Y2hTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBDYXRjaFNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RXaXRoU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgV2l0aFNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RDbGFzc1Njb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IENsYXNzU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdFN3aXRjaFNjb3BlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19uZXN0U2NvcGUobmV3IFN3aXRjaFNjb3BlKHRoaXMsIHRoaXMuX19jdXJyZW50U2NvcGUsIG5vZGUpKTtcbiAgICB9XG5cbiAgICBfX25lc3RNb2R1bGVTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBNb2R1bGVTY29wZSh0aGlzLCB0aGlzLl9fY3VycmVudFNjb3BlLCBub2RlKSk7XG4gICAgfVxuXG4gICAgX19uZXN0VERaU2NvcGUobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX25lc3RTY29wZShuZXcgVERaU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9fbmVzdEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZShub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fbmVzdFNjb3BlKG5ldyBGdW5jdGlvbkV4cHJlc3Npb25OYW1lU2NvcGUodGhpcywgdGhpcy5fX2N1cnJlbnRTY29wZSwgbm9kZSkpO1xuICAgIH1cblxuICAgIF9faXNFUzYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2O1xuICAgIH1cbn1cblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(12)() ? WeakMap : __webpack_require__(13);


/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var weakMap, x;
		if (typeof WeakMap !== 'function') return false;
		try {
			// WebKit doesn't support arguments and crashes
			weakMap = new WeakMap([[x = {}, 'one'], [{}, 'two'], [{}, 'three']]);
		} catch (e) {
			return false;
		}
		if (String(weakMap) !== '[object WeakMap]') return false;
		if (typeof weakMap.set !== 'function') return false;
		if (weakMap.set({}, 1) !== weakMap) return false;
		if (typeof weakMap.delete !== 'function') return false;
		if (typeof weakMap.has !== 'function') return false;
		if (weakMap.get(x) !== 'one') return false;
	
		return true;
	};


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var setPrototypeOf    = __webpack_require__(14)
	  , object            = __webpack_require__(20)
	  , value             = __webpack_require__(18)
	  , randomUniq        = __webpack_require__(21)
	  , d                 = __webpack_require__(22)
	  , getIterator       = __webpack_require__(34)
	  , forOf             = __webpack_require__(54)
	  , toStringTagSymbol = __webpack_require__(46).toStringTag
	  , isNative          = __webpack_require__(55)
	
	  , isArray = Array.isArray, defineProperty = Object.defineProperty
	  , hasOwnProperty = Object.prototype.hasOwnProperty, getPrototypeOf = Object.getPrototypeOf
	  , WeakMapPoly;
	
	module.exports = WeakMapPoly = function (/*iterable*/) {
		var iterable = arguments[0], self;
		if (!(this instanceof WeakMapPoly)) throw new TypeError('Constructor requires \'new\'');
		if (isNative && setPrototypeOf && (WeakMap !== WeakMapPoly)) {
			self = setPrototypeOf(new WeakMap(), getPrototypeOf(this));
		} else {
			self = this;
		}
		if (iterable != null) {
			if (!isArray(iterable)) iterable = getIterator(iterable);
		}
		defineProperty(self, '__weakMapData__', d('c', '$weakMap$' + randomUniq()));
		if (!iterable) return self;
		forOf(iterable, function (val) {
			value(val);
			self.set(val[0], val[1]);
		});
		return self;
	};
	
	if (isNative) {
		if (setPrototypeOf) setPrototypeOf(WeakMapPoly, WeakMap);
		WeakMapPoly.prototype = Object.create(WeakMap.prototype, {
			constructor: d(WeakMapPoly)
		});
	}
	
	Object.defineProperties(WeakMapPoly.prototype, {
		delete: d(function (key) {
			if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
				delete key[this.__weakMapData__];
				return true;
			}
			return false;
		}),
		get: d(function (key) {
			if (hasOwnProperty.call(object(key), this.__weakMapData__)) {
				return key[this.__weakMapData__];
			}
		}),
		has: d(function (key) {
			return hasOwnProperty.call(object(key), this.__weakMapData__);
		}),
		set: d(function (key, value) {
			defineProperty(object(key), this.__weakMapData__, d('c', value));
			return this;
		}),
		toString: d(function () { return '[object WeakMap]'; })
	});
	defineProperty(WeakMapPoly.prototype, toStringTagSymbol, d('c', 'WeakMap'));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(15)()
		? Object.setPrototypeOf
		: __webpack_require__(16);


/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';
	
	var create = Object.create, getPrototypeOf = Object.getPrototypeOf
	  , x = {};
	
	module.exports = function (/*customCreate*/) {
		var setPrototypeOf = Object.setPrototypeOf
		  , customCreate = arguments[0] || create;
		if (typeof setPrototypeOf !== 'function') return false;
		return getPrototypeOf(setPrototypeOf(customCreate(null), x)) === x;
	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// Big thanks to @WebReflection for sorting this out
	// https://gist.github.com/WebReflection/5593554
	
	'use strict';
	
	var isObject      = __webpack_require__(17)
	  , value         = __webpack_require__(18)
	
	  , isPrototypeOf = Object.prototype.isPrototypeOf
	  , defineProperty = Object.defineProperty
	  , nullDesc = { configurable: true, enumerable: false, writable: true,
			value: undefined }
	  , validate;
	
	validate = function (obj, prototype) {
		value(obj);
		if ((prototype === null) || isObject(prototype)) return obj;
		throw new TypeError('Prototype must be null or an object');
	};
	
	module.exports = (function (status) {
		var fn, set;
		if (!status) return null;
		if (status.level === 2) {
			if (status.set) {
				set = status.set;
				fn = function (obj, prototype) {
					set.call(validate(obj, prototype), prototype);
					return obj;
				};
			} else {
				fn = function (obj, prototype) {
					validate(obj, prototype).__proto__ = prototype;
					return obj;
				};
			}
		} else {
			fn = function self(obj, prototype) {
				var isNullBase;
				validate(obj, prototype);
				isNullBase = isPrototypeOf.call(self.nullPolyfill, obj);
				if (isNullBase) delete self.nullPolyfill.__proto__;
				if (prototype === null) prototype = self.nullPolyfill;
				obj.__proto__ = prototype;
				if (isNullBase) defineProperty(self.nullPolyfill, '__proto__', nullDesc);
				return obj;
			};
		}
		return Object.defineProperty(fn, 'level', { configurable: false,
			enumerable: false, writable: false, value: status.level });
	}((function () {
		var x = Object.create(null), y = {}, set
		  , desc = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');
	
		if (desc) {
			try {
				set = desc.set; // Opera crashes at this point
				set.call(x, y);
			} catch (ignore) { }
			if (Object.getPrototypeOf(x) === y) return { set: set, level: 2 };
		}
	
		x.__proto__ = y;
		if (Object.getPrototypeOf(x) === y) return { level: 2 };
	
		x = {};
		x.__proto__ = y;
		if (Object.getPrototypeOf(x) === y) return { level: 1 };
	
		return false;
	}())));
	
	__webpack_require__(19);


/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';
	
	var map = { function: true, object: true };
	
	module.exports = function (x) {
		return ((x != null) && map[typeof x]) || false;
	};


/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		if (value == null) throw new TypeError("Cannot use null or undefined");
		return value;
	};


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	// Workaround for http://code.google.com/p/v8/issues/detail?id=2804
	
	'use strict';
	
	var create = Object.create, shim;
	
	if (!__webpack_require__(15)()) {
		shim = __webpack_require__(16);
	}
	
	module.exports = (function () {
		var nullObject, props, desc;
		if (!shim) return create;
		if (shim.level !== 1) return create;
	
		nullObject = {};
		props = {};
		desc = { configurable: false, enumerable: false, writable: true,
			value: undefined };
		Object.getOwnPropertyNames(Object.prototype).forEach(function (name) {
			if (name === '__proto__') {
				props[name] = { configurable: true, enumerable: false, writable: true,
					value: undefined };
				return;
			}
			props[name] = desc;
		});
		Object.defineProperties(nullObject, props);
	
		Object.defineProperty(shim, 'nullPolyfill', { configurable: false,
			enumerable: false, writable: false, value: nullObject });
	
		return function (prototype, props) {
			return create((prototype === null) ? nullObject : prototype, props);
		};
	}());


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isObject = __webpack_require__(17);
	
	module.exports = function (value) {
		if (!isObject(value)) throw new TypeError(value + " is not an Object");
		return value;
	};


/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';
	
	var generated = Object.create(null)
	
	  , random = Math.random;
	
	module.exports = function () {
		var str;
		do { str = random().toString(36).slice(2); } while (generated[str]);
		return str;
	};


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign        = __webpack_require__(23)
	  , normalizeOpts = __webpack_require__(29)
	  , isCallable    = __webpack_require__(30)
	  , contains      = __webpack_require__(31)
	
	  , d;
	
	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}
	
		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};
	
	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}
	
		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOpts(options), desc);
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(24)()
		? Object.assign
		: __webpack_require__(25);


/***/ },
/* 24 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== 'function') return false;
		obj = { foo: 'raz' };
		assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
		return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
	};


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var keys  = __webpack_require__(26)
	  , value = __webpack_require__(18)
	
	  , max = Math.max;
	
	module.exports = function (dest, src/*, srcn*/) {
		var error, i, l = max(arguments.length, 2), assign;
		dest = Object(value(dest));
		assign = function (key) {
			try { dest[key] = src[key]; } catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < l; ++i) {
			src = arguments[i];
			keys(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(27)()
		? Object.keys
		: __webpack_require__(28);


/***/ },
/* 27 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		try {
			Object.keys('primitive');
			return true;
		} catch (e) { return false; }
	};


/***/ },
/* 28 */
/***/ function(module, exports) {

	'use strict';
	
	var keys = Object.keys;
	
	module.exports = function (object) {
		return keys(object == null ? object : Object(object));
	};


/***/ },
/* 29 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};
	
	module.exports = function (options/*, options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (options == null) return;
			process(Object(options), result);
		});
		return result;
	};


/***/ },
/* 30 */
/***/ function(module, exports) {

	// Deprecated
	
	'use strict';
	
	module.exports = function (obj) { return typeof obj === 'function'; };


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(32)()
		? String.prototype.contains
		: __webpack_require__(33);


/***/ },
/* 32 */
/***/ function(module, exports) {

	'use strict';
	
	var str = 'razdwatrzy';
	
	module.exports = function () {
		if (typeof str.contains !== 'function') return false;
		return ((str.contains('dwa') === true) && (str.contains('foo') === false));
	};


/***/ },
/* 33 */
/***/ function(module, exports) {

	'use strict';
	
	var indexOf = String.prototype.indexOf;
	
	module.exports = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isArguments    = __webpack_require__(35)
	  , isString       = __webpack_require__(36)
	  , ArrayIterator  = __webpack_require__(37)
	  , StringIterator = __webpack_require__(51)
	  , iterable       = __webpack_require__(52)
	  , iteratorSymbol = __webpack_require__(46).iterator;
	
	module.exports = function (obj) {
		if (typeof iterable(obj)[iteratorSymbol] === 'function') return obj[iteratorSymbol]();
		if (isArguments(obj)) return new ArrayIterator(obj);
		if (isString(obj)) return new StringIterator(obj);
		return new ArrayIterator(obj);
	};


/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';
	
	var toString = Object.prototype.toString
	
	  , id = toString.call((function () { return arguments; }()));
	
	module.exports = function (x) { return (toString.call(x) === id); };


/***/ },
/* 36 */
/***/ function(module, exports) {

	'use strict';
	
	var toString = Object.prototype.toString
	
	  , id = toString.call('');
	
	module.exports = function (x) {
		return (typeof x === 'string') || (x && (typeof x === 'object') &&
			((x instanceof String) || (toString.call(x) === id))) || false;
	};


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var setPrototypeOf = __webpack_require__(14)
	  , contains       = __webpack_require__(31)
	  , d              = __webpack_require__(22)
	  , Iterator       = __webpack_require__(38)
	
	  , defineProperty = Object.defineProperty
	  , ArrayIterator;
	
	ArrayIterator = module.exports = function (arr, kind) {
		if (!(this instanceof ArrayIterator)) return new ArrayIterator(arr, kind);
		Iterator.call(this, arr);
		if (!kind) kind = 'value';
		else if (contains.call(kind, 'key+value')) kind = 'key+value';
		else if (contains.call(kind, 'key')) kind = 'key';
		else kind = 'value';
		defineProperty(this, '__kind__', d('', kind));
	};
	if (setPrototypeOf) setPrototypeOf(ArrayIterator, Iterator);
	
	ArrayIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(ArrayIterator),
		_resolve: d(function (i) {
			if (this.__kind__ === 'value') return this.__list__[i];
			if (this.__kind__ === 'key+value') return [i, this.__list__[i]];
			return i;
		}),
		toString: d(function () { return '[object Array Iterator]'; })
	});


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var clear    = __webpack_require__(39)
	  , assign   = __webpack_require__(23)
	  , callable = __webpack_require__(40)
	  , value    = __webpack_require__(18)
	  , d        = __webpack_require__(22)
	  , autoBind = __webpack_require__(41)
	  , Symbol   = __webpack_require__(46)
	
	  , defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , Iterator;
	
	module.exports = Iterator = function (list, context) {
		if (!(this instanceof Iterator)) return new Iterator(list, context);
		defineProperties(this, {
			__list__: d('w', value(list)),
			__context__: d('w', context),
			__nextIndex__: d('w', 0)
		});
		if (!context) return;
		callable(context.on);
		context.on('_add', this._onAdd);
		context.on('_delete', this._onDelete);
		context.on('_clear', this._onClear);
	};
	
	defineProperties(Iterator.prototype, assign({
		constructor: d(Iterator),
		_next: d(function () {
			var i;
			if (!this.__list__) return;
			if (this.__redo__) {
				i = this.__redo__.shift();
				if (i !== undefined) return i;
			}
			if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
			this._unBind();
		}),
		next: d(function () { return this._createResult(this._next()); }),
		_createResult: d(function (i) {
			if (i === undefined) return { done: true, value: undefined };
			return { done: false, value: this._resolve(i) };
		}),
		_resolve: d(function (i) { return this.__list__[i]; }),
		_unBind: d(function () {
			this.__list__ = null;
			delete this.__redo__;
			if (!this.__context__) return;
			this.__context__.off('_add', this._onAdd);
			this.__context__.off('_delete', this._onDelete);
			this.__context__.off('_clear', this._onClear);
			this.__context__ = null;
		}),
		toString: d(function () { return '[object Iterator]'; })
	}, autoBind({
		_onAdd: d(function (index) {
			if (index >= this.__nextIndex__) return;
			++this.__nextIndex__;
			if (!this.__redo__) {
				defineProperty(this, '__redo__', d('c', [index]));
				return;
			}
			this.__redo__.forEach(function (redo, i) {
				if (redo >= index) this.__redo__[i] = ++redo;
			}, this);
			this.__redo__.push(index);
		}),
		_onDelete: d(function (index) {
			var i;
			if (index >= this.__nextIndex__) return;
			--this.__nextIndex__;
			if (!this.__redo__) return;
			i = this.__redo__.indexOf(index);
			if (i !== -1) this.__redo__.splice(i, 1);
			this.__redo__.forEach(function (redo, i) {
				if (redo > index) this.__redo__[i] = --redo;
			}, this);
		}),
		_onClear: d(function () {
			if (this.__redo__) clear.call(this.__redo__);
			this.__nextIndex__ = 0;
		})
	})));
	
	defineProperty(Iterator.prototype, Symbol.iterator, d(function () {
		return this;
	}));
	defineProperty(Iterator.prototype, Symbol.toStringTag, d('', 'Iterator'));


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	// Inspired by Google Closure:
	// http://closure-library.googlecode.com/svn/docs/
	// closure_goog_array_array.js.html#goog.array.clear
	
	'use strict';
	
	var value = __webpack_require__(18);
	
	module.exports = function () {
		value(this).length = 0;
		return this;
	};


/***/ },
/* 40 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (fn) {
		if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
		return fn;
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var copy       = __webpack_require__(42)
	  , map        = __webpack_require__(43)
	  , callable   = __webpack_require__(40)
	  , validValue = __webpack_require__(18)
	
	  , bind = Function.prototype.bind, defineProperty = Object.defineProperty
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , define;
	
	define = function (name, desc, bindTo) {
		var value = validValue(desc) && callable(desc.value), dgs;
		dgs = copy(desc);
		delete dgs.writable;
		delete dgs.value;
		dgs.get = function () {
			if (hasOwnProperty.call(this, name)) return value;
			desc.value = bind.call(value, (bindTo == null) ? this : this[bindTo]);
			defineProperty(this, name, desc);
			return this[name];
		};
		return dgs;
	};
	
	module.exports = function (props/*, bindTo*/) {
		var bindTo = arguments[1];
		return map(props, function (desc, name) {
			return define(name, desc, bindTo);
		});
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var assign = __webpack_require__(23)
	  , value  = __webpack_require__(18);
	
	module.exports = function (obj) {
		var copy = Object(value(obj));
		if (copy !== obj) return copy;
		return assign({}, obj);
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var callable = __webpack_require__(40)
	  , forEach  = __webpack_require__(44)
	
	  , call = Function.prototype.call;
	
	module.exports = function (obj, cb/*, thisArg*/) {
		var o = {}, thisArg = arguments[2];
		callable(cb);
		forEach(obj, function (value, key, obj, index) {
			o[key] = call.call(cb, thisArg, value, key, obj, index);
		});
		return o;
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(45)('forEach');


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// Internal method, used by iteration functions.
	// Calls a function for each key-value pair found in object
	// Optionally takes compareFn to iterate object in specific order
	
	'use strict';
	
	var callable = __webpack_require__(40)
	  , value    = __webpack_require__(18)
	
	  , bind = Function.prototype.bind, call = Function.prototype.call, keys = Object.keys
	  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	module.exports = function (method, defVal) {
		return function (obj, cb/*, thisArg, compareFn*/) {
			var list, thisArg = arguments[2], compareFn = arguments[3];
			obj = Object(value(obj));
			callable(cb);
	
			list = keys(obj);
			if (compareFn) {
				list.sort((typeof compareFn === 'function') ? bind.call(compareFn, obj) : undefined);
			}
			if (typeof method !== 'function') method = list[method];
			return call.call(method, list, function (key, index) {
				if (!propertyIsEnumerable.call(obj, key)) return defVal;
				return call.call(cb, thisArg, obj[key], key, obj, index);
			});
		};
	};


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(47)() ? Symbol : __webpack_require__(48);


/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';
	
	var validTypes = { object: true, symbol: true };
	
	module.exports = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }
	
		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;
	
		return true;
	};


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	// ES2015 Symbol polyfill for environments that do not support it (or partially support it)
	
	'use strict';
	
	var d              = __webpack_require__(22)
	  , validateSymbol = __webpack_require__(49)
	
	  , create = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create(null)
	  , isNativeSafe;
	
	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}
	
	var generateName = (function () {
		var created = create(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());
	
	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('TypeError: Symbol is not a constructor');
		return SymbolPolyfill(description);
	};
	
	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	module.exports = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('TypeError: Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d('', description),
			__name__: d('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),
	
		// If there's native implementation of given symbol, let's fallback to it
		// to ensure proper interoperability with other native functions e.g. Array.from
		hasInstance: d('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});
	
	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d(SymbolPolyfill),
		toString: d('', function () { return this.__name__; })
	});
	
	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d('c', 'Symbol'));
	
	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
	
	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isSymbol = __webpack_require__(50);
	
	module.exports = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};


/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	// Thanks @mathiasbynens
	// http://mathiasbynens.be/notes/javascript-unicode#iterating-over-symbols
	
	'use strict';
	
	var setPrototypeOf = __webpack_require__(14)
	  , d              = __webpack_require__(22)
	  , Iterator       = __webpack_require__(38)
	
	  , defineProperty = Object.defineProperty
	  , StringIterator;
	
	StringIterator = module.exports = function (str) {
		if (!(this instanceof StringIterator)) return new StringIterator(str);
		str = String(str);
		Iterator.call(this, str);
		defineProperty(this, '__length__', d('', str.length));
	
	};
	if (setPrototypeOf) setPrototypeOf(StringIterator, Iterator);
	
	StringIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(StringIterator),
		_next: d(function () {
			if (!this.__list__) return;
			if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
			this._unBind();
		}),
		_resolve: d(function (i) {
			var char = this.__list__[i], code;
			if (this.__nextIndex__ === this.__length__) return char;
			code = char.charCodeAt(0);
			if ((code >= 0xD800) && (code <= 0xDBFF)) return char + this.__list__[this.__nextIndex__++];
			return char;
		}),
		toString: d(function () { return '[object String Iterator]'; })
	});


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isIterable = __webpack_require__(53);
	
	module.exports = function (value) {
		if (!isIterable(value)) throw new TypeError(value + " is not iterable");
		return value;
	};


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isArguments    = __webpack_require__(35)
	  , isString       = __webpack_require__(36)
	  , iteratorSymbol = __webpack_require__(46).iterator
	
	  , isArray = Array.isArray;
	
	module.exports = function (value) {
		if (value == null) return false;
		if (isArray(value)) return true;
		if (isString(value)) return true;
		if (isArguments(value)) return true;
		return (typeof value[iteratorSymbol] === 'function');
	};


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var isArguments = __webpack_require__(35)
	  , callable    = __webpack_require__(40)
	  , isString    = __webpack_require__(36)
	  , get         = __webpack_require__(34)
	
	  , isArray = Array.isArray, call = Function.prototype.call
	  , some = Array.prototype.some;
	
	module.exports = function (iterable, cb/*, thisArg*/) {
		var mode, thisArg = arguments[2], result, doBreak, broken, i, l, char, code;
		if (isArray(iterable) || isArguments(iterable)) mode = 'array';
		else if (isString(iterable)) mode = 'string';
		else iterable = get(iterable);
	
		callable(cb);
		doBreak = function () { broken = true; };
		if (mode === 'array') {
			some.call(iterable, function (value) {
				call.call(cb, thisArg, value, doBreak);
				if (broken) return true;
			});
			return;
		}
		if (mode === 'string') {
			l = iterable.length;
			for (i = 0; i < l; ++i) {
				char = iterable[i];
				if ((i + 1) < l) {
					code = char.charCodeAt(0);
					if ((code >= 0xD800) && (code <= 0xDBFF)) char += iterable[++i];
				}
				call.call(cb, thisArg, char, doBreak);
				if (broken) break;
			}
			return;
		}
		result = iterable.next();
	
		while (!result.done) {
			call.call(cb, thisArg, result.value, doBreak);
			if (broken) return;
			result = iterable.next();
		}
	};


/***/ },
/* 55 */
/***/ function(module, exports) {

	// Exports true if environment provides native `WeakMap` implementation, whatever that is.
	
	'use strict';
	
	module.exports = (function () {
		if (typeof WeakMap !== 'function') return false;
		return (Object.prototype.toString.call(new WeakMap()) === '[object WeakMap]');
	}());


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.ClassScope = exports.ForScope = exports.FunctionScope = exports.SwitchScope = exports.BlockScope = exports.TDZScope = exports.WithScope = exports.CatchScope = exports.FunctionExpressionNameScope = exports.ModuleScope = exports.GlobalScope = undefined;
	
	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Redistribution and use in source and binary forms, with or without
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       modification, are permitted provided that the following conditions are met:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions of source code must retain the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           documentation and/or other materials provided with the distribution.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     */
	
	var _estraverse = __webpack_require__(57);
	
	var _es6Map = __webpack_require__(59);
	
	var _es6Map2 = _interopRequireDefault(_es6Map);
	
	var _reference = __webpack_require__(73);
	
	var _reference2 = _interopRequireDefault(_reference);
	
	var _variable = __webpack_require__(74);
	
	var _variable2 = _interopRequireDefault(_variable);
	
	var _definition = __webpack_require__(75);
	
	var _definition2 = _interopRequireDefault(_definition);
	
	var _assert = __webpack_require__(3);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function isStrictScope(scope, block, isMethodDefinition, useDirective) {
	    var body, i, iz, stmt, expr;
	
	    // When upper scope is exists and strict, inner scope is also strict.
	    if (scope.upper && scope.upper.isStrict) {
	        return true;
	    }
	
	    // ArrowFunctionExpression's scope is always strict scope.
	    if (block.type === _estraverse.Syntax.ArrowFunctionExpression) {
	        return true;
	    }
	
	    if (isMethodDefinition) {
	        return true;
	    }
	
	    if (scope.type === 'class' || scope.type === 'module') {
	        return true;
	    }
	
	    if (scope.type === 'block' || scope.type === 'switch') {
	        return false;
	    }
	
	    if (scope.type === 'function') {
	        if (block.type === _estraverse.Syntax.Program) {
	            body = block;
	        } else {
	            body = block.body;
	        }
	    } else if (scope.type === 'global') {
	        body = block;
	    } else {
	        return false;
	    }
	
	    // Search 'use strict' directive.
	    if (useDirective) {
	        for (i = 0, iz = body.body.length; i < iz; ++i) {
	            stmt = body.body[i];
	            if (stmt.type !== _estraverse.Syntax.DirectiveStatement) {
	                break;
	            }
	            if (stmt.raw === '"use strict"' || stmt.raw === '\'use strict\'') {
	                return true;
	            }
	        }
	    } else {
	        for (i = 0, iz = body.body.length; i < iz; ++i) {
	            stmt = body.body[i];
	            if (stmt.type !== _estraverse.Syntax.ExpressionStatement) {
	                break;
	            }
	            expr = stmt.expression;
	            if (expr.type !== _estraverse.Syntax.Literal || typeof expr.value !== 'string') {
	                break;
	            }
	            if (expr.raw != null) {
	                if (expr.raw === '"use strict"' || expr.raw === '\'use strict\'') {
	                    return true;
	                }
	            } else {
	                if (expr.value === 'use strict') {
	                    return true;
	                }
	            }
	        }
	    }
	    return false;
	}
	
	function registerScope(scopeManager, scope) {
	    var scopes;
	
	    scopeManager.scopes.push(scope);
	
	    scopes = scopeManager.__nodeToScope.get(scope.block);
	    if (scopes) {
	        scopes.push(scope);
	    } else {
	        scopeManager.__nodeToScope.set(scope.block, [scope]);
	    }
	}
	
	function shouldBeStatically(def) {
	    return def.type === _variable2.default.ClassName || def.type === _variable2.default.Variable && def.parent.kind !== 'var';
	}
	
	/**
	 * @class Scope
	 */
	
	var Scope = function () {
	    function Scope(scopeManager, type, upperScope, block, isMethodDefinition) {
	        _classCallCheck(this, Scope);
	
	        /**
	         * One of 'TDZ', 'module', 'block', 'switch', 'function', 'catch', 'with', 'function', 'class', 'global'.
	         * @member {String} Scope#type
	         */
	        this.type = type;
	        /**
	        * The scoped {@link Variable}s of this scope, as <code>{ Variable.name
	        * : Variable }</code>.
	        * @member {Map} Scope#set
	        */
	        this.set = new _es6Map2.default();
	        /**
	         * The tainted variables of this scope, as <code>{ Variable.name :
	         * boolean }</code>.
	         * @member {Map} Scope#taints */
	        this.taints = new _es6Map2.default();
	        /**
	         * Generally, through the lexical scoping of JS you can always know
	         * which variable an identifier in the source code refers to. There are
	         * a few exceptions to this rule. With 'global' and 'with' scopes you
	         * can only decide at runtime which variable a reference refers to.
	         * Moreover, if 'eval()' is used in a scope, it might introduce new
	         * bindings in this or its parent scopes.
	         * All those scopes are considered 'dynamic'.
	         * @member {boolean} Scope#dynamic
	         */
	        this.dynamic = this.type === 'global' || this.type === 'with';
	        /**
	         * A reference to the scope-defining syntax node.
	         * @member {esprima.Node} Scope#block
	         */
	        this.block = block;
	        /**
	        * The {@link Reference|references} that are not resolved with this scope.
	        * @member {Reference[]} Scope#through
	        */
	        this.through = [];
	        /**
	        * The scoped {@link Variable}s of this scope. In the case of a
	        * 'function' scope this includes the automatic argument <em>arguments</em> as
	        * its first element, as well as all further formal arguments.
	        * @member {Variable[]} Scope#variables
	        */
	        this.variables = [];
	        /**
	        * Any variable {@link Reference|reference} found in this scope. This
	        * includes occurrences of local variables as well as variables from
	        * parent scopes (including the global scope). For local variables
	        * this also includes defining occurrences (like in a 'var' statement).
	        * In a 'function' scope this does not include the occurrences of the
	        * formal parameter in the parameter list.
	        * @member {Reference[]} Scope#references
	        */
	        this.references = [];
	
	        /**
	        * For 'global' and 'function' scopes, this is a self-reference. For
	        * other scope types this is the <em>variableScope</em> value of the
	        * parent scope.
	        * @member {Scope} Scope#variableScope
	        */
	        this.variableScope = this.type === 'global' || this.type === 'function' || this.type === 'module' ? this : upperScope.variableScope;
	        /**
	        * Whether this scope is created by a FunctionExpression.
	        * @member {boolean} Scope#functionExpressionScope
	        */
	        this.functionExpressionScope = false;
	        /**
	        * Whether this is a scope that contains an 'eval()' invocation.
	        * @member {boolean} Scope#directCallToEvalScope
	        */
	        this.directCallToEvalScope = false;
	        /**
	        * @member {boolean} Scope#thisFound
	        */
	        this.thisFound = false;
	
	        this.__left = [];
	
	        /**
	        * Reference to the parent {@link Scope|scope}.
	        * @member {Scope} Scope#upper
	        */
	        this.upper = upperScope;
	        /**
	        * Whether 'use strict' is in effect in this scope.
	        * @member {boolean} Scope#isStrict
	        */
	        this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
	
	        /**
	        * List of nested {@link Scope}s.
	        * @member {Scope[]} Scope#childScopes
	        */
	        this.childScopes = [];
	        if (this.upper) {
	            this.upper.childScopes.push(this);
	        }
	
	        this.__declaredVariables = scopeManager.__declaredVariables;
	
	        registerScope(scopeManager, this);
	    }
	
	    _createClass(Scope, [{
	        key: '__shouldStaticallyClose',
	        value: function __shouldStaticallyClose(scopeManager) {
	            return !this.dynamic || scopeManager.__isOptimistic();
	        }
	    }, {
	        key: '__shouldStaticallyCloseForGlobal',
	        value: function __shouldStaticallyCloseForGlobal(ref) {
	            // On global scope, let/const/class declarations should be resolved statically.
	            var name = ref.identifier.name;
	            if (!this.set.has(name)) {
	                return false;
	            }
	
	            var variable = this.set.get(name);
	            var defs = variable.defs;
	            return defs.length > 0 && defs.every(shouldBeStatically);
	        }
	    }, {
	        key: '__staticCloseRef',
	        value: function __staticCloseRef(ref) {
	            if (!this.__resolve(ref)) {
	                this.__delegateToUpperScope(ref);
	            }
	        }
	    }, {
	        key: '__dynamicCloseRef',
	        value: function __dynamicCloseRef(ref) {
	            // notify all names are through to global
	            var current = this;
	            do {
	                current.through.push(ref);
	                current = current.upper;
	            } while (current);
	        }
	    }, {
	        key: '__globalCloseRef',
	        value: function __globalCloseRef(ref) {
	            // let/const/class declarations should be resolved statically.
	            // others should be resolved dynamically.
	            if (this.__shouldStaticallyCloseForGlobal(ref)) {
	                this.__staticCloseRef(ref);
	            } else {
	                this.__dynamicCloseRef(ref);
	            }
	        }
	    }, {
	        key: '__close',
	        value: function __close(scopeManager) {
	            var closeRef;
	            if (this.__shouldStaticallyClose(scopeManager)) {
	                closeRef = this.__staticCloseRef;
	            } else if (this.type !== 'global') {
	                closeRef = this.__dynamicCloseRef;
	            } else {
	                closeRef = this.__globalCloseRef;
	            }
	
	            // Try Resolving all references in this scope.
	            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
	                var ref = this.__left[i];
	                closeRef.call(this, ref);
	            }
	            this.__left = null;
	
	            return this.upper;
	        }
	    }, {
	        key: '__resolve',
	        value: function __resolve(ref) {
	            var variable, name;
	            name = ref.identifier.name;
	            if (this.set.has(name)) {
	                variable = this.set.get(name);
	                variable.references.push(ref);
	                variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
	                if (ref.tainted) {
	                    variable.tainted = true;
	                    this.taints.set(variable.name, true);
	                }
	                ref.resolved = variable;
	                return true;
	            }
	            return false;
	        }
	    }, {
	        key: '__delegateToUpperScope',
	        value: function __delegateToUpperScope(ref) {
	            if (this.upper) {
	                this.upper.__left.push(ref);
	            }
	            this.through.push(ref);
	        }
	    }, {
	        key: '__addDeclaredVariablesOfNode',
	        value: function __addDeclaredVariablesOfNode(variable, node) {
	            if (node == null) {
	                return;
	            }
	
	            var variables = this.__declaredVariables.get(node);
	            if (variables == null) {
	                variables = [];
	                this.__declaredVariables.set(node, variables);
	            }
	            if (variables.indexOf(variable) === -1) {
	                variables.push(variable);
	            }
	        }
	    }, {
	        key: '__defineGeneric',
	        value: function __defineGeneric(name, set, variables, node, def) {
	            var variable;
	
	            variable = set.get(name);
	            if (!variable) {
	                variable = new _variable2.default(name, this);
	                set.set(name, variable);
	                variables.push(variable);
	            }
	
	            if (def) {
	                variable.defs.push(def);
	                if (def.type !== _variable2.default.TDZ) {
	                    this.__addDeclaredVariablesOfNode(variable, def.node);
	                    this.__addDeclaredVariablesOfNode(variable, def.parent);
	                }
	            }
	            if (node) {
	                variable.identifiers.push(node);
	            }
	        }
	    }, {
	        key: '__define',
	        value: function __define(node, def) {
	            if (node && node.type === _estraverse.Syntax.Identifier) {
	                this.__defineGeneric(node.name, this.set, this.variables, node, def);
	            }
	        }
	    }, {
	        key: '__referencing',
	        value: function __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
	            // because Array element may be null
	            if (!node || node.type !== _estraverse.Syntax.Identifier) {
	                return;
	            }
	
	            // Specially handle like `this`.
	            if (node.name === 'super') {
	                return;
	            }
	
	            var ref = new _reference2.default(node, this, assign || _reference2.default.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
	            this.references.push(ref);
	            this.__left.push(ref);
	        }
	    }, {
	        key: '__detectEval',
	        value: function __detectEval() {
	            var current;
	            current = this;
	            this.directCallToEvalScope = true;
	            do {
	                current.dynamic = true;
	                current = current.upper;
	            } while (current);
	        }
	    }, {
	        key: '__detectThis',
	        value: function __detectThis() {
	            this.thisFound = true;
	        }
	    }, {
	        key: '__isClosed',
	        value: function __isClosed() {
	            return this.__left === null;
	        }
	
	        /**
	         * returns resolved {Reference}
	         * @method Scope#resolve
	         * @param {Esprima.Identifier} ident - identifier to be resolved.
	         * @return {Reference}
	         */
	
	    }, {
	        key: 'resolve',
	        value: function resolve(ident) {
	            var ref, i, iz;
	            (0, _assert2.default)(this.__isClosed(), 'Scope should be closed.');
	            (0, _assert2.default)(ident.type === _estraverse.Syntax.Identifier, 'Target should be identifier.');
	            for (i = 0, iz = this.references.length; i < iz; ++i) {
	                ref = this.references[i];
	                if (ref.identifier === ident) {
	                    return ref;
	                }
	            }
	            return null;
	        }
	
	        /**
	         * returns this scope is static
	         * @method Scope#isStatic
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isStatic',
	        value: function isStatic() {
	            return !this.dynamic;
	        }
	
	        /**
	         * returns this scope has materialized arguments
	         * @method Scope#isArgumentsMaterialized
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isArgumentsMaterialized',
	        value: function isArgumentsMaterialized() {
	            return true;
	        }
	
	        /**
	         * returns this scope has materialized `this` reference
	         * @method Scope#isThisMaterialized
	         * @return {boolean}
	         */
	
	    }, {
	        key: 'isThisMaterialized',
	        value: function isThisMaterialized() {
	            return true;
	        }
	    }, {
	        key: 'isUsedName',
	        value: function isUsedName(name) {
	            if (this.set.has(name)) {
	                return true;
	            }
	            for (var i = 0, iz = this.through.length; i < iz; ++i) {
	                if (this.through[i].identifier.name === name) {
	                    return true;
	                }
	            }
	            return false;
	        }
	    }]);
	
	    return Scope;
	}();
	
	exports.default = Scope;
	
	var GlobalScope = exports.GlobalScope = function (_Scope) {
	    _inherits(GlobalScope, _Scope);
	
	    function GlobalScope(scopeManager, block) {
	        _classCallCheck(this, GlobalScope);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GlobalScope).call(this, scopeManager, 'global', null, block, false));
	
	        _this.implicit = {
	            set: new _es6Map2.default(),
	            variables: [],
	            /**
	            * List of {@link Reference}s that are left to be resolved (i.e. which
	            * need to be linked to the variable they refer to).
	            * @member {Reference[]} Scope#implicit#left
	            */
	            left: []
	        };
	        return _this;
	    }
	
	    _createClass(GlobalScope, [{
	        key: '__close',
	        value: function __close(scopeManager) {
	            var implicit = [];
	            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
	                var ref = this.__left[i];
	                if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
	                    implicit.push(ref.__maybeImplicitGlobal);
	                }
	            }
	
	            // create an implicit global variable from assignment expression
	            for (var _i = 0, _iz = implicit.length; _i < _iz; ++_i) {
	                var info = implicit[_i];
	                this.__defineImplicit(info.pattern, new _definition2.default(_variable2.default.ImplicitGlobalVariable, info.pattern, info.node, null, null, null));
	            }
	
	            this.implicit.left = this.__left;
	
	            return _get(Object.getPrototypeOf(GlobalScope.prototype), '__close', this).call(this, scopeManager);
	        }
	    }, {
	        key: '__defineImplicit',
	        value: function __defineImplicit(node, def) {
	            if (node && node.type === _estraverse.Syntax.Identifier) {
	                this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
	            }
	        }
	    }]);
	
	    return GlobalScope;
	}(Scope);
	
	var ModuleScope = exports.ModuleScope = function (_Scope2) {
	    _inherits(ModuleScope, _Scope2);
	
	    function ModuleScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, ModuleScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleScope).call(this, scopeManager, 'module', upperScope, block, false));
	    }
	
	    return ModuleScope;
	}(Scope);
	
	var FunctionExpressionNameScope = exports.FunctionExpressionNameScope = function (_Scope3) {
	    _inherits(FunctionExpressionNameScope, _Scope3);
	
	    function FunctionExpressionNameScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, FunctionExpressionNameScope);
	
	        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionExpressionNameScope).call(this, scopeManager, 'function-expression-name', upperScope, block, false));
	
	        _this3.__define(block.id, new _definition2.default(_variable2.default.FunctionName, block.id, block, null, null, null));
	        _this3.functionExpressionScope = true;
	        return _this3;
	    }
	
	    return FunctionExpressionNameScope;
	}(Scope);
	
	var CatchScope = exports.CatchScope = function (_Scope4) {
	    _inherits(CatchScope, _Scope4);
	
	    function CatchScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, CatchScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(CatchScope).call(this, scopeManager, 'catch', upperScope, block, false));
	    }
	
	    return CatchScope;
	}(Scope);
	
	var WithScope = exports.WithScope = function (_Scope5) {
	    _inherits(WithScope, _Scope5);
	
	    function WithScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, WithScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(WithScope).call(this, scopeManager, 'with', upperScope, block, false));
	    }
	
	    _createClass(WithScope, [{
	        key: '__close',
	        value: function __close(scopeManager) {
	            if (this.__shouldStaticallyClose(scopeManager)) {
	                return _get(Object.getPrototypeOf(WithScope.prototype), '__close', this).call(this, scopeManager);
	            }
	
	            for (var i = 0, iz = this.__left.length; i < iz; ++i) {
	                var ref = this.__left[i];
	                ref.tainted = true;
	                this.__delegateToUpperScope(ref);
	            }
	            this.__left = null;
	
	            return this.upper;
	        }
	    }]);
	
	    return WithScope;
	}(Scope);
	
	var TDZScope = exports.TDZScope = function (_Scope6) {
	    _inherits(TDZScope, _Scope6);
	
	    function TDZScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, TDZScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(TDZScope).call(this, scopeManager, 'TDZ', upperScope, block, false));
	    }
	
	    return TDZScope;
	}(Scope);
	
	var BlockScope = exports.BlockScope = function (_Scope7) {
	    _inherits(BlockScope, _Scope7);
	
	    function BlockScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, BlockScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(BlockScope).call(this, scopeManager, 'block', upperScope, block, false));
	    }
	
	    return BlockScope;
	}(Scope);
	
	var SwitchScope = exports.SwitchScope = function (_Scope8) {
	    _inherits(SwitchScope, _Scope8);
	
	    function SwitchScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, SwitchScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(SwitchScope).call(this, scopeManager, 'switch', upperScope, block, false));
	    }
	
	    return SwitchScope;
	}(Scope);
	
	var FunctionScope = exports.FunctionScope = function (_Scope9) {
	    _inherits(FunctionScope, _Scope9);
	
	    function FunctionScope(scopeManager, upperScope, block, isMethodDefinition) {
	        _classCallCheck(this, FunctionScope);
	
	        // section 9.2.13, FunctionDeclarationInstantiation.
	        // NOTE Arrow functions never have an arguments objects.
	
	        var _this9 = _possibleConstructorReturn(this, Object.getPrototypeOf(FunctionScope).call(this, scopeManager, 'function', upperScope, block, isMethodDefinition));
	
	        if (_this9.block.type !== _estraverse.Syntax.ArrowFunctionExpression) {
	            _this9.__defineArguments();
	        }
	        return _this9;
	    }
	
	    _createClass(FunctionScope, [{
	        key: 'isArgumentsMaterialized',
	        value: function isArgumentsMaterialized() {
	            // TODO(Constellation)
	            // We can more aggressive on this condition like this.
	            //
	            // function t() {
	            //     // arguments of t is always hidden.
	            //     function arguments() {
	            //     }
	            // }
	            if (this.block.type === _estraverse.Syntax.ArrowFunctionExpression) {
	                return false;
	            }
	
	            if (!this.isStatic()) {
	                return true;
	            }
	
	            var variable = this.set.get('arguments');
	            (0, _assert2.default)(variable, 'Always have arguments variable.');
	            return variable.tainted || variable.references.length !== 0;
	        }
	    }, {
	        key: 'isThisMaterialized',
	        value: function isThisMaterialized() {
	            if (!this.isStatic()) {
	                return true;
	            }
	            return this.thisFound;
	        }
	    }, {
	        key: '__defineArguments',
	        value: function __defineArguments() {
	            this.__defineGeneric('arguments', this.set, this.variables, null, null);
	            this.taints.set('arguments', true);
	        }
	    }]);
	
	    return FunctionScope;
	}(Scope);
	
	var ForScope = exports.ForScope = function (_Scope10) {
	    _inherits(ForScope, _Scope10);
	
	    function ForScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, ForScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ForScope).call(this, scopeManager, 'for', upperScope, block, false));
	    }
	
	    return ForScope;
	}(Scope);
	
	var ClassScope = exports.ClassScope = function (_Scope11) {
	    _inherits(ClassScope, _Scope11);
	
	    function ClassScope(scopeManager, upperScope, block) {
	        _classCallCheck(this, ClassScope);
	
	        return _possibleConstructorReturn(this, Object.getPrototypeOf(ClassScope).call(this, scopeManager, 'class', upperScope, block, false));
	    }
	
	    return ClassScope;
	}(Scope);
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNjb3BlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQTs7QUFDQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7Ozs7Ozs7QUFFQSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsRUFBOEIsS0FBOUIsRUFBcUMsa0JBQXJDLEVBQXlELFlBQXpELEVBQXVFO0FBQ25FLFFBQUksSUFBSixFQUFVLENBQVYsRUFBYSxFQUFiLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCOzs7QUFEbUUsUUFJL0QsTUFBTSxLQUFOLElBQWUsTUFBTSxLQUFOLENBQVksUUFBWixFQUFzQjtBQUNyQyxlQUFPLElBQVAsQ0FEcUM7S0FBekM7OztBQUptRSxRQVMvRCxNQUFNLElBQU4sS0FBZSxtQkFBTyx1QkFBUCxFQUFnQztBQUMvQyxlQUFPLElBQVAsQ0FEK0M7S0FBbkQ7O0FBSUEsUUFBSSxrQkFBSixFQUF3QjtBQUNwQixlQUFPLElBQVAsQ0FEb0I7S0FBeEI7O0FBSUEsUUFBSSxNQUFNLElBQU4sS0FBZSxPQUFmLElBQTBCLE1BQU0sSUFBTixLQUFlLFFBQWYsRUFBeUI7QUFDbkQsZUFBTyxJQUFQLENBRG1EO0tBQXZEOztBQUlBLFFBQUksTUFBTSxJQUFOLEtBQWUsT0FBZixJQUEwQixNQUFNLElBQU4sS0FBZSxRQUFmLEVBQXlCO0FBQ25ELGVBQU8sS0FBUCxDQURtRDtLQUF2RDs7QUFJQSxRQUFJLE1BQU0sSUFBTixLQUFlLFVBQWYsRUFBMkI7QUFDM0IsWUFBSSxNQUFNLElBQU4sS0FBZSxtQkFBTyxPQUFQLEVBQWdCO0FBQy9CLG1CQUFPLEtBQVAsQ0FEK0I7U0FBbkMsTUFFTztBQUNILG1CQUFPLE1BQU0sSUFBTixDQURKO1NBRlA7S0FESixNQU1PLElBQUksTUFBTSxJQUFOLEtBQWUsUUFBZixFQUF5QjtBQUNoQyxlQUFPLEtBQVAsQ0FEZ0M7S0FBN0IsTUFFQTtBQUNILGVBQU8sS0FBUCxDQURHO0tBRkE7OztBQS9CNEQsUUFzQy9ELFlBQUosRUFBa0I7QUFDZCxhQUFLLElBQUksQ0FBSixFQUFPLEtBQUssS0FBSyxJQUFMLENBQVUsTUFBVixFQUFrQixJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUM1QyxtQkFBTyxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQVAsQ0FENEM7QUFFNUMsZ0JBQUksS0FBSyxJQUFMLEtBQWMsbUJBQU8sa0JBQVAsRUFBMkI7QUFDekMsc0JBRHlDO2FBQTdDO0FBR0EsZ0JBQUksS0FBSyxHQUFMLEtBQWEsY0FBYixJQUErQixLQUFLLEdBQUwsS0FBYSxnQkFBYixFQUErQjtBQUM5RCx1QkFBTyxJQUFQLENBRDhEO2FBQWxFO1NBTEo7S0FESixNQVVPO0FBQ0gsYUFBSyxJQUFJLENBQUosRUFBTyxLQUFLLEtBQUssSUFBTCxDQUFVLE1BQVYsRUFBa0IsSUFBSSxFQUFKLEVBQVEsRUFBRSxDQUFGLEVBQUs7QUFDNUMsbUJBQU8sS0FBSyxJQUFMLENBQVUsQ0FBVixDQUFQLENBRDRDO0FBRTVDLGdCQUFJLEtBQUssSUFBTCxLQUFjLG1CQUFPLG1CQUFQLEVBQTRCO0FBQzFDLHNCQUQwQzthQUE5QztBQUdBLG1CQUFPLEtBQUssVUFBTCxDQUxxQztBQU01QyxnQkFBSSxLQUFLLElBQUwsS0FBYyxtQkFBTyxPQUFQLElBQWtCLE9BQU8sS0FBSyxLQUFMLEtBQWUsUUFBdEIsRUFBZ0M7QUFDaEUsc0JBRGdFO2FBQXBFO0FBR0EsZ0JBQUksS0FBSyxHQUFMLElBQVksSUFBWixFQUFrQjtBQUNsQixvQkFBSSxLQUFLLEdBQUwsS0FBYSxjQUFiLElBQStCLEtBQUssR0FBTCxLQUFhLGdCQUFiLEVBQStCO0FBQzlELDJCQUFPLElBQVAsQ0FEOEQ7aUJBQWxFO2FBREosTUFJTztBQUNILG9CQUFJLEtBQUssS0FBTCxLQUFlLFlBQWYsRUFBNkI7QUFDN0IsMkJBQU8sSUFBUCxDQUQ2QjtpQkFBakM7YUFMSjtTQVRKO0tBWEo7QUErQkEsV0FBTyxLQUFQLENBckVtRTtDQUF2RTs7QUF3RUEsU0FBUyxhQUFULENBQXVCLFlBQXZCLEVBQXFDLEtBQXJDLEVBQTRDO0FBQ3hDLFFBQUksTUFBSixDQUR3Qzs7QUFHeEMsaUJBQWEsTUFBYixDQUFvQixJQUFwQixDQUF5QixLQUF6QixFQUh3Qzs7QUFLeEMsYUFBUyxhQUFhLGFBQWIsQ0FBMkIsR0FBM0IsQ0FBK0IsTUFBTSxLQUFOLENBQXhDLENBTHdDO0FBTXhDLFFBQUksTUFBSixFQUFZO0FBQ1IsZUFBTyxJQUFQLENBQVksS0FBWixFQURRO0tBQVosTUFFTztBQUNILHFCQUFhLGFBQWIsQ0FBMkIsR0FBM0IsQ0FBK0IsTUFBTSxLQUFOLEVBQWEsQ0FBRSxLQUFGLENBQTVDLEVBREc7S0FGUDtDQU5KOztBQWFBLFNBQVMsa0JBQVQsQ0FBNEIsR0FBNUIsRUFBaUM7QUFDN0IsV0FDSSxHQUFDLENBQUksSUFBSixLQUFhLG1CQUFTLFNBQVQsSUFDYixJQUFJLElBQUosS0FBYSxtQkFBUyxRQUFULElBQXFCLElBQUksTUFBSixDQUFXLElBQVgsS0FBb0IsS0FBcEIsQ0FIVjtDQUFqQzs7Ozs7O0lBVXFCO0FBQ2pCLGFBRGlCLEtBQ2pCLENBQVksWUFBWixFQUEwQixJQUExQixFQUFnQyxVQUFoQyxFQUE0QyxLQUE1QyxFQUFtRCxrQkFBbkQsRUFBdUU7OEJBRHRELE9BQ3NEOzs7Ozs7QUFLbkUsYUFBSyxJQUFMLEdBQVksSUFBWjs7Ozs7O0FBTG1FLFlBV25FLENBQUssR0FBTCxHQUFXLHNCQUFYOzs7OztBQVhtRSxZQWdCbkUsQ0FBSyxNQUFMLEdBQWMsc0JBQWQ7Ozs7Ozs7Ozs7O0FBaEJtRSxZQTJCbkUsQ0FBSyxPQUFMLEdBQWUsS0FBSyxJQUFMLEtBQWMsUUFBZCxJQUEwQixLQUFLLElBQUwsS0FBYyxNQUFkOzs7OztBQTNCMEIsWUFnQ25FLENBQUssS0FBTCxHQUFhLEtBQWI7Ozs7O0FBaENtRSxZQXFDbkUsQ0FBSyxPQUFMLEdBQWUsRUFBZjs7Ozs7OztBQXJDbUUsWUE0Q25FLENBQUssU0FBTCxHQUFpQixFQUFqQjs7Ozs7Ozs7OztBQTVDbUUsWUFzRG5FLENBQUssVUFBTCxHQUFrQixFQUFsQjs7Ozs7Ozs7QUF0RG1FLFlBOERuRSxDQUFLLGFBQUwsR0FDSSxJQUFDLENBQUssSUFBTCxLQUFjLFFBQWQsSUFBMEIsS0FBSyxJQUFMLEtBQWMsVUFBZCxJQUE0QixLQUFLLElBQUwsS0FBYyxRQUFkLEdBQTBCLElBQWpGLEdBQXdGLFdBQVcsYUFBWDs7Ozs7QUEvRHpCLFlBb0VuRSxDQUFLLHVCQUFMLEdBQStCLEtBQS9COzs7OztBQXBFbUUsWUF5RW5FLENBQUsscUJBQUwsR0FBNkIsS0FBN0I7Ozs7QUF6RW1FLFlBNkVuRSxDQUFLLFNBQUwsR0FBaUIsS0FBakIsQ0E3RW1FOztBQStFbkUsYUFBSyxNQUFMLEdBQWMsRUFBZDs7Ozs7O0FBL0VtRSxZQXFGbkUsQ0FBSyxLQUFMLEdBQWEsVUFBYjs7Ozs7QUFyRm1FLFlBMEZuRSxDQUFLLFFBQUwsR0FBZ0IsY0FBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQTJCLGtCQUEzQixFQUErQyxhQUFhLGNBQWIsRUFBL0MsQ0FBaEI7Ozs7OztBQTFGbUUsWUFnR25FLENBQUssV0FBTCxHQUFtQixFQUFuQixDQWhHbUU7QUFpR25FLFlBQUksS0FBSyxLQUFMLEVBQVk7QUFDWixpQkFBSyxLQUFMLENBQVcsV0FBWCxDQUF1QixJQUF2QixDQUE0QixJQUE1QixFQURZO1NBQWhCOztBQUlBLGFBQUssbUJBQUwsR0FBMkIsYUFBYSxtQkFBYixDQXJHd0M7O0FBdUduRSxzQkFBYyxZQUFkLEVBQTRCLElBQTVCLEVBdkdtRTtLQUF2RTs7aUJBRGlCOztnREEyR08sY0FBYztBQUNsQyxtQkFBUSxDQUFDLEtBQUssT0FBTCxJQUFnQixhQUFhLGNBQWIsRUFBakIsQ0FEMEI7Ozs7eURBSUwsS0FBSzs7QUFFbEMsZ0JBQUksT0FBTyxJQUFJLFVBQUosQ0FBZSxJQUFmLENBRnVCO0FBR2xDLGdCQUFJLENBQUMsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWIsQ0FBRCxFQUFxQjtBQUNyQix1QkFBTyxLQUFQLENBRHFCO2FBQXpCOztBQUlBLGdCQUFJLFdBQVcsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWIsQ0FBWCxDQVA4QjtBQVFsQyxnQkFBSSxPQUFPLFNBQVMsSUFBVCxDQVJ1QjtBQVNsQyxtQkFBTyxLQUFLLE1BQUwsR0FBYyxDQUFkLElBQW1CLEtBQUssS0FBTCxDQUFXLGtCQUFYLENBQW5CLENBVDJCOzs7O3lDQVlyQixLQUFLO0FBQ2xCLGdCQUFJLENBQUMsS0FBSyxTQUFMLENBQWUsR0FBZixDQUFELEVBQXNCO0FBQ3RCLHFCQUFLLHNCQUFMLENBQTRCLEdBQTVCLEVBRHNCO2FBQTFCOzs7OzBDQUtjLEtBQUs7O0FBRW5CLGdCQUFJLFVBQVUsSUFBVixDQUZlO0FBR25CLGVBQUc7QUFDQyx3QkFBUSxPQUFSLENBQWdCLElBQWhCLENBQXFCLEdBQXJCLEVBREQ7QUFFQywwQkFBVSxRQUFRLEtBQVIsQ0FGWDthQUFILFFBR1MsT0FIVCxFQUhtQjs7Ozt5Q0FTTixLQUFLOzs7QUFHbEIsZ0JBQUksS0FBSyxnQ0FBTCxDQUFzQyxHQUF0QyxDQUFKLEVBQWdEO0FBQzVDLHFCQUFLLGdCQUFMLENBQXNCLEdBQXRCLEVBRDRDO2FBQWhELE1BRU87QUFDSCxxQkFBSyxpQkFBTCxDQUF1QixHQUF2QixFQURHO2FBRlA7Ozs7Z0NBT0ksY0FBYztBQUNsQixnQkFBSSxRQUFKLENBRGtCO0FBRWxCLGdCQUFJLEtBQUssdUJBQUwsQ0FBNkIsWUFBN0IsQ0FBSixFQUFnRDtBQUM1QywyQkFBVyxLQUFLLGdCQUFMLENBRGlDO2FBQWhELE1BRU8sSUFBSSxLQUFLLElBQUwsS0FBYyxRQUFkLEVBQXdCO0FBQy9CLDJCQUFXLEtBQUssaUJBQUwsQ0FEb0I7YUFBNUIsTUFFQTtBQUNILDJCQUFXLEtBQUssZ0JBQUwsQ0FEUjthQUZBOzs7QUFKVyxpQkFXYixJQUFJLElBQUksQ0FBSixFQUFPLEtBQUssS0FBSyxNQUFMLENBQVksTUFBWixFQUFvQixJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUNsRCxvQkFBSSxNQUFNLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBTixDQUQ4QztBQUVsRCx5QkFBUyxJQUFULENBQWMsSUFBZCxFQUFvQixHQUFwQixFQUZrRDthQUF0RDtBQUlBLGlCQUFLLE1BQUwsR0FBYyxJQUFkLENBZmtCOztBQWlCbEIsbUJBQU8sS0FBSyxLQUFMLENBakJXOzs7O2tDQW9CWixLQUFLO0FBQ1gsZ0JBQUksUUFBSixFQUFjLElBQWQsQ0FEVztBQUVYLG1CQUFPLElBQUksVUFBSixDQUFlLElBQWYsQ0FGSTtBQUdYLGdCQUFJLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxJQUFiLENBQUosRUFBd0I7QUFDcEIsMkJBQVcsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWIsQ0FBWCxDQURvQjtBQUVwQix5QkFBUyxVQUFULENBQW9CLElBQXBCLENBQXlCLEdBQXpCLEVBRm9CO0FBR3BCLHlCQUFTLEtBQVQsR0FBaUIsU0FBUyxLQUFULElBQWtCLElBQUksSUFBSixDQUFTLGFBQVQsS0FBMkIsS0FBSyxhQUFMLENBSDFDO0FBSXBCLG9CQUFJLElBQUksT0FBSixFQUFhO0FBQ2IsNkJBQVMsT0FBVCxHQUFtQixJQUFuQixDQURhO0FBRWIseUJBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsU0FBUyxJQUFULEVBQWUsSUFBL0IsRUFGYTtpQkFBakI7QUFJQSxvQkFBSSxRQUFKLEdBQWUsUUFBZixDQVJvQjtBQVNwQix1QkFBTyxJQUFQLENBVG9CO2FBQXhCO0FBV0EsbUJBQU8sS0FBUCxDQWRXOzs7OytDQWlCUSxLQUFLO0FBQ3hCLGdCQUFJLEtBQUssS0FBTCxFQUFZO0FBQ1oscUJBQUssS0FBTCxDQUFXLE1BQVgsQ0FBa0IsSUFBbEIsQ0FBdUIsR0FBdkIsRUFEWTthQUFoQjtBQUdBLGlCQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLEdBQWxCLEVBSndCOzs7O3FEQU9DLFVBQVUsTUFBTTtBQUN6QyxnQkFBSSxRQUFRLElBQVIsRUFBYztBQUNkLHVCQURjO2FBQWxCOztBQUlBLGdCQUFJLFlBQVksS0FBSyxtQkFBTCxDQUF5QixHQUF6QixDQUE2QixJQUE3QixDQUFaLENBTHFDO0FBTXpDLGdCQUFJLGFBQWEsSUFBYixFQUFtQjtBQUNuQiw0QkFBWSxFQUFaLENBRG1CO0FBRW5CLHFCQUFLLG1CQUFMLENBQXlCLEdBQXpCLENBQTZCLElBQTdCLEVBQW1DLFNBQW5DLEVBRm1CO2FBQXZCO0FBSUEsZ0JBQUksVUFBVSxPQUFWLENBQWtCLFFBQWxCLE1BQWdDLENBQUMsQ0FBRCxFQUFJO0FBQ3BDLDBCQUFVLElBQVYsQ0FBZSxRQUFmLEVBRG9DO2FBQXhDOzs7O3dDQUtZLE1BQU0sS0FBSyxXQUFXLE1BQU0sS0FBSztBQUM3QyxnQkFBSSxRQUFKLENBRDZDOztBQUc3Qyx1QkFBVyxJQUFJLEdBQUosQ0FBUSxJQUFSLENBQVgsQ0FINkM7QUFJN0MsZ0JBQUksQ0FBQyxRQUFELEVBQVc7QUFDWCwyQkFBVyx1QkFBYSxJQUFiLEVBQW1CLElBQW5CLENBQVgsQ0FEVztBQUVYLG9CQUFJLEdBQUosQ0FBUSxJQUFSLEVBQWMsUUFBZCxFQUZXO0FBR1gsMEJBQVUsSUFBVixDQUFlLFFBQWYsRUFIVzthQUFmOztBQU1BLGdCQUFJLEdBQUosRUFBUztBQUNMLHlCQUFTLElBQVQsQ0FBYyxJQUFkLENBQW1CLEdBQW5CLEVBREs7QUFFTCxvQkFBSSxJQUFJLElBQUosS0FBYSxtQkFBUyxHQUFULEVBQWM7QUFDM0IseUJBQUssNEJBQUwsQ0FBa0MsUUFBbEMsRUFBNEMsSUFBSSxJQUFKLENBQTVDLENBRDJCO0FBRTNCLHlCQUFLLDRCQUFMLENBQWtDLFFBQWxDLEVBQTRDLElBQUksTUFBSixDQUE1QyxDQUYyQjtpQkFBL0I7YUFGSjtBQU9BLGdCQUFJLElBQUosRUFBVTtBQUNOLHlCQUFTLFdBQVQsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsRUFETTthQUFWOzs7O2lDQUtLLE1BQU0sS0FBSztBQUNoQixnQkFBSSxRQUFRLEtBQUssSUFBTCxLQUFjLG1CQUFPLFVBQVAsRUFBbUI7QUFDekMscUJBQUssZUFBTCxDQUNRLEtBQUssSUFBTCxFQUNBLEtBQUssR0FBTCxFQUNBLEtBQUssU0FBTCxFQUNBLElBSlIsRUFLUSxHQUxSLEVBRHlDO2FBQTdDOzs7O3NDQVVVLE1BQU0sUUFBUSxXQUFXLHFCQUFxQixTQUFTLE1BQU07O0FBRXZFLGdCQUFJLENBQUMsSUFBRCxJQUFTLEtBQUssSUFBTCxLQUFjLG1CQUFPLFVBQVAsRUFBbUI7QUFDMUMsdUJBRDBDO2FBQTlDOzs7QUFGdUUsZ0JBT25FLEtBQUssSUFBTCxLQUFjLE9BQWQsRUFBdUI7QUFDdkIsdUJBRHVCO2FBQTNCOztBQUlBLGdCQUFJLE1BQU0sd0JBQWMsSUFBZCxFQUFvQixJQUFwQixFQUEwQixVQUFVLG9CQUFVLElBQVYsRUFBZ0IsU0FBcEQsRUFBK0QsbUJBQS9ELEVBQW9GLENBQUMsQ0FBQyxPQUFELEVBQVUsQ0FBQyxDQUFDLElBQUQsQ0FBdEcsQ0FYbUU7QUFZdkUsaUJBQUssVUFBTCxDQUFnQixJQUFoQixDQUFxQixHQUFyQixFQVp1RTtBQWF2RSxpQkFBSyxNQUFMLENBQVksSUFBWixDQUFpQixHQUFqQixFQWJ1RTs7Ozt1Q0FnQjVEO0FBQ1gsZ0JBQUksT0FBSixDQURXO0FBRVgsc0JBQVUsSUFBVixDQUZXO0FBR1gsaUJBQUsscUJBQUwsR0FBNkIsSUFBN0IsQ0FIVztBQUlYLGVBQUc7QUFDQyx3QkFBUSxPQUFSLEdBQWtCLElBQWxCLENBREQ7QUFFQywwQkFBVSxRQUFRLEtBQVIsQ0FGWDthQUFILFFBR1MsT0FIVCxFQUpXOzs7O3VDQVVBO0FBQ1gsaUJBQUssU0FBTCxHQUFpQixJQUFqQixDQURXOzs7O3FDQUlGO0FBQ1QsbUJBQU8sS0FBSyxNQUFMLEtBQWdCLElBQWhCLENBREU7Ozs7Ozs7Ozs7OztnQ0FVTCxPQUFPO0FBQ1gsZ0JBQUksR0FBSixFQUFTLENBQVQsRUFBWSxFQUFaLENBRFc7QUFFWCxrQ0FBTyxLQUFLLFVBQUwsRUFBUCxFQUEwQix5QkFBMUIsRUFGVztBQUdYLGtDQUFPLE1BQU0sSUFBTixLQUFlLG1CQUFPLFVBQVAsRUFBbUIsOEJBQXpDLEVBSFc7QUFJWCxpQkFBSyxJQUFJLENBQUosRUFBTyxLQUFLLEtBQUssVUFBTCxDQUFnQixNQUFoQixFQUF3QixJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUNsRCxzQkFBTSxLQUFLLFVBQUwsQ0FBZ0IsQ0FBaEIsQ0FBTixDQURrRDtBQUVsRCxvQkFBSSxJQUFJLFVBQUosS0FBbUIsS0FBbkIsRUFBMEI7QUFDMUIsMkJBQU8sR0FBUCxDQUQwQjtpQkFBOUI7YUFGSjtBQU1BLG1CQUFPLElBQVAsQ0FWVzs7Ozs7Ozs7Ozs7bUNBa0JKO0FBQ1AsbUJBQU8sQ0FBQyxLQUFLLE9BQUwsQ0FERDs7Ozs7Ozs7Ozs7a0RBU2U7QUFDdEIsbUJBQU8sSUFBUCxDQURzQjs7Ozs7Ozs7Ozs7NkNBU0w7QUFDakIsbUJBQU8sSUFBUCxDQURpQjs7OzttQ0FJVixNQUFNO0FBQ2IsZ0JBQUksS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLElBQWIsQ0FBSixFQUF3QjtBQUNwQix1QkFBTyxJQUFQLENBRG9CO2FBQXhCO0FBR0EsaUJBQUssSUFBSSxJQUFJLENBQUosRUFBTyxLQUFLLEtBQUssT0FBTCxDQUFhLE1BQWIsRUFBcUIsSUFBSSxFQUFKLEVBQVEsRUFBRSxDQUFGLEVBQUs7QUFDbkQsb0JBQUksS0FBSyxPQUFMLENBQWEsQ0FBYixFQUFnQixVQUFoQixDQUEyQixJQUEzQixLQUFvQyxJQUFwQyxFQUEwQztBQUMxQywyQkFBTyxJQUFQLENBRDBDO2lCQUE5QzthQURKO0FBS0EsbUJBQU8sS0FBUCxDQVRhOzs7O1dBaFVBOzs7OztJQTZVUjs7O0FBQ1QsYUFEUyxXQUNULENBQVksWUFBWixFQUEwQixLQUExQixFQUFpQzs4QkFEeEIsYUFDd0I7OzJFQUR4Qix3QkFFQyxjQUFjLFVBQVUsTUFBTSxPQUFPLFFBRGQ7O0FBRTdCLGNBQUssUUFBTCxHQUFnQjtBQUNaLGlCQUFLLHNCQUFMO0FBQ0EsdUJBQVcsRUFBWDs7Ozs7O0FBTUEsa0JBQU0sRUFBTjtTQVJKLENBRjZCOztLQUFqQzs7aUJBRFM7O2dDQWVELGNBQWM7QUFDbEIsZ0JBQUksV0FBVyxFQUFYLENBRGM7QUFFbEIsaUJBQUssSUFBSSxJQUFJLENBQUosRUFBTyxLQUFLLEtBQUssTUFBTCxDQUFZLE1BQVosRUFBb0IsSUFBSSxFQUFKLEVBQVEsRUFBRSxDQUFGLEVBQUs7QUFDbEQsb0JBQUksTUFBTSxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQU4sQ0FEOEM7QUFFbEQsb0JBQUksSUFBSSxxQkFBSixJQUE2QixDQUFDLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FBYSxJQUFJLFVBQUosQ0FBZSxJQUFmLENBQWQsRUFBb0M7QUFDakUsNkJBQVMsSUFBVCxDQUFjLElBQUkscUJBQUosQ0FBZCxDQURpRTtpQkFBckU7YUFGSjs7O0FBRmtCLGlCQVViLElBQUksS0FBSSxDQUFKLEVBQU8sTUFBSyxTQUFTLE1BQVQsRUFBaUIsS0FBSSxHQUFKLEVBQVEsRUFBRSxFQUFGLEVBQUs7QUFDL0Msb0JBQUksT0FBTyxTQUFTLEVBQVQsQ0FBUCxDQUQyQztBQUUvQyxxQkFBSyxnQkFBTCxDQUFzQixLQUFLLE9BQUwsRUFDZCx5QkFDSSxtQkFBUyxzQkFBVCxFQUNBLEtBQUssT0FBTCxFQUNBLEtBQUssSUFBTCxFQUNBLElBSkosRUFLSSxJQUxKLEVBTUksSUFOSixDQURSLEVBRitDO2FBQW5EOztBQWNBLGlCQUFLLFFBQUwsQ0FBYyxJQUFkLEdBQXFCLEtBQUssTUFBTCxDQXhCSDs7QUEwQmxCLDhDQXpDSyxvREF5Q2dCLGFBQXJCLENBMUJrQjs7Ozt5Q0E2QkwsTUFBTSxLQUFLO0FBQ3hCLGdCQUFJLFFBQVEsS0FBSyxJQUFMLEtBQWMsbUJBQU8sVUFBUCxFQUFtQjtBQUN6QyxxQkFBSyxlQUFMLENBQ1EsS0FBSyxJQUFMLEVBQ0EsS0FBSyxRQUFMLENBQWMsR0FBZCxFQUNBLEtBQUssUUFBTCxDQUFjLFNBQWQsRUFDQSxJQUpSLEVBS1EsR0FMUixFQUR5QzthQUE3Qzs7OztXQTdDSztFQUFvQjs7SUF3RHBCOzs7QUFDVCxhQURTLFdBQ1QsQ0FBWSxZQUFaLEVBQTBCLFVBQTFCLEVBQXNDLEtBQXRDLEVBQTZDOzhCQURwQyxhQUNvQzs7c0VBRHBDLHdCQUVDLGNBQWMsVUFBVSxZQUFZLE9BQU8sUUFEUjtLQUE3Qzs7V0FEUztFQUFvQjs7SUFNcEI7OztBQUNULGFBRFMsMkJBQ1QsQ0FBWSxZQUFaLEVBQTBCLFVBQTFCLEVBQXNDLEtBQXRDLEVBQTZDOzhCQURwQyw2QkFDb0M7OzRFQURwQyx3Q0FFQyxjQUFjLDRCQUE0QixZQUFZLE9BQU8sUUFEMUI7O0FBRXpDLGVBQUssUUFBTCxDQUFjLE1BQU0sRUFBTixFQUNOLHlCQUNJLG1CQUFTLFlBQVQsRUFDQSxNQUFNLEVBQU4sRUFDQSxLQUhKLEVBSUksSUFKSixFQUtJLElBTEosRUFNSSxJQU5KLENBRFIsRUFGeUM7QUFXekMsZUFBSyx1QkFBTCxHQUErQixJQUEvQixDQVh5Qzs7S0FBN0M7O1dBRFM7RUFBb0M7O0lBZ0JwQzs7O0FBQ1QsYUFEUyxVQUNULENBQVksWUFBWixFQUEwQixVQUExQixFQUFzQyxLQUF0QyxFQUE2Qzs4QkFEcEMsWUFDb0M7O3NFQURwQyx1QkFFQyxjQUFjLFNBQVMsWUFBWSxPQUFPLFFBRFA7S0FBN0M7O1dBRFM7RUFBbUI7O0lBTW5COzs7QUFDVCxhQURTLFNBQ1QsQ0FBWSxZQUFaLEVBQTBCLFVBQTFCLEVBQXNDLEtBQXRDLEVBQTZDOzhCQURwQyxXQUNvQzs7c0VBRHBDLHNCQUVDLGNBQWMsUUFBUSxZQUFZLE9BQU8sUUFETjtLQUE3Qzs7aUJBRFM7O2dDQUtELGNBQWM7QUFDbEIsZ0JBQUksS0FBSyx1QkFBTCxDQUE2QixZQUE3QixDQUFKLEVBQWdEO0FBQzVDLGtEQVBDLGtEQU9vQixhQUFyQixDQUQ0QzthQUFoRDs7QUFJQSxpQkFBSyxJQUFJLElBQUksQ0FBSixFQUFPLEtBQUssS0FBSyxNQUFMLENBQVksTUFBWixFQUFvQixJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUNsRCxvQkFBSSxNQUFNLEtBQUssTUFBTCxDQUFZLENBQVosQ0FBTixDQUQ4QztBQUVsRCxvQkFBSSxPQUFKLEdBQWMsSUFBZCxDQUZrRDtBQUdsRCxxQkFBSyxzQkFBTCxDQUE0QixHQUE1QixFQUhrRDthQUF0RDtBQUtBLGlCQUFLLE1BQUwsR0FBYyxJQUFkLENBVmtCOztBQVlsQixtQkFBTyxLQUFLLEtBQUwsQ0FaVzs7OztXQUxiO0VBQWtCOztJQXFCbEI7OztBQUNULGFBRFMsUUFDVCxDQUFZLFlBQVosRUFBMEIsVUFBMUIsRUFBc0MsS0FBdEMsRUFBNkM7OEJBRHBDLFVBQ29DOztzRUFEcEMscUJBRUMsY0FBYyxPQUFPLFlBQVksT0FBTyxRQURMO0tBQTdDOztXQURTO0VBQWlCOztJQU1qQjs7O0FBQ1QsYUFEUyxVQUNULENBQVksWUFBWixFQUEwQixVQUExQixFQUFzQyxLQUF0QyxFQUE2Qzs4QkFEcEMsWUFDb0M7O3NFQURwQyx1QkFFQyxjQUFjLFNBQVMsWUFBWSxPQUFPLFFBRFA7S0FBN0M7O1dBRFM7RUFBbUI7O0lBTW5COzs7QUFDVCxhQURTLFdBQ1QsQ0FBWSxZQUFaLEVBQTBCLFVBQTFCLEVBQXNDLEtBQXRDLEVBQTZDOzhCQURwQyxhQUNvQzs7c0VBRHBDLHdCQUVDLGNBQWMsVUFBVSxZQUFZLE9BQU8sUUFEUjtLQUE3Qzs7V0FEUztFQUFvQjs7SUFNcEI7OztBQUNULGFBRFMsYUFDVCxDQUFZLFlBQVosRUFBMEIsVUFBMUIsRUFBc0MsS0FBdEMsRUFBNkMsa0JBQTdDLEVBQWlFOzhCQUR4RCxlQUN3RDs7Ozs7NEVBRHhELDBCQUVDLGNBQWMsWUFBWSxZQUFZLE9BQU8scUJBRFU7O0FBSzdELFlBQUksT0FBSyxLQUFMLENBQVcsSUFBWCxLQUFvQixtQkFBTyx1QkFBUCxFQUFnQztBQUNwRCxtQkFBSyxpQkFBTCxHQURvRDtTQUF4RDtzQkFMNkQ7S0FBakU7O2lCQURTOztrREFXaUI7Ozs7Ozs7OztBQVN0QixnQkFBSSxLQUFLLEtBQUwsQ0FBVyxJQUFYLEtBQW9CLG1CQUFPLHVCQUFQLEVBQWdDO0FBQ3BELHVCQUFPLEtBQVAsQ0FEb0Q7YUFBeEQ7O0FBSUEsZ0JBQUksQ0FBQyxLQUFLLFFBQUwsRUFBRCxFQUFrQjtBQUNsQix1QkFBTyxJQUFQLENBRGtCO2FBQXRCOztBQUlBLGdCQUFJLFdBQVcsS0FBSyxHQUFMLENBQVMsR0FBVCxDQUFhLFdBQWIsQ0FBWCxDQWpCa0I7QUFrQnRCLGtDQUFPLFFBQVAsRUFBaUIsaUNBQWpCLEVBbEJzQjtBQW1CdEIsbUJBQU8sU0FBUyxPQUFULElBQW9CLFNBQVMsVUFBVCxDQUFvQixNQUFwQixLQUFnQyxDQUFoQyxDQW5CTDs7Ozs2Q0FzQkw7QUFDakIsZ0JBQUksQ0FBQyxLQUFLLFFBQUwsRUFBRCxFQUFrQjtBQUNsQix1QkFBTyxJQUFQLENBRGtCO2FBQXRCO0FBR0EsbUJBQU8sS0FBSyxTQUFMLENBSlU7Ozs7NENBT0Q7QUFDaEIsaUJBQUssZUFBTCxDQUNRLFdBRFIsRUFFUSxLQUFLLEdBQUwsRUFDQSxLQUFLLFNBQUwsRUFDQSxJQUpSLEVBS1EsSUFMUixFQURnQjtBQU9oQixpQkFBSyxNQUFMLENBQVksR0FBWixDQUFnQixXQUFoQixFQUE2QixJQUE3QixFQVBnQjs7OztXQXhDWDtFQUFzQjs7SUFtRHRCOzs7QUFDVCxhQURTLFFBQ1QsQ0FBWSxZQUFaLEVBQTBCLFVBQTFCLEVBQXNDLEtBQXRDLEVBQTZDOzhCQURwQyxVQUNvQzs7c0VBRHBDLHFCQUVDLGNBQWMsT0FBTyxZQUFZLE9BQU8sUUFETDtLQUE3Qzs7V0FEUztFQUFpQjs7SUFNakI7OztBQUNULGFBRFMsVUFDVCxDQUFZLFlBQVosRUFBMEIsVUFBMUIsRUFBc0MsS0FBdEMsRUFBNkM7OEJBRHBDLFlBQ29DOztzRUFEcEMsdUJBRUMsY0FBYyxTQUFTLFlBQVksT0FBTyxRQURQO0tBQTdDOztXQURTO0VBQW1CIiwiZmlsZSI6InNjb3BlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgeyBTeW50YXggfSBmcm9tICdlc3RyYXZlcnNlJztcbmltcG9ydCBNYXAgZnJvbSAnZXM2LW1hcCc7XG5cbmltcG9ydCBSZWZlcmVuY2UgZnJvbSAnLi9yZWZlcmVuY2UnO1xuaW1wb3J0IFZhcmlhYmxlIGZyb20gJy4vdmFyaWFibGUnO1xuaW1wb3J0IERlZmluaXRpb24gZnJvbSAnLi9kZWZpbml0aW9uJztcbmltcG9ydCBhc3NlcnQgZnJvbSAnYXNzZXJ0JztcblxuZnVuY3Rpb24gaXNTdHJpY3RTY29wZShzY29wZSwgYmxvY2ssIGlzTWV0aG9kRGVmaW5pdGlvbiwgdXNlRGlyZWN0aXZlKSB7XG4gICAgdmFyIGJvZHksIGksIGl6LCBzdG10LCBleHByO1xuXG4gICAgLy8gV2hlbiB1cHBlciBzY29wZSBpcyBleGlzdHMgYW5kIHN0cmljdCwgaW5uZXIgc2NvcGUgaXMgYWxzbyBzdHJpY3QuXG4gICAgaWYgKHNjb3BlLnVwcGVyICYmIHNjb3BlLnVwcGVyLmlzU3RyaWN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFycm93RnVuY3Rpb25FeHByZXNzaW9uJ3Mgc2NvcGUgaXMgYWx3YXlzIHN0cmljdCBzY29wZS5cbiAgICBpZiAoYmxvY2sudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnR5cGUgPT09ICdjbGFzcycgfHwgc2NvcGUudHlwZSA9PT0gJ21vZHVsZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHNjb3BlLnR5cGUgPT09ICdibG9jaycgfHwgc2NvcGUudHlwZSA9PT0gJ3N3aXRjaCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChzY29wZS50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChibG9jay50eXBlID09PSBTeW50YXguUHJvZ3JhbSkge1xuICAgICAgICAgICAgYm9keSA9IGJsb2NrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm9keSA9IGJsb2NrLmJvZHk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNjb3BlLnR5cGUgPT09ICdnbG9iYWwnKSB7XG4gICAgICAgIGJvZHkgPSBibG9jaztcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUuXG4gICAgaWYgKHVzZURpcmVjdGl2ZSkge1xuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IGJvZHkuYm9keS5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBzdG10ID0gYm9keS5ib2R5W2ldO1xuICAgICAgICAgICAgaWYgKHN0bXQudHlwZSAhPT0gU3ludGF4LkRpcmVjdGl2ZVN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0bXQucmF3ID09PSAnXCJ1c2Ugc3RyaWN0XCInIHx8IHN0bXQucmF3ID09PSAnXFwndXNlIHN0cmljdFxcJycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gYm9keS5ib2R5Lmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHN0bXQgPSBib2R5LmJvZHlbaV07XG4gICAgICAgICAgICBpZiAoc3RtdC50eXBlICE9PSBTeW50YXguRXhwcmVzc2lvblN0YXRlbWVudCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXhwciA9IHN0bXQuZXhwcmVzc2lvbjtcbiAgICAgICAgICAgIGlmIChleHByLnR5cGUgIT09IFN5bnRheC5MaXRlcmFsIHx8IHR5cGVvZiBleHByLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIucmF3ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwci5yYXcgPT09ICdcInVzZSBzdHJpY3RcIicgfHwgZXhwci5yYXcgPT09ICdcXCd1c2Ugc3RyaWN0XFwnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChleHByLnZhbHVlID09PSAndXNlIHN0cmljdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJTY29wZShzY29wZU1hbmFnZXIsIHNjb3BlKSB7XG4gICAgdmFyIHNjb3BlcztcblxuICAgIHNjb3BlTWFuYWdlci5zY29wZXMucHVzaChzY29wZSk7XG5cbiAgICBzY29wZXMgPSBzY29wZU1hbmFnZXIuX19ub2RlVG9TY29wZS5nZXQoc2NvcGUuYmxvY2spO1xuICAgIGlmIChzY29wZXMpIHtcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlTWFuYWdlci5fX25vZGVUb1Njb3BlLnNldChzY29wZS5ibG9jaywgWyBzY29wZSBdKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZEJlU3RhdGljYWxseShkZWYpIHtcbiAgICByZXR1cm4gKFxuICAgICAgICAoZGVmLnR5cGUgPT09IFZhcmlhYmxlLkNsYXNzTmFtZSkgfHxcbiAgICAgICAgKGRlZi50eXBlID09PSBWYXJpYWJsZS5WYXJpYWJsZSAmJiBkZWYucGFyZW50LmtpbmQgIT09ICd2YXInKVxuICAgICk7XG59XG5cbi8qKlxuICogQGNsYXNzIFNjb3BlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHR5cGUsIHVwcGVyU2NvcGUsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uZSBvZiAnVERaJywgJ21vZHVsZScsICdibG9jaycsICdzd2l0Y2gnLCAnZnVuY3Rpb24nLCAnY2F0Y2gnLCAnd2l0aCcsICdmdW5jdGlvbicsICdjbGFzcycsICdnbG9iYWwnLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFNjb3BlI3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHNjb3BlZCB7QGxpbmsgVmFyaWFibGV9cyBvZiB0aGlzIHNjb3BlLCBhcyA8Y29kZT57IFZhcmlhYmxlLm5hbWVcbiAgICAgICAgICogOiBWYXJpYWJsZSB9PC9jb2RlPi5cbiAgICAgICAgICogQG1lbWJlciB7TWFwfSBTY29wZSNzZXRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRhaW50ZWQgdmFyaWFibGVzIG9mIHRoaXMgc2NvcGUsIGFzIDxjb2RlPnsgVmFyaWFibGUubmFtZSA6XG4gICAgICAgICAqIGJvb2xlYW4gfTwvY29kZT4uXG4gICAgICAgICAqIEBtZW1iZXIge01hcH0gU2NvcGUjdGFpbnRzICovXG4gICAgICAgIHRoaXMudGFpbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2VuZXJhbGx5LCB0aHJvdWdoIHRoZSBsZXhpY2FsIHNjb3Bpbmcgb2YgSlMgeW91IGNhbiBhbHdheXMga25vd1xuICAgICAgICAgKiB3aGljaCB2YXJpYWJsZSBhbiBpZGVudGlmaWVyIGluIHRoZSBzb3VyY2UgY29kZSByZWZlcnMgdG8uIFRoZXJlIGFyZVxuICAgICAgICAgKiBhIGZldyBleGNlcHRpb25zIHRvIHRoaXMgcnVsZS4gV2l0aCAnZ2xvYmFsJyBhbmQgJ3dpdGgnIHNjb3BlcyB5b3VcbiAgICAgICAgICogY2FuIG9ubHkgZGVjaWRlIGF0IHJ1bnRpbWUgd2hpY2ggdmFyaWFibGUgYSByZWZlcmVuY2UgcmVmZXJzIHRvLlxuICAgICAgICAgKiBNb3Jlb3ZlciwgaWYgJ2V2YWwoKScgaXMgdXNlZCBpbiBhIHNjb3BlLCBpdCBtaWdodCBpbnRyb2R1Y2UgbmV3XG4gICAgICAgICAqIGJpbmRpbmdzIGluIHRoaXMgb3IgaXRzIHBhcmVudCBzY29wZXMuXG4gICAgICAgICAqIEFsbCB0aG9zZSBzY29wZXMgYXJlIGNvbnNpZGVyZWQgJ2R5bmFtaWMnLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSNkeW5hbWljXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmR5bmFtaWMgPSB0aGlzLnR5cGUgPT09ICdnbG9iYWwnIHx8IHRoaXMudHlwZSA9PT0gJ3dpdGgnO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHNjb3BlLWRlZmluaW5nIHN5bnRheCBub2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hLk5vZGV9IFNjb3BlI2Jsb2NrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2s7XG4gICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHtAbGluayBSZWZlcmVuY2V8cmVmZXJlbmNlc30gdGhhdCBhcmUgbm90IHJlc29sdmVkIHdpdGggdGhpcyBzY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7UmVmZXJlbmNlW119IFNjb3BlI3Rocm91Z2hcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhyb3VnaCA9IFtdO1xuICAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBzY29wZWQge0BsaW5rIFZhcmlhYmxlfXMgb2YgdGhpcyBzY29wZS4gSW4gdGhlIGNhc2Ugb2YgYVxuICAgICAgICAgKiAnZnVuY3Rpb24nIHNjb3BlIHRoaXMgaW5jbHVkZXMgdGhlIGF1dG9tYXRpYyBhcmd1bWVudCA8ZW0+YXJndW1lbnRzPC9lbT4gYXNcbiAgICAgICAgICogaXRzIGZpcnN0IGVsZW1lbnQsIGFzIHdlbGwgYXMgYWxsIGZ1cnRoZXIgZm9ybWFsIGFyZ3VtZW50cy5cbiAgICAgICAgICogQG1lbWJlciB7VmFyaWFibGVbXX0gU2NvcGUjdmFyaWFibGVzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IFtdO1xuICAgICAgICAgLyoqXG4gICAgICAgICAqIEFueSB2YXJpYWJsZSB7QGxpbmsgUmVmZXJlbmNlfHJlZmVyZW5jZX0gZm91bmQgaW4gdGhpcyBzY29wZS4gVGhpc1xuICAgICAgICAgKiBpbmNsdWRlcyBvY2N1cnJlbmNlcyBvZiBsb2NhbCB2YXJpYWJsZXMgYXMgd2VsbCBhcyB2YXJpYWJsZXMgZnJvbVxuICAgICAgICAgKiBwYXJlbnQgc2NvcGVzIChpbmNsdWRpbmcgdGhlIGdsb2JhbCBzY29wZSkuIEZvciBsb2NhbCB2YXJpYWJsZXNcbiAgICAgICAgICogdGhpcyBhbHNvIGluY2x1ZGVzIGRlZmluaW5nIG9jY3VycmVuY2VzIChsaWtlIGluIGEgJ3Zhcicgc3RhdGVtZW50KS5cbiAgICAgICAgICogSW4gYSAnZnVuY3Rpb24nIHNjb3BlIHRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgb2NjdXJyZW5jZXMgb2YgdGhlXG4gICAgICAgICAqIGZvcm1hbCBwYXJhbWV0ZXIgaW4gdGhlIHBhcmFtZXRlciBsaXN0LlxuICAgICAgICAgKiBAbWVtYmVyIHtSZWZlcmVuY2VbXX0gU2NvcGUjcmVmZXJlbmNlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzID0gW107XG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgJ2dsb2JhbCcgYW5kICdmdW5jdGlvbicgc2NvcGVzLCB0aGlzIGlzIGEgc2VsZi1yZWZlcmVuY2UuIEZvclxuICAgICAgICAgKiBvdGhlciBzY29wZSB0eXBlcyB0aGlzIGlzIHRoZSA8ZW0+dmFyaWFibGVTY29wZTwvZW0+IHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBwYXJlbnQgc2NvcGUuXG4gICAgICAgICAqIEBtZW1iZXIge1Njb3BlfSBTY29wZSN2YXJpYWJsZVNjb3BlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZhcmlhYmxlU2NvcGUgPVxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PT0gJ2dsb2JhbCcgfHwgdGhpcy50eXBlID09PSAnZnVuY3Rpb24nIHx8IHRoaXMudHlwZSA9PT0gJ21vZHVsZScpID8gdGhpcyA6IHVwcGVyU2NvcGUudmFyaWFibGVTY29wZTtcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgc2NvcGUgaXMgY3JlYXRlZCBieSBhIEZ1bmN0aW9uRXhwcmVzc2lvbi5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gU2NvcGUjZnVuY3Rpb25FeHByZXNzaW9uU2NvcGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnVuY3Rpb25FeHByZXNzaW9uU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaXMgYSBzY29wZSB0aGF0IGNvbnRhaW5zIGFuICdldmFsKCknIGludm9jYXRpb24uXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFNjb3BlI2RpcmVjdENhbGxUb0V2YWxTY29wZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXJlY3RDYWxsVG9FdmFsU2NvcGUgPSBmYWxzZTtcbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBTY29wZSN0aGlzRm91bmRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGhpc0ZvdW5kID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fX2xlZnQgPSBbXTtcblxuICAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgcGFyZW50IHtAbGluayBTY29wZXxzY29wZX0uXG4gICAgICAgICAqIEBtZW1iZXIge1Njb3BlfSBTY29wZSN1cHBlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cHBlciA9IHVwcGVyU2NvcGU7XG4gICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciAndXNlIHN0cmljdCcgaXMgaW4gZWZmZWN0IGluIHRoaXMgc2NvcGUuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFNjb3BlI2lzU3RyaWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU3RyaWN0ID0gaXNTdHJpY3RTY29wZSh0aGlzLCBibG9jaywgaXNNZXRob2REZWZpbml0aW9uLCBzY29wZU1hbmFnZXIuX191c2VEaXJlY3RpdmUoKSk7XG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIG5lc3RlZCB7QGxpbmsgU2NvcGV9cy5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGVbXX0gU2NvcGUjY2hpbGRTY29wZXNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRTY29wZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMudXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIuY2hpbGRTY29wZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcyA9IHNjb3BlTWFuYWdlci5fX2RlY2xhcmVkVmFyaWFibGVzO1xuXG4gICAgICAgIHJlZ2lzdGVyU2NvcGUoc2NvcGVNYW5hZ2VyLCB0aGlzKTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZFN0YXRpY2FsbHlDbG9zZShzY29wZU1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuICghdGhpcy5keW5hbWljIHx8IHNjb3BlTWFuYWdlci5fX2lzT3B0aW1pc3RpYygpKTtcbiAgICB9XG5cbiAgICBfX3Nob3VsZFN0YXRpY2FsbHlDbG9zZUZvckdsb2JhbChyZWYpIHtcbiAgICAgICAgLy8gT24gZ2xvYmFsIHNjb3BlLCBsZXQvY29uc3QvY2xhc3MgZGVjbGFyYXRpb25zIHNob3VsZCBiZSByZXNvbHZlZCBzdGF0aWNhbGx5LlxuICAgICAgICB2YXIgbmFtZSA9IHJlZi5pZGVudGlmaWVyLm5hbWU7XG4gICAgICAgIGlmICghdGhpcy5zZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFyaWFibGUgPSB0aGlzLnNldC5nZXQobmFtZSk7XG4gICAgICAgIHZhciBkZWZzID0gdmFyaWFibGUuZGVmcztcbiAgICAgICAgcmV0dXJuIGRlZnMubGVuZ3RoID4gMCAmJiBkZWZzLmV2ZXJ5KHNob3VsZEJlU3RhdGljYWxseSk7XG4gICAgfVxuXG4gICAgX19zdGF0aWNDbG9zZVJlZihyZWYpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fcmVzb2x2ZShyZWYpKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVsZWdhdGVUb1VwcGVyU2NvcGUocmVmKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fZHluYW1pY0Nsb3NlUmVmKHJlZikge1xuICAgICAgICAvLyBub3RpZnkgYWxsIG5hbWVzIGFyZSB0aHJvdWdoIHRvIGdsb2JhbFxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXM7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1cnJlbnQudGhyb3VnaC5wdXNoKHJlZik7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC51cHBlcjtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgfVxuXG4gICAgX19nbG9iYWxDbG9zZVJlZihyZWYpIHtcbiAgICAgICAgLy8gbGV0L2NvbnN0L2NsYXNzIGRlY2xhcmF0aW9ucyBzaG91bGQgYmUgcmVzb2x2ZWQgc3RhdGljYWxseS5cbiAgICAgICAgLy8gb3RoZXJzIHNob3VsZCBiZSByZXNvbHZlZCBkeW5hbWljYWxseS5cbiAgICAgICAgaWYgKHRoaXMuX19zaG91bGRTdGF0aWNhbGx5Q2xvc2VGb3JHbG9iYWwocmVmKSkge1xuICAgICAgICAgICAgdGhpcy5fX3N0YXRpY0Nsb3NlUmVmKHJlZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fZHluYW1pY0Nsb3NlUmVmKHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfX2Nsb3NlKHNjb3BlTWFuYWdlcikge1xuICAgICAgICB2YXIgY2xvc2VSZWY7XG4gICAgICAgIGlmICh0aGlzLl9fc2hvdWxkU3RhdGljYWxseUNsb3NlKHNjb3BlTWFuYWdlcikpIHtcbiAgICAgICAgICAgIGNsb3NlUmVmID0gdGhpcy5fX3N0YXRpY0Nsb3NlUmVmO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSAhPT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgICAgIGNsb3NlUmVmID0gdGhpcy5fX2R5bmFtaWNDbG9zZVJlZjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsb3NlUmVmID0gdGhpcy5fX2dsb2JhbENsb3NlUmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJ5IFJlc29sdmluZyBhbGwgcmVmZXJlbmNlcyBpbiB0aGlzIHNjb3BlLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSB0aGlzLl9fbGVmdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy5fX2xlZnRbaV07XG4gICAgICAgICAgICBjbG9zZVJlZi5jYWxsKHRoaXMsIHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2xlZnQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwcGVyO1xuICAgIH1cblxuICAgIF9fcmVzb2x2ZShyZWYpIHtcbiAgICAgICAgdmFyIHZhcmlhYmxlLCBuYW1lO1xuICAgICAgICBuYW1lID0gcmVmLmlkZW50aWZpZXIubmFtZTtcbiAgICAgICAgaWYgKHRoaXMuc2V0LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdmFyaWFibGUgPSB0aGlzLnNldC5nZXQobmFtZSk7XG4gICAgICAgICAgICB2YXJpYWJsZS5yZWZlcmVuY2VzLnB1c2gocmVmKTtcbiAgICAgICAgICAgIHZhcmlhYmxlLnN0YWNrID0gdmFyaWFibGUuc3RhY2sgJiYgcmVmLmZyb20udmFyaWFibGVTY29wZSA9PT0gdGhpcy52YXJpYWJsZVNjb3BlO1xuICAgICAgICAgICAgaWYgKHJlZi50YWludGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyaWFibGUudGFpbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy50YWludHMuc2V0KHZhcmlhYmxlLm5hbWUsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmLnJlc29sdmVkID0gdmFyaWFibGU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX19kZWxlZ2F0ZVRvVXBwZXJTY29wZShyZWYpIHtcbiAgICAgICAgaWYgKHRoaXMudXBwZXIpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIuX19sZWZ0LnB1c2gocmVmKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm91Z2gucHVzaChyZWYpO1xuICAgIH1cblxuICAgIF9fYWRkRGVjbGFyZWRWYXJpYWJsZXNPZk5vZGUodmFyaWFibGUsIG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHZhcmlhYmxlcyA9IHRoaXMuX19kZWNsYXJlZFZhcmlhYmxlcy5nZXQobm9kZSk7XG4gICAgICAgIGlmICh2YXJpYWJsZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyaWFibGVzID0gW107XG4gICAgICAgICAgICB0aGlzLl9fZGVjbGFyZWRWYXJpYWJsZXMuc2V0KG5vZGUsIHZhcmlhYmxlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhcmlhYmxlcy5pbmRleE9mKHZhcmlhYmxlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlcy5wdXNoKHZhcmlhYmxlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fZGVmaW5lR2VuZXJpYyhuYW1lLCBzZXQsIHZhcmlhYmxlcywgbm9kZSwgZGVmKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZTtcblxuICAgICAgICB2YXJpYWJsZSA9IHNldC5nZXQobmFtZSk7XG4gICAgICAgIGlmICghdmFyaWFibGUpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlID0gbmV3IFZhcmlhYmxlKG5hbWUsIHRoaXMpO1xuICAgICAgICAgICAgc2V0LnNldChuYW1lLCB2YXJpYWJsZSk7XG4gICAgICAgICAgICB2YXJpYWJsZXMucHVzaCh2YXJpYWJsZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVmKSB7XG4gICAgICAgICAgICB2YXJpYWJsZS5kZWZzLnB1c2goZGVmKTtcbiAgICAgICAgICAgIGlmIChkZWYudHlwZSAhPT0gVmFyaWFibGUuVERaKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2FkZERlY2xhcmVkVmFyaWFibGVzT2ZOb2RlKHZhcmlhYmxlLCBkZWYubm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2FkZERlY2xhcmVkVmFyaWFibGVzT2ZOb2RlKHZhcmlhYmxlLCBkZWYucGFyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdmFyaWFibGUuaWRlbnRpZmllcnMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9fZGVmaW5lKG5vZGUsIGRlZikge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lR2VuZXJpYyhcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfX3JlZmVyZW5jaW5nKG5vZGUsIGFzc2lnbiwgd3JpdGVFeHByLCBtYXliZUltcGxpY2l0R2xvYmFsLCBwYXJ0aWFsLCBpbml0KSB7XG4gICAgICAgIC8vIGJlY2F1c2UgQXJyYXkgZWxlbWVudCBtYXkgYmUgbnVsbFxuICAgICAgICBpZiAoIW5vZGUgfHwgbm9kZS50eXBlICE9PSBTeW50YXguSWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BlY2lhbGx5IGhhbmRsZSBsaWtlIGB0aGlzYC5cbiAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ3N1cGVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlZiA9IG5ldyBSZWZlcmVuY2Uobm9kZSwgdGhpcywgYXNzaWduIHx8IFJlZmVyZW5jZS5SRUFELCB3cml0ZUV4cHIsIG1heWJlSW1wbGljaXRHbG9iYWwsICEhcGFydGlhbCwgISFpbml0KTtcbiAgICAgICAgdGhpcy5yZWZlcmVuY2VzLnB1c2gocmVmKTtcbiAgICAgICAgdGhpcy5fX2xlZnQucHVzaChyZWYpO1xuICAgIH1cblxuICAgIF9fZGV0ZWN0RXZhbCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpcmVjdENhbGxUb0V2YWxTY29wZSA9IHRydWU7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGN1cnJlbnQuZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC51cHBlcjtcbiAgICAgICAgfSB3aGlsZSAoY3VycmVudCk7XG4gICAgfVxuXG4gICAgX19kZXRlY3RUaGlzKCkge1xuICAgICAgICB0aGlzLnRoaXNGb3VuZCA9IHRydWU7XG4gICAgfVxuXG4gICAgX19pc0Nsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19sZWZ0ID09PSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgcmVzb2x2ZWQge1JlZmVyZW5jZX1cbiAgICAgKiBAbWV0aG9kIFNjb3BlI3Jlc29sdmVcbiAgICAgKiBAcGFyYW0ge0VzcHJpbWEuSWRlbnRpZmllcn0gaWRlbnQgLSBpZGVudGlmaWVyIHRvIGJlIHJlc29sdmVkLlxuICAgICAqIEByZXR1cm4ge1JlZmVyZW5jZX1cbiAgICAgKi9cbiAgICByZXNvbHZlKGlkZW50KSB7XG4gICAgICAgIHZhciByZWYsIGksIGl6O1xuICAgICAgICBhc3NlcnQodGhpcy5fX2lzQ2xvc2VkKCksICdTY29wZSBzaG91bGQgYmUgY2xvc2VkLicpO1xuICAgICAgICBhc3NlcnQoaWRlbnQudHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIsICdUYXJnZXQgc2hvdWxkIGJlIGlkZW50aWZpZXIuJyk7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gdGhpcy5yZWZlcmVuY2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWYuaWRlbnRpZmllciA9PT0gaWRlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhpcyBzY29wZSBpcyBzdGF0aWNcbiAgICAgKiBAbWV0aG9kIFNjb3BlI2lzU3RhdGljXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0YXRpYygpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmR5bmFtaWM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGlzIHNjb3BlIGhhcyBtYXRlcmlhbGl6ZWQgYXJndW1lbnRzXG4gICAgICogQG1ldGhvZCBTY29wZSNpc0FyZ3VtZW50c01hdGVyaWFsaXplZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNBcmd1bWVudHNNYXRlcmlhbGl6ZWQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhpcyBzY29wZSBoYXMgbWF0ZXJpYWxpemVkIGB0aGlzYCByZWZlcmVuY2VcbiAgICAgKiBAbWV0aG9kIFNjb3BlI2lzVGhpc01hdGVyaWFsaXplZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaGlzTWF0ZXJpYWxpemVkKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpc1VzZWROYW1lKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0LmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGl6ID0gdGhpcy50aHJvdWdoLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRocm91Z2hbaV0uaWRlbnRpZmllci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIEdsb2JhbFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnZ2xvYmFsJywgbnVsbCwgYmxvY2ssIGZhbHNlKTtcbiAgICAgICAgdGhpcy5pbXBsaWNpdCA9IHtcbiAgICAgICAgICAgIHNldDogbmV3IE1hcCgpLFxuICAgICAgICAgICAgdmFyaWFibGVzOiBbXSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBMaXN0IG9mIHtAbGluayBSZWZlcmVuY2V9cyB0aGF0IGFyZSBsZWZ0IHRvIGJlIHJlc29sdmVkIChpLmUuIHdoaWNoXG4gICAgICAgICAgICAqIG5lZWQgdG8gYmUgbGlua2VkIHRvIHRoZSB2YXJpYWJsZSB0aGV5IHJlZmVyIHRvKS5cbiAgICAgICAgICAgICogQG1lbWJlciB7UmVmZXJlbmNlW119IFNjb3BlI2ltcGxpY2l0I2xlZnRcbiAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZWZ0OiBbXVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9fY2xvc2Uoc2NvcGVNYW5hZ2VyKSB7XG4gICAgICAgIGxldCBpbXBsaWNpdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaXogPSB0aGlzLl9fbGVmdC5sZW5ndGg7IGkgPCBpejsgKytpKSB7XG4gICAgICAgICAgICBsZXQgcmVmID0gdGhpcy5fX2xlZnRbaV07XG4gICAgICAgICAgICBpZiAocmVmLl9fbWF5YmVJbXBsaWNpdEdsb2JhbCAmJiAhdGhpcy5zZXQuaGFzKHJlZi5pZGVudGlmaWVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaW1wbGljaXQucHVzaChyZWYuX19tYXliZUltcGxpY2l0R2xvYmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSBhbiBpbXBsaWNpdCBnbG9iYWwgdmFyaWFibGUgZnJvbSBhc3NpZ25tZW50IGV4cHJlc3Npb25cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gaW1wbGljaXQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSBpbXBsaWNpdFtpXTtcbiAgICAgICAgICAgIHRoaXMuX19kZWZpbmVJbXBsaWNpdChpbmZvLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIG5ldyBEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuSW1wbGljaXRHbG9iYWxWYXJpYWJsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ucGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZm8ubm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbXBsaWNpdC5sZWZ0ID0gdGhpcy5fX2xlZnQ7XG5cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9fY2xvc2Uoc2NvcGVNYW5hZ2VyKTtcbiAgICB9XG5cbiAgICBfX2RlZmluZUltcGxpY2l0KG5vZGUsIGRlZikge1xuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lR2VuZXJpYyhcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltcGxpY2l0LnNldCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbXBsaWNpdC52YXJpYWJsZXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGRlZik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNb2R1bGVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ21vZHVsZScsIHVwcGVyU2NvcGUsIGJsb2NrLCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25FeHByZXNzaW9uTmFtZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnZnVuY3Rpb24tZXhwcmVzc2lvbi1uYW1lJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fX2RlZmluZShibG9jay5pZCxcbiAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuRnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBibG9jay5pZCxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgdGhpcy5mdW5jdGlvbkV4cHJlc3Npb25TY29wZSA9IHRydWU7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgQ2F0Y2hTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZU1hbmFnZXIsIHVwcGVyU2NvcGUsIGJsb2NrKSB7XG4gICAgICAgIHN1cGVyKHNjb3BlTWFuYWdlciwgJ2NhdGNoJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBXaXRoU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICd3aXRoJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG5cbiAgICBfX2Nsb3NlKHNjb3BlTWFuYWdlcikge1xuICAgICAgICBpZiAodGhpcy5fX3Nob3VsZFN0YXRpY2FsbHlDbG9zZShzY29wZU1hbmFnZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX19jbG9zZShzY29wZU1hbmFnZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGl6ID0gdGhpcy5fX2xlZnQubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgbGV0IHJlZiA9IHRoaXMuX19sZWZ0W2ldO1xuICAgICAgICAgICAgcmVmLnRhaW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fX2RlbGVnYXRlVG9VcHBlclNjb3BlKHJlZik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2xlZnQgPSBudWxsO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnVwcGVyO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFREWlNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnVERaJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCbG9ja1Njb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnYmxvY2snLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFN3aXRjaFNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2spIHtcbiAgICAgICAgc3VwZXIoc2NvcGVNYW5hZ2VyLCAnc3dpdGNoJywgdXBwZXJTY29wZSwgYmxvY2ssIGZhbHNlKTtcbiAgICB9XG59XG5cbmV4cG9ydCBjbGFzcyBGdW5jdGlvblNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjb3BlTWFuYWdlciwgdXBwZXJTY29wZSwgYmxvY2ssIGlzTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdmdW5jdGlvbicsIHVwcGVyU2NvcGUsIGJsb2NrLCBpc01ldGhvZERlZmluaXRpb24pO1xuXG4gICAgICAgIC8vIHNlY3Rpb24gOS4yLjEzLCBGdW5jdGlvbkRlY2xhcmF0aW9uSW5zdGFudGlhdGlvbi5cbiAgICAgICAgLy8gTk9URSBBcnJvdyBmdW5jdGlvbnMgbmV2ZXIgaGF2ZSBhbiBhcmd1bWVudHMgb2JqZWN0cy5cbiAgICAgICAgaWYgKHRoaXMuYmxvY2sudHlwZSAhPT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9fZGVmaW5lQXJndW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpc0FyZ3VtZW50c01hdGVyaWFsaXplZCgpIHtcbiAgICAgICAgLy8gVE9ETyhDb25zdGVsbGF0aW9uKVxuICAgICAgICAvLyBXZSBjYW4gbW9yZSBhZ2dyZXNzaXZlIG9uIHRoaXMgY29uZGl0aW9uIGxpa2UgdGhpcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gZnVuY3Rpb24gdCgpIHtcbiAgICAgICAgLy8gICAgIC8vIGFyZ3VtZW50cyBvZiB0IGlzIGFsd2F5cyBoaWRkZW4uXG4gICAgICAgIC8vICAgICBmdW5jdGlvbiBhcmd1bWVudHMoKSB7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKHRoaXMuYmxvY2sudHlwZSA9PT0gU3ludGF4LkFycm93RnVuY3Rpb25FeHByZXNzaW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNTdGF0aWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFyaWFibGUgPSB0aGlzLnNldC5nZXQoJ2FyZ3VtZW50cycpO1xuICAgICAgICBhc3NlcnQodmFyaWFibGUsICdBbHdheXMgaGF2ZSBhcmd1bWVudHMgdmFyaWFibGUuJyk7XG4gICAgICAgIHJldHVybiB2YXJpYWJsZS50YWludGVkIHx8IHZhcmlhYmxlLnJlZmVyZW5jZXMubGVuZ3RoICAhPT0gMDtcbiAgICB9XG5cbiAgICBpc1RoaXNNYXRlcmlhbGl6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1N0YXRpYygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50aGlzRm91bmQ7XG4gICAgfVxuXG4gICAgX19kZWZpbmVBcmd1bWVudHMoKSB7XG4gICAgICAgIHRoaXMuX19kZWZpbmVHZW5lcmljKFxuICAgICAgICAgICAgICAgICdhcmd1bWVudHMnLFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0LFxuICAgICAgICAgICAgICAgIHRoaXMudmFyaWFibGVzLFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgbnVsbCk7XG4gICAgICAgIHRoaXMudGFpbnRzLnNldCgnYXJndW1lbnRzJywgdHJ1ZSk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRm9yU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdmb3InLCB1cHBlclNjb3BlLCBibG9jaywgZmFsc2UpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIENsYXNzU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGVNYW5hZ2VyLCB1cHBlclNjb3BlLCBibG9jaykge1xuICAgICAgICBzdXBlcihzY29wZU1hbmFnZXIsICdjbGFzcycsIHVwcGVyU2NvcGUsIGJsb2NrLCBmYWxzZSk7XG4gICAgfVxufVxuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*jslint vars:false, bitwise:true*/
	/*jshint indent:4*/
	/*global exports:true*/
	(function clone(exports) {
	    'use strict';
	
	    var Syntax,
	        isArray,
	        VisitorOption,
	        VisitorKeys,
	        objectCreate,
	        objectKeys,
	        BREAK,
	        SKIP,
	        REMOVE;
	
	    function ignoreJSHintError() { }
	
	    isArray = Array.isArray;
	    if (!isArray) {
	        isArray = function isArray(array) {
	            return Object.prototype.toString.call(array) === '[object Array]';
	        };
	    }
	
	    function deepCopy(obj) {
	        var ret = {}, key, val;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                val = obj[key];
	                if (typeof val === 'object' && val !== null) {
	                    ret[key] = deepCopy(val);
	                } else {
	                    ret[key] = val;
	                }
	            }
	        }
	        return ret;
	    }
	
	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    ignoreJSHintError(shallowCopy);
	
	    // based on LLVM libc++ upper_bound / lower_bound
	    // MIT License
	
	    function upperBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                len = diff;
	            } else {
	                i = current + 1;
	                len -= diff + 1;
	            }
	        }
	        return i;
	    }
	
	    function lowerBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                i = current + 1;
	                len -= diff + 1;
	            } else {
	                len = diff;
	            }
	        }
	        return i;
	    }
	    ignoreJSHintError(lowerBound);
	
	    objectCreate = Object.create || (function () {
	        function F() { }
	
	        return function (o) {
	            F.prototype = o;
	            return new F();
	        };
	    })();
	
	    objectKeys = Object.keys || function (o) {
	        var keys = [], key;
	        for (key in o) {
	            keys.push(key);
	        }
	        return keys;
	    };
	
	    function extend(to, from) {
	        var keys = objectKeys(from), key, i, len;
	        for (i = 0, len = keys.length; i < len; i += 1) {
	            key = keys[i];
	            to[key] = from[key];
	        }
	        return to;
	    }
	
	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        DirectiveStatement: 'DirectiveStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        ForOfStatement: 'ForOfStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        ModuleSpecifier: 'ModuleSpecifier',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };
	
	    VisitorKeys = {
	        AssignmentExpression: ['left', 'right'],
	        AssignmentPattern: ['left', 'right'],
	        ArrayExpression: ['elements'],
	        ArrayPattern: ['elements'],
	        ArrowFunctionExpression: ['params', 'body'],
	        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
	        BlockStatement: ['body'],
	        BinaryExpression: ['left', 'right'],
	        BreakStatement: ['label'],
	        CallExpression: ['callee', 'arguments'],
	        CatchClause: ['param', 'body'],
	        ClassBody: ['body'],
	        ClassDeclaration: ['id', 'superClass', 'body'],
	        ClassExpression: ['id', 'superClass', 'body'],
	        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: ['test', 'consequent', 'alternate'],
	        ContinueStatement: ['label'],
	        DebuggerStatement: [],
	        DirectiveStatement: [],
	        DoWhileStatement: ['body', 'test'],
	        EmptyStatement: [],
	        ExportAllDeclaration: ['source'],
	        ExportDefaultDeclaration: ['declaration'],
	        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
	        ExportSpecifier: ['exported', 'local'],
	        ExpressionStatement: ['expression'],
	        ForStatement: ['init', 'test', 'update', 'body'],
	        ForInStatement: ['left', 'right', 'body'],
	        ForOfStatement: ['left', 'right', 'body'],
	        FunctionDeclaration: ['id', 'params', 'body'],
	        FunctionExpression: ['id', 'params', 'body'],
	        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        Identifier: [],
	        IfStatement: ['test', 'consequent', 'alternate'],
	        ImportDeclaration: ['specifiers', 'source'],
	        ImportDefaultSpecifier: ['local'],
	        ImportNamespaceSpecifier: ['local'],
	        ImportSpecifier: ['imported', 'local'],
	        Literal: [],
	        LabeledStatement: ['label', 'body'],
	        LogicalExpression: ['left', 'right'],
	        MemberExpression: ['object', 'property'],
	        MetaProperty: ['meta', 'property'],
	        MethodDefinition: ['key', 'value'],
	        ModuleSpecifier: [],
	        NewExpression: ['callee', 'arguments'],
	        ObjectExpression: ['properties'],
	        ObjectPattern: ['properties'],
	        Program: ['body'],
	        Property: ['key', 'value'],
	        RestElement: [ 'argument' ],
	        ReturnStatement: ['argument'],
	        SequenceExpression: ['expressions'],
	        SpreadElement: ['argument'],
	        Super: [],
	        SwitchStatement: ['discriminant', 'cases'],
	        SwitchCase: ['test', 'consequent'],
	        TaggedTemplateExpression: ['tag', 'quasi'],
	        TemplateElement: [],
	        TemplateLiteral: ['quasis', 'expressions'],
	        ThisExpression: [],
	        ThrowStatement: ['argument'],
	        TryStatement: ['block', 'handler', 'finalizer'],
	        UnaryExpression: ['argument'],
	        UpdateExpression: ['argument'],
	        VariableDeclaration: ['declarations'],
	        VariableDeclarator: ['id', 'init'],
	        WhileStatement: ['test', 'body'],
	        WithStatement: ['object', 'body'],
	        YieldExpression: ['argument']
	    };
	
	    // unique id
	    BREAK = {};
	    SKIP = {};
	    REMOVE = {};
	
	    VisitorOption = {
	        Break: BREAK,
	        Skip: SKIP,
	        Remove: REMOVE
	    };
	
	    function Reference(parent, key) {
	        this.parent = parent;
	        this.key = key;
	    }
	
	    Reference.prototype.replace = function replace(node) {
	        this.parent[this.key] = node;
	    };
	
	    Reference.prototype.remove = function remove() {
	        if (isArray(this.parent)) {
	            this.parent.splice(this.key, 1);
	            return true;
	        } else {
	            this.replace(null);
	            return false;
	        }
	    };
	
	    function Element(node, path, wrap, ref) {
	        this.node = node;
	        this.path = path;
	        this.wrap = wrap;
	        this.ref = ref;
	    }
	
	    function Controller() { }
	
	    // API:
	    // return property path array from root to current node
	    Controller.prototype.path = function path() {
	        var i, iz, j, jz, result, element;
	
	        function addToPath(result, path) {
	            if (isArray(path)) {
	                for (j = 0, jz = path.length; j < jz; ++j) {
	                    result.push(path[j]);
	                }
	            } else {
	                result.push(path);
	            }
	        }
	
	        // root node
	        if (!this.__current.path) {
	            return null;
	        }
	
	        // first node is sentinel, second node is root element
	        result = [];
	        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
	            element = this.__leavelist[i];
	            addToPath(result, element.path);
	        }
	        addToPath(result, this.__current.path);
	        return result;
	    };
	
	    // API:
	    // return type of current node
	    Controller.prototype.type = function () {
	        var node = this.current();
	        return node.type || this.__current.wrap;
	    };
	
	    // API:
	    // return array of parent elements
	    Controller.prototype.parents = function parents() {
	        var i, iz, result;
	
	        // first node is sentinel
	        result = [];
	        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
	            result.push(this.__leavelist[i].node);
	        }
	
	        return result;
	    };
	
	    // API:
	    // return current node
	    Controller.prototype.current = function current() {
	        return this.__current.node;
	    };
	
	    Controller.prototype.__execute = function __execute(callback, element) {
	        var previous, result;
	
	        result = undefined;
	
	        previous  = this.__current;
	        this.__current = element;
	        this.__state = null;
	        if (callback) {
	            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
	        }
	        this.__current = previous;
	
	        return result;
	    };
	
	    // API:
	    // notify control skip / break
	    Controller.prototype.notify = function notify(flag) {
	        this.__state = flag;
	    };
	
	    // API:
	    // skip child nodes of current node
	    Controller.prototype.skip = function () {
	        this.notify(SKIP);
	    };
	
	    // API:
	    // break traversals
	    Controller.prototype['break'] = function () {
	        this.notify(BREAK);
	    };
	
	    // API:
	    // remove node
	    Controller.prototype.remove = function () {
	        this.notify(REMOVE);
	    };
	
	    Controller.prototype.__initialize = function(root, visitor) {
	        this.visitor = visitor;
	        this.root = root;
	        this.__worklist = [];
	        this.__leavelist = [];
	        this.__current = null;
	        this.__state = null;
	        this.__fallback = null;
	        if (visitor.fallback === 'iteration') {
	            this.__fallback = objectKeys;
	        } else if (typeof visitor.fallback === 'function') {
	            this.__fallback = visitor.fallback;
	        }
	
	        this.__keys = VisitorKeys;
	        if (visitor.keys) {
	            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
	        }
	    };
	
	    function isNode(node) {
	        if (node == null) {
	            return false;
	        }
	        return typeof node === 'object' && typeof node.type === 'string';
	    }
	
	    function isProperty(nodeType, key) {
	        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	    }
	
	    Controller.prototype.traverse = function traverse(root, visitor) {
	        var worklist,
	            leavelist,
	            element,
	            node,
	            nodeType,
	            ret,
	            key,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel;
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        worklist.push(new Element(root, null, null, null));
	        leavelist.push(new Element(null, null, null, null));
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                ret = this.__execute(visitor.leave, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	                continue;
	            }
	
	            if (element.node) {
	
	                ret = this.__execute(visitor.enter, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	
	                worklist.push(sentinel);
	                leavelist.push(element);
	
	                if (this.__state === SKIP || ret === SKIP) {
	                    continue;
	                }
	
	                node = element.node;
	                nodeType = node.type || element.wrap;
	                candidates = this.__keys[nodeType];
	                if (!candidates) {
	                    if (this.__fallback) {
	                        candidates = this.__fallback(node);
	                    } else {
	                        throw new Error('Unknown node type ' + nodeType + '.');
	                    }
	                }
	
	                current = candidates.length;
	                while ((current -= 1) >= 0) {
	                    key = candidates[current];
	                    candidate = node[key];
	                    if (!candidate) {
	                        continue;
	                    }
	
	                    if (isArray(candidate)) {
	                        current2 = candidate.length;
	                        while ((current2 -= 1) >= 0) {
	                            if (!candidate[current2]) {
	                                continue;
	                            }
	                            if (isProperty(nodeType, candidates[current])) {
	                                element = new Element(candidate[current2], [key, current2], 'Property', null);
	                            } else if (isNode(candidate[current2])) {
	                                element = new Element(candidate[current2], [key, current2], null, null);
	                            } else {
	                                continue;
	                            }
	                            worklist.push(element);
	                        }
	                    } else if (isNode(candidate)) {
	                        worklist.push(new Element(candidate, key, null, null));
	                    }
	                }
	            }
	        }
	    };
	
	    Controller.prototype.replace = function replace(root, visitor) {
	        var worklist,
	            leavelist,
	            node,
	            nodeType,
	            target,
	            element,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel,
	            outer,
	            key;
	
	        function removeElem(element) {
	            var i,
	                key,
	                nextElem,
	                parent;
	
	            if (element.ref.remove()) {
	                // When the reference is an element of an array.
	                key = element.ref.key;
	                parent = element.ref.parent;
	
	                // If removed from array, then decrease following items' keys.
	                i = worklist.length;
	                while (i--) {
	                    nextElem = worklist[i];
	                    if (nextElem.ref && nextElem.ref.parent === parent) {
	                        if  (nextElem.ref.key < key) {
	                            break;
	                        }
	                        --nextElem.ref.key;
	                    }
	                }
	            }
	        }
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        outer = {
	            root: root
	        };
	        element = new Element(root, null, null, new Reference(outer, 'root'));
	        worklist.push(element);
	        leavelist.push(element);
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                target = this.__execute(visitor.leave, element);
	
	                // node may be replaced with null,
	                // so distinguish between undefined and null in this place
	                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                    // replace
	                    element.ref.replace(target);
	                }
	
	                if (this.__state === REMOVE || target === REMOVE) {
	                    removeElem(element);
	                }
	
	                if (this.__state === BREAK || target === BREAK) {
	                    return outer.root;
	                }
	                continue;
	            }
	
	            target = this.__execute(visitor.enter, element);
	
	            // node may be replaced with null,
	            // so distinguish between undefined and null in this place
	            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                // replace
	                element.ref.replace(target);
	                element.node = target;
	            }
	
	            if (this.__state === REMOVE || target === REMOVE) {
	                removeElem(element);
	                element.node = null;
	            }
	
	            if (this.__state === BREAK || target === BREAK) {
	                return outer.root;
	            }
	
	            // node may be null
	            node = element.node;
	            if (!node) {
	                continue;
	            }
	
	            worklist.push(sentinel);
	            leavelist.push(element);
	
	            if (this.__state === SKIP || target === SKIP) {
	                continue;
	            }
	
	            nodeType = node.type || element.wrap;
	            candidates = this.__keys[nodeType];
	            if (!candidates) {
	                if (this.__fallback) {
	                    candidates = this.__fallback(node);
	                } else {
	                    throw new Error('Unknown node type ' + nodeType + '.');
	                }
	            }
	
	            current = candidates.length;
	            while ((current -= 1) >= 0) {
	                key = candidates[current];
	                candidate = node[key];
	                if (!candidate) {
	                    continue;
	                }
	
	                if (isArray(candidate)) {
	                    current2 = candidate.length;
	                    while ((current2 -= 1) >= 0) {
	                        if (!candidate[current2]) {
	                            continue;
	                        }
	                        if (isProperty(nodeType, candidates[current])) {
	                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
	                        } else if (isNode(candidate[current2])) {
	                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
	                        } else {
	                            continue;
	                        }
	                        worklist.push(element);
	                    }
	                } else if (isNode(candidate)) {
	                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
	                }
	            }
	        }
	
	        return outer.root;
	    };
	
	    function traverse(root, visitor) {
	        var controller = new Controller();
	        return controller.traverse(root, visitor);
	    }
	
	    function replace(root, visitor) {
	        var controller = new Controller();
	        return controller.replace(root, visitor);
	    }
	
	    function extendCommentRange(comment, tokens) {
	        var target;
	
	        target = upperBound(tokens, function search(token) {
	            return token.range[0] > comment.range[0];
	        });
	
	        comment.extendedRange = [comment.range[0], comment.range[1]];
	
	        if (target !== tokens.length) {
	            comment.extendedRange[1] = tokens[target].range[0];
	        }
	
	        target -= 1;
	        if (target >= 0) {
	            comment.extendedRange[0] = tokens[target].range[1];
	        }
	
	        return comment;
	    }
	
	    function attachComments(tree, providedComments, tokens) {
	        // At first, we should calculate extended comment ranges.
	        var comments = [], comment, len, i, cursor;
	
	        if (!tree.range) {
	            throw new Error('attachComments needs range information');
	        }
	
	        // tokens array is empty, we attach comments to tree as 'leadingComments'
	        if (!tokens.length) {
	            if (providedComments.length) {
	                for (i = 0, len = providedComments.length; i < len; i += 1) {
	                    comment = deepCopy(providedComments[i]);
	                    comment.extendedRange = [0, tree.range[0]];
	                    comments.push(comment);
	                }
	                tree.leadingComments = comments;
	            }
	            return tree;
	        }
	
	        for (i = 0, len = providedComments.length; i < len; i += 1) {
	            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
	        }
	
	        // This is based on John Freeman's implementation.
	        cursor = 0;
	        traverse(tree, {
	            enter: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (comment.extendedRange[1] > node.range[0]) {
	                        break;
	                    }
	
	                    if (comment.extendedRange[1] === node.range[0]) {
	                        if (!node.leadingComments) {
	                            node.leadingComments = [];
	                        }
	                        node.leadingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        cursor = 0;
	        traverse(tree, {
	            leave: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (node.range[1] < comment.extendedRange[0]) {
	                        break;
	                    }
	
	                    if (node.range[1] === comment.extendedRange[0]) {
	                        if (!node.trailingComments) {
	                            node.trailingComments = [];
	                        }
	                        node.trailingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        return tree;
	    }
	
	    exports.version = __webpack_require__(58).version;
	    exports.Syntax = Syntax;
	    exports.traverse = traverse;
	    exports.replace = replace;
	    exports.attachComments = attachComments;
	    exports.VisitorKeys = VisitorKeys;
	    exports.VisitorOption = VisitorOption;
	    exports.Controller = Controller;
	    exports.cloneEnvironment = function () { return clone({}); };
	
	    return exports;
	}(exports));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 58 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "estraverse@^4.2.0",
					"scope": null,
					"escapedName": "estraverse",
					"name": "estraverse",
					"rawSpec": "^4.2.0",
					"spec": ">=4.2.0 <5.0.0",
					"type": "range"
				},
				"/home/joe/prog/googlejs-site/node_modules/eslint"
			]
		],
		"_from": "estraverse@>=4.2.0 <5.0.0",
		"_id": "estraverse@4.2.0",
		"_inCache": true,
		"_location": "/estraverse",
		"_nodeVersion": "0.12.9",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/estraverse-4.2.0.tgz_1457646738925_0.7118953282479197"
		},
		"_npmUser": {
			"name": "nzakas",
			"email": "nicholas@nczconsulting.com"
		},
		"_npmVersion": "2.14.9",
		"_phantomChildren": {},
		"_requested": {
			"raw": "estraverse@^4.2.0",
			"scope": null,
			"escapedName": "estraverse",
			"name": "estraverse",
			"rawSpec": "^4.2.0",
			"spec": ">=4.2.0 <5.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/escope",
			"/eslint"
		],
		"_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz",
		"_shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
		"_shrinkwrap": null,
		"_spec": "estraverse@^4.2.0",
		"_where": "/home/joe/prog/googlejs-site/node_modules/eslint",
		"bugs": {
			"url": "https://github.com/estools/estraverse/issues"
		},
		"dependencies": {},
		"description": "ECMAScript JS AST traversal functions",
		"devDependencies": {
			"babel-preset-es2015": "^6.3.13",
			"babel-register": "^6.3.13",
			"chai": "^2.1.1",
			"espree": "^1.11.0",
			"gulp": "^3.8.10",
			"gulp-bump": "^0.2.2",
			"gulp-filter": "^2.0.0",
			"gulp-git": "^1.0.1",
			"gulp-tag-version": "^1.2.1",
			"jshint": "^2.5.6",
			"mocha": "^2.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "0dee3fed31fcd469618ce7342099fc1afa0bdb13",
			"tarball": "https://registry.npmjs.org/estraverse/-/estraverse-4.2.0.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"gitHead": "6f6a4e99653908e859c7c10d04d9518bf4844ede",
		"homepage": "https://github.com/estools/estraverse",
		"license": "BSD-2-Clause",
		"main": "estraverse.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "michaelficarra",
				"email": "npm@michael.ficarra.me"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "estraverse",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/estools/estraverse.git"
		},
		"scripts": {
			"lint": "jshint estraverse.js",
			"test": "npm run-script lint && npm run-script unit-test",
			"unit-test": "mocha --compilers js:babel-register"
		},
		"version": "4.2.0"
	};

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(60)() ? Map : __webpack_require__(61);


/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var map, iterator, result;
		if (typeof Map !== 'function') return false;
		try {
			// WebKit doesn't support arguments and crashes
			map = new Map([['raz', 'one'], ['dwa', 'two'], ['trzy', 'three']]);
		} catch (e) {
			return false;
		}
		if (String(map) !== '[object Map]') return false;
		if (map.size !== 3) return false;
		if (typeof map.clear !== 'function') return false;
		if (typeof map.delete !== 'function') return false;
		if (typeof map.entries !== 'function') return false;
		if (typeof map.forEach !== 'function') return false;
		if (typeof map.get !== 'function') return false;
		if (typeof map.has !== 'function') return false;
		if (typeof map.keys !== 'function') return false;
		if (typeof map.set !== 'function') return false;
		if (typeof map.values !== 'function') return false;
	
		iterator = map.entries();
		result = iterator.next();
		if (result.done !== false) return false;
		if (!result.value) return false;
		if (result.value[0] !== 'raz') return false;
		if (result.value[1] !== 'one') return false;
	
		return true;
	};


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var clear          = __webpack_require__(39)
	  , eIndexOf       = __webpack_require__(62)
	  , setPrototypeOf = __webpack_require__(14)
	  , callable       = __webpack_require__(40)
	  , validValue     = __webpack_require__(18)
	  , d              = __webpack_require__(22)
	  , ee             = __webpack_require__(68)
	  , Symbol         = __webpack_require__(46)
	  , iterator       = __webpack_require__(52)
	  , forOf          = __webpack_require__(54)
	  , Iterator       = __webpack_require__(69)
	  , isNative       = __webpack_require__(72)
	
	  , call = Function.prototype.call
	  , defineProperties = Object.defineProperties, getPrototypeOf = Object.getPrototypeOf
	  , MapPoly;
	
	module.exports = MapPoly = function (/*iterable*/) {
		var iterable = arguments[0], keys, values, self;
		if (!(this instanceof MapPoly)) throw new TypeError('Constructor requires \'new\'');
		if (isNative && setPrototypeOf && (Map !== MapPoly)) {
			self = setPrototypeOf(new Map(), getPrototypeOf(this));
		} else {
			self = this;
		}
		if (iterable != null) iterator(iterable);
		defineProperties(self, {
			__mapKeysData__: d('c', keys = []),
			__mapValuesData__: d('c', values = [])
		});
		if (!iterable) return self;
		forOf(iterable, function (value) {
			var key = validValue(value)[0];
			value = value[1];
			if (eIndexOf.call(keys, key) !== -1) return;
			keys.push(key);
			values.push(value);
		}, self);
		return self;
	};
	
	if (isNative) {
		if (setPrototypeOf) setPrototypeOf(MapPoly, Map);
		MapPoly.prototype = Object.create(Map.prototype, {
			constructor: d(MapPoly)
		});
	}
	
	ee(defineProperties(MapPoly.prototype, {
		clear: d(function () {
			if (!this.__mapKeysData__.length) return;
			clear.call(this.__mapKeysData__);
			clear.call(this.__mapValuesData__);
			this.emit('_clear');
		}),
		delete: d(function (key) {
			var index = eIndexOf.call(this.__mapKeysData__, key);
			if (index === -1) return false;
			this.__mapKeysData__.splice(index, 1);
			this.__mapValuesData__.splice(index, 1);
			this.emit('_delete', index, key);
			return true;
		}),
		entries: d(function () { return new Iterator(this, 'key+value'); }),
		forEach: d(function (cb/*, thisArg*/) {
			var thisArg = arguments[1], iterator, result;
			callable(cb);
			iterator = this.entries();
			result = iterator._next();
			while (result !== undefined) {
				call.call(cb, thisArg, this.__mapValuesData__[result],
					this.__mapKeysData__[result], this);
				result = iterator._next();
			}
		}),
		get: d(function (key) {
			var index = eIndexOf.call(this.__mapKeysData__, key);
			if (index === -1) return;
			return this.__mapValuesData__[index];
		}),
		has: d(function (key) {
			return (eIndexOf.call(this.__mapKeysData__, key) !== -1);
		}),
		keys: d(function () { return new Iterator(this, 'key'); }),
		set: d(function (key, value) {
			var index = eIndexOf.call(this.__mapKeysData__, key), emit;
			if (index === -1) {
				index = this.__mapKeysData__.push(key) - 1;
				emit = true;
			}
			this.__mapValuesData__[index] = value;
			if (emit) this.emit('_add', index, key);
			return this;
		}),
		size: d.gs(function () { return this.__mapKeysData__.length; }),
		values: d(function () { return new Iterator(this, 'value'); }),
		toString: d(function () { return '[object Map]'; })
	}));
	Object.defineProperty(MapPoly.prototype, Symbol.iterator, d(function () {
		return this.entries();
	}));
	Object.defineProperty(MapPoly.prototype, Symbol.toStringTag, d('c', 'Map'));


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var toPosInt = __webpack_require__(63)
	  , value    = __webpack_require__(18)
	
	  , indexOf = Array.prototype.indexOf
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , abs = Math.abs, floor = Math.floor;
	
	module.exports = function (searchElement/*, fromIndex*/) {
		var i, l, fromIndex, val;
		if (searchElement === searchElement) { //jslint: ignore
			return indexOf.apply(this, arguments);
		}
	
		l = toPosInt(value(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor(fromIndex);
		else fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
	
		for (i = fromIndex; i < l; ++i) {
			if (hasOwnProperty.call(this, i)) {
				val = this[i];
				if (val !== val) return i; //jslint: ignore
			}
		}
		return -1;
	};


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var toInteger = __webpack_require__(64)
	
	  , max = Math.max;
	
	module.exports = function (value) { return max(0, toInteger(value)); };


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var sign = __webpack_require__(65)
	
	  , abs = Math.abs, floor = Math.floor;
	
	module.exports = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(66)()
		? Math.sign
		: __webpack_require__(67);


/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function () {
		var sign = Math.sign;
		if (typeof sign !== 'function') return false;
		return ((sign(10) === 1) && (sign(-20) === -1));
	};


/***/ },
/* 67 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return (value > 0) ? 1 : -1;
	};


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var d        = __webpack_require__(22)
	  , callable = __webpack_require__(40)
	
	  , apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }
	
	  , on, once, off, emit, methods, descriptors, base;
	
	on = function (type, listener) {
		var data;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];
	
		return this;
	};
	
	once = function (type, listener) {
		var once, self;
	
		callable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});
	
		once.__eeOnceListener__ = listener;
		return this;
	};
	
	off = function (type, listener) {
		var data, listeners, candidate, i;
	
		callable(listener);
	
		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];
	
		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}
	
		return this;
	};
	
	emit = function (type) {
		var i, l, listener, listeners, args;
	
		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;
	
		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
	
			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};
	
	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};
	
	descriptors = {
		on: d(on),
		once: d(once),
		off: d(off),
		emit: d(emit)
	};
	
	base = defineProperties({}, descriptors);
	
	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var setPrototypeOf    = __webpack_require__(14)
	  , d                 = __webpack_require__(22)
	  , Iterator          = __webpack_require__(38)
	  , toStringTagSymbol = __webpack_require__(46).toStringTag
	  , kinds             = __webpack_require__(70)
	
	  , defineProperties = Object.defineProperties
	  , unBind = Iterator.prototype._unBind
	  , MapIterator;
	
	MapIterator = module.exports = function (map, kind) {
		if (!(this instanceof MapIterator)) return new MapIterator(map, kind);
		Iterator.call(this, map.__mapKeysData__, map);
		if (!kind || !kinds[kind]) kind = 'key+value';
		defineProperties(this, {
			__kind__: d('', kind),
			__values__: d('w', map.__mapValuesData__)
		});
	};
	if (setPrototypeOf) setPrototypeOf(MapIterator, Iterator);
	
	MapIterator.prototype = Object.create(Iterator.prototype, {
		constructor: d(MapIterator),
		_resolve: d(function (i) {
			if (this.__kind__ === 'value') return this.__values__[i];
			if (this.__kind__ === 'key') return this.__list__[i];
			return [this.__list__[i], this.__values__[i]];
		}),
		_unBind: d(function () {
			this.__values__ = null;
			unBind.call(this);
		}),
		toString: d(function () { return '[object Map Iterator]'; })
	});
	Object.defineProperty(MapIterator.prototype, toStringTagSymbol,
		d('c', 'Map Iterator'));


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(71)('key',
		'value', 'key+value');


/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';
	
	var forEach = Array.prototype.forEach, create = Object.create;
	
	module.exports = function (arg/*, args*/) {
		var set = create(null);
		forEach.call(arguments, function (name) { set[name] = true; });
		return set;
	};


/***/ },
/* 72 */
/***/ function(module, exports) {

	// Exports true if environment provides native `Map` implementation,
	// whatever that is.
	
	'use strict';
	
	module.exports = (function () {
		if (typeof Map === 'undefined') return false;
		return (Object.prototype.toString.call(new Map()) === '[object Map]');
	}());


/***/ },
/* 73 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/*
	  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	var READ = 0x1;
	var WRITE = 0x2;
	var RW = READ | WRITE;
	
	/**
	 * A Reference represents a single occurrence of an identifier in code.
	 * @class Reference
	 */
	
	var Reference = function () {
	  function Reference(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
	    _classCallCheck(this, Reference);
	
	    /**
	     * Identifier syntax node.
	     * @member {esprima#Identifier} Reference#identifier
	     */
	    this.identifier = ident;
	    /**
	     * Reference to the enclosing Scope.
	     * @member {Scope} Reference#from
	     */
	    this.from = scope;
	    /**
	     * Whether the reference comes from a dynamic scope (such as 'eval',
	     * 'with', etc.), and may be trapped by dynamic scopes.
	     * @member {boolean} Reference#tainted
	     */
	    this.tainted = false;
	    /**
	     * The variable this reference is resolved with.
	     * @member {Variable} Reference#resolved
	     */
	    this.resolved = null;
	    /**
	     * The read-write mode of the reference. (Value is one of {@link
	     * Reference.READ}, {@link Reference.RW}, {@link Reference.WRITE}).
	     * @member {number} Reference#flag
	     * @private
	     */
	    this.flag = flag;
	    if (this.isWrite()) {
	      /**
	       * If reference is writeable, this is the tree being written to it.
	       * @member {esprima#Node} Reference#writeExpr
	       */
	      this.writeExpr = writeExpr;
	      /**
	       * Whether the Reference might refer to a partial value of writeExpr.
	       * @member {boolean} Reference#partial
	       */
	      this.partial = partial;
	      /**
	       * Whether the Reference is to write of initialization.
	       * @member {boolean} Reference#init
	       */
	      this.init = init;
	    }
	    this.__maybeImplicitGlobal = maybeImplicitGlobal;
	  }
	
	  /**
	   * Whether the reference is static.
	   * @method Reference#isStatic
	   * @return {boolean}
	   */
	
	
	  _createClass(Reference, [{
	    key: "isStatic",
	    value: function isStatic() {
	      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
	    }
	
	    /**
	     * Whether the reference is writeable.
	     * @method Reference#isWrite
	     * @return {boolean}
	     */
	
	  }, {
	    key: "isWrite",
	    value: function isWrite() {
	      return !!(this.flag & Reference.WRITE);
	    }
	
	    /**
	     * Whether the reference is readable.
	     * @method Reference#isRead
	     * @return {boolean}
	     */
	
	  }, {
	    key: "isRead",
	    value: function isRead() {
	      return !!(this.flag & Reference.READ);
	    }
	
	    /**
	     * Whether the reference is read-only.
	     * @method Reference#isReadOnly
	     * @return {boolean}
	     */
	
	  }, {
	    key: "isReadOnly",
	    value: function isReadOnly() {
	      return this.flag === Reference.READ;
	    }
	
	    /**
	     * Whether the reference is write-only.
	     * @method Reference#isWriteOnly
	     * @return {boolean}
	     */
	
	  }, {
	    key: "isWriteOnly",
	    value: function isWriteOnly() {
	      return this.flag === Reference.WRITE;
	    }
	
	    /**
	     * Whether the reference is read-write.
	     * @method Reference#isReadWrite
	     * @return {boolean}
	     */
	
	  }, {
	    key: "isReadWrite",
	    value: function isReadWrite() {
	      return this.flag === Reference.RW;
	    }
	  }]);
	
	  return Reference;
	}();
	
	/**
	 * @constant Reference.READ
	 * @private
	 */
	
	
	exports.default = Reference;
	Reference.READ = READ;
	/**
	 * @constant Reference.WRITE
	 * @private
	 */
	Reference.WRITE = WRITE;
	/**
	 * @constant Reference.RW
	 * @private
	 */
	Reference.RW = RW;
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZmVyZW5jZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JBLElBQU0sT0FBTyxHQUFQO0FBQ04sSUFBTSxRQUFRLEdBQVI7QUFDTixJQUFNLEtBQUssT0FBTyxLQUFQOzs7Ozs7O0lBTVU7QUFDakIsV0FEaUIsU0FDakIsQ0FBWSxLQUFaLEVBQW1CLEtBQW5CLEVBQTBCLElBQTFCLEVBQWlDLFNBQWpDLEVBQTRDLG1CQUE1QyxFQUFpRSxPQUFqRSxFQUEwRSxJQUExRSxFQUFnRjswQkFEL0QsV0FDK0Q7Ozs7OztBQUs1RSxTQUFLLFVBQUwsR0FBa0IsS0FBbEI7Ozs7O0FBTDRFLFFBVTVFLENBQUssSUFBTCxHQUFZLEtBQVo7Ozs7OztBQVY0RSxRQWdCNUUsQ0FBSyxPQUFMLEdBQWUsS0FBZjs7Ozs7QUFoQjRFLFFBcUI1RSxDQUFLLFFBQUwsR0FBZ0IsSUFBaEI7Ozs7Ozs7QUFyQjRFLFFBNEI1RSxDQUFLLElBQUwsR0FBWSxJQUFaLENBNUI0RTtBQTZCNUUsUUFBSSxLQUFLLE9BQUwsRUFBSixFQUFvQjs7Ozs7QUFLaEIsV0FBSyxTQUFMLEdBQWlCLFNBQWpCOzs7OztBQUxnQixVQVVoQixDQUFLLE9BQUwsR0FBZSxPQUFmOzs7OztBQVZnQixVQWVoQixDQUFLLElBQUwsR0FBWSxJQUFaLENBZmdCO0tBQXBCO0FBaUJBLFNBQUsscUJBQUwsR0FBNkIsbUJBQTdCLENBOUM0RTtHQUFoRjs7Ozs7Ozs7O2VBRGlCOzsrQkF1RE47QUFDUCxhQUFPLENBQUMsS0FBSyxPQUFMLElBQWdCLEtBQUssUUFBTCxJQUFpQixLQUFLLFFBQUwsQ0FBYyxLQUFkLENBQW9CLFFBQXBCLEVBQWxDLENBREE7Ozs7Ozs7Ozs7OzhCQVNEO0FBQ04sYUFBTyxDQUFDLEVBQUUsS0FBSyxJQUFMLEdBQVksVUFBVSxLQUFWLENBQWQsQ0FERjs7Ozs7Ozs7Ozs7NkJBU0Q7QUFDTCxhQUFPLENBQUMsRUFBRSxLQUFLLElBQUwsR0FBWSxVQUFVLElBQVYsQ0FBZCxDQURIOzs7Ozs7Ozs7OztpQ0FTSTtBQUNULGFBQU8sS0FBSyxJQUFMLEtBQWMsVUFBVSxJQUFWLENBRFo7Ozs7Ozs7Ozs7O2tDQVNDO0FBQ1YsYUFBTyxLQUFLLElBQUwsS0FBYyxVQUFVLEtBQVYsQ0FEWDs7Ozs7Ozs7Ozs7a0NBU0E7QUFDVixhQUFPLEtBQUssSUFBTCxLQUFjLFVBQVUsRUFBVixDQURYOzs7O1NBcEdHOzs7Ozs7Ozs7O0FBNkdyQixVQUFVLElBQVYsR0FBaUIsSUFBakI7Ozs7O0FBS0EsVUFBVSxLQUFWLEdBQWtCLEtBQWxCOzs7OztBQUtBLFVBQVUsRUFBVixHQUFlLEVBQWYiLCJmaWxlIjoicmVmZXJlbmNlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5jb25zdCBSRUFEID0gMHgxO1xuY29uc3QgV1JJVEUgPSAweDI7XG5jb25zdCBSVyA9IFJFQUQgfCBXUklURTtcblxuLyoqXG4gKiBBIFJlZmVyZW5jZSByZXByZXNlbnRzIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYW4gaWRlbnRpZmllciBpbiBjb2RlLlxuICogQGNsYXNzIFJlZmVyZW5jZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWZlcmVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGlkZW50LCBzY29wZSwgZmxhZywgIHdyaXRlRXhwciwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgcGFydGlhbCwgaW5pdCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlbnRpZmllciBzeW50YXggbm9kZS5cbiAgICAgICAgICogQG1lbWJlciB7ZXNwcmltYSNJZGVudGlmaWVyfSBSZWZlcmVuY2UjaWRlbnRpZmllclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWZlcmVuY2UgdG8gdGhlIGVuY2xvc2luZyBTY29wZS5cbiAgICAgICAgICogQG1lbWJlciB7U2NvcGV9IFJlZmVyZW5jZSNmcm9tXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZyb20gPSBzY29wZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBjb21lcyBmcm9tIGEgZHluYW1pYyBzY29wZSAoc3VjaCBhcyAnZXZhbCcsXG4gICAgICAgICAqICd3aXRoJywgZXRjLiksIGFuZCBtYXkgYmUgdHJhcHBlZCBieSBkeW5hbWljIHNjb3Blcy5cbiAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI3RhaW50ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHZhcmlhYmxlIHRoaXMgcmVmZXJlbmNlIGlzIHJlc29sdmVkIHdpdGguXG4gICAgICAgICAqIEBtZW1iZXIge1ZhcmlhYmxlfSBSZWZlcmVuY2UjcmVzb2x2ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlYWQtd3JpdGUgbW9kZSBvZiB0aGUgcmVmZXJlbmNlLiAoVmFsdWUgaXMgb25lIG9mIHtAbGlua1xuICAgICAgICAgKiBSZWZlcmVuY2UuUkVBRH0sIHtAbGluayBSZWZlcmVuY2UuUld9LCB7QGxpbmsgUmVmZXJlbmNlLldSSVRFfSkuXG4gICAgICAgICAqIEBtZW1iZXIge251bWJlcn0gUmVmZXJlbmNlI2ZsYWdcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZmxhZyA9IGZsYWc7XG4gICAgICAgIGlmICh0aGlzLmlzV3JpdGUoKSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiByZWZlcmVuY2UgaXMgd3JpdGVhYmxlLCB0aGlzIGlzIHRoZSB0cmVlIGJlaW5nIHdyaXR0ZW4gdG8gaXQuXG4gICAgICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hI05vZGV9IFJlZmVyZW5jZSN3cml0ZUV4cHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy53cml0ZUV4cHIgPSB3cml0ZUV4cHI7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZXRoZXIgdGhlIFJlZmVyZW5jZSBtaWdodCByZWZlciB0byBhIHBhcnRpYWwgdmFsdWUgb2Ygd3JpdGVFeHByLlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI3BhcnRpYWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsID0gcGFydGlhbDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hldGhlciB0aGUgUmVmZXJlbmNlIGlzIHRvIHdyaXRlIG9mIGluaXRpYWxpemF0aW9uLlxuICAgICAgICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gUmVmZXJlbmNlI2luaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pbml0ID0gaW5pdDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG1heWJlSW1wbGljaXRHbG9iYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHN0YXRpYy5cbiAgICAgKiBAbWV0aG9kIFJlZmVyZW5jZSNpc1N0YXRpY1xuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNTdGF0aWMoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy50YWludGVkICYmIHRoaXMucmVzb2x2ZWQgJiYgdGhpcy5yZXNvbHZlZC5zY29wZS5pc1N0YXRpYygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBpcyB3cml0ZWFibGUuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNXcml0ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNXcml0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuZmxhZyAmIFJlZmVyZW5jZS5XUklURSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHJlYWRhYmxlLlxuICAgICAqIEBtZXRob2QgUmVmZXJlbmNlI2lzUmVhZFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWFkKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5mbGFnICYgUmVmZXJlbmNlLlJFQUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHJlZmVyZW5jZSBpcyByZWFkLW9ubHkuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNSZWFkT25seVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAgICovXG4gICAgaXNSZWFkT25seSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhZyA9PT0gUmVmZXJlbmNlLlJFQUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHdyaXRlLW9ubHkuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNXcml0ZU9ubHlcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzV3JpdGVPbmx5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID09PSBSZWZlcmVuY2UuV1JJVEU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgcmVmZXJlbmNlIGlzIHJlYWQtd3JpdGUuXG4gICAgICogQG1ldGhvZCBSZWZlcmVuY2UjaXNSZWFkV3JpdGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzUmVhZFdyaXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFnID09PSBSZWZlcmVuY2UuUlc7XG4gICAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCBSZWZlcmVuY2UuUkVBRFxuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLlJFQUQgPSBSRUFEO1xuLyoqXG4gKiBAY29uc3RhbnQgUmVmZXJlbmNlLldSSVRFXG4gKiBAcHJpdmF0ZVxuICovXG5SZWZlcmVuY2UuV1JJVEUgPSBXUklURTtcbi8qKlxuICogQGNvbnN0YW50IFJlZmVyZW5jZS5SV1xuICogQHByaXZhdGVcbiAqL1xuUmVmZXJlbmNlLlJXID0gUlc7XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=


/***/ },
/* 74 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/*
	  Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	/**
	 * A Variable represents a locally scoped identifier. These include arguments to
	 * functions.
	 * @class Variable
	 */
	
	var Variable = function Variable(name, scope) {
	  _classCallCheck(this, Variable);
	
	  /**
	   * The variable name, as given in the source code.
	   * @member {String} Variable#name
	   */
	  this.name = name;
	  /**
	   * List of defining occurrences of this variable (like in 'var ...'
	   * statements or as parameter), as AST nodes.
	   * @member {esprima.Identifier[]} Variable#identifiers
	   */
	  this.identifiers = [];
	  /**
	   * List of {@link Reference|references} of this variable (excluding parameter entries)
	   * in its defining scope and all nested scopes. For defining
	   * occurrences only see {@link Variable#defs}.
	   * @member {Reference[]} Variable#references
	   */
	  this.references = [];
	
	  /**
	   * List of defining occurrences of this variable (like in 'var ...'
	   * statements or as parameter), as custom objects.
	   * @member {Definition[]} Variable#defs
	   */
	  this.defs = [];
	
	  this.tainted = false;
	  /**
	   * Whether this is a stack variable.
	   * @member {boolean} Variable#stack
	   */
	  this.stack = true;
	  /**
	   * Reference to the enclosing Scope.
	   * @member {Scope} Variable#scope
	   */
	  this.scope = scope;
	};
	
	exports.default = Variable;
	
	
	Variable.CatchClause = 'CatchClause';
	Variable.Parameter = 'Parameter';
	Variable.FunctionName = 'FunctionName';
	Variable.ClassName = 'ClassName';
	Variable.Variable = 'Variable';
	Variable.ImportBinding = 'ImportBinding';
	Variable.TDZ = 'TDZ';
	Variable.ImplicitGlobalVariable = 'ImplicitGlobalVariable';
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZhcmlhYmxlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBNkJxQixXQUNqQixTQURpQixRQUNqQixDQUFZLElBQVosRUFBa0IsS0FBbEIsRUFBeUI7d0JBRFIsVUFDUTs7Ozs7O0FBS3JCLE9BQUssSUFBTCxHQUFZLElBQVo7Ozs7OztBQUxxQixNQVdyQixDQUFLLFdBQUwsR0FBbUIsRUFBbkI7Ozs7Ozs7QUFYcUIsTUFrQnJCLENBQUssVUFBTCxHQUFrQixFQUFsQjs7Ozs7OztBQWxCcUIsTUF5QnJCLENBQUssSUFBTCxHQUFZLEVBQVosQ0F6QnFCOztBQTJCckIsT0FBSyxPQUFMLEdBQWUsS0FBZjs7Ozs7QUEzQnFCLE1BZ0NyQixDQUFLLEtBQUwsR0FBYSxJQUFiOzs7OztBQWhDcUIsTUFxQ3JCLENBQUssS0FBTCxHQUFhLEtBQWIsQ0FyQ3FCO0NBQXpCOztrQkFEaUI7OztBQTBDckIsU0FBUyxXQUFULEdBQXVCLGFBQXZCO0FBQ0EsU0FBUyxTQUFULEdBQXFCLFdBQXJCO0FBQ0EsU0FBUyxZQUFULEdBQXdCLGNBQXhCO0FBQ0EsU0FBUyxTQUFULEdBQXFCLFdBQXJCO0FBQ0EsU0FBUyxRQUFULEdBQW9CLFVBQXBCO0FBQ0EsU0FBUyxhQUFULEdBQXlCLGVBQXpCO0FBQ0EsU0FBUyxHQUFULEdBQWUsS0FBZjtBQUNBLFNBQVMsc0JBQVQsR0FBa0Msd0JBQWxDIiwiZmlsZSI6InZhcmlhYmxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG4vKipcbiAqIEEgVmFyaWFibGUgcmVwcmVzZW50cyBhIGxvY2FsbHkgc2NvcGVkIGlkZW50aWZpZXIuIFRoZXNlIGluY2x1ZGUgYXJndW1lbnRzIHRvXG4gKiBmdW5jdGlvbnMuXG4gKiBAY2xhc3MgVmFyaWFibGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFyaWFibGUge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHNjb3BlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdmFyaWFibGUgbmFtZSwgYXMgZ2l2ZW4gaW4gdGhlIHNvdXJjZSBjb2RlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTdHJpbmd9IFZhcmlhYmxlI25hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGRlZmluaW5nIG9jY3VycmVuY2VzIG9mIHRoaXMgdmFyaWFibGUgKGxpa2UgaW4gJ3ZhciAuLi4nXG4gICAgICAgICAqIHN0YXRlbWVudHMgb3IgYXMgcGFyYW1ldGVyKSwgYXMgQVNUIG5vZGVzLlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hLklkZW50aWZpZXJbXX0gVmFyaWFibGUjaWRlbnRpZmllcnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWRlbnRpZmllcnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3Qgb2Yge0BsaW5rIFJlZmVyZW5jZXxyZWZlcmVuY2VzfSBvZiB0aGlzIHZhcmlhYmxlIChleGNsdWRpbmcgcGFyYW1ldGVyIGVudHJpZXMpXG4gICAgICAgICAqIGluIGl0cyBkZWZpbmluZyBzY29wZSBhbmQgYWxsIG5lc3RlZCBzY29wZXMuIEZvciBkZWZpbmluZ1xuICAgICAgICAgKiBvY2N1cnJlbmNlcyBvbmx5IHNlZSB7QGxpbmsgVmFyaWFibGUjZGVmc30uXG4gICAgICAgICAqIEBtZW1iZXIge1JlZmVyZW5jZVtdfSBWYXJpYWJsZSNyZWZlcmVuY2VzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdCBvZiBkZWZpbmluZyBvY2N1cnJlbmNlcyBvZiB0aGlzIHZhcmlhYmxlIChsaWtlIGluICd2YXIgLi4uJ1xuICAgICAgICAgKiBzdGF0ZW1lbnRzIG9yIGFzIHBhcmFtZXRlciksIGFzIGN1c3RvbSBvYmplY3RzLlxuICAgICAgICAgKiBAbWVtYmVyIHtEZWZpbml0aW9uW119IFZhcmlhYmxlI2RlZnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmcyA9IFtdO1xuXG4gICAgICAgIHRoaXMudGFpbnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGlzIGlzIGEgc3RhY2sgdmFyaWFibGUuXG4gICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IFZhcmlhYmxlI3N0YWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YWNrID0gdHJ1ZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZmVyZW5jZSB0byB0aGUgZW5jbG9zaW5nIFNjb3BlLlxuICAgICAgICAgKiBAbWVtYmVyIHtTY29wZX0gVmFyaWFibGUjc2NvcGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICB9XG59XG5cblZhcmlhYmxlLkNhdGNoQ2xhdXNlID0gJ0NhdGNoQ2xhdXNlJztcblZhcmlhYmxlLlBhcmFtZXRlciA9ICdQYXJhbWV0ZXInO1xuVmFyaWFibGUuRnVuY3Rpb25OYW1lID0gJ0Z1bmN0aW9uTmFtZSc7XG5WYXJpYWJsZS5DbGFzc05hbWUgPSAnQ2xhc3NOYW1lJztcblZhcmlhYmxlLlZhcmlhYmxlID0gJ1ZhcmlhYmxlJztcblZhcmlhYmxlLkltcG9ydEJpbmRpbmcgPSAnSW1wb3J0QmluZGluZyc7XG5WYXJpYWJsZS5URFogPSAnVERaJztcblZhcmlhYmxlLkltcGxpY2l0R2xvYmFsVmFyaWFibGUgPSAnSW1wbGljaXRHbG9iYWxWYXJpYWJsZSc7XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.Definition = exports.ParameterDefinition = undefined;
	
	var _variable = __webpack_require__(74);
	
	var _variable2 = _interopRequireDefault(_variable);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } } /*
	                                                                                                                                                            Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                          
	                                                                                                                                                            Redistribution and use in source and binary forms, with or without
	                                                                                                                                                            modification, are permitted provided that the following conditions are met:
	                                                                                                                                                          
	                                                                                                                                                              * Redistributions of source code must retain the above copyright
	                                                                                                                                                                notice, this list of conditions and the following disclaimer.
	                                                                                                                                                              * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                documentation and/or other materials provided with the distribution.
	                                                                                                                                                          
	                                                                                                                                                            THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                            AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                            IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                            ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                            DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                            (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                            LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                            ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                            (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                            THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                          */
	
	/**
	 * @class Definition
	 */
	
	var Definition = function Definition(type, name, node, parent, index, kind) {
	  _classCallCheck(this, Definition);
	
	  /**
	   * @member {String} Definition#type - type of the occurrence (e.g. "Parameter", "Variable", ...).
	   */
	  this.type = type;
	  /**
	   * @member {esprima.Identifier} Definition#name - the identifier AST node of the occurrence.
	   */
	  this.name = name;
	  /**
	   * @member {esprima.Node} Definition#node - the enclosing node of the identifier.
	   */
	  this.node = node;
	  /**
	   * @member {esprima.Node?} Definition#parent - the enclosing statement node of the identifier.
	   */
	  this.parent = parent;
	  /**
	   * @member {Number?} Definition#index - the index in the declaration statement.
	   */
	  this.index = index;
	  /**
	   * @member {String?} Definition#kind - the kind of the declaration statement.
	   */
	  this.kind = kind;
	};
	
	/**
	 * @class ParameterDefinition
	 */
	
	
	exports.default = Definition;
	
	var ParameterDefinition = function (_Definition) {
	  _inherits(ParameterDefinition, _Definition);
	
	  function ParameterDefinition(name, node, index, rest) {
	    _classCallCheck(this, ParameterDefinition);
	
	    /**
	     * Whether the parameter definition is a part of a rest parameter.
	     * @member {boolean} ParameterDefinition#rest
	     */
	
	    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ParameterDefinition).call(this, _variable2.default.Parameter, name, node, null, index, null));
	
	    _this.rest = rest;
	    return _this;
	  }
	
	  return ParameterDefinition;
	}(Definition);
	
	exports.ParameterDefinition = ParameterDefinition;
	exports.Definition = Definition;
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImRlZmluaXRpb24uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQXdCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFLcUIsYUFDakIsU0FEaUIsVUFDakIsQ0FBWSxJQUFaLEVBQWtCLElBQWxCLEVBQXdCLElBQXhCLEVBQThCLE1BQTlCLEVBQXNDLEtBQXRDLEVBQTZDLElBQTdDLEVBQW1EO3dCQURsQyxZQUNrQzs7Ozs7QUFJL0MsT0FBSyxJQUFMLEdBQVksSUFBWjs7OztBQUorQyxNQVEvQyxDQUFLLElBQUwsR0FBWSxJQUFaOzs7O0FBUitDLE1BWS9DLENBQUssSUFBTCxHQUFZLElBQVo7Ozs7QUFaK0MsTUFnQi9DLENBQUssTUFBTCxHQUFjLE1BQWQ7Ozs7QUFoQitDLE1Bb0IvQyxDQUFLLEtBQUwsR0FBYSxLQUFiOzs7O0FBcEIrQyxNQXdCL0MsQ0FBSyxJQUFMLEdBQVksSUFBWixDQXhCK0M7Q0FBbkQ7Ozs7Ozs7a0JBRGlCOztJQWdDZjs7O0FBQ0YsV0FERSxtQkFDRixDQUFZLElBQVosRUFBa0IsSUFBbEIsRUFBd0IsS0FBeEIsRUFBK0IsSUFBL0IsRUFBcUM7MEJBRG5DLHFCQUNtQzs7Ozs7Ozt1RUFEbkMsZ0NBRVEsbUJBQVMsU0FBVCxFQUFvQixNQUFNLE1BQU0sTUFBTSxPQUFPLE9BRGxCOztBQU1qQyxVQUFLLElBQUwsR0FBWSxJQUFaLENBTmlDOztHQUFyQzs7U0FERTtFQUE0Qjs7UUFZOUI7UUFDQSIsImZpbGUiOiJkZWZpbml0aW9uLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE1IFl1c3VrZSBTdXp1a2kgPHV0YXRhbmUudGVhQGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xuXG5pbXBvcnQgVmFyaWFibGUgZnJvbSAnLi92YXJpYWJsZSc7XG5cbi8qKlxuICogQGNsYXNzIERlZmluaXRpb25cbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmaW5pdGlvbiB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgbmFtZSwgbm9kZSwgcGFyZW50LCBpbmRleCwga2luZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nfSBEZWZpbml0aW9uI3R5cGUgLSB0eXBlIG9mIHRoZSBvY2N1cnJlbmNlIChlLmcuIFwiUGFyYW1ldGVyXCIsIFwiVmFyaWFibGVcIiwgLi4uKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAbWVtYmVyIHtlc3ByaW1hLklkZW50aWZpZXJ9IERlZmluaXRpb24jbmFtZSAtIHRoZSBpZGVudGlmaWVyIEFTVCBub2RlIG9mIHRoZSBvY2N1cnJlbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2VzcHJpbWEuTm9kZX0gRGVmaW5pdGlvbiNub2RlIC0gdGhlIGVuY2xvc2luZyBub2RlIG9mIHRoZSBpZGVudGlmaWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBtZW1iZXIge2VzcHJpbWEuTm9kZT99IERlZmluaXRpb24jcGFyZW50IC0gdGhlIGVuY2xvc2luZyBzdGF0ZW1lbnQgbm9kZSBvZiB0aGUgaWRlbnRpZmllci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7TnVtYmVyP30gRGVmaW5pdGlvbiNpbmRleCAtIHRoZSBpbmRleCBpbiB0aGUgZGVjbGFyYXRpb24gc3RhdGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICAvKipcbiAgICAgICAgICogQG1lbWJlciB7U3RyaW5nP30gRGVmaW5pdGlvbiNraW5kIC0gdGhlIGtpbmQgb2YgdGhlIGRlY2xhcmF0aW9uIHN0YXRlbWVudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBjbGFzcyBQYXJhbWV0ZXJEZWZpbml0aW9uXG4gKi9cbmNsYXNzIFBhcmFtZXRlckRlZmluaXRpb24gZXh0ZW5kcyBEZWZpbml0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBub2RlLCBpbmRleCwgcmVzdCkge1xuICAgICAgICBzdXBlcihWYXJpYWJsZS5QYXJhbWV0ZXIsIG5hbWUsIG5vZGUsIG51bGwsIGluZGV4LCBudWxsKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZXRoZXIgdGhlIHBhcmFtZXRlciBkZWZpbml0aW9uIGlzIGEgcGFydCBvZiBhIHJlc3QgcGFyYW1ldGVyLlxuICAgICAgICAgKiBAbWVtYmVyIHtib29sZWFufSBQYXJhbWV0ZXJEZWZpbml0aW9uI3Jlc3RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgfVxufVxuXG5leHBvcnQge1xuICAgIFBhcmFtZXRlckRlZmluaXRpb24sXG4gICAgRGVmaW5pdGlvblxufVxuXG4vKiB2aW06IHNldCBzdz00IHRzPTQgZXQgdHc9ODAgOiAqL1xuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _estraverse = __webpack_require__(57);
	
	var _esrecurse = __webpack_require__(77);
	
	var _esrecurse2 = _interopRequireDefault(_esrecurse);
	
	var _reference = __webpack_require__(73);
	
	var _reference2 = _interopRequireDefault(_reference);
	
	var _variable = __webpack_require__(74);
	
	var _variable2 = _interopRequireDefault(_variable);
	
	var _patternVisitor = __webpack_require__(82);
	
	var _patternVisitor2 = _interopRequireDefault(_patternVisitor);
	
	var _definition = __webpack_require__(75);
	
	var _assert = __webpack_require__(3);
	
	var _assert2 = _interopRequireDefault(_assert);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */
	
	
	function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
	    // Call the callback at left hand identifier nodes, and Collect right hand nodes.
	    var visitor = new _patternVisitor2.default(options, rootPattern, callback);
	    visitor.visit(rootPattern);
	
	    // Process the right hand nodes recursively.
	    if (referencer != null) {
	        visitor.rightHandNodes.forEach(referencer.visit, referencer);
	    }
	}
	
	// Importing ImportDeclaration.
	// http://people.mozilla.org/~jorendorff/es6-draft.html#sec-moduledeclarationinstantiation
	// https://github.com/estree/estree/blob/master/es6.md#importdeclaration
	// FIXME: Now, we don't create module environment, because the context is
	// implementation dependent.
	
	var Importer = function (_esrecurse$Visitor) {
	    _inherits(Importer, _esrecurse$Visitor);
	
	    function Importer(declaration, referencer) {
	        _classCallCheck(this, Importer);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Importer).call(this, null, referencer.options));
	
	        _this.declaration = declaration;
	        _this.referencer = referencer;
	        return _this;
	    }
	
	    _createClass(Importer, [{
	        key: 'visitImport',
	        value: function visitImport(id, specifier) {
	            var _this2 = this;
	
	            this.referencer.visitPattern(id, function (pattern) {
	                _this2.referencer.currentScope().__define(pattern, new _definition.Definition(_variable2.default.ImportBinding, pattern, specifier, _this2.declaration, null, null));
	            });
	        }
	    }, {
	        key: 'ImportNamespaceSpecifier',
	        value: function ImportNamespaceSpecifier(node) {
	            var local = node.local || node.id;
	            if (local) {
	                this.visitImport(local, node);
	            }
	        }
	    }, {
	        key: 'ImportDefaultSpecifier',
	        value: function ImportDefaultSpecifier(node) {
	            var local = node.local || node.id;
	            this.visitImport(local, node);
	        }
	    }, {
	        key: 'ImportSpecifier',
	        value: function ImportSpecifier(node) {
	            var local = node.local || node.id;
	            if (node.name) {
	                this.visitImport(node.name, node);
	            } else {
	                this.visitImport(local, node);
	            }
	        }
	    }]);
	
	    return Importer;
	}(_esrecurse2.default.Visitor);
	
	// Referencing variables and creating bindings.
	
	
	var Referencer = function (_esrecurse$Visitor2) {
	    _inherits(Referencer, _esrecurse$Visitor2);
	
	    function Referencer(options, scopeManager) {
	        _classCallCheck(this, Referencer);
	
	        var _this3 = _possibleConstructorReturn(this, Object.getPrototypeOf(Referencer).call(this, null, options));
	
	        _this3.options = options;
	        _this3.scopeManager = scopeManager;
	        _this3.parent = null;
	        _this3.isInnerMethodDefinition = false;
	        return _this3;
	    }
	
	    _createClass(Referencer, [{
	        key: 'currentScope',
	        value: function currentScope() {
	            return this.scopeManager.__currentScope;
	        }
	    }, {
	        key: 'close',
	        value: function close(node) {
	            while (this.currentScope() && node === this.currentScope().block) {
	                this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
	            }
	        }
	    }, {
	        key: 'pushInnerMethodDefinition',
	        value: function pushInnerMethodDefinition(isInnerMethodDefinition) {
	            var previous = this.isInnerMethodDefinition;
	            this.isInnerMethodDefinition = isInnerMethodDefinition;
	            return previous;
	        }
	    }, {
	        key: 'popInnerMethodDefinition',
	        value: function popInnerMethodDefinition(isInnerMethodDefinition) {
	            this.isInnerMethodDefinition = isInnerMethodDefinition;
	        }
	    }, {
	        key: 'materializeTDZScope',
	        value: function materializeTDZScope(node, iterationNode) {
	            // http://people.mozilla.org/~jorendorff/es6-draft.html#sec-runtime-semantics-forin-div-ofexpressionevaluation-abstract-operation
	            // TDZ scope hides the declaration's names.
	            this.scopeManager.__nestTDZScope(node, iterationNode);
	            this.visitVariableDeclaration(this.currentScope(), _variable2.default.TDZ, iterationNode.left, 0, true);
	        }
	    }, {
	        key: 'materializeIterationScope',
	        value: function materializeIterationScope(node) {
	            var _this4 = this;
	
	            // Generate iteration scope for upper ForIn/ForOf Statements.
	            var letOrConstDecl;
	            this.scopeManager.__nestForScope(node);
	            letOrConstDecl = node.left;
	            this.visitVariableDeclaration(this.currentScope(), _variable2.default.Variable, letOrConstDecl, 0);
	            this.visitPattern(letOrConstDecl.declarations[0].id, function (pattern) {
	                _this4.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
	            });
	        }
	    }, {
	        key: 'referencingDefaultValue',
	        value: function referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
	            var scope = this.currentScope();
	            assignments.forEach(function (assignment) {
	                scope.__referencing(pattern, _reference2.default.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
	            });
	        }
	    }, {
	        key: 'visitPattern',
	        value: function visitPattern(node, options, callback) {
	            if (typeof options === 'function') {
	                callback = options;
	                options = { processRightHandNodes: false };
	            }
	            traverseIdentifierInPattern(this.options, node, options.processRightHandNodes ? this : null, callback);
	        }
	    }, {
	        key: 'visitFunction',
	        value: function visitFunction(node) {
	            var _this5 = this;
	
	            var i, iz;
	            // FunctionDeclaration name is defined in upper scope
	            // NOTE: Not referring variableScope. It is intended.
	            // Since
	            //  in ES5, FunctionDeclaration should be in FunctionBody.
	            //  in ES6, FunctionDeclaration should be block scoped.
	            if (node.type === _estraverse.Syntax.FunctionDeclaration) {
	                // id is defined in upper scope
	                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.FunctionName, node.id, node, null, null, null));
	            }
	
	            // FunctionExpression with name creates its special scope;
	            // FunctionExpressionNameScope.
	            if (node.type === _estraverse.Syntax.FunctionExpression && node.id) {
	                this.scopeManager.__nestFunctionExpressionNameScope(node);
	            }
	
	            // Consider this function is in the MethodDefinition.
	            this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
	
	            // Process parameter declarations.
	            for (i = 0, iz = node.params.length; i < iz; ++i) {
	                this.visitPattern(node.params[i], { processRightHandNodes: true }, function (pattern, info) {
	                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, i, info.rest));
	
	                    _this5.referencingDefaultValue(pattern, info.assignments, null, true);
	                });
	            }
	
	            // if there's a rest argument, add that
	            if (node.rest) {
	                this.visitPattern({
	                    type: 'RestElement',
	                    argument: node.rest
	                }, function (pattern) {
	                    _this5.currentScope().__define(pattern, new _definition.ParameterDefinition(pattern, node, node.params.length, true));
	                });
	            }
	
	            // Skip BlockStatement to prevent creating BlockStatement scope.
	            if (node.body.type === _estraverse.Syntax.BlockStatement) {
	                this.visitChildren(node.body);
	            } else {
	                this.visit(node.body);
	            }
	
	            this.close(node);
	        }
	    }, {
	        key: 'visitClass',
	        value: function visitClass(node) {
	            if (node.type === _estraverse.Syntax.ClassDeclaration) {
	                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node, null, null, null));
	            }
	
	            // FIXME: Maybe consider TDZ.
	            this.visit(node.superClass);
	
	            this.scopeManager.__nestClassScope(node);
	
	            if (node.id) {
	                this.currentScope().__define(node.id, new _definition.Definition(_variable2.default.ClassName, node.id, node));
	            }
	            this.visit(node.body);
	
	            this.close(node);
	        }
	    }, {
	        key: 'visitProperty',
	        value: function visitProperty(node) {
	            var previous, isMethodDefinition;
	            if (node.computed) {
	                this.visit(node.key);
	            }
	
	            isMethodDefinition = node.type === _estraverse.Syntax.MethodDefinition;
	            if (isMethodDefinition) {
	                previous = this.pushInnerMethodDefinition(true);
	            }
	            this.visit(node.value);
	            if (isMethodDefinition) {
	                this.popInnerMethodDefinition(previous);
	            }
	        }
	    }, {
	        key: 'visitForIn',
	        value: function visitForIn(node) {
	            var _this6 = this;
	
	            if (node.left.type === _estraverse.Syntax.VariableDeclaration && node.left.kind !== 'var') {
	                this.materializeTDZScope(node.right, node);
	                this.visit(node.right);
	                this.close(node.right);
	
	                this.materializeIterationScope(node);
	                this.visit(node.body);
	                this.close(node);
	            } else {
	                if (node.left.type === _estraverse.Syntax.VariableDeclaration) {
	                    this.visit(node.left);
	                    this.visitPattern(node.left.declarations[0].id, function (pattern) {
	                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, null, true, true);
	                    });
	                } else {
	                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
	                        var maybeImplicitGlobal = null;
	                        if (!_this6.currentScope().isStrict) {
	                            maybeImplicitGlobal = {
	                                pattern: pattern,
	                                node: node
	                            };
	                        }
	                        _this6.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
	                        _this6.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, true, false);
	                    });
	                }
	                this.visit(node.right);
	                this.visit(node.body);
	            }
	        }
	    }, {
	        key: 'visitVariableDeclaration',
	        value: function visitVariableDeclaration(variableTargetScope, type, node, index, fromTDZ) {
	            var _this7 = this;
	
	            // If this was called to initialize a TDZ scope, this needs to make definitions, but doesn't make references.
	            var decl, init;
	
	            decl = node.declarations[index];
	            init = decl.init;
	            this.visitPattern(decl.id, { processRightHandNodes: !fromTDZ }, function (pattern, info) {
	                variableTargetScope.__define(pattern, new _definition.Definition(type, pattern, decl, node, index, node.kind));
	
	                if (!fromTDZ) {
	                    _this7.referencingDefaultValue(pattern, info.assignments, null, true);
	                }
	                if (init) {
	                    _this7.currentScope().__referencing(pattern, _reference2.default.WRITE, init, null, !info.topLevel, true);
	                }
	            });
	        }
	    }, {
	        key: 'AssignmentExpression',
	        value: function AssignmentExpression(node) {
	            var _this8 = this;
	
	            if (_patternVisitor2.default.isPattern(node.left)) {
	                if (node.operator === '=') {
	                    this.visitPattern(node.left, { processRightHandNodes: true }, function (pattern, info) {
	                        var maybeImplicitGlobal = null;
	                        if (!_this8.currentScope().isStrict) {
	                            maybeImplicitGlobal = {
	                                pattern: pattern,
	                                node: node
	                            };
	                        }
	                        _this8.referencingDefaultValue(pattern, info.assignments, maybeImplicitGlobal, false);
	                        _this8.currentScope().__referencing(pattern, _reference2.default.WRITE, node.right, maybeImplicitGlobal, !info.topLevel, false);
	                    });
	                } else {
	                    this.currentScope().__referencing(node.left, _reference2.default.RW, node.right);
	                }
	            } else {
	                this.visit(node.left);
	            }
	            this.visit(node.right);
	        }
	    }, {
	        key: 'CatchClause',
	        value: function CatchClause(node) {
	            var _this9 = this;
	
	            this.scopeManager.__nestCatchScope(node);
	
	            this.visitPattern(node.param, { processRightHandNodes: true }, function (pattern, info) {
	                _this9.currentScope().__define(pattern, new _definition.Definition(_variable2.default.CatchClause, node.param, node, null, null, null));
	                _this9.referencingDefaultValue(pattern, info.assignments, null, true);
	            });
	            this.visit(node.body);
	
	            this.close(node);
	        }
	    }, {
	        key: 'Program',
	        value: function Program(node) {
	            this.scopeManager.__nestGlobalScope(node);
	
	            if (this.scopeManager.__isNodejsScope()) {
	                // Force strictness of GlobalScope to false when using node.js scope.
	                this.currentScope().isStrict = false;
	                this.scopeManager.__nestFunctionScope(node, false);
	            }
	
	            if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
	                this.scopeManager.__nestModuleScope(node);
	            }
	
	            if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
	                this.currentScope().isStrict = true;
	            }
	
	            this.visitChildren(node);
	            this.close(node);
	        }
	    }, {
	        key: 'Identifier',
	        value: function Identifier(node) {
	            this.currentScope().__referencing(node);
	        }
	    }, {
	        key: 'UpdateExpression',
	        value: function UpdateExpression(node) {
	            if (_patternVisitor2.default.isPattern(node.argument)) {
	                this.currentScope().__referencing(node.argument, _reference2.default.RW, null);
	            } else {
	                this.visitChildren(node);
	            }
	        }
	    }, {
	        key: 'MemberExpression',
	        value: function MemberExpression(node) {
	            this.visit(node.object);
	            if (node.computed) {
	                this.visit(node.property);
	            }
	        }
	    }, {
	        key: 'Property',
	        value: function Property(node) {
	            this.visitProperty(node);
	        }
	    }, {
	        key: 'MethodDefinition',
	        value: function MethodDefinition(node) {
	            this.visitProperty(node);
	        }
	    }, {
	        key: 'BreakStatement',
	        value: function BreakStatement() {}
	    }, {
	        key: 'ContinueStatement',
	        value: function ContinueStatement() {}
	    }, {
	        key: 'LabeledStatement',
	        value: function LabeledStatement(node) {
	            this.visit(node.body);
	        }
	    }, {
	        key: 'ForStatement',
	        value: function ForStatement(node) {
	            // Create ForStatement declaration.
	            // NOTE: In ES6, ForStatement dynamically generates
	            // per iteration environment. However, escope is
	            // a static analyzer, we only generate one scope for ForStatement.
	            if (node.init && node.init.type === _estraverse.Syntax.VariableDeclaration && node.init.kind !== 'var') {
	                this.scopeManager.__nestForScope(node);
	            }
	
	            this.visitChildren(node);
	
	            this.close(node);
	        }
	    }, {
	        key: 'ClassExpression',
	        value: function ClassExpression(node) {
	            this.visitClass(node);
	        }
	    }, {
	        key: 'ClassDeclaration',
	        value: function ClassDeclaration(node) {
	            this.visitClass(node);
	        }
	    }, {
	        key: 'CallExpression',
	        value: function CallExpression(node) {
	            // Check this is direct call to eval
	            if (!this.scopeManager.__ignoreEval() && node.callee.type === _estraverse.Syntax.Identifier && node.callee.name === 'eval') {
	                // NOTE: This should be `variableScope`. Since direct eval call always creates Lexical environment and
	                // let / const should be enclosed into it. Only VariableDeclaration affects on the caller's environment.
	                this.currentScope().variableScope.__detectEval();
	            }
	            this.visitChildren(node);
	        }
	    }, {
	        key: 'BlockStatement',
	        value: function BlockStatement(node) {
	            if (this.scopeManager.__isES6()) {
	                this.scopeManager.__nestBlockScope(node);
	            }
	
	            this.visitChildren(node);
	
	            this.close(node);
	        }
	    }, {
	        key: 'ThisExpression',
	        value: function ThisExpression() {
	            this.currentScope().variableScope.__detectThis();
	        }
	    }, {
	        key: 'WithStatement',
	        value: function WithStatement(node) {
	            this.visit(node.object);
	            // Then nest scope for WithStatement.
	            this.scopeManager.__nestWithScope(node);
	
	            this.visit(node.body);
	
	            this.close(node);
	        }
	    }, {
	        key: 'VariableDeclaration',
	        value: function VariableDeclaration(node) {
	            var variableTargetScope, i, iz, decl;
	            variableTargetScope = node.kind === 'var' ? this.currentScope().variableScope : this.currentScope();
	            for (i = 0, iz = node.declarations.length; i < iz; ++i) {
	                decl = node.declarations[i];
	                this.visitVariableDeclaration(variableTargetScope, _variable2.default.Variable, node, i);
	                if (decl.init) {
	                    this.visit(decl.init);
	                }
	            }
	        }
	
	        // sec 13.11.8
	
	    }, {
	        key: 'SwitchStatement',
	        value: function SwitchStatement(node) {
	            var i, iz;
	
	            this.visit(node.discriminant);
	
	            if (this.scopeManager.__isES6()) {
	                this.scopeManager.__nestSwitchScope(node);
	            }
	
	            for (i = 0, iz = node.cases.length; i < iz; ++i) {
	                this.visit(node.cases[i]);
	            }
	
	            this.close(node);
	        }
	    }, {
	        key: 'FunctionDeclaration',
	        value: function FunctionDeclaration(node) {
	            this.visitFunction(node);
	        }
	    }, {
	        key: 'FunctionExpression',
	        value: function FunctionExpression(node) {
	            this.visitFunction(node);
	        }
	    }, {
	        key: 'ForOfStatement',
	        value: function ForOfStatement(node) {
	            this.visitForIn(node);
	        }
	    }, {
	        key: 'ForInStatement',
	        value: function ForInStatement(node) {
	            this.visitForIn(node);
	        }
	    }, {
	        key: 'ArrowFunctionExpression',
	        value: function ArrowFunctionExpression(node) {
	            this.visitFunction(node);
	        }
	    }, {
	        key: 'ImportDeclaration',
	        value: function ImportDeclaration(node) {
	            var importer;
	
	            (0, _assert2.default)(this.scopeManager.__isES6() && this.scopeManager.isModule(), 'ImportDeclaration should appear when the mode is ES6 and in the module context.');
	
	            importer = new Importer(node, this);
	            importer.visit(node);
	        }
	    }, {
	        key: 'visitExportDeclaration',
	        value: function visitExportDeclaration(node) {
	            if (node.source) {
	                return;
	            }
	            if (node.declaration) {
	                this.visit(node.declaration);
	                return;
	            }
	
	            this.visitChildren(node);
	        }
	    }, {
	        key: 'ExportDeclaration',
	        value: function ExportDeclaration(node) {
	            this.visitExportDeclaration(node);
	        }
	    }, {
	        key: 'ExportNamedDeclaration',
	        value: function ExportNamedDeclaration(node) {
	            this.visitExportDeclaration(node);
	        }
	    }, {
	        key: 'ExportSpecifier',
	        value: function ExportSpecifier(node) {
	            var local = node.id || node.local;
	            this.visit(local);
	        }
	    }, {
	        key: 'MetaProperty',
	        value: function MetaProperty() {
	            // do nothing.
	        }
	    }]);
	
	    return Referencer;
	}(_esrecurse2.default.Visitor);
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	
	
	exports.default = Referencer;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJlZmVyZW5jZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUF1QkE7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxTQUFTLDJCQUFULENBQXFDLE9BQXJDLEVBQThDLFdBQTlDLEVBQTJELFVBQTNELEVBQXVFLFFBQXZFLEVBQWlGOztBQUU3RSxRQUFJLFVBQVUsNkJBQW1CLE9BQW5CLEVBQTRCLFdBQTVCLEVBQXlDLFFBQXpDLENBQVYsQ0FGeUU7QUFHN0UsWUFBUSxLQUFSLENBQWMsV0FBZDs7O0FBSDZFLFFBTXpFLGNBQWMsSUFBZCxFQUFvQjtBQUNwQixnQkFBUSxjQUFSLENBQXVCLE9BQXZCLENBQStCLFdBQVcsS0FBWCxFQUFrQixVQUFqRCxFQURvQjtLQUF4QjtDQU5KOzs7Ozs7OztJQWlCTTs7O0FBQ0YsYUFERSxRQUNGLENBQVksV0FBWixFQUF5QixVQUF6QixFQUFxQzs4QkFEbkMsVUFDbUM7OzJFQURuQyxxQkFFUSxNQUFNLFdBQVcsT0FBWCxHQURxQjs7QUFFakMsY0FBSyxXQUFMLEdBQW1CLFdBQW5CLENBRmlDO0FBR2pDLGNBQUssVUFBTCxHQUFrQixVQUFsQixDQUhpQzs7S0FBckM7O2lCQURFOztvQ0FPVSxJQUFJLFdBQVc7OztBQUN2QixpQkFBSyxVQUFMLENBQWdCLFlBQWhCLENBQTZCLEVBQTdCLEVBQWlDLFVBQUMsT0FBRCxFQUFhO0FBQzFDLHVCQUFLLFVBQUwsQ0FBZ0IsWUFBaEIsR0FBK0IsUUFBL0IsQ0FBd0MsT0FBeEMsRUFDSSwyQkFDSSxtQkFBUyxhQUFULEVBQ0EsT0FGSixFQUdJLFNBSEosRUFJSSxPQUFLLFdBQUwsRUFDQSxJQUxKLEVBTUksSUFOSixDQURKLEVBRDBDO2FBQWIsQ0FBakMsQ0FEdUI7Ozs7aURBY0YsTUFBTTtBQUMzQixnQkFBSSxRQUFTLEtBQUssS0FBTCxJQUFjLEtBQUssRUFBTCxDQURBO0FBRTNCLGdCQUFJLEtBQUosRUFBVztBQUNQLHFCQUFLLFdBQUwsQ0FBaUIsS0FBakIsRUFBd0IsSUFBeEIsRUFETzthQUFYOzs7OytDQUttQixNQUFNO0FBQ3pCLGdCQUFJLFFBQVMsS0FBSyxLQUFMLElBQWMsS0FBSyxFQUFMLENBREY7QUFFekIsaUJBQUssV0FBTCxDQUFpQixLQUFqQixFQUF3QixJQUF4QixFQUZ5Qjs7Ozt3Q0FLYixNQUFNO0FBQ2xCLGdCQUFJLFFBQVMsS0FBSyxLQUFMLElBQWMsS0FBSyxFQUFMLENBRFQ7QUFFbEIsZ0JBQUksS0FBSyxJQUFMLEVBQVc7QUFDWCxxQkFBSyxXQUFMLENBQWlCLEtBQUssSUFBTCxFQUFXLElBQTVCLEVBRFc7YUFBZixNQUVPO0FBQ0gscUJBQUssV0FBTCxDQUFpQixLQUFqQixFQUF3QixJQUF4QixFQURHO2FBRlA7Ozs7V0FuQ0Y7RUFBaUIsb0JBQVUsT0FBVjs7Ozs7SUE0Q0Y7OztBQUNqQixhQURpQixVQUNqQixDQUFZLE9BQVosRUFBcUIsWUFBckIsRUFBbUM7OEJBRGxCLFlBQ2tCOzs0RUFEbEIsdUJBRVAsTUFBTSxVQURtQjs7QUFFL0IsZUFBSyxPQUFMLEdBQWUsT0FBZixDQUYrQjtBQUcvQixlQUFLLFlBQUwsR0FBb0IsWUFBcEIsQ0FIK0I7QUFJL0IsZUFBSyxNQUFMLEdBQWMsSUFBZCxDQUorQjtBQUsvQixlQUFLLHVCQUFMLEdBQStCLEtBQS9CLENBTCtCOztLQUFuQzs7aUJBRGlCOzt1Q0FTRjtBQUNYLG1CQUFPLEtBQUssWUFBTCxDQUFrQixjQUFsQixDQURJOzs7OzhCQUlULE1BQU07QUFDUixtQkFBTyxLQUFLLFlBQUwsTUFBdUIsU0FBUyxLQUFLLFlBQUwsR0FBb0IsS0FBcEIsRUFBMkI7QUFDOUQscUJBQUssWUFBTCxDQUFrQixjQUFsQixHQUFtQyxLQUFLLFlBQUwsR0FBb0IsT0FBcEIsQ0FBNEIsS0FBSyxZQUFMLENBQS9ELENBRDhEO2FBQWxFOzs7O2tEQUtzQix5QkFBeUI7QUFDL0MsZ0JBQUksV0FBVyxLQUFLLHVCQUFMLENBRGdDO0FBRS9DLGlCQUFLLHVCQUFMLEdBQStCLHVCQUEvQixDQUYrQztBQUcvQyxtQkFBTyxRQUFQLENBSCtDOzs7O2lEQU0xQix5QkFBeUI7QUFDOUMsaUJBQUssdUJBQUwsR0FBK0IsdUJBQS9CLENBRDhDOzs7OzRDQUk5QixNQUFNLGVBQWU7OztBQUdyQyxpQkFBSyxZQUFMLENBQWtCLGNBQWxCLENBQWlDLElBQWpDLEVBQXVDLGFBQXZDLEVBSHFDO0FBSXJDLGlCQUFLLHdCQUFMLENBQThCLEtBQUssWUFBTCxFQUE5QixFQUFtRCxtQkFBUyxHQUFULEVBQWMsY0FBYyxJQUFkLEVBQW9CLENBQXJGLEVBQXdGLElBQXhGLEVBSnFDOzs7O2tEQU9mLE1BQU07Ozs7QUFFNUIsZ0JBQUksY0FBSixDQUY0QjtBQUc1QixpQkFBSyxZQUFMLENBQWtCLGNBQWxCLENBQWlDLElBQWpDLEVBSDRCO0FBSTVCLDZCQUFpQixLQUFLLElBQUwsQ0FKVztBQUs1QixpQkFBSyx3QkFBTCxDQUE4QixLQUFLLFlBQUwsRUFBOUIsRUFBbUQsbUJBQVMsUUFBVCxFQUFtQixjQUF0RSxFQUFzRixDQUF0RixFQUw0QjtBQU01QixpQkFBSyxZQUFMLENBQWtCLGVBQWUsWUFBZixDQUE0QixDQUE1QixFQUErQixFQUEvQixFQUFtQyxVQUFDLE9BQUQsRUFBYTtBQUM5RCx1QkFBSyxZQUFMLEdBQW9CLGFBQXBCLENBQWtDLE9BQWxDLEVBQTJDLG9CQUFVLEtBQVYsRUFBaUIsS0FBSyxLQUFMLEVBQVksSUFBeEUsRUFBOEUsSUFBOUUsRUFBb0YsSUFBcEYsRUFEOEQ7YUFBYixDQUFyRCxDQU40Qjs7OztnREFXUixTQUFTLGFBQWEscUJBQXFCLE1BQU07QUFDckUsZ0JBQU0sUUFBUSxLQUFLLFlBQUwsRUFBUixDQUQrRDtBQUVyRSx3QkFBWSxPQUFaLENBQW9CLHNCQUFjO0FBQzlCLHNCQUFNLGFBQU4sQ0FDSSxPQURKLEVBRUksb0JBQVUsS0FBVixFQUNBLFdBQVcsS0FBWCxFQUNBLG1CQUpKLEVBS0ksWUFBWSxXQUFXLElBQVgsRUFDWixJQU5KLEVBRDhCO2FBQWQsQ0FBcEIsQ0FGcUU7Ozs7cUNBYTVELE1BQU0sU0FBUyxVQUFVO0FBQ2xDLGdCQUFJLE9BQU8sT0FBUCxLQUFtQixVQUFuQixFQUErQjtBQUMvQiwyQkFBVyxPQUFYLENBRCtCO0FBRS9CLDBCQUFVLEVBQUMsdUJBQXVCLEtBQXZCLEVBQVgsQ0FGK0I7YUFBbkM7QUFJQSx3Q0FDSSxLQUFLLE9BQUwsRUFDQSxJQUZKLEVBR0ksUUFBUSxxQkFBUixHQUFnQyxJQUFoQyxHQUF1QyxJQUF2QyxFQUNBLFFBSkosRUFMa0M7Ozs7c0NBWXhCLE1BQU07OztBQUNoQixnQkFBSSxDQUFKLEVBQU8sRUFBUDs7Ozs7O0FBRGdCLGdCQU9aLEtBQUssSUFBTCxLQUFjLG1CQUFPLG1CQUFQLEVBQTRCOztBQUUxQyxxQkFBSyxZQUFMLEdBQW9CLFFBQXBCLENBQTZCLEtBQUssRUFBTCxFQUNyQiwyQkFDSSxtQkFBUyxZQUFULEVBQ0EsS0FBSyxFQUFMLEVBQ0EsSUFISixFQUlJLElBSkosRUFLSSxJQUxKLEVBTUksSUFOSixDQURSLEVBRjBDO2FBQTlDOzs7O0FBUGdCLGdCQXNCWixLQUFLLElBQUwsS0FBYyxtQkFBTyxrQkFBUCxJQUE2QixLQUFLLEVBQUwsRUFBUztBQUNwRCxxQkFBSyxZQUFMLENBQWtCLGlDQUFsQixDQUFvRCxJQUFwRCxFQURvRDthQUF4RDs7O0FBdEJnQixnQkEyQmhCLENBQUssWUFBTCxDQUFrQixtQkFBbEIsQ0FBc0MsSUFBdEMsRUFBNEMsS0FBSyx1QkFBTCxDQUE1Qzs7O0FBM0JnQixpQkE4QlgsSUFBSSxDQUFKLEVBQU8sS0FBSyxLQUFLLE1BQUwsQ0FBWSxNQUFaLEVBQW9CLElBQUksRUFBSixFQUFRLEVBQUUsQ0FBRixFQUFLO0FBQzlDLHFCQUFLLFlBQUwsQ0FBa0IsS0FBSyxNQUFMLENBQVksQ0FBWixDQUFsQixFQUFrQyxFQUFDLHVCQUF1QixJQUF2QixFQUFuQyxFQUFpRSxVQUFDLE9BQUQsRUFBVSxJQUFWLEVBQW1CO0FBQ2hGLDJCQUFLLFlBQUwsR0FBb0IsUUFBcEIsQ0FBNkIsT0FBN0IsRUFDSSxvQ0FDSSxPQURKLEVBRUksSUFGSixFQUdJLENBSEosRUFJSSxLQUFLLElBQUwsQ0FMUixFQURnRjs7QUFTaEYsMkJBQUssdUJBQUwsQ0FBNkIsT0FBN0IsRUFBc0MsS0FBSyxXQUFMLEVBQWtCLElBQXhELEVBQThELElBQTlELEVBVGdGO2lCQUFuQixDQUFqRSxDQUQ4QzthQUFsRDs7O0FBOUJnQixnQkE2Q1osS0FBSyxJQUFMLEVBQVc7QUFDWCxxQkFBSyxZQUFMLENBQWtCO0FBQ2QsMEJBQU0sYUFBTjtBQUNBLDhCQUFVLEtBQUssSUFBTDtpQkFGZCxFQUdHLFVBQUMsT0FBRCxFQUFhO0FBQ1osMkJBQUssWUFBTCxHQUFvQixRQUFwQixDQUE2QixPQUE3QixFQUNJLG9DQUNJLE9BREosRUFFSSxJQUZKLEVBR0ksS0FBSyxNQUFMLENBQVksTUFBWixFQUNBLElBSkosQ0FESixFQURZO2lCQUFiLENBSEgsQ0FEVzthQUFmOzs7QUE3Q2dCLGdCQTZEWixLQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLG1CQUFPLGNBQVAsRUFBdUI7QUFDMUMscUJBQUssYUFBTCxDQUFtQixLQUFLLElBQUwsQ0FBbkIsQ0FEMEM7YUFBOUMsTUFFTztBQUNILHFCQUFLLEtBQUwsQ0FBVyxLQUFLLElBQUwsQ0FBWCxDQURHO2FBRlA7O0FBTUEsaUJBQUssS0FBTCxDQUFXLElBQVgsRUFuRWdCOzs7O21DQXNFVCxNQUFNO0FBQ2IsZ0JBQUksS0FBSyxJQUFMLEtBQWMsbUJBQU8sZ0JBQVAsRUFBeUI7QUFDdkMscUJBQUssWUFBTCxHQUFvQixRQUFwQixDQUE2QixLQUFLLEVBQUwsRUFDckIsMkJBQ0ksbUJBQVMsU0FBVCxFQUNBLEtBQUssRUFBTCxFQUNBLElBSEosRUFJSSxJQUpKLEVBS0ksSUFMSixFQU1JLElBTkosQ0FEUixFQUR1QzthQUEzQzs7O0FBRGEsZ0JBY2IsQ0FBSyxLQUFMLENBQVcsS0FBSyxVQUFMLENBQVgsQ0FkYTs7QUFnQmIsaUJBQUssWUFBTCxDQUFrQixnQkFBbEIsQ0FBbUMsSUFBbkMsRUFoQmE7O0FBa0JiLGdCQUFJLEtBQUssRUFBTCxFQUFTO0FBQ1QscUJBQUssWUFBTCxHQUFvQixRQUFwQixDQUE2QixLQUFLLEVBQUwsRUFDckIsMkJBQ0ksbUJBQVMsU0FBVCxFQUNBLEtBQUssRUFBTCxFQUNBLElBSEosQ0FEUixFQURTO2FBQWI7QUFRQSxpQkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0ExQmE7O0FBNEJiLGlCQUFLLEtBQUwsQ0FBVyxJQUFYLEVBNUJhOzs7O3NDQStCSCxNQUFNO0FBQ2hCLGdCQUFJLFFBQUosRUFBYyxrQkFBZCxDQURnQjtBQUVoQixnQkFBSSxLQUFLLFFBQUwsRUFBZTtBQUNmLHFCQUFLLEtBQUwsQ0FBVyxLQUFLLEdBQUwsQ0FBWCxDQURlO2FBQW5COztBQUlBLGlDQUFxQixLQUFLLElBQUwsS0FBYyxtQkFBTyxnQkFBUCxDQU5uQjtBQU9oQixnQkFBSSxrQkFBSixFQUF3QjtBQUNwQiwyQkFBVyxLQUFLLHlCQUFMLENBQStCLElBQS9CLENBQVgsQ0FEb0I7YUFBeEI7QUFHQSxpQkFBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVgsQ0FWZ0I7QUFXaEIsZ0JBQUksa0JBQUosRUFBd0I7QUFDcEIscUJBQUssd0JBQUwsQ0FBOEIsUUFBOUIsRUFEb0I7YUFBeEI7Ozs7bUNBS08sTUFBTTs7O0FBQ2IsZ0JBQUksS0FBSyxJQUFMLENBQVUsSUFBVixLQUFtQixtQkFBTyxtQkFBUCxJQUE4QixLQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLEtBQW5CLEVBQTBCO0FBQzNFLHFCQUFLLG1CQUFMLENBQXlCLEtBQUssS0FBTCxFQUFZLElBQXJDLEVBRDJFO0FBRTNFLHFCQUFLLEtBQUwsQ0FBVyxLQUFLLEtBQUwsQ0FBWCxDQUYyRTtBQUczRSxxQkFBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVgsQ0FIMkU7O0FBSzNFLHFCQUFLLHlCQUFMLENBQStCLElBQS9CLEVBTDJFO0FBTTNFLHFCQUFLLEtBQUwsQ0FBVyxLQUFLLElBQUwsQ0FBWCxDQU4yRTtBQU8zRSxxQkFBSyxLQUFMLENBQVcsSUFBWCxFQVAyRTthQUEvRSxNQVFPO0FBQ0gsb0JBQUksS0FBSyxJQUFMLENBQVUsSUFBVixLQUFtQixtQkFBTyxtQkFBUCxFQUE0QjtBQUMvQyx5QkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0FEK0M7QUFFL0MseUJBQUssWUFBTCxDQUFrQixLQUFLLElBQUwsQ0FBVSxZQUFWLENBQXVCLENBQXZCLEVBQTBCLEVBQTFCLEVBQThCLFVBQUMsT0FBRCxFQUFhO0FBQ3pELCtCQUFLLFlBQUwsR0FBb0IsYUFBcEIsQ0FBa0MsT0FBbEMsRUFBMkMsb0JBQVUsS0FBVixFQUFpQixLQUFLLEtBQUwsRUFBWSxJQUF4RSxFQUE4RSxJQUE5RSxFQUFvRixJQUFwRixFQUR5RDtxQkFBYixDQUFoRCxDQUYrQztpQkFBbkQsTUFLTztBQUNILHlCQUFLLFlBQUwsQ0FBa0IsS0FBSyxJQUFMLEVBQVcsRUFBQyx1QkFBdUIsSUFBdkIsRUFBOUIsRUFBNEQsVUFBQyxPQUFELEVBQVUsSUFBVixFQUFtQjtBQUMzRSw0QkFBSSxzQkFBc0IsSUFBdEIsQ0FEdUU7QUFFM0UsNEJBQUksQ0FBQyxPQUFLLFlBQUwsR0FBb0IsUUFBcEIsRUFBOEI7QUFDL0Isa0RBQXNCO0FBQ2xCLHlDQUFTLE9BQVQ7QUFDQSxzQ0FBTSxJQUFOOzZCQUZKLENBRCtCO3lCQUFuQztBQU1BLCtCQUFLLHVCQUFMLENBQTZCLE9BQTdCLEVBQXNDLEtBQUssV0FBTCxFQUFrQixtQkFBeEQsRUFBNkUsS0FBN0UsRUFSMkU7QUFTM0UsK0JBQUssWUFBTCxHQUFvQixhQUFwQixDQUFrQyxPQUFsQyxFQUEyQyxvQkFBVSxLQUFWLEVBQWlCLEtBQUssS0FBTCxFQUFZLG1CQUF4RSxFQUE2RixJQUE3RixFQUFtRyxLQUFuRyxFQVQyRTtxQkFBbkIsQ0FBNUQsQ0FERztpQkFMUDtBQWtCQSxxQkFBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVgsQ0FuQkc7QUFvQkgscUJBQUssS0FBTCxDQUFXLEtBQUssSUFBTCxDQUFYLENBcEJHO2FBUlA7Ozs7aURBZ0NxQixxQkFBcUIsTUFBTSxNQUFNLE9BQU8sU0FBUzs7OztBQUV0RSxnQkFBSSxJQUFKLEVBQVUsSUFBVixDQUZzRTs7QUFJdEUsbUJBQU8sS0FBSyxZQUFMLENBQWtCLEtBQWxCLENBQVAsQ0FKc0U7QUFLdEUsbUJBQU8sS0FBSyxJQUFMLENBTCtEO0FBTXRFLGlCQUFLLFlBQUwsQ0FBa0IsS0FBSyxFQUFMLEVBQVMsRUFBQyx1QkFBdUIsQ0FBQyxPQUFELEVBQW5ELEVBQThELFVBQUMsT0FBRCxFQUFVLElBQVYsRUFBbUI7QUFDN0Usb0NBQW9CLFFBQXBCLENBQTZCLE9BQTdCLEVBQ0ksMkJBQ0ksSUFESixFQUVJLE9BRkosRUFHSSxJQUhKLEVBSUksSUFKSixFQUtJLEtBTEosRUFNSSxLQUFLLElBQUwsQ0FQUixFQUQ2RTs7QUFXN0Usb0JBQUksQ0FBQyxPQUFELEVBQVU7QUFDViwyQkFBSyx1QkFBTCxDQUE2QixPQUE3QixFQUFzQyxLQUFLLFdBQUwsRUFBa0IsSUFBeEQsRUFBOEQsSUFBOUQsRUFEVTtpQkFBZDtBQUdBLG9CQUFJLElBQUosRUFBVTtBQUNOLDJCQUFLLFlBQUwsR0FBb0IsYUFBcEIsQ0FBa0MsT0FBbEMsRUFBMkMsb0JBQVUsS0FBVixFQUFpQixJQUE1RCxFQUFrRSxJQUFsRSxFQUF3RSxDQUFDLEtBQUssUUFBTCxFQUFlLElBQXhGLEVBRE07aUJBQVY7YUFkMEQsQ0FBOUQsQ0FOc0U7Ozs7NkNBMEJyRCxNQUFNOzs7QUFDdkIsZ0JBQUkseUJBQWUsU0FBZixDQUF5QixLQUFLLElBQUwsQ0FBN0IsRUFBeUM7QUFDckMsb0JBQUksS0FBSyxRQUFMLEtBQWtCLEdBQWxCLEVBQXVCO0FBQ3ZCLHlCQUFLLFlBQUwsQ0FBa0IsS0FBSyxJQUFMLEVBQVcsRUFBQyx1QkFBdUIsSUFBdkIsRUFBOUIsRUFBNEQsVUFBQyxPQUFELEVBQVUsSUFBVixFQUFtQjtBQUMzRSw0QkFBSSxzQkFBc0IsSUFBdEIsQ0FEdUU7QUFFM0UsNEJBQUksQ0FBQyxPQUFLLFlBQUwsR0FBb0IsUUFBcEIsRUFBOEI7QUFDL0Isa0RBQXNCO0FBQ2xCLHlDQUFTLE9BQVQ7QUFDQSxzQ0FBTSxJQUFOOzZCQUZKLENBRCtCO3lCQUFuQztBQU1BLCtCQUFLLHVCQUFMLENBQTZCLE9BQTdCLEVBQXNDLEtBQUssV0FBTCxFQUFrQixtQkFBeEQsRUFBNkUsS0FBN0UsRUFSMkU7QUFTM0UsK0JBQUssWUFBTCxHQUFvQixhQUFwQixDQUFrQyxPQUFsQyxFQUEyQyxvQkFBVSxLQUFWLEVBQWlCLEtBQUssS0FBTCxFQUFZLG1CQUF4RSxFQUE2RixDQUFDLEtBQUssUUFBTCxFQUFlLEtBQTdHLEVBVDJFO3FCQUFuQixDQUE1RCxDQUR1QjtpQkFBM0IsTUFZTztBQUNILHlCQUFLLFlBQUwsR0FBb0IsYUFBcEIsQ0FBa0MsS0FBSyxJQUFMLEVBQVcsb0JBQVUsRUFBVixFQUFjLEtBQUssS0FBTCxDQUEzRCxDQURHO2lCQVpQO2FBREosTUFnQk87QUFDSCxxQkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0FERzthQWhCUDtBQW1CQSxpQkFBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVgsQ0FwQnVCOzs7O29DQXVCZixNQUFNOzs7QUFDZCxpQkFBSyxZQUFMLENBQWtCLGdCQUFsQixDQUFtQyxJQUFuQyxFQURjOztBQUdkLGlCQUFLLFlBQUwsQ0FBa0IsS0FBSyxLQUFMLEVBQVksRUFBQyx1QkFBdUIsSUFBdkIsRUFBL0IsRUFBNkQsVUFBQyxPQUFELEVBQVUsSUFBVixFQUFtQjtBQUM1RSx1QkFBSyxZQUFMLEdBQW9CLFFBQXBCLENBQTZCLE9BQTdCLEVBQ0ksMkJBQ0ksbUJBQVMsV0FBVCxFQUNBLEtBQUssS0FBTCxFQUNBLElBSEosRUFJSSxJQUpKLEVBS0ksSUFMSixFQU1JLElBTkosQ0FESixFQUQ0RTtBQVU1RSx1QkFBSyx1QkFBTCxDQUE2QixPQUE3QixFQUFzQyxLQUFLLFdBQUwsRUFBa0IsSUFBeEQsRUFBOEQsSUFBOUQsRUFWNEU7YUFBbkIsQ0FBN0QsQ0FIYztBQWVkLGlCQUFLLEtBQUwsQ0FBVyxLQUFLLElBQUwsQ0FBWCxDQWZjOztBQWlCZCxpQkFBSyxLQUFMLENBQVcsSUFBWCxFQWpCYzs7OztnQ0FvQlYsTUFBTTtBQUNWLGlCQUFLLFlBQUwsQ0FBa0IsaUJBQWxCLENBQW9DLElBQXBDLEVBRFU7O0FBR1YsZ0JBQUksS0FBSyxZQUFMLENBQWtCLGVBQWxCLEVBQUosRUFBeUM7O0FBRXJDLHFCQUFLLFlBQUwsR0FBb0IsUUFBcEIsR0FBK0IsS0FBL0IsQ0FGcUM7QUFHckMscUJBQUssWUFBTCxDQUFrQixtQkFBbEIsQ0FBc0MsSUFBdEMsRUFBNEMsS0FBNUMsRUFIcUM7YUFBekM7O0FBTUEsZ0JBQUksS0FBSyxZQUFMLENBQWtCLE9BQWxCLE1BQStCLEtBQUssWUFBTCxDQUFrQixRQUFsQixFQUEvQixFQUE2RDtBQUM3RCxxQkFBSyxZQUFMLENBQWtCLGlCQUFsQixDQUFvQyxJQUFwQyxFQUQ2RDthQUFqRTs7QUFJQSxnQkFBSSxLQUFLLFlBQUwsQ0FBa0IscUJBQWxCLE1BQTZDLEtBQUssWUFBTCxDQUFrQixlQUFsQixFQUE3QyxFQUFrRjtBQUNsRixxQkFBSyxZQUFMLEdBQW9CLFFBQXBCLEdBQStCLElBQS9CLENBRGtGO2FBQXRGOztBQUlBLGlCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFqQlU7QUFrQlYsaUJBQUssS0FBTCxDQUFXLElBQVgsRUFsQlU7Ozs7bUNBcUJILE1BQU07QUFDYixpQkFBSyxZQUFMLEdBQW9CLGFBQXBCLENBQWtDLElBQWxDLEVBRGE7Ozs7eUNBSUEsTUFBTTtBQUNuQixnQkFBSSx5QkFBZSxTQUFmLENBQXlCLEtBQUssUUFBTCxDQUE3QixFQUE2QztBQUN6QyxxQkFBSyxZQUFMLEdBQW9CLGFBQXBCLENBQWtDLEtBQUssUUFBTCxFQUFlLG9CQUFVLEVBQVYsRUFBYyxJQUEvRCxFQUR5QzthQUE3QyxNQUVPO0FBQ0gscUJBQUssYUFBTCxDQUFtQixJQUFuQixFQURHO2FBRlA7Ozs7eUNBT2EsTUFBTTtBQUNuQixpQkFBSyxLQUFMLENBQVcsS0FBSyxNQUFMLENBQVgsQ0FEbUI7QUFFbkIsZ0JBQUksS0FBSyxRQUFMLEVBQWU7QUFDZixxQkFBSyxLQUFMLENBQVcsS0FBSyxRQUFMLENBQVgsQ0FEZTthQUFuQjs7OztpQ0FLSyxNQUFNO0FBQ1gsaUJBQUssYUFBTCxDQUFtQixJQUFuQixFQURXOzs7O3lDQUlFLE1BQU07QUFDbkIsaUJBQUssYUFBTCxDQUFtQixJQUFuQixFQURtQjs7Ozt5Q0FJTjs7OzRDQUVHOzs7eUNBRUgsTUFBTTtBQUNuQixpQkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0FEbUI7Ozs7cUNBSVYsTUFBTTs7Ozs7QUFLZixnQkFBSSxLQUFLLElBQUwsSUFBYSxLQUFLLElBQUwsQ0FBVSxJQUFWLEtBQW1CLG1CQUFPLG1CQUFQLElBQThCLEtBQUssSUFBTCxDQUFVLElBQVYsS0FBbUIsS0FBbkIsRUFBMEI7QUFDeEYscUJBQUssWUFBTCxDQUFrQixjQUFsQixDQUFpQyxJQUFqQyxFQUR3RjthQUE1Rjs7QUFJQSxpQkFBSyxhQUFMLENBQW1CLElBQW5CLEVBVGU7O0FBV2YsaUJBQUssS0FBTCxDQUFXLElBQVgsRUFYZTs7Ozt3Q0FjSCxNQUFNO0FBQ2xCLGlCQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsRUFEa0I7Ozs7eUNBSUwsTUFBTTtBQUNuQixpQkFBSyxVQUFMLENBQWdCLElBQWhCLEVBRG1COzs7O3VDQUlSLE1BQU07O0FBRWpCLGdCQUFJLENBQUMsS0FBSyxZQUFMLENBQWtCLFlBQWxCLEVBQUQsSUFBcUMsS0FBSyxNQUFMLENBQVksSUFBWixLQUFxQixtQkFBTyxVQUFQLElBQXFCLEtBQUssTUFBTCxDQUFZLElBQVosS0FBcUIsTUFBckIsRUFBNkI7OztBQUc1RyxxQkFBSyxZQUFMLEdBQW9CLGFBQXBCLENBQWtDLFlBQWxDLEdBSDRHO2FBQWhIO0FBS0EsaUJBQUssYUFBTCxDQUFtQixJQUFuQixFQVBpQjs7Ozt1Q0FVTixNQUFNO0FBQ2pCLGdCQUFJLEtBQUssWUFBTCxDQUFrQixPQUFsQixFQUFKLEVBQWlDO0FBQzdCLHFCQUFLLFlBQUwsQ0FBa0IsZ0JBQWxCLENBQW1DLElBQW5DLEVBRDZCO2FBQWpDOztBQUlBLGlCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFMaUI7O0FBT2pCLGlCQUFLLEtBQUwsQ0FBVyxJQUFYLEVBUGlCOzs7O3lDQVVKO0FBQ2IsaUJBQUssWUFBTCxHQUFvQixhQUFwQixDQUFrQyxZQUFsQyxHQURhOzs7O3NDQUlILE1BQU07QUFDaEIsaUJBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxDQUFYOztBQURnQixnQkFHaEIsQ0FBSyxZQUFMLENBQWtCLGVBQWxCLENBQWtDLElBQWxDLEVBSGdCOztBQUtoQixpQkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0FMZ0I7O0FBT2hCLGlCQUFLLEtBQUwsQ0FBVyxJQUFYLEVBUGdCOzs7OzRDQVVBLE1BQU07QUFDdEIsZ0JBQUksbUJBQUosRUFBeUIsQ0FBekIsRUFBNEIsRUFBNUIsRUFBZ0MsSUFBaEMsQ0FEc0I7QUFFdEIsa0NBQXNCLElBQUMsQ0FBSyxJQUFMLEtBQWMsS0FBZCxHQUF1QixLQUFLLFlBQUwsR0FBb0IsYUFBcEIsR0FBb0MsS0FBSyxZQUFMLEVBQTVELENBRkE7QUFHdEIsaUJBQUssSUFBSSxDQUFKLEVBQU8sS0FBSyxLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsRUFBMEIsSUFBSSxFQUFKLEVBQVEsRUFBRSxDQUFGLEVBQUs7QUFDcEQsdUJBQU8sS0FBSyxZQUFMLENBQWtCLENBQWxCLENBQVAsQ0FEb0Q7QUFFcEQscUJBQUssd0JBQUwsQ0FBOEIsbUJBQTlCLEVBQW1ELG1CQUFTLFFBQVQsRUFBbUIsSUFBdEUsRUFBNEUsQ0FBNUUsRUFGb0Q7QUFHcEQsb0JBQUksS0FBSyxJQUFMLEVBQVc7QUFDWCx5QkFBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVgsQ0FEVztpQkFBZjthQUhKOzs7Ozs7O3dDQVVZLE1BQU07QUFDbEIsZ0JBQUksQ0FBSixFQUFPLEVBQVAsQ0FEa0I7O0FBR2xCLGlCQUFLLEtBQUwsQ0FBVyxLQUFLLFlBQUwsQ0FBWCxDQUhrQjs7QUFLbEIsZ0JBQUksS0FBSyxZQUFMLENBQWtCLE9BQWxCLEVBQUosRUFBaUM7QUFDN0IscUJBQUssWUFBTCxDQUFrQixpQkFBbEIsQ0FBb0MsSUFBcEMsRUFENkI7YUFBakM7O0FBSUEsaUJBQUssSUFBSSxDQUFKLEVBQU8sS0FBSyxLQUFLLEtBQUwsQ0FBVyxNQUFYLEVBQW1CLElBQUksRUFBSixFQUFRLEVBQUUsQ0FBRixFQUFLO0FBQzdDLHFCQUFLLEtBQUwsQ0FBVyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQVgsRUFENkM7YUFBakQ7O0FBSUEsaUJBQUssS0FBTCxDQUFXLElBQVgsRUFia0I7Ozs7NENBZ0JGLE1BQU07QUFDdEIsaUJBQUssYUFBTCxDQUFtQixJQUFuQixFQURzQjs7OzsyQ0FJUCxNQUFNO0FBQ3JCLGlCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFEcUI7Ozs7dUNBSVYsTUFBTTtBQUNqQixpQkFBSyxVQUFMLENBQWdCLElBQWhCLEVBRGlCOzs7O3VDQUlOLE1BQU07QUFDakIsaUJBQUssVUFBTCxDQUFnQixJQUFoQixFQURpQjs7OztnREFJRyxNQUFNO0FBQzFCLGlCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFEMEI7Ozs7MENBSVosTUFBTTtBQUNwQixnQkFBSSxRQUFKLENBRG9COztBQUdwQixrQ0FBTyxLQUFLLFlBQUwsQ0FBa0IsT0FBbEIsTUFBK0IsS0FBSyxZQUFMLENBQWtCLFFBQWxCLEVBQS9CLEVBQTZELGlGQUFwRSxFQUhvQjs7QUFLcEIsdUJBQVcsSUFBSSxRQUFKLENBQWEsSUFBYixFQUFtQixJQUFuQixDQUFYLENBTG9CO0FBTXBCLHFCQUFTLEtBQVQsQ0FBZSxJQUFmLEVBTm9COzs7OytDQVNELE1BQU07QUFDekIsZ0JBQUksS0FBSyxNQUFMLEVBQWE7QUFDYix1QkFEYTthQUFqQjtBQUdBLGdCQUFJLEtBQUssV0FBTCxFQUFrQjtBQUNsQixxQkFBSyxLQUFMLENBQVcsS0FBSyxXQUFMLENBQVgsQ0FEa0I7QUFFbEIsdUJBRmtCO2FBQXRCOztBQUtBLGlCQUFLLGFBQUwsQ0FBbUIsSUFBbkIsRUFUeUI7Ozs7MENBWVgsTUFBTTtBQUNwQixpQkFBSyxzQkFBTCxDQUE0QixJQUE1QixFQURvQjs7OzsrQ0FJRCxNQUFNO0FBQ3pCLGlCQUFLLHNCQUFMLENBQTRCLElBQTVCLEVBRHlCOzs7O3dDQUliLE1BQU07QUFDbEIsZ0JBQUksUUFBUyxLQUFLLEVBQUwsSUFBVyxLQUFLLEtBQUwsQ0FETjtBQUVsQixpQkFBSyxLQUFMLENBQVcsS0FBWCxFQUZrQjs7Ozt1Q0FLUDs7Ozs7V0F0ZUU7RUFBbUIsb0JBQVUsT0FBVjs7Ozs7a0JBQW5CIiwiZmlsZSI6InJlZmVyZW5jZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5pbXBvcnQgeyBTeW50YXggfSBmcm9tICdlc3RyYXZlcnNlJztcbmltcG9ydCBlc3JlY3Vyc2UgZnJvbSAnZXNyZWN1cnNlJztcbmltcG9ydCBSZWZlcmVuY2UgZnJvbSAnLi9yZWZlcmVuY2UnO1xuaW1wb3J0IFZhcmlhYmxlIGZyb20gJy4vdmFyaWFibGUnO1xuaW1wb3J0IFBhdHRlcm5WaXNpdG9yIGZyb20gJy4vcGF0dGVybi12aXNpdG9yJztcbmltcG9ydCB7IFBhcmFtZXRlckRlZmluaXRpb24sIERlZmluaXRpb24gfSBmcm9tICcuL2RlZmluaXRpb24nO1xuaW1wb3J0IGFzc2VydCBmcm9tICdhc3NlcnQnO1xuXG5mdW5jdGlvbiB0cmF2ZXJzZUlkZW50aWZpZXJJblBhdHRlcm4ob3B0aW9ucywgcm9vdFBhdHRlcm4sIHJlZmVyZW5jZXIsIGNhbGxiYWNrKSB7XG4gICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgYXQgbGVmdCBoYW5kIGlkZW50aWZpZXIgbm9kZXMsIGFuZCBDb2xsZWN0IHJpZ2h0IGhhbmQgbm9kZXMuXG4gICAgdmFyIHZpc2l0b3IgPSBuZXcgUGF0dGVyblZpc2l0b3Iob3B0aW9ucywgcm9vdFBhdHRlcm4sIGNhbGxiYWNrKTtcbiAgICB2aXNpdG9yLnZpc2l0KHJvb3RQYXR0ZXJuKTtcblxuICAgIC8vIFByb2Nlc3MgdGhlIHJpZ2h0IGhhbmQgbm9kZXMgcmVjdXJzaXZlbHkuXG4gICAgaWYgKHJlZmVyZW5jZXIgIT0gbnVsbCkge1xuICAgICAgICB2aXNpdG9yLnJpZ2h0SGFuZE5vZGVzLmZvckVhY2gocmVmZXJlbmNlci52aXNpdCwgcmVmZXJlbmNlcik7XG4gICAgfVxufVxuXG4vLyBJbXBvcnRpbmcgSW1wb3J0RGVjbGFyYXRpb24uXG4vLyBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy1tb2R1bGVkZWNsYXJhdGlvbmluc3RhbnRpYXRpb25cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9lc3RyZWUvZXN0cmVlL2Jsb2IvbWFzdGVyL2VzNi5tZCNpbXBvcnRkZWNsYXJhdGlvblxuLy8gRklYTUU6IE5vdywgd2UgZG9uJ3QgY3JlYXRlIG1vZHVsZSBlbnZpcm9ubWVudCwgYmVjYXVzZSB0aGUgY29udGV4dCBpc1xuLy8gaW1wbGVtZW50YXRpb24gZGVwZW5kZW50LlxuXG5jbGFzcyBJbXBvcnRlciBleHRlbmRzIGVzcmVjdXJzZS5WaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihkZWNsYXJhdGlvbiwgcmVmZXJlbmNlcikge1xuICAgICAgICBzdXBlcihudWxsLCByZWZlcmVuY2VyLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLmRlY2xhcmF0aW9uID0gZGVjbGFyYXRpb247XG4gICAgICAgIHRoaXMucmVmZXJlbmNlciA9IHJlZmVyZW5jZXI7XG4gICAgfVxuXG4gICAgdmlzaXRJbXBvcnQoaWQsIHNwZWNpZmllcikge1xuICAgICAgICB0aGlzLnJlZmVyZW5jZXIudmlzaXRQYXR0ZXJuKGlkLCAocGF0dGVybikgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2VyLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIFZhcmlhYmxlLkltcG9ydEJpbmRpbmcsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIHNwZWNpZmllcixcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWNsYXJhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsID0gKG5vZGUubG9jYWwgfHwgbm9kZS5pZCk7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdEltcG9ydChsb2NhbCwgbm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBJbXBvcnREZWZhdWx0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsID0gKG5vZGUubG9jYWwgfHwgbm9kZS5pZCk7XG4gICAgICAgIHRoaXMudmlzaXRJbXBvcnQobG9jYWwsIG5vZGUpO1xuICAgIH1cblxuICAgIEltcG9ydFNwZWNpZmllcihub2RlKSB7XG4gICAgICAgIGxldCBsb2NhbCA9IChub2RlLmxvY2FsIHx8IG5vZGUuaWQpO1xuICAgICAgICBpZiAobm9kZS5uYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0SW1wb3J0KG5vZGUubmFtZSwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0SW1wb3J0KGxvY2FsLCBub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gUmVmZXJlbmNpbmcgdmFyaWFibGVzIGFuZCBjcmVhdGluZyBiaW5kaW5ncy5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlZmVyZW5jZXIgZXh0ZW5kcyBlc3JlY3Vyc2UuVmlzaXRvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucywgc2NvcGVNYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlciA9IHNjb3BlTWFuYWdlcjtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzSW5uZXJNZXRob2REZWZpbml0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY3VycmVudFNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZU1hbmFnZXIuX19jdXJyZW50U2NvcGU7XG4gICAgfVxuXG4gICAgY2xvc2Uobm9kZSkge1xuICAgICAgICB3aGlsZSAodGhpcy5jdXJyZW50U2NvcGUoKSAmJiBub2RlID09PSB0aGlzLmN1cnJlbnRTY29wZSgpLmJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX2N1cnJlbnRTY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCkuX19jbG9zZSh0aGlzLnNjb3BlTWFuYWdlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdXNoSW5uZXJNZXRob2REZWZpbml0aW9uKGlzSW5uZXJNZXRob2REZWZpbml0aW9uKSB7XG4gICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuaXNJbm5lck1ldGhvZERlZmluaXRpb247XG4gICAgICAgIHRoaXMuaXNJbm5lck1ldGhvZERlZmluaXRpb24gPSBpc0lubmVyTWV0aG9kRGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgIH1cblxuICAgIHBvcElubmVyTWV0aG9kRGVmaW5pdGlvbihpc0lubmVyTWV0aG9kRGVmaW5pdGlvbikge1xuICAgICAgICB0aGlzLmlzSW5uZXJNZXRob2REZWZpbml0aW9uID0gaXNJbm5lck1ldGhvZERlZmluaXRpb247XG4gICAgfVxuXG4gICAgbWF0ZXJpYWxpemVURFpTY29wZShub2RlLCBpdGVyYXRpb25Ob2RlKSB7XG4gICAgICAgIC8vIGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXJ1bnRpbWUtc2VtYW50aWNzLWZvcmluLWRpdi1vZmV4cHJlc3Npb25ldmFsdWF0aW9uLWFic3RyYWN0LW9wZXJhdGlvblxuICAgICAgICAvLyBURFogc2NvcGUgaGlkZXMgdGhlIGRlY2xhcmF0aW9uJ3MgbmFtZXMuXG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdFREWlNjb3BlKG5vZGUsIGl0ZXJhdGlvbk5vZGUpO1xuICAgICAgICB0aGlzLnZpc2l0VmFyaWFibGVEZWNsYXJhdGlvbih0aGlzLmN1cnJlbnRTY29wZSgpLCBWYXJpYWJsZS5URFosIGl0ZXJhdGlvbk5vZGUubGVmdCwgMCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgbWF0ZXJpYWxpemVJdGVyYXRpb25TY29wZShub2RlKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGl0ZXJhdGlvbiBzY29wZSBmb3IgdXBwZXIgRm9ySW4vRm9yT2YgU3RhdGVtZW50cy5cbiAgICAgICAgdmFyIGxldE9yQ29uc3REZWNsO1xuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RGb3JTY29wZShub2RlKTtcbiAgICAgICAgbGV0T3JDb25zdERlY2wgPSBub2RlLmxlZnQ7XG4gICAgICAgIHRoaXMudmlzaXRWYXJpYWJsZURlY2xhcmF0aW9uKHRoaXMuY3VycmVudFNjb3BlKCksIFZhcmlhYmxlLlZhcmlhYmxlLCBsZXRPckNvbnN0RGVjbCwgMCk7XG4gICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKGxldE9yQ29uc3REZWNsLmRlY2xhcmF0aW9uc1swXS5pZCwgKHBhdHRlcm4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhwYXR0ZXJuLCBSZWZlcmVuY2UuV1JJVEUsIG5vZGUucmlnaHQsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBhc3NpZ25tZW50cywgbWF5YmVJbXBsaWNpdEdsb2JhbCwgaW5pdCkge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICAgIGFzc2lnbm1lbnRzLmZvckVhY2goYXNzaWdubWVudCA9PiB7XG4gICAgICAgICAgICBzY29wZS5fX3JlZmVyZW5jaW5nKFxuICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgUmVmZXJlbmNlLldSSVRFLFxuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQucmlnaHQsXG4gICAgICAgICAgICAgICAgbWF5YmVJbXBsaWNpdEdsb2JhbCxcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICE9PSBhc3NpZ25tZW50LmxlZnQsXG4gICAgICAgICAgICAgICAgaW5pdCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZpc2l0UGF0dGVybihub2RlLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7cHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiBmYWxzZX1cbiAgICAgICAgfVxuICAgICAgICB0cmF2ZXJzZUlkZW50aWZpZXJJblBhdHRlcm4oXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgb3B0aW9ucy5wcm9jZXNzUmlnaHRIYW5kTm9kZXMgPyB0aGlzIDogbnVsbCxcbiAgICAgICAgICAgIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2aXNpdEZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6O1xuICAgICAgICAvLyBGdW5jdGlvbkRlY2xhcmF0aW9uIG5hbWUgaXMgZGVmaW5lZCBpbiB1cHBlciBzY29wZVxuICAgICAgICAvLyBOT1RFOiBOb3QgcmVmZXJyaW5nIHZhcmlhYmxlU2NvcGUuIEl0IGlzIGludGVuZGVkLlxuICAgICAgICAvLyBTaW5jZVxuICAgICAgICAvLyAgaW4gRVM1LCBGdW5jdGlvbkRlY2xhcmF0aW9uIHNob3VsZCBiZSBpbiBGdW5jdGlvbkJvZHkuXG4gICAgICAgIC8vICBpbiBFUzYsIEZ1bmN0aW9uRGVjbGFyYXRpb24gc2hvdWxkIGJlIGJsb2NrIHNjb3BlZC5cbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gU3ludGF4LkZ1bmN0aW9uRGVjbGFyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGlkIGlzIGRlZmluZWQgaW4gdXBwZXIgc2NvcGVcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19kZWZpbmUobm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5GdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbFxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZ1bmN0aW9uRXhwcmVzc2lvbiB3aXRoIG5hbWUgY3JlYXRlcyBpdHMgc3BlY2lhbCBzY29wZTtcbiAgICAgICAgLy8gRnVuY3Rpb25FeHByZXNzaW9uTmFtZVNjb3BlLlxuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguRnVuY3Rpb25FeHByZXNzaW9uICYmIG5vZGUuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZ1bmN0aW9uRXhwcmVzc2lvbk5hbWVTY29wZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnNpZGVyIHRoaXMgZnVuY3Rpb24gaXMgaW4gdGhlIE1ldGhvZERlZmluaXRpb24uXG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZ1bmN0aW9uU2NvcGUobm9kZSwgdGhpcy5pc0lubmVyTWV0aG9kRGVmaW5pdGlvbik7XG5cbiAgICAgICAgLy8gUHJvY2VzcyBwYXJhbWV0ZXIgZGVjbGFyYXRpb25zLlxuICAgICAgICBmb3IgKGkgPSAwLCBpeiA9IG5vZGUucGFyYW1zLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKG5vZGUucGFyYW1zW2ldLCB7cHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiB0cnVlfSwgKHBhdHRlcm4sIGluZm8pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY29wZSgpLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIG5ldyBQYXJhbWV0ZXJEZWZpbml0aW9uKFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mby5yZXN0XG4gICAgICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUncyBhIHJlc3QgYXJndW1lbnQsIGFkZCB0aGF0XG4gICAgICAgIGlmIChub2RlLnJlc3QpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnUmVzdEVsZW1lbnQnLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBub2RlLnJlc3RcbiAgICAgICAgICAgIH0sIChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUGFyYW1ldGVyRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJhbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2tpcCBCbG9ja1N0YXRlbWVudCB0byBwcmV2ZW50IGNyZWF0aW5nIEJsb2NrU3RhdGVtZW50IHNjb3BlLlxuICAgICAgICBpZiAobm9kZS5ib2R5LnR5cGUgPT09IFN5bnRheC5CbG9ja1N0YXRlbWVudCkge1xuICAgICAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUuYm9keSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIHZpc2l0Q2xhc3Mobm9kZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlID09PSBTeW50YXguQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX2RlZmluZShub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgICAgIFZhcmlhYmxlLkNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsXG4gICAgICAgICAgICAgICAgICAgICkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRklYTUU6IE1heWJlIGNvbnNpZGVyIFREWi5cbiAgICAgICAgdGhpcy52aXNpdChub2RlLnN1cGVyQ2xhc3MpO1xuXG4gICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdENsYXNzU2NvcGUobm9kZSk7XG5cbiAgICAgICAgaWYgKG5vZGUuaWQpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19kZWZpbmUobm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgICAgICBWYXJpYWJsZS5DbGFzc05hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVxuICAgICAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICB2aXNpdFByb3BlcnR5KG5vZGUpIHtcbiAgICAgICAgdmFyIHByZXZpb3VzLCBpc01ldGhvZERlZmluaXRpb247XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUua2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTWV0aG9kRGVmaW5pdGlvbiA9IG5vZGUudHlwZSA9PT0gU3ludGF4Lk1ldGhvZERlZmluaXRpb247XG4gICAgICAgIGlmIChpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHByZXZpb3VzID0gdGhpcy5wdXNoSW5uZXJNZXRob2REZWZpbml0aW9uKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS52YWx1ZSk7XG4gICAgICAgIGlmIChpc01ldGhvZERlZmluaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wSW5uZXJNZXRob2REZWZpbml0aW9uKHByZXZpb3VzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZpc2l0Rm9ySW4obm9kZSkge1xuICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uICYmIG5vZGUubGVmdC5raW5kICE9PSAndmFyJykge1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbGl6ZVREWlNjb3BlKG5vZGUucmlnaHQsIG5vZGUpO1xuICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2Uobm9kZS5yaWdodCk7XG5cbiAgICAgICAgICAgIHRoaXMubWF0ZXJpYWxpemVJdGVyYXRpb25TY29wZShub2RlKTtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5ib2R5KTtcbiAgICAgICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWZ0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdChub2RlLmxlZnQpO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKG5vZGUubGVmdC5kZWNsYXJhdGlvbnNbMF0uaWQsIChwYXR0ZXJuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhwYXR0ZXJuLCBSZWZlcmVuY2UuV1JJVEUsIG5vZGUucmlnaHQsIG51bGwsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLmxlZnQsIHtwcm9jZXNzUmlnaHRIYW5kTm9kZXM6IHRydWV9LCAocGF0dGVybiwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF5YmVJbXBsaWNpdEdsb2JhbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50U2NvcGUoKS5pc1N0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF5YmVJbXBsaWNpdEdsb2JhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBwYXR0ZXJuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGU6IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBtYXliZUltcGxpY2l0R2xvYmFsLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhwYXR0ZXJuLCBSZWZlcmVuY2UuV1JJVEUsIG5vZGUucmlnaHQsIG1heWJlSW1wbGljaXRHbG9iYWwsIHRydWUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5yaWdodCk7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyaWFibGVUYXJnZXRTY29wZSwgdHlwZSwgbm9kZSwgaW5kZXgsIGZyb21URFopIHtcbiAgICAgICAgLy8gSWYgdGhpcyB3YXMgY2FsbGVkIHRvIGluaXRpYWxpemUgYSBURFogc2NvcGUsIHRoaXMgbmVlZHMgdG8gbWFrZSBkZWZpbml0aW9ucywgYnV0IGRvZXNuJ3QgbWFrZSByZWZlcmVuY2VzLlxuICAgICAgICB2YXIgZGVjbCwgaW5pdDtcblxuICAgICAgICBkZWNsID0gbm9kZS5kZWNsYXJhdGlvbnNbaW5kZXhdO1xuICAgICAgICBpbml0ID0gZGVjbC5pbml0O1xuICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihkZWNsLmlkLCB7cHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiAhZnJvbVREWn0sIChwYXR0ZXJuLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICB2YXJpYWJsZVRhcmdldFNjb3BlLl9fZGVmaW5lKHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbmV3IERlZmluaXRpb24oXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgIGRlY2wsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBub2RlLmtpbmRcbiAgICAgICAgICAgICAgICApKTtcblxuICAgICAgICAgICAgaWYgKCFmcm9tVERaKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2luZ0RlZmF1bHRWYWx1ZShwYXR0ZXJuLCBpbmZvLmFzc2lnbm1lbnRzLCBudWxsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKHBhdHRlcm4sIFJlZmVyZW5jZS5XUklURSwgaW5pdCwgbnVsbCwgIWluZm8udG9wTGV2ZWwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIGlmIChQYXR0ZXJuVmlzaXRvci5pc1BhdHRlcm4obm9kZS5sZWZ0KSkge1xuICAgICAgICAgICAgaWYgKG5vZGUub3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRQYXR0ZXJuKG5vZGUubGVmdCwge3Byb2Nlc3NSaWdodEhhbmROb2RlczogdHJ1ZX0sIChwYXR0ZXJuLCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXliZUltcGxpY2l0R2xvYmFsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRTY29wZSgpLmlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXliZUltcGxpY2l0R2xvYmFsID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHBhdHRlcm4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmVyZW5jaW5nRGVmYXVsdFZhbHVlKHBhdHRlcm4sIGluZm8uYXNzaWdubWVudHMsIG1heWJlSW1wbGljaXRHbG9iYWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKHBhdHRlcm4sIFJlZmVyZW5jZS5XUklURSwgbm9kZS5yaWdodCwgbWF5YmVJbXBsaWNpdEdsb2JhbCwgIWluZm8udG9wTGV2ZWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKG5vZGUubGVmdCwgUmVmZXJlbmNlLlJXLCBub2RlLnJpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5sZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0KG5vZGUucmlnaHQpO1xuICAgIH1cblxuICAgIENhdGNoQ2xhdXNlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Q2F0Y2hTY29wZShub2RlKTtcblxuICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlLnBhcmFtLCB7cHJvY2Vzc1JpZ2h0SGFuZE5vZGVzOiB0cnVlfSwgKHBhdHRlcm4sIGluZm8pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19kZWZpbmUocGF0dGVybixcbiAgICAgICAgICAgICAgICBuZXcgRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICAgICAgVmFyaWFibGUuQ2F0Y2hDbGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyYW0sXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHRoaXMucmVmZXJlbmNpbmdEZWZhdWx0VmFsdWUocGF0dGVybiwgaW5mby5hc3NpZ25tZW50cywgbnVsbCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYm9keSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICBQcm9ncmFtKG5vZGUpIHtcbiAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0R2xvYmFsU2NvcGUobm9kZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2NvcGVNYW5hZ2VyLl9faXNOb2RlanNTY29wZSgpKSB7XG4gICAgICAgICAgICAvLyBGb3JjZSBzdHJpY3RuZXNzIG9mIEdsb2JhbFNjb3BlIHRvIGZhbHNlIHdoZW4gdXNpbmcgbm9kZS5qcyBzY29wZS5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuaXNTdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEZ1bmN0aW9uU2NvcGUobm9kZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc2NvcGVNYW5hZ2VyLl9faXNFUzYoKSAmJiB0aGlzLnNjb3BlTWFuYWdlci5pc01vZHVsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RNb2R1bGVTY29wZShub2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5pc1N0cmljdE1vZGVTdXBwb3J0ZWQoKSAmJiB0aGlzLnNjb3BlTWFuYWdlci5pc0ltcGxpZWRTdHJpY3QoKSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5pc1N0cmljdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgSWRlbnRpZmllcihub2RlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNjb3BlKCkuX19yZWZlcmVuY2luZyhub2RlKTtcbiAgICB9XG5cbiAgICBVcGRhdGVFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgaWYgKFBhdHRlcm5WaXNpdG9yLmlzUGF0dGVybihub2RlLmFyZ3VtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS5fX3JlZmVyZW5jaW5nKG5vZGUuYXJndW1lbnQsIFJlZmVyZW5jZS5SVywgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBNZW1iZXJFeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLm9iamVjdCk7XG4gICAgICAgIGlmIChub2RlLmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgUHJvcGVydHkobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0UHJvcGVydHkobm9kZSk7XG4gICAgfVxuXG4gICAgTWV0aG9kRGVmaW5pdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRQcm9wZXJ0eShub2RlKTtcbiAgICB9XG5cbiAgICBCcmVha1N0YXRlbWVudCgpIHt9XG5cbiAgICBDb250aW51ZVN0YXRlbWVudCgpIHt9XG5cbiAgICBMYWJlbGVkU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuICAgIH1cblxuICAgIEZvclN0YXRlbWVudChub2RlKSB7XG4gICAgICAgIC8vIENyZWF0ZSBGb3JTdGF0ZW1lbnQgZGVjbGFyYXRpb24uXG4gICAgICAgIC8vIE5PVEU6IEluIEVTNiwgRm9yU3RhdGVtZW50IGR5bmFtaWNhbGx5IGdlbmVyYXRlc1xuICAgICAgICAvLyBwZXIgaXRlcmF0aW9uIGVudmlyb25tZW50LiBIb3dldmVyLCBlc2NvcGUgaXNcbiAgICAgICAgLy8gYSBzdGF0aWMgYW5hbHl6ZXIsIHdlIG9ubHkgZ2VuZXJhdGUgb25lIHNjb3BlIGZvciBGb3JTdGF0ZW1lbnQuXG4gICAgICAgIGlmIChub2RlLmluaXQgJiYgbm9kZS5pbml0LnR5cGUgPT09IFN5bnRheC5WYXJpYWJsZURlY2xhcmF0aW9uICYmIG5vZGUuaW5pdC5raW5kICE9PSAndmFyJykge1xuICAgICAgICAgICAgdGhpcy5zY29wZU1hbmFnZXIuX19uZXN0Rm9yU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICBDbGFzc0V4cHJlc3Npb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0Q2xhc3Mobm9kZSk7XG4gICAgfVxuXG4gICAgQ2xhc3NEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMudmlzaXRDbGFzcyhub2RlKTtcbiAgICB9XG5cbiAgICBDYWxsRXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIC8vIENoZWNrIHRoaXMgaXMgZGlyZWN0IGNhbGwgdG8gZXZhbFxuICAgICAgICBpZiAoIXRoaXMuc2NvcGVNYW5hZ2VyLl9faWdub3JlRXZhbCgpICYmIG5vZGUuY2FsbGVlLnR5cGUgPT09IFN5bnRheC5JZGVudGlmaWVyICYmIG5vZGUuY2FsbGVlLm5hbWUgPT09ICdldmFsJykge1xuICAgICAgICAgICAgLy8gTk9URTogVGhpcyBzaG91bGQgYmUgYHZhcmlhYmxlU2NvcGVgLiBTaW5jZSBkaXJlY3QgZXZhbCBjYWxsIGFsd2F5cyBjcmVhdGVzIExleGljYWwgZW52aXJvbm1lbnQgYW5kXG4gICAgICAgICAgICAvLyBsZXQgLyBjb25zdCBzaG91bGQgYmUgZW5jbG9zZWQgaW50byBpdC4gT25seSBWYXJpYWJsZURlY2xhcmF0aW9uIGFmZmVjdHMgb24gdGhlIGNhbGxlcidzIGVudmlyb25tZW50LlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS52YXJpYWJsZVNjb3BlLl9fZGV0ZWN0RXZhbCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlzaXRDaGlsZHJlbihub2RlKTtcbiAgICB9XG5cbiAgICBCbG9ja1N0YXRlbWVudChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdEJsb2NrU2NvcGUobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG5cbiAgICAgICAgdGhpcy5jbG9zZShub2RlKTtcbiAgICB9XG5cbiAgICBUaGlzRXhwcmVzc2lvbigpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U2NvcGUoKS52YXJpYWJsZVNjb3BlLl9fZGV0ZWN0VGhpcygpO1xuICAgIH1cblxuICAgIFdpdGhTdGF0ZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUub2JqZWN0KTtcbiAgICAgICAgLy8gVGhlbiBuZXN0IHNjb3BlIGZvciBXaXRoU3RhdGVtZW50LlxuICAgICAgICB0aGlzLnNjb3BlTWFuYWdlci5fX25lc3RXaXRoU2NvcGUobm9kZSk7XG5cbiAgICAgICAgdGhpcy52aXNpdChub2RlLmJvZHkpO1xuXG4gICAgICAgIHRoaXMuY2xvc2Uobm9kZSk7XG4gICAgfVxuXG4gICAgVmFyaWFibGVEZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIHZhciB2YXJpYWJsZVRhcmdldFNjb3BlLCBpLCBpeiwgZGVjbDtcbiAgICAgICAgdmFyaWFibGVUYXJnZXRTY29wZSA9IChub2RlLmtpbmQgPT09ICd2YXInKSA/IHRoaXMuY3VycmVudFNjb3BlKCkudmFyaWFibGVTY29wZSA6IHRoaXMuY3VycmVudFNjb3BlKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGl6ID0gbm9kZS5kZWNsYXJhdGlvbnMubGVuZ3RoOyBpIDwgaXo7ICsraSkge1xuICAgICAgICAgICAgZGVjbCA9IG5vZGUuZGVjbGFyYXRpb25zW2ldO1xuICAgICAgICAgICAgdGhpcy52aXNpdFZhcmlhYmxlRGVjbGFyYXRpb24odmFyaWFibGVUYXJnZXRTY29wZSwgVmFyaWFibGUuVmFyaWFibGUsIG5vZGUsIGkpO1xuICAgICAgICAgICAgaWYgKGRlY2wuaW5pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoZGVjbC5pbml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNlYyAxMy4xMS44XG4gICAgU3dpdGNoU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdmFyIGksIGl6O1xuXG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5kaXNjcmltaW5hbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2NvcGVNYW5hZ2VyLl9fbmVzdFN3aXRjaFNjb3BlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBub2RlLmNhc2VzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaXQobm9kZS5jYXNlc1tpXSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKG5vZGUpO1xuICAgIH1cblxuICAgIEZ1bmN0aW9uRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RnVuY3Rpb24obm9kZSk7XG4gICAgfVxuXG4gICAgRnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEZvck9mU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZvckluKG5vZGUpO1xuICAgIH1cblxuICAgIEZvckluU3RhdGVtZW50KG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZvckluKG5vZGUpO1xuICAgIH1cblxuICAgIEFycm93RnVuY3Rpb25FeHByZXNzaW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEZ1bmN0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEltcG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdmFyIGltcG9ydGVyO1xuXG4gICAgICAgIGFzc2VydCh0aGlzLnNjb3BlTWFuYWdlci5fX2lzRVM2KCkgJiYgdGhpcy5zY29wZU1hbmFnZXIuaXNNb2R1bGUoKSwgJ0ltcG9ydERlY2xhcmF0aW9uIHNob3VsZCBhcHBlYXIgd2hlbiB0aGUgbW9kZSBpcyBFUzYgYW5kIGluIHRoZSBtb2R1bGUgY29udGV4dC4nKTtcblxuICAgICAgICBpbXBvcnRlciA9IG5ldyBJbXBvcnRlcihub2RlLCB0aGlzKTtcbiAgICAgICAgaW1wb3J0ZXIudmlzaXQobm9kZSk7XG4gICAgfVxuXG4gICAgdmlzaXRFeHBvcnREZWNsYXJhdGlvbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnNvdXJjZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmRlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2l0KG5vZGUuZGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy52aXNpdEV4cG9ydERlY2xhcmF0aW9uKG5vZGUpO1xuICAgIH1cblxuICAgIEV4cG9ydE5hbWVkRGVjbGFyYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0RXhwb3J0RGVjbGFyYXRpb24obm9kZSk7XG4gICAgfVxuXG4gICAgRXhwb3J0U3BlY2lmaWVyKG5vZGUpIHtcbiAgICAgICAgbGV0IGxvY2FsID0gKG5vZGUuaWQgfHwgbm9kZS5sb2NhbCk7XG4gICAgICAgIHRoaXMudmlzaXQobG9jYWwpO1xuICAgIH1cblxuICAgIE1ldGFQcm9wZXJ0eSgpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZy5cbiAgICB9XG59XG5cbi8qIHZpbTogc2V0IHN3PTQgdHM9NCBldCB0dz04MCA6ICovXG4iXSwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2014 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	(function () {
	    'use strict';
	
	    var assign,
	        estraverse,
	        isArray,
	        objectKeys;
	
	    assign = __webpack_require__(78);
	    estraverse = __webpack_require__(79);
	
	    isArray = Array.isArray || function isArray(array) {
	        return Object.prototype.toString.call(array) === '[object Array]';
	    };
	
	    objectKeys = Object.keys || function (o) {
	        var keys = [], key;
	        for (key in o) {
	            keys.push(key);
	        }
	        return keys;
	    };
	
	    function isNode(node) {
	        if (node == null) {
	            return false;
	        }
	        return typeof node === 'object' && typeof node.type === 'string';
	    }
	
	    function isProperty(nodeType, key) {
	        return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === 'properties';
	    }
	
	    function Visitor(visitor, options) {
	        options = options || {};
	
	        this.__visitor = visitor ||  this;
	        this.__childVisitorKeys = options.childVisitorKeys
	            ? assign({}, estraverse.VisitorKeys, options.childVisitorKeys)
	            : estraverse.VisitorKeys;
	        if (options.fallback === 'iteration') {
	            this.__fallback = objectKeys;
	        } else if (typeof options.fallback === 'function') {
	            this.__fallback = options.fallback;
	        }
	    }
	
	    /* Default method for visiting children.
	     * When you need to call default visiting operation inside custom visiting
	     * operation, you can use it with `this.visitChildren(node)`.
	     */
	    Visitor.prototype.visitChildren = function (node) {
	        var type, children, i, iz, j, jz, child;
	
	        if (node == null) {
	            return;
	        }
	
	        type = node.type || estraverse.Syntax.Property;
	
	        children = this.__childVisitorKeys[type];
	        if (!children) {
	            if (this.__fallback) {
	                children = this.__fallback(node);
	            } else {
	                throw new Error('Unknown node type ' + type + '.');
	            }
	        }
	
	        for (i = 0, iz = children.length; i < iz; ++i) {
	            child = node[children[i]];
	            if (child) {
	                if (isArray(child)) {
	                    for (j = 0, jz = child.length; j < jz; ++j) {
	                        if (child[j]) {
	                            if (isNode(child[j]) || isProperty(type, children[i])) {
	                                this.visit(child[j]);
	                            }
	                        }
	                    }
	                } else if (isNode(child)) {
	                    this.visit(child);
	                }
	            }
	        }
	    };
	
	    /* Dispatching node. */
	    Visitor.prototype.visit = function (node) {
	        var type;
	
	        if (node == null) {
	            return;
	        }
	
	        type = node.type || estraverse.Syntax.Property;
	        if (this.__visitor[type]) {
	            this.__visitor[type].call(this, node);
	            return;
	        }
	        this.visitChildren(node);
	    };
	
	    exports.version = __webpack_require__(81).version;
	    exports.Visitor = Visitor;
	    exports.visit = function (node, visitor, options) {
	        var v = new Visitor(visitor, options);
	        v.visit(node);
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 78 */
/***/ function(module, exports) {

	'use strict';
	/* eslint-disable no-unused-vars */
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
	
	function toObject(val) {
		if (val === null || val === undefined) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}
	
		return Object(val);
	}
	
	function shouldUseNative() {
		try {
			if (!Object.assign) {
				return false;
			}
	
			// Detect buggy property enumeration order in older V8 versions.
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
			var test1 = new String('abc');  // eslint-disable-line
			test1[5] = 'de';
			if (Object.getOwnPropertyNames(test1)[0] === '5') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test2 = {};
			for (var i = 0; i < 10; i++) {
				test2['_' + String.fromCharCode(i)] = i;
			}
			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
				return test2[n];
			});
			if (order2.join('') !== '0123456789') {
				return false;
			}
	
			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
			var test3 = {};
			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
				test3[letter] = letter;
			});
			if (Object.keys(Object.assign({}, test3)).join('') !==
					'abcdefghijklmnopqrst') {
				return false;
			}
	
			return true;
		} catch (e) {
			// We don't expect any of the above to throw, but better to be safe.
			return false;
		}
	}
	
	module.exports = shouldUseNative() ? Object.assign : function (target, source) {
		var from;
		var to = toObject(target);
		var symbols;
	
		for (var s = 1; s < arguments.length; s++) {
			from = Object(arguments[s]);
	
			for (var key in from) {
				if (hasOwnProperty.call(from, key)) {
					to[key] = from[key];
				}
			}
	
			if (Object.getOwnPropertySymbols) {
				symbols = Object.getOwnPropertySymbols(from);
				for (var i = 0; i < symbols.length; i++) {
					if (propIsEnumerable.call(from, symbols[i])) {
						to[symbols[i]] = from[symbols[i]];
					}
				}
			}
		}
	
		return to;
	};


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	/*jslint vars:false, bitwise:true*/
	/*jshint indent:4*/
	/*global exports:true*/
	(function clone(exports) {
	    'use strict';
	
	    var Syntax,
	        isArray,
	        VisitorOption,
	        VisitorKeys,
	        objectCreate,
	        objectKeys,
	        BREAK,
	        SKIP,
	        REMOVE;
	
	    function ignoreJSHintError() { }
	
	    isArray = Array.isArray;
	    if (!isArray) {
	        isArray = function isArray(array) {
	            return Object.prototype.toString.call(array) === '[object Array]';
	        };
	    }
	
	    function deepCopy(obj) {
	        var ret = {}, key, val;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                val = obj[key];
	                if (typeof val === 'object' && val !== null) {
	                    ret[key] = deepCopy(val);
	                } else {
	                    ret[key] = val;
	                }
	            }
	        }
	        return ret;
	    }
	
	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    ignoreJSHintError(shallowCopy);
	
	    // based on LLVM libc++ upper_bound / lower_bound
	    // MIT License
	
	    function upperBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                len = diff;
	            } else {
	                i = current + 1;
	                len -= diff + 1;
	            }
	        }
	        return i;
	    }
	
	    function lowerBound(array, func) {
	        var diff, len, i, current;
	
	        len = array.length;
	        i = 0;
	
	        while (len) {
	            diff = len >>> 1;
	            current = i + diff;
	            if (func(array[current])) {
	                i = current + 1;
	                len -= diff + 1;
	            } else {
	                len = diff;
	            }
	        }
	        return i;
	    }
	    ignoreJSHintError(lowerBound);
	
	    objectCreate = Object.create || (function () {
	        function F() { }
	
	        return function (o) {
	            F.prototype = o;
	            return new F();
	        };
	    })();
	
	    objectKeys = Object.keys || function (o) {
	        var keys = [], key;
	        for (key in o) {
	            keys.push(key);
	        }
	        return keys;
	    };
	
	    function extend(to, from) {
	        var keys = objectKeys(from), key, i, len;
	        for (i = 0, len = keys.length; i < len; i += 1) {
	            key = keys[i];
	            to[key] = from[key];
	        }
	        return to;
	    }
	
	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        AwaitExpression: 'AwaitExpression', // CAUTION: It's deferred to ES7.
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ComprehensionBlock: 'ComprehensionBlock',  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: 'ComprehensionExpression',  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        DirectiveStatement: 'DirectiveStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForInStatement: 'ForInStatement',
	        ForOfStatement: 'ForOfStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        GeneratorExpression: 'GeneratorExpression',  // CAUTION: It's deferred to ES7.
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        ModuleSpecifier: 'ModuleSpecifier',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchStatement: 'SwitchStatement',
	        SwitchCase: 'SwitchCase',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };
	
	    VisitorKeys = {
	        AssignmentExpression: ['left', 'right'],
	        AssignmentPattern: ['left', 'right'],
	        ArrayExpression: ['elements'],
	        ArrayPattern: ['elements'],
	        ArrowFunctionExpression: ['params', 'body'],
	        AwaitExpression: ['argument'], // CAUTION: It's deferred to ES7.
	        BlockStatement: ['body'],
	        BinaryExpression: ['left', 'right'],
	        BreakStatement: ['label'],
	        CallExpression: ['callee', 'arguments'],
	        CatchClause: ['param', 'body'],
	        ClassBody: ['body'],
	        ClassDeclaration: ['id', 'superClass', 'body'],
	        ClassExpression: ['id', 'superClass', 'body'],
	        ComprehensionBlock: ['left', 'right'],  // CAUTION: It's deferred to ES7.
	        ComprehensionExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        ConditionalExpression: ['test', 'consequent', 'alternate'],
	        ContinueStatement: ['label'],
	        DebuggerStatement: [],
	        DirectiveStatement: [],
	        DoWhileStatement: ['body', 'test'],
	        EmptyStatement: [],
	        ExportAllDeclaration: ['source'],
	        ExportDefaultDeclaration: ['declaration'],
	        ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
	        ExportSpecifier: ['exported', 'local'],
	        ExpressionStatement: ['expression'],
	        ForStatement: ['init', 'test', 'update', 'body'],
	        ForInStatement: ['left', 'right', 'body'],
	        ForOfStatement: ['left', 'right', 'body'],
	        FunctionDeclaration: ['id', 'params', 'body'],
	        FunctionExpression: ['id', 'params', 'body'],
	        GeneratorExpression: ['blocks', 'filter', 'body'],  // CAUTION: It's deferred to ES7.
	        Identifier: [],
	        IfStatement: ['test', 'consequent', 'alternate'],
	        ImportDeclaration: ['specifiers', 'source'],
	        ImportDefaultSpecifier: ['local'],
	        ImportNamespaceSpecifier: ['local'],
	        ImportSpecifier: ['imported', 'local'],
	        Literal: [],
	        LabeledStatement: ['label', 'body'],
	        LogicalExpression: ['left', 'right'],
	        MemberExpression: ['object', 'property'],
	        MetaProperty: ['meta', 'property'],
	        MethodDefinition: ['key', 'value'],
	        ModuleSpecifier: [],
	        NewExpression: ['callee', 'arguments'],
	        ObjectExpression: ['properties'],
	        ObjectPattern: ['properties'],
	        Program: ['body'],
	        Property: ['key', 'value'],
	        RestElement: [ 'argument' ],
	        ReturnStatement: ['argument'],
	        SequenceExpression: ['expressions'],
	        SpreadElement: ['argument'],
	        Super: [],
	        SwitchStatement: ['discriminant', 'cases'],
	        SwitchCase: ['test', 'consequent'],
	        TaggedTemplateExpression: ['tag', 'quasi'],
	        TemplateElement: [],
	        TemplateLiteral: ['quasis', 'expressions'],
	        ThisExpression: [],
	        ThrowStatement: ['argument'],
	        TryStatement: ['block', 'handler', 'finalizer'],
	        UnaryExpression: ['argument'],
	        UpdateExpression: ['argument'],
	        VariableDeclaration: ['declarations'],
	        VariableDeclarator: ['id', 'init'],
	        WhileStatement: ['test', 'body'],
	        WithStatement: ['object', 'body'],
	        YieldExpression: ['argument']
	    };
	
	    // unique id
	    BREAK = {};
	    SKIP = {};
	    REMOVE = {};
	
	    VisitorOption = {
	        Break: BREAK,
	        Skip: SKIP,
	        Remove: REMOVE
	    };
	
	    function Reference(parent, key) {
	        this.parent = parent;
	        this.key = key;
	    }
	
	    Reference.prototype.replace = function replace(node) {
	        this.parent[this.key] = node;
	    };
	
	    Reference.prototype.remove = function remove() {
	        if (isArray(this.parent)) {
	            this.parent.splice(this.key, 1);
	            return true;
	        } else {
	            this.replace(null);
	            return false;
	        }
	    };
	
	    function Element(node, path, wrap, ref) {
	        this.node = node;
	        this.path = path;
	        this.wrap = wrap;
	        this.ref = ref;
	    }
	
	    function Controller() { }
	
	    // API:
	    // return property path array from root to current node
	    Controller.prototype.path = function path() {
	        var i, iz, j, jz, result, element;
	
	        function addToPath(result, path) {
	            if (isArray(path)) {
	                for (j = 0, jz = path.length; j < jz; ++j) {
	                    result.push(path[j]);
	                }
	            } else {
	                result.push(path);
	            }
	        }
	
	        // root node
	        if (!this.__current.path) {
	            return null;
	        }
	
	        // first node is sentinel, second node is root element
	        result = [];
	        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
	            element = this.__leavelist[i];
	            addToPath(result, element.path);
	        }
	        addToPath(result, this.__current.path);
	        return result;
	    };
	
	    // API:
	    // return type of current node
	    Controller.prototype.type = function () {
	        var node = this.current();
	        return node.type || this.__current.wrap;
	    };
	
	    // API:
	    // return array of parent elements
	    Controller.prototype.parents = function parents() {
	        var i, iz, result;
	
	        // first node is sentinel
	        result = [];
	        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
	            result.push(this.__leavelist[i].node);
	        }
	
	        return result;
	    };
	
	    // API:
	    // return current node
	    Controller.prototype.current = function current() {
	        return this.__current.node;
	    };
	
	    Controller.prototype.__execute = function __execute(callback, element) {
	        var previous, result;
	
	        result = undefined;
	
	        previous  = this.__current;
	        this.__current = element;
	        this.__state = null;
	        if (callback) {
	            result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
	        }
	        this.__current = previous;
	
	        return result;
	    };
	
	    // API:
	    // notify control skip / break
	    Controller.prototype.notify = function notify(flag) {
	        this.__state = flag;
	    };
	
	    // API:
	    // skip child nodes of current node
	    Controller.prototype.skip = function () {
	        this.notify(SKIP);
	    };
	
	    // API:
	    // break traversals
	    Controller.prototype['break'] = function () {
	        this.notify(BREAK);
	    };
	
	    // API:
	    // remove node
	    Controller.prototype.remove = function () {
	        this.notify(REMOVE);
	    };
	
	    Controller.prototype.__initialize = function(root, visitor) {
	        this.visitor = visitor;
	        this.root = root;
	        this.__worklist = [];
	        this.__leavelist = [];
	        this.__current = null;
	        this.__state = null;
	        this.__fallback = visitor.fallback === 'iteration';
	        this.__keys = VisitorKeys;
	        if (visitor.keys) {
	            this.__keys = extend(objectCreate(this.__keys), visitor.keys);
	        }
	    };
	
	    function isNode(node) {
	        if (node == null) {
	            return false;
	        }
	        return typeof node === 'object' && typeof node.type === 'string';
	    }
	
	    function isProperty(nodeType, key) {
	        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
	    }
	
	    Controller.prototype.traverse = function traverse(root, visitor) {
	        var worklist,
	            leavelist,
	            element,
	            node,
	            nodeType,
	            ret,
	            key,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel;
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        worklist.push(new Element(root, null, null, null));
	        leavelist.push(new Element(null, null, null, null));
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                ret = this.__execute(visitor.leave, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	                continue;
	            }
	
	            if (element.node) {
	
	                ret = this.__execute(visitor.enter, element);
	
	                if (this.__state === BREAK || ret === BREAK) {
	                    return;
	                }
	
	                worklist.push(sentinel);
	                leavelist.push(element);
	
	                if (this.__state === SKIP || ret === SKIP) {
	                    continue;
	                }
	
	                node = element.node;
	                nodeType = node.type || element.wrap;
	                candidates = this.__keys[nodeType];
	                if (!candidates) {
	                    if (this.__fallback) {
	                        candidates = objectKeys(node);
	                    } else {
	                        throw new Error('Unknown node type ' + nodeType + '.');
	                    }
	                }
	
	                current = candidates.length;
	                while ((current -= 1) >= 0) {
	                    key = candidates[current];
	                    candidate = node[key];
	                    if (!candidate) {
	                        continue;
	                    }
	
	                    if (isArray(candidate)) {
	                        current2 = candidate.length;
	                        while ((current2 -= 1) >= 0) {
	                            if (!candidate[current2]) {
	                                continue;
	                            }
	                            if (isProperty(nodeType, candidates[current])) {
	                                element = new Element(candidate[current2], [key, current2], 'Property', null);
	                            } else if (isNode(candidate[current2])) {
	                                element = new Element(candidate[current2], [key, current2], null, null);
	                            } else {
	                                continue;
	                            }
	                            worklist.push(element);
	                        }
	                    } else if (isNode(candidate)) {
	                        worklist.push(new Element(candidate, key, null, null));
	                    }
	                }
	            }
	        }
	    };
	
	    Controller.prototype.replace = function replace(root, visitor) {
	        function removeElem(element) {
	            var i,
	                key,
	                nextElem,
	                parent;
	
	            if (element.ref.remove()) {
	                // When the reference is an element of an array.
	                key = element.ref.key;
	                parent = element.ref.parent;
	
	                // If removed from array, then decrease following items' keys.
	                i = worklist.length;
	                while (i--) {
	                    nextElem = worklist[i];
	                    if (nextElem.ref && nextElem.ref.parent === parent) {
	                        if  (nextElem.ref.key < key) {
	                            break;
	                        }
	                        --nextElem.ref.key;
	                    }
	                }
	            }
	        }
	
	        var worklist,
	            leavelist,
	            node,
	            nodeType,
	            target,
	            element,
	            current,
	            current2,
	            candidates,
	            candidate,
	            sentinel,
	            outer,
	            key;
	
	        this.__initialize(root, visitor);
	
	        sentinel = {};
	
	        // reference
	        worklist = this.__worklist;
	        leavelist = this.__leavelist;
	
	        // initialize
	        outer = {
	            root: root
	        };
	        element = new Element(root, null, null, new Reference(outer, 'root'));
	        worklist.push(element);
	        leavelist.push(element);
	
	        while (worklist.length) {
	            element = worklist.pop();
	
	            if (element === sentinel) {
	                element = leavelist.pop();
	
	                target = this.__execute(visitor.leave, element);
	
	                // node may be replaced with null,
	                // so distinguish between undefined and null in this place
	                if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                    // replace
	                    element.ref.replace(target);
	                }
	
	                if (this.__state === REMOVE || target === REMOVE) {
	                    removeElem(element);
	                }
	
	                if (this.__state === BREAK || target === BREAK) {
	                    return outer.root;
	                }
	                continue;
	            }
	
	            target = this.__execute(visitor.enter, element);
	
	            // node may be replaced with null,
	            // so distinguish between undefined and null in this place
	            if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
	                // replace
	                element.ref.replace(target);
	                element.node = target;
	            }
	
	            if (this.__state === REMOVE || target === REMOVE) {
	                removeElem(element);
	                element.node = null;
	            }
	
	            if (this.__state === BREAK || target === BREAK) {
	                return outer.root;
	            }
	
	            // node may be null
	            node = element.node;
	            if (!node) {
	                continue;
	            }
	
	            worklist.push(sentinel);
	            leavelist.push(element);
	
	            if (this.__state === SKIP || target === SKIP) {
	                continue;
	            }
	
	            nodeType = node.type || element.wrap;
	            candidates = this.__keys[nodeType];
	            if (!candidates) {
	                if (this.__fallback) {
	                    candidates = objectKeys(node);
	                } else {
	                    throw new Error('Unknown node type ' + nodeType + '.');
	                }
	            }
	
	            current = candidates.length;
	            while ((current -= 1) >= 0) {
	                key = candidates[current];
	                candidate = node[key];
	                if (!candidate) {
	                    continue;
	                }
	
	                if (isArray(candidate)) {
	                    current2 = candidate.length;
	                    while ((current2 -= 1) >= 0) {
	                        if (!candidate[current2]) {
	                            continue;
	                        }
	                        if (isProperty(nodeType, candidates[current])) {
	                            element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
	                        } else if (isNode(candidate[current2])) {
	                            element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
	                        } else {
	                            continue;
	                        }
	                        worklist.push(element);
	                    }
	                } else if (isNode(candidate)) {
	                    worklist.push(new Element(candidate, key, null, new Reference(node, key)));
	                }
	            }
	        }
	
	        return outer.root;
	    };
	
	    function traverse(root, visitor) {
	        var controller = new Controller();
	        return controller.traverse(root, visitor);
	    }
	
	    function replace(root, visitor) {
	        var controller = new Controller();
	        return controller.replace(root, visitor);
	    }
	
	    function extendCommentRange(comment, tokens) {
	        var target;
	
	        target = upperBound(tokens, function search(token) {
	            return token.range[0] > comment.range[0];
	        });
	
	        comment.extendedRange = [comment.range[0], comment.range[1]];
	
	        if (target !== tokens.length) {
	            comment.extendedRange[1] = tokens[target].range[0];
	        }
	
	        target -= 1;
	        if (target >= 0) {
	            comment.extendedRange[0] = tokens[target].range[1];
	        }
	
	        return comment;
	    }
	
	    function attachComments(tree, providedComments, tokens) {
	        // At first, we should calculate extended comment ranges.
	        var comments = [], comment, len, i, cursor;
	
	        if (!tree.range) {
	            throw new Error('attachComments needs range information');
	        }
	
	        // tokens array is empty, we attach comments to tree as 'leadingComments'
	        if (!tokens.length) {
	            if (providedComments.length) {
	                for (i = 0, len = providedComments.length; i < len; i += 1) {
	                    comment = deepCopy(providedComments[i]);
	                    comment.extendedRange = [0, tree.range[0]];
	                    comments.push(comment);
	                }
	                tree.leadingComments = comments;
	            }
	            return tree;
	        }
	
	        for (i = 0, len = providedComments.length; i < len; i += 1) {
	            comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
	        }
	
	        // This is based on John Freeman's implementation.
	        cursor = 0;
	        traverse(tree, {
	            enter: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (comment.extendedRange[1] > node.range[0]) {
	                        break;
	                    }
	
	                    if (comment.extendedRange[1] === node.range[0]) {
	                        if (!node.leadingComments) {
	                            node.leadingComments = [];
	                        }
	                        node.leadingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        cursor = 0;
	        traverse(tree, {
	            leave: function (node) {
	                var comment;
	
	                while (cursor < comments.length) {
	                    comment = comments[cursor];
	                    if (node.range[1] < comment.extendedRange[0]) {
	                        break;
	                    }
	
	                    if (node.range[1] === comment.extendedRange[0]) {
	                        if (!node.trailingComments) {
	                            node.trailingComments = [];
	                        }
	                        node.trailingComments.push(comment);
	                        comments.splice(cursor, 1);
	                    } else {
	                        cursor += 1;
	                    }
	                }
	
	                // already out of owned node
	                if (cursor === comments.length) {
	                    return VisitorOption.Break;
	                }
	
	                if (comments[cursor].extendedRange[0] > node.range[1]) {
	                    return VisitorOption.Skip;
	                }
	            }
	        });
	
	        return tree;
	    }
	
	    exports.version = __webpack_require__(80).version;
	    exports.Syntax = Syntax;
	    exports.traverse = traverse;
	    exports.replace = replace;
	    exports.attachComments = attachComments;
	    exports.VisitorKeys = VisitorKeys;
	    exports.VisitorOption = VisitorOption;
	    exports.Controller = Controller;
	    exports.cloneEnvironment = function () { return clone({}); };
	
	    return exports;
	}(exports));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 80 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "estraverse@~4.1.0",
					"scope": null,
					"escapedName": "estraverse",
					"name": "estraverse",
					"rawSpec": "~4.1.0",
					"spec": ">=4.1.0 <4.2.0",
					"type": "range"
				},
				"/home/joe/prog/googlejs-site/node_modules/esrecurse"
			]
		],
		"_from": "estraverse@>=4.1.0 <4.2.0",
		"_id": "estraverse@4.1.1",
		"_inCache": true,
		"_location": "/esrecurse/estraverse",
		"_nodeVersion": "4.1.1",
		"_npmUser": {
			"name": "constellation",
			"email": "utatane.tea@gmail.com"
		},
		"_npmVersion": "2.14.4",
		"_phantomChildren": {},
		"_requested": {
			"raw": "estraverse@~4.1.0",
			"scope": null,
			"escapedName": "estraverse",
			"name": "estraverse",
			"rawSpec": "~4.1.0",
			"spec": ">=4.1.0 <4.2.0",
			"type": "range"
		},
		"_requiredBy": [
			"/esrecurse"
		],
		"_resolved": "https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz",
		"_shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
		"_shrinkwrap": null,
		"_spec": "estraverse@~4.1.0",
		"_where": "/home/joe/prog/googlejs-site/node_modules/esrecurse",
		"bugs": {
			"url": "https://github.com/estools/estraverse/issues"
		},
		"dependencies": {},
		"description": "ECMAScript JS AST traversal functions",
		"devDependencies": {
			"chai": "^2.1.1",
			"coffee-script": "^1.8.0",
			"espree": "^1.11.0",
			"gulp": "^3.8.10",
			"gulp-bump": "^0.2.2",
			"gulp-filter": "^2.0.0",
			"gulp-git": "^1.0.1",
			"gulp-tag-version": "^1.2.1",
			"jshint": "^2.5.6",
			"mocha": "^2.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "f6caca728933a850ef90661d0e17982ba47111a2",
			"tarball": "https://registry.npmjs.org/estraverse/-/estraverse-4.1.1.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"gitHead": "bbcccbfe98296585e4311c8755e1d00dcd581e3c",
		"homepage": "https://github.com/estools/estraverse",
		"license": "BSD-2-Clause",
		"main": "estraverse.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "michaelficarra",
				"email": "npm@michael.ficarra.me"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "estraverse",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+ssh://git@github.com/estools/estraverse.git"
		},
		"scripts": {
			"lint": "jshint estraverse.js",
			"test": "npm run-script lint && npm run-script unit-test",
			"unit-test": "mocha --compilers coffee:coffee-script/register"
		},
		"version": "4.1.1"
	};

/***/ },
/* 81 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "esrecurse@^4.1.0",
					"scope": null,
					"escapedName": "esrecurse",
					"name": "esrecurse",
					"rawSpec": "^4.1.0",
					"spec": ">=4.1.0 <5.0.0",
					"type": "range"
				},
				"/home/joe/prog/googlejs-site/node_modules/escope"
			]
		],
		"_from": "esrecurse@>=4.1.0 <5.0.0",
		"_id": "esrecurse@4.1.0",
		"_inCache": true,
		"_location": "/esrecurse",
		"_nodeVersion": "0.12.9",
		"_npmOperationalInternal": {
			"host": "packages-13-west.internal.npmjs.com",
			"tmp": "tmp/esrecurse-4.1.0.tgz_1457712782215_0.15950557170435786"
		},
		"_npmUser": {
			"name": "nzakas",
			"email": "nicholas@nczconsulting.com"
		},
		"_npmVersion": "2.14.9",
		"_phantomChildren": {},
		"_requested": {
			"raw": "esrecurse@^4.1.0",
			"scope": null,
			"escapedName": "esrecurse",
			"name": "esrecurse",
			"rawSpec": "^4.1.0",
			"spec": ">=4.1.0 <5.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/escope"
		],
		"_resolved": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.1.0.tgz",
		"_shasum": "4713b6536adf7f2ac4f327d559e7756bff648220",
		"_shrinkwrap": null,
		"_spec": "esrecurse@^4.1.0",
		"_where": "/home/joe/prog/googlejs-site/node_modules/escope",
		"bugs": {
			"url": "https://github.com/estools/esrecurse/issues"
		},
		"dependencies": {
			"estraverse": "~4.1.0",
			"object-assign": "^4.0.1"
		},
		"description": "ECMAScript AST recursive visitor",
		"devDependencies": {
			"chai": "^3.3.0",
			"coffee-script": "^1.9.1",
			"esprima": "^2.1.0",
			"gulp": "^3.9.0",
			"gulp-bump": "^1.0.0",
			"gulp-eslint": "^1.0.0",
			"gulp-filter": "^3.0.1",
			"gulp-git": "^1.1.0",
			"gulp-mocha": "^2.1.3",
			"gulp-tag-version": "^1.2.1",
			"jsdoc": "^3.3.0-alpha10",
			"minimist": "^1.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "4713b6536adf7f2ac4f327d559e7756bff648220",
			"tarball": "https://registry.npmjs.org/esrecurse/-/esrecurse-4.1.0.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"gitHead": "63a34714834bd7ad2063054bd4abb24fb82ca667",
		"homepage": "https://github.com/estools/esrecurse",
		"license": "BSD-2-Clause",
		"main": "esrecurse.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "michaelficarra",
				"email": "npm@michael.ficarra.me"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "esrecurse",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/estools/esrecurse.git"
		},
		"scripts": {
			"lint": "gulp lint",
			"test": "gulp travis",
			"unit-test": "gulp test"
		},
		"version": "4.1.0"
	};

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _estraverse = __webpack_require__(57);
	
	var _esrecurse = __webpack_require__(77);
	
	var _esrecurse2 = _interopRequireDefault(_esrecurse);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Copyright (C) 2015 Yusuke Suzuki <utatane.tea@gmail.com>
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Redistribution and use in source and binary forms, with or without
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 modification, are permitted provided that the following conditions are met:
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions of source code must retain the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   * Redistributions in binary form must reproduce the above copyright
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     notice, this list of conditions and the following disclaimer in the
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     documentation and/or other materials provided with the distribution.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               */
	
	function getLast(xs) {
	    return xs[xs.length - 1] || null;
	}
	
	var PatternVisitor = function (_esrecurse$Visitor) {
	    _inherits(PatternVisitor, _esrecurse$Visitor);
	
	    _createClass(PatternVisitor, null, [{
	        key: 'isPattern',
	        value: function isPattern(node) {
	            var nodeType = node.type;
	            return nodeType === _estraverse.Syntax.Identifier || nodeType === _estraverse.Syntax.ObjectPattern || nodeType === _estraverse.Syntax.ArrayPattern || nodeType === _estraverse.Syntax.SpreadElement || nodeType === _estraverse.Syntax.RestElement || nodeType === _estraverse.Syntax.AssignmentPattern;
	        }
	    }]);
	
	    function PatternVisitor(options, rootPattern, callback) {
	        _classCallCheck(this, PatternVisitor);
	
	        var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(PatternVisitor).call(this, null, options));
	
	        _this.rootPattern = rootPattern;
	        _this.callback = callback;
	        _this.assignments = [];
	        _this.rightHandNodes = [];
	        _this.restElements = [];
	        return _this;
	    }
	
	    _createClass(PatternVisitor, [{
	        key: 'Identifier',
	        value: function Identifier(pattern) {
	            var lastRestElement = getLast(this.restElements);
	            this.callback(pattern, {
	                topLevel: pattern === this.rootPattern,
	                rest: lastRestElement != null && lastRestElement.argument === pattern,
	                assignments: this.assignments
	            });
	        }
	    }, {
	        key: 'Property',
	        value: function Property(property) {
	            // Computed property's key is a right hand node.
	            if (property.computed) {
	                this.rightHandNodes.push(property.key);
	            }
	
	            // If it's shorthand, its key is same as its value.
	            // If it's shorthand and has its default value, its key is same as its value.left (the value is AssignmentPattern).
	            // If it's not shorthand, the name of new variable is its value's.
	            this.visit(property.value);
	        }
	    }, {
	        key: 'ArrayPattern',
	        value: function ArrayPattern(pattern) {
	            var i, iz, element;
	            for (i = 0, iz = pattern.elements.length; i < iz; ++i) {
	                element = pattern.elements[i];
	                this.visit(element);
	            }
	        }
	    }, {
	        key: 'AssignmentPattern',
	        value: function AssignmentPattern(pattern) {
	            this.assignments.push(pattern);
	            this.visit(pattern.left);
	            this.rightHandNodes.push(pattern.right);
	            this.assignments.pop();
	        }
	    }, {
	        key: 'RestElement',
	        value: function RestElement(pattern) {
	            this.restElements.push(pattern);
	            this.visit(pattern.argument);
	            this.restElements.pop();
	        }
	    }, {
	        key: 'MemberExpression',
	        value: function MemberExpression(node) {
	            // Computed property's key is a right hand node.
	            if (node.computed) {
	                this.rightHandNodes.push(node.property);
	            }
	            // the object is only read, write to its property.
	            this.rightHandNodes.push(node.object);
	        }
	
	        //
	        // ForInStatement.left and AssignmentExpression.left are LeftHandSideExpression.
	        // By spec, LeftHandSideExpression is Pattern or MemberExpression.
	        //   (see also: https://github.com/estree/estree/pull/20#issuecomment-74584758)
	        // But espree 2.0 and esprima 2.0 parse to ArrayExpression, ObjectExpression, etc...
	        //
	
	    }, {
	        key: 'SpreadElement',
	        value: function SpreadElement(node) {
	            this.visit(node.argument);
	        }
	    }, {
	        key: 'ArrayExpression',
	        value: function ArrayExpression(node) {
	            node.elements.forEach(this.visit, this);
	        }
	    }, {
	        key: 'AssignmentExpression',
	        value: function AssignmentExpression(node) {
	            this.assignments.push(node);
	            this.visit(node.left);
	            this.rightHandNodes.push(node.right);
	            this.assignments.pop();
	        }
	    }, {
	        key: 'CallExpression',
	        value: function CallExpression(node) {
	            var _this2 = this;
	
	            // arguments are right hand nodes.
	            node.arguments.forEach(function (a) {
	                _this2.rightHandNodes.push(a);
	            });
	            this.visit(node.callee);
	        }
	    }]);
	
	    return PatternVisitor;
	}(_esrecurse2.default.Visitor);
	
	/* vim: set sw=4 ts=4 et tw=80 : */
	
	
	exports.default = PatternVisitor;
	//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhdHRlcm4tdmlzaXRvci5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQXdCQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVBLFNBQVMsT0FBVCxDQUFpQixFQUFqQixFQUFxQjtBQUNqQixXQUFPLEdBQUcsR0FBRyxNQUFILEdBQVksQ0FBWixDQUFILElBQXFCLElBQXJCLENBRFU7Q0FBckI7O0lBSXFCOzs7OztrQ0FDQSxNQUFNO0FBQ25CLGdCQUFJLFdBQVcsS0FBSyxJQUFMLENBREk7QUFFbkIsbUJBQ0ksYUFBYSxtQkFBTyxVQUFQLElBQ2IsYUFBYSxtQkFBTyxhQUFQLElBQ2IsYUFBYSxtQkFBTyxZQUFQLElBQ2IsYUFBYSxtQkFBTyxhQUFQLElBQ2IsYUFBYSxtQkFBTyxXQUFQLElBQ2IsYUFBYSxtQkFBTyxpQkFBUCxDQVJFOzs7O0FBWXZCLGFBYmlCLGNBYWpCLENBQVksT0FBWixFQUFxQixXQUFyQixFQUFrQyxRQUFsQyxFQUE0Qzs4QkFiM0IsZ0JBYTJCOzsyRUFiM0IsMkJBY1AsTUFBTSxVQUQ0Qjs7QUFFeEMsY0FBSyxXQUFMLEdBQW1CLFdBQW5CLENBRndDO0FBR3hDLGNBQUssUUFBTCxHQUFnQixRQUFoQixDQUh3QztBQUl4QyxjQUFLLFdBQUwsR0FBbUIsRUFBbkIsQ0FKd0M7QUFLeEMsY0FBSyxjQUFMLEdBQXNCLEVBQXRCLENBTHdDO0FBTXhDLGNBQUssWUFBTCxHQUFvQixFQUFwQixDQU53Qzs7S0FBNUM7O2lCQWJpQjs7bUNBc0JOLFNBQVM7QUFDaEIsZ0JBQU0sa0JBQWtCLFFBQVEsS0FBSyxZQUFMLENBQTFCLENBRFU7QUFFaEIsaUJBQUssUUFBTCxDQUFjLE9BQWQsRUFBdUI7QUFDbkIsMEJBQVUsWUFBWSxLQUFLLFdBQUw7QUFDdEIsc0JBQU0sbUJBQW1CLElBQW5CLElBQTJCLGdCQUFnQixRQUFoQixLQUE2QixPQUE3QjtBQUNqQyw2QkFBYSxLQUFLLFdBQUw7YUFIakIsRUFGZ0I7Ozs7aUNBU1gsVUFBVTs7QUFFZixnQkFBSSxTQUFTLFFBQVQsRUFBbUI7QUFDbkIscUJBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixTQUFTLEdBQVQsQ0FBekIsQ0FEbUI7YUFBdkI7Ozs7O0FBRmUsZ0JBU2YsQ0FBSyxLQUFMLENBQVcsU0FBUyxLQUFULENBQVgsQ0FUZTs7OztxQ0FZTixTQUFTO0FBQ2xCLGdCQUFJLENBQUosRUFBTyxFQUFQLEVBQVcsT0FBWCxDQURrQjtBQUVsQixpQkFBSyxJQUFJLENBQUosRUFBTyxLQUFLLFFBQVEsUUFBUixDQUFpQixNQUFqQixFQUF5QixJQUFJLEVBQUosRUFBUSxFQUFFLENBQUYsRUFBSztBQUNuRCwwQkFBVSxRQUFRLFFBQVIsQ0FBaUIsQ0FBakIsQ0FBVixDQURtRDtBQUVuRCxxQkFBSyxLQUFMLENBQVcsT0FBWCxFQUZtRDthQUF2RDs7OzswQ0FNYyxTQUFTO0FBQ3ZCLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsT0FBdEIsRUFEdUI7QUFFdkIsaUJBQUssS0FBTCxDQUFXLFFBQVEsSUFBUixDQUFYLENBRnVCO0FBR3ZCLGlCQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsUUFBUSxLQUFSLENBQXpCLENBSHVCO0FBSXZCLGlCQUFLLFdBQUwsQ0FBaUIsR0FBakIsR0FKdUI7Ozs7b0NBT2YsU0FBUztBQUNqQixpQkFBSyxZQUFMLENBQWtCLElBQWxCLENBQXVCLE9BQXZCLEVBRGlCO0FBRWpCLGlCQUFLLEtBQUwsQ0FBVyxRQUFRLFFBQVIsQ0FBWCxDQUZpQjtBQUdqQixpQkFBSyxZQUFMLENBQWtCLEdBQWxCLEdBSGlCOzs7O3lDQU1KLE1BQU07O0FBRW5CLGdCQUFJLEtBQUssUUFBTCxFQUFlO0FBQ2YscUJBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixLQUFLLFFBQUwsQ0FBekIsQ0FEZTthQUFuQjs7QUFGbUIsZ0JBTW5CLENBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixLQUFLLE1BQUwsQ0FBekIsQ0FObUI7Ozs7Ozs7Ozs7OztzQ0FnQlQsTUFBTTtBQUNoQixpQkFBSyxLQUFMLENBQVcsS0FBSyxRQUFMLENBQVgsQ0FEZ0I7Ozs7d0NBSUosTUFBTTtBQUNsQixpQkFBSyxRQUFMLENBQWMsT0FBZCxDQUFzQixLQUFLLEtBQUwsRUFBWSxJQUFsQyxFQURrQjs7Ozs2Q0FJRCxNQUFNO0FBQ3ZCLGlCQUFLLFdBQUwsQ0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsRUFEdUI7QUFFdkIsaUJBQUssS0FBTCxDQUFXLEtBQUssSUFBTCxDQUFYLENBRnVCO0FBR3ZCLGlCQUFLLGNBQUwsQ0FBb0IsSUFBcEIsQ0FBeUIsS0FBSyxLQUFMLENBQXpCLENBSHVCO0FBSXZCLGlCQUFLLFdBQUwsQ0FBaUIsR0FBakIsR0FKdUI7Ozs7dUNBT1osTUFBTTs7OztBQUVqQixpQkFBSyxTQUFMLENBQWUsT0FBZixDQUF1QixhQUFLO0FBQUUsdUJBQUssY0FBTCxDQUFvQixJQUFwQixDQUF5QixDQUF6QixFQUFGO2FBQUwsQ0FBdkIsQ0FGaUI7QUFHakIsaUJBQUssS0FBTCxDQUFXLEtBQUssTUFBTCxDQUFYLENBSGlCOzs7O1dBL0ZKO0VBQXVCLG9CQUFVLE9BQVY7Ozs7O2tCQUF2QiIsImZpbGUiOiJwYXR0ZXJuLXZpc2l0b3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBDb3B5cmlnaHQgKEMpIDIwMTUgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuXG4gIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0VcbiAgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICAoSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG4gIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICAoSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0ZcbiAgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiovXG5cbmltcG9ydCB7IFN5bnRheCB9IGZyb20gJ2VzdHJhdmVyc2UnO1xuaW1wb3J0IGVzcmVjdXJzZSBmcm9tICdlc3JlY3Vyc2UnO1xuXG5mdW5jdGlvbiBnZXRMYXN0KHhzKSB7XG4gICAgcmV0dXJuIHhzW3hzLmxlbmd0aCAtIDFdIHx8IG51bGw7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhdHRlcm5WaXNpdG9yIGV4dGVuZHMgZXNyZWN1cnNlLlZpc2l0b3Ige1xuICAgIHN0YXRpYyBpc1BhdHRlcm4obm9kZSkge1xuICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBub2RlVHlwZSA9PT0gU3ludGF4LklkZW50aWZpZXIgfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTeW50YXguT2JqZWN0UGF0dGVybiB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5BcnJheVBhdHRlcm4gfHxcbiAgICAgICAgICAgIG5vZGVUeXBlID09PSBTeW50YXguU3ByZWFkRWxlbWVudCB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5SZXN0RWxlbWVudCB8fFxuICAgICAgICAgICAgbm9kZVR5cGUgPT09IFN5bnRheC5Bc3NpZ25tZW50UGF0dGVyblxuICAgICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJvb3RQYXR0ZXJuLCBjYWxsYmFjaykge1xuICAgICAgICBzdXBlcihudWxsLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yb290UGF0dGVybiA9IHJvb3RQYXR0ZXJuO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5yaWdodEhhbmROb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLnJlc3RFbGVtZW50cyA9IFtdO1xuICAgIH1cblxuICAgIElkZW50aWZpZXIocGF0dGVybikge1xuICAgICAgICBjb25zdCBsYXN0UmVzdEVsZW1lbnQgPSBnZXRMYXN0KHRoaXMucmVzdEVsZW1lbnRzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayhwYXR0ZXJuLCB7XG4gICAgICAgICAgICB0b3BMZXZlbDogcGF0dGVybiA9PT0gdGhpcy5yb290UGF0dGVybixcbiAgICAgICAgICAgIHJlc3Q6IGxhc3RSZXN0RWxlbWVudCAhPSBudWxsICYmIGxhc3RSZXN0RWxlbWVudC5hcmd1bWVudCA9PT0gcGF0dGVybixcbiAgICAgICAgICAgIGFzc2lnbm1lbnRzOiB0aGlzLmFzc2lnbm1lbnRzXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICAgIC8vIENvbXB1dGVkIHByb3BlcnR5J3Mga2V5IGlzIGEgcmlnaHQgaGFuZCBub2RlLlxuICAgICAgICBpZiAocHJvcGVydHkuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChwcm9wZXJ0eS5rZXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBzaG9ydGhhbmQsIGl0cyBrZXkgaXMgc2FtZSBhcyBpdHMgdmFsdWUuXG4gICAgICAgIC8vIElmIGl0J3Mgc2hvcnRoYW5kIGFuZCBoYXMgaXRzIGRlZmF1bHQgdmFsdWUsIGl0cyBrZXkgaXMgc2FtZSBhcyBpdHMgdmFsdWUubGVmdCAodGhlIHZhbHVlIGlzIEFzc2lnbm1lbnRQYXR0ZXJuKS5cbiAgICAgICAgLy8gSWYgaXQncyBub3Qgc2hvcnRoYW5kLCB0aGUgbmFtZSBvZiBuZXcgdmFyaWFibGUgaXMgaXRzIHZhbHVlJ3MuXG4gICAgICAgIHRoaXMudmlzaXQocHJvcGVydHkudmFsdWUpO1xuICAgIH1cblxuICAgIEFycmF5UGF0dGVybihwYXR0ZXJuKSB7XG4gICAgICAgIHZhciBpLCBpeiwgZWxlbWVudDtcbiAgICAgICAgZm9yIChpID0gMCwgaXogPSBwYXR0ZXJuLmVsZW1lbnRzLmxlbmd0aDsgaSA8IGl6OyArK2kpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBwYXR0ZXJuLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdGhpcy52aXNpdChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEFzc2lnbm1lbnRQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cy5wdXNoKHBhdHRlcm4pO1xuICAgICAgICB0aGlzLnZpc2l0KHBhdHRlcm4ubGVmdCk7XG4gICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChwYXR0ZXJuLnJpZ2h0KTtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50cy5wb3AoKTtcbiAgICB9XG5cbiAgICBSZXN0RWxlbWVudChwYXR0ZXJuKSB7XG4gICAgICAgIHRoaXMucmVzdEVsZW1lbnRzLnB1c2gocGF0dGVybik7XG4gICAgICAgIHRoaXMudmlzaXQocGF0dGVybi5hcmd1bWVudCk7XG4gICAgICAgIHRoaXMucmVzdEVsZW1lbnRzLnBvcCgpO1xuICAgIH1cblxuICAgIE1lbWJlckV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICAvLyBDb21wdXRlZCBwcm9wZXJ0eSdzIGtleSBpcyBhIHJpZ2h0IGhhbmQgbm9kZS5cbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChub2RlLnByb3BlcnR5KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgb2JqZWN0IGlzIG9ubHkgcmVhZCwgd3JpdGUgdG8gaXRzIHByb3BlcnR5LlxuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gobm9kZS5vYmplY3QpO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gRm9ySW5TdGF0ZW1lbnQubGVmdCBhbmQgQXNzaWdubWVudEV4cHJlc3Npb24ubGVmdCBhcmUgTGVmdEhhbmRTaWRlRXhwcmVzc2lvbi5cbiAgICAvLyBCeSBzcGVjLCBMZWZ0SGFuZFNpZGVFeHByZXNzaW9uIGlzIFBhdHRlcm4gb3IgTWVtYmVyRXhwcmVzc2lvbi5cbiAgICAvLyAgIChzZWUgYWxzbzogaHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvcHVsbC8yMCNpc3N1ZWNvbW1lbnQtNzQ1ODQ3NTgpXG4gICAgLy8gQnV0IGVzcHJlZSAyLjAgYW5kIGVzcHJpbWEgMi4wIHBhcnNlIHRvIEFycmF5RXhwcmVzc2lvbiwgT2JqZWN0RXhwcmVzc2lvbiwgZXRjLi4uXG4gICAgLy9cblxuICAgIFNwcmVhZEVsZW1lbnQobm9kZSkge1xuICAgICAgICB0aGlzLnZpc2l0KG5vZGUuYXJndW1lbnQpO1xuICAgIH1cblxuICAgIEFycmF5RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIG5vZGUuZWxlbWVudHMuZm9yRWFjaCh0aGlzLnZpc2l0LCB0aGlzKTtcbiAgICB9XG5cbiAgICBBc3NpZ25tZW50RXhwcmVzc2lvbihub2RlKSB7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMucHVzaChub2RlKTtcbiAgICAgICAgdGhpcy52aXNpdChub2RlLmxlZnQpO1xuICAgICAgICB0aGlzLnJpZ2h0SGFuZE5vZGVzLnB1c2gobm9kZS5yaWdodCk7XG4gICAgICAgIHRoaXMuYXNzaWdubWVudHMucG9wKCk7XG4gICAgfVxuXG4gICAgQ2FsbEV4cHJlc3Npb24obm9kZSkge1xuICAgICAgICAvLyBhcmd1bWVudHMgYXJlIHJpZ2h0IGhhbmQgbm9kZXMuXG4gICAgICAgIG5vZGUuYXJndW1lbnRzLmZvckVhY2goYSA9PiB7IHRoaXMucmlnaHRIYW5kTm9kZXMucHVzaChhKTsgfSk7XG4gICAgICAgIHRoaXMudmlzaXQobm9kZS5jYWxsZWUpO1xuICAgIH1cbn1cblxuLyogdmltOiBzZXQgc3c9NCB0cz00IGV0IHR3PTgwIDogKi9cbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==


/***/ },
/* 83 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "escope@^3.6.0",
					"scope": null,
					"escapedName": "escope",
					"name": "escope",
					"rawSpec": "^3.6.0",
					"spec": ">=3.6.0 <4.0.0",
					"type": "range"
				},
				"/home/joe/prog/googlejs-site/node_modules/eslint"
			]
		],
		"_from": "escope@>=3.6.0 <4.0.0",
		"_id": "escope@3.6.0",
		"_inCache": true,
		"_location": "/escope",
		"_nodeVersion": "0.12.9",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/escope-3.6.0.tgz_1457720018969_0.025237560039386153"
		},
		"_npmUser": {
			"name": "nzakas",
			"email": "nicholas@nczconsulting.com"
		},
		"_npmVersion": "2.14.9",
		"_phantomChildren": {},
		"_requested": {
			"raw": "escope@^3.6.0",
			"scope": null,
			"escapedName": "escope",
			"name": "escope",
			"rawSpec": "^3.6.0",
			"spec": ">=3.6.0 <4.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/eslint"
		],
		"_resolved": "https://registry.npmjs.org/escope/-/escope-3.6.0.tgz",
		"_shasum": "e01975e812781a163a6dadfdd80398dc64c889c3",
		"_shrinkwrap": null,
		"_spec": "escope@^3.6.0",
		"_where": "/home/joe/prog/googlejs-site/node_modules/eslint",
		"bugs": {
			"url": "https://github.com/estools/escope/issues"
		},
		"dependencies": {
			"es6-map": "^0.1.3",
			"es6-weak-map": "^2.0.1",
			"esrecurse": "^4.1.0",
			"estraverse": "^4.1.1"
		},
		"description": "ECMAScript scope analyzer",
		"devDependencies": {
			"babel": "^6.3.26",
			"babel-preset-es2015": "^6.3.13",
			"babel-register": "^6.3.13",
			"browserify": "^13.0.0",
			"chai": "^3.4.1",
			"espree": "^3.1.1",
			"esprima": "^2.7.1",
			"gulp": "^3.9.0",
			"gulp-babel": "^6.1.1",
			"gulp-bump": "^1.0.0",
			"gulp-eslint": "^1.1.1",
			"gulp-espower": "^1.0.2",
			"gulp-filter": "^3.0.1",
			"gulp-git": "^1.6.1",
			"gulp-mocha": "^2.2.0",
			"gulp-plumber": "^1.0.1",
			"gulp-sourcemaps": "^1.6.0",
			"gulp-tag-version": "^1.3.0",
			"jsdoc": "^3.4.0",
			"lazypipe": "^1.0.1",
			"vinyl-source-stream": "^1.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "e01975e812781a163a6dadfdd80398dc64c889c3",
			"tarball": "https://registry.npmjs.org/escope/-/escope-3.6.0.tgz"
		},
		"engines": {
			"node": ">=0.4.0"
		},
		"gitHead": "aa35861faa76a09f01203dee3497a939d70b463c",
		"homepage": "http://github.com/estools/escope",
		"license": "BSD-2-Clause",
		"main": "lib/index.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "michaelficarra",
				"email": "npm@michael.ficarra.me"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "escope",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/estools/escope.git"
		},
		"scripts": {
			"jsdoc": "jsdoc src/*.js README.md",
			"lint": "gulp lint",
			"test": "gulp travis",
			"unit-test": "gulp test"
		},
		"version": "3.6.0"
	};

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
	  parseString = __webpack_require__(85);
	  cast = __webpack_require__(92);
	  parseType = __webpack_require__(93).parseType;
	  VERSION = '0.3.0';
	  parsedTypeParse = function(parsedType, string, options){
	    options == null && (options = {});
	    options.explicit == null && (options.explicit = false);
	    options.customTypes == null && (options.customTypes = {});
	    return cast(parseString(parsedType, string, options), parsedType, options);
	  };
	  parse = function(type, string, options){
	    return parsedTypeParse(parseType(type), string, options);
	  };
	  module.exports = {
	    VERSION: VERSION,
	    parse: parse,
	    parsedTypeParse: parsedTypeParse
	  };
	}).call(this);


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var reject, special, tokenRegex;
	  reject = __webpack_require__(86).reject;
	  function consumeOp(tokens, op){
	    if (tokens[0] === op) {
	      return tokens.shift();
	    } else {
	      throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
	    }
	  }
	  function maybeConsumeOp(tokens, op){
	    if (tokens[0] === op) {
	      return tokens.shift();
	    }
	  }
	  function consumeList(tokens, arg$, hasDelimiters){
	    var open, close, result, untilTest;
	    open = arg$[0], close = arg$[1];
	    if (hasDelimiters) {
	      consumeOp(tokens, open);
	    }
	    result = [];
	    untilTest = "," + (hasDelimiters ? close : '');
	    while (tokens.length && (hasDelimiters && tokens[0] !== close)) {
	      result.push(consumeElement(tokens, untilTest));
	      maybeConsumeOp(tokens, ',');
	    }
	    if (hasDelimiters) {
	      consumeOp(tokens, close);
	    }
	    return result;
	  }
	  function consumeArray(tokens, hasDelimiters){
	    return consumeList(tokens, ['[', ']'], hasDelimiters);
	  }
	  function consumeTuple(tokens, hasDelimiters){
	    return consumeList(tokens, ['(', ')'], hasDelimiters);
	  }
	  function consumeFields(tokens, hasDelimiters){
	    var result, untilTest, key;
	    if (hasDelimiters) {
	      consumeOp(tokens, '{');
	    }
	    result = {};
	    untilTest = "," + (hasDelimiters ? '}' : '');
	    while (tokens.length && (!hasDelimiters || tokens[0] !== '}')) {
	      key = consumeValue(tokens, ':');
	      consumeOp(tokens, ':');
	      result[key] = consumeElement(tokens, untilTest);
	      maybeConsumeOp(tokens, ',');
	    }
	    if (hasDelimiters) {
	      consumeOp(tokens, '}');
	    }
	    return result;
	  }
	  function consumeValue(tokens, untilTest){
	    var out;
	    untilTest == null && (untilTest = '');
	    out = '';
	    while (tokens.length && -1 === untilTest.indexOf(tokens[0])) {
	      out += tokens.shift();
	    }
	    return out;
	  }
	  function consumeElement(tokens, untilTest){
	    switch (tokens[0]) {
	    case '[':
	      return consumeArray(tokens, true);
	    case '(':
	      return consumeTuple(tokens, true);
	    case '{':
	      return consumeFields(tokens, true);
	    default:
	      return consumeValue(tokens, untilTest);
	    }
	  }
	  function consumeTopLevel(tokens, types, options){
	    var ref$, type, structure, origTokens, result, finalResult, x$, y$;
	    ref$ = types[0], type = ref$.type, structure = ref$.structure;
	    origTokens = tokens.concat();
	    if (!options.explicit && types.length === 1 && ((!type && structure) || (type === 'Array' || type === 'Object'))) {
	      result = structure === 'array' || type === 'Array'
	        ? consumeArray(tokens, tokens[0] === '[')
	        : structure === 'tuple'
	          ? consumeTuple(tokens, tokens[0] === '(')
	          : consumeFields(tokens, tokens[0] === '{');
	      finalResult = tokens.length ? consumeElement(structure === 'array' || type === 'Array'
	        ? (x$ = origTokens, x$.unshift('['), x$.push(']'), x$)
	        : (y$ = origTokens, y$.unshift('('), y$.push(')'), y$)) : result;
	    } else {
	      finalResult = consumeElement(tokens);
	    }
	    return finalResult;
	  }
	  special = /\[\]\(\)}{:,/.source;
	  tokenRegex = RegExp('("(?:\\\\"|[^"])*")|(\'(?:\\\\\'|[^\'])*\')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([' + special + '])|([^\\s' + special + '](?:\\s*[^\\s' + special + ']+)*)|\\s*');
	  module.exports = function(types, string, options){
	    var tokens, node;
	    options == null && (options = {});
	    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
	      return "'" + string.replace(/\\'/g, "\\\\'") + "'";
	    }
	    tokens = reject(not$, string.split(tokenRegex));
	    node = consumeTopLevel(tokens, types, options);
	    if (!node) {
	      throw new Error("Error parsing '" + string + "'.");
	    }
	    return node;
	  };
	  function not$(x){ return !x; }
	}).call(this);


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
	Func = __webpack_require__(87);
	List = __webpack_require__(88);
	Obj = __webpack_require__(89);
	Str = __webpack_require__(90);
	Num = __webpack_require__(91);
	id = function(x){
	  return x;
	};
	isType = curry$(function(type, x){
	  return toString$.call(x).slice(8, -1) === type;
	});
	replicate = curry$(function(n, x){
	  var i$, results$ = [];
	  for (i$ = 0; i$ < n; ++i$) {
	    results$.push(x);
	  }
	  return results$;
	});
	Str.empty = List.empty;
	Str.slice = List.slice;
	Str.take = List.take;
	Str.drop = List.drop;
	Str.splitAt = List.splitAt;
	Str.takeWhile = List.takeWhile;
	Str.dropWhile = List.dropWhile;
	Str.span = List.span;
	Str.breakStr = List.breakList;
	prelude = {
	  Func: Func,
	  List: List,
	  Obj: Obj,
	  Str: Str,
	  Num: Num,
	  id: id,
	  isType: isType,
	  replicate: replicate
	};
	prelude.each = List.each;
	prelude.map = List.map;
	prelude.filter = List.filter;
	prelude.compact = List.compact;
	prelude.reject = List.reject;
	prelude.partition = List.partition;
	prelude.find = List.find;
	prelude.head = List.head;
	prelude.first = List.first;
	prelude.tail = List.tail;
	prelude.last = List.last;
	prelude.initial = List.initial;
	prelude.empty = List.empty;
	prelude.reverse = List.reverse;
	prelude.difference = List.difference;
	prelude.intersection = List.intersection;
	prelude.union = List.union;
	prelude.countBy = List.countBy;
	prelude.groupBy = List.groupBy;
	prelude.fold = List.fold;
	prelude.foldl = List.foldl;
	prelude.fold1 = List.fold1;
	prelude.foldl1 = List.foldl1;
	prelude.foldr = List.foldr;
	prelude.foldr1 = List.foldr1;
	prelude.unfoldr = List.unfoldr;
	prelude.andList = List.andList;
	prelude.orList = List.orList;
	prelude.any = List.any;
	prelude.all = List.all;
	prelude.unique = List.unique;
	prelude.uniqueBy = List.uniqueBy;
	prelude.sort = List.sort;
	prelude.sortWith = List.sortWith;
	prelude.sortBy = List.sortBy;
	prelude.sum = List.sum;
	prelude.product = List.product;
	prelude.mean = List.mean;
	prelude.average = List.average;
	prelude.concat = List.concat;
	prelude.concatMap = List.concatMap;
	prelude.flatten = List.flatten;
	prelude.maximum = List.maximum;
	prelude.minimum = List.minimum;
	prelude.maximumBy = List.maximumBy;
	prelude.minimumBy = List.minimumBy;
	prelude.scan = List.scan;
	prelude.scanl = List.scanl;
	prelude.scan1 = List.scan1;
	prelude.scanl1 = List.scanl1;
	prelude.scanr = List.scanr;
	prelude.scanr1 = List.scanr1;
	prelude.slice = List.slice;
	prelude.take = List.take;
	prelude.drop = List.drop;
	prelude.splitAt = List.splitAt;
	prelude.takeWhile = List.takeWhile;
	prelude.dropWhile = List.dropWhile;
	prelude.span = List.span;
	prelude.breakList = List.breakList;
	prelude.zip = List.zip;
	prelude.zipWith = List.zipWith;
	prelude.zipAll = List.zipAll;
	prelude.zipAllWith = List.zipAllWith;
	prelude.at = List.at;
	prelude.elemIndex = List.elemIndex;
	prelude.elemIndices = List.elemIndices;
	prelude.findIndex = List.findIndex;
	prelude.findIndices = List.findIndices;
	prelude.apply = Func.apply;
	prelude.curry = Func.curry;
	prelude.flip = Func.flip;
	prelude.fix = Func.fix;
	prelude.over = Func.over;
	prelude.split = Str.split;
	prelude.join = Str.join;
	prelude.lines = Str.lines;
	prelude.unlines = Str.unlines;
	prelude.words = Str.words;
	prelude.unwords = Str.unwords;
	prelude.chars = Str.chars;
	prelude.unchars = Str.unchars;
	prelude.repeat = Str.repeat;
	prelude.capitalize = Str.capitalize;
	prelude.camelize = Str.camelize;
	prelude.dasherize = Str.dasherize;
	prelude.values = Obj.values;
	prelude.keys = Obj.keys;
	prelude.pairsToObj = Obj.pairsToObj;
	prelude.objToPairs = Obj.objToPairs;
	prelude.listsToObj = Obj.listsToObj;
	prelude.objToLists = Obj.objToLists;
	prelude.max = Num.max;
	prelude.min = Num.min;
	prelude.negate = Num.negate;
	prelude.abs = Num.abs;
	prelude.signum = Num.signum;
	prelude.quot = Num.quot;
	prelude.rem = Num.rem;
	prelude.div = Num.div;
	prelude.mod = Num.mod;
	prelude.recip = Num.recip;
	prelude.pi = Num.pi;
	prelude.tau = Num.tau;
	prelude.exp = Num.exp;
	prelude.sqrt = Num.sqrt;
	prelude.ln = Num.ln;
	prelude.pow = Num.pow;
	prelude.sin = Num.sin;
	prelude.tan = Num.tan;
	prelude.cos = Num.cos;
	prelude.acos = Num.acos;
	prelude.asin = Num.asin;
	prelude.atan = Num.atan;
	prelude.atan2 = Num.atan2;
	prelude.truncate = Num.truncate;
	prelude.round = Num.round;
	prelude.ceiling = Num.ceiling;
	prelude.floor = Num.floor;
	prelude.isItNaN = Num.isItNaN;
	prelude.even = Num.even;
	prelude.odd = Num.odd;
	prelude.gcd = Num.gcd;
	prelude.lcm = Num.lcm;
	prelude.VERSION = '1.1.2';
	module.exports = prelude;
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}

/***/ },
/* 87 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	var apply, curry, flip, fix, over, memoize, slice$ = [].slice, toString$ = {}.toString;
	apply = curry$(function(f, list){
	  return f.apply(null, list);
	});
	curry = function(f){
	  return curry$(f);
	};
	flip = curry$(function(f, x, y){
	  return f(y, x);
	});
	fix = function(f){
	  return function(g){
	    return function(){
	      return f(g(g)).apply(null, arguments);
	    };
	  }(function(g){
	    return function(){
	      return f(g(g)).apply(null, arguments);
	    };
	  });
	};
	over = curry$(function(f, g, x, y){
	  return f(g(x), g(y));
	});
	memoize = function(f){
	  var memo;
	  memo = {};
	  return function(){
	    var args, key, arg;
	    args = slice$.call(arguments);
	    key = (function(){
	      var i$, ref$, len$, results$ = [];
	      for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
	        arg = ref$[i$];
	        results$.push(arg + toString$.call(arg).slice(8, -1));
	      }
	      return results$;
	    }()).join('');
	    return memo[key] = key in memo
	      ? memo[key]
	      : f.apply(null, args);
	  };
	};
	module.exports = {
	  curry: curry,
	  flip: flip,
	  fix: fix,
	  apply: apply,
	  over: over,
	  memoize: memoize
	};
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}

/***/ },
/* 88 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
	each = curry$(function(f, xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    f(x);
	  }
	  return xs;
	});
	map = curry$(function(f, xs){
	  var i$, len$, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    results$.push(f(x));
	  }
	  return results$;
	});
	compact = function(xs){
	  var i$, len$, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (x) {
	      results$.push(x);
	    }
	  }
	  return results$;
	};
	filter = curry$(function(f, xs){
	  var i$, len$, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (f(x)) {
	      results$.push(x);
	    }
	  }
	  return results$;
	});
	reject = curry$(function(f, xs){
	  var i$, len$, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (!f(x)) {
	      results$.push(x);
	    }
	  }
	  return results$;
	});
	partition = curry$(function(f, xs){
	  var passed, failed, i$, len$, x;
	  passed = [];
	  failed = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    (f(x) ? passed : failed).push(x);
	  }
	  return [passed, failed];
	});
	find = curry$(function(f, xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (f(x)) {
	      return x;
	    }
	  }
	});
	head = first = function(xs){
	  return xs[0];
	};
	tail = function(xs){
	  if (!xs.length) {
	    return;
	  }
	  return xs.slice(1);
	};
	last = function(xs){
	  return xs[xs.length - 1];
	};
	initial = function(xs){
	  if (!xs.length) {
	    return;
	  }
	  return xs.slice(0, -1);
	};
	empty = function(xs){
	  return !xs.length;
	};
	reverse = function(xs){
	  return xs.concat().reverse();
	};
	unique = function(xs){
	  var result, i$, len$, x;
	  result = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (!in$(x, result)) {
	      result.push(x);
	    }
	  }
	  return result;
	};
	uniqueBy = curry$(function(f, xs){
	  var seen, i$, len$, x, val, results$ = [];
	  seen = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    val = f(x);
	    if (in$(val, seen)) {
	      continue;
	    }
	    seen.push(val);
	    results$.push(x);
	  }
	  return results$;
	});
	fold = foldl = curry$(function(f, memo, xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    memo = f(memo, x);
	  }
	  return memo;
	});
	fold1 = foldl1 = curry$(function(f, xs){
	  return fold(f, xs[0], xs.slice(1));
	});
	foldr = curry$(function(f, memo, xs){
	  var i$, x;
	  for (i$ = xs.length - 1; i$ >= 0; --i$) {
	    x = xs[i$];
	    memo = f(x, memo);
	  }
	  return memo;
	});
	foldr1 = curry$(function(f, xs){
	  return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
	});
	unfoldr = curry$(function(f, b){
	  var result, x, that;
	  result = [];
	  x = b;
	  while ((that = f(x)) != null) {
	    result.push(that[0]);
	    x = that[1];
	  }
	  return result;
	});
	concat = function(xss){
	  return [].concat.apply([], xss);
	};
	concatMap = curry$(function(f, xs){
	  var x;
	  return [].concat.apply([], (function(){
	    var i$, ref$, len$, results$ = [];
	    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
	      x = ref$[i$];
	      results$.push(f(x));
	    }
	    return results$;
	  }()));
	});
	flatten = function(xs){
	  var x;
	  return [].concat.apply([], (function(){
	    var i$, ref$, len$, results$ = [];
	    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
	      x = ref$[i$];
	      if (toString$.call(x).slice(8, -1) === 'Array') {
	        results$.push(flatten(x));
	      } else {
	        results$.push(x);
	      }
	    }
	    return results$;
	  }()));
	};
	difference = function(xs){
	  var yss, results, i$, len$, x, j$, len1$, ys;
	  yss = slice$.call(arguments, 1);
	  results = [];
	  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
	      ys = yss[j$];
	      if (in$(x, ys)) {
	        continue outer;
	      }
	    }
	    results.push(x);
	  }
	  return results;
	};
	intersection = function(xs){
	  var yss, results, i$, len$, x, j$, len1$, ys;
	  yss = slice$.call(arguments, 1);
	  results = [];
	  outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
	      ys = yss[j$];
	      if (!in$(x, ys)) {
	        continue outer;
	      }
	    }
	    results.push(x);
	  }
	  return results;
	};
	union = function(){
	  var xss, results, i$, len$, xs, j$, len1$, x;
	  xss = slice$.call(arguments);
	  results = [];
	  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	    xs = xss[i$];
	    for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
	      x = xs[j$];
	      if (!in$(x, results)) {
	        results.push(x);
	      }
	    }
	  }
	  return results;
	};
	countBy = curry$(function(f, xs){
	  var results, i$, len$, x, key;
	  results = {};
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    key = f(x);
	    if (key in results) {
	      results[key] += 1;
	    } else {
	      results[key] = 1;
	    }
	  }
	  return results;
	});
	groupBy = curry$(function(f, xs){
	  var results, i$, len$, x, key;
	  results = {};
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    key = f(x);
	    if (key in results) {
	      results[key].push(x);
	    } else {
	      results[key] = [x];
	    }
	  }
	  return results;
	});
	andList = function(xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (!x) {
	      return false;
	    }
	  }
	  return true;
	};
	orList = function(xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (x) {
	      return true;
	    }
	  }
	  return false;
	};
	any = curry$(function(f, xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (f(x)) {
	      return true;
	    }
	  }
	  return false;
	});
	all = curry$(function(f, xs){
	  var i$, len$, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    if (!f(x)) {
	      return false;
	    }
	  }
	  return true;
	});
	sort = function(xs){
	  return xs.concat().sort(function(x, y){
	    if (x > y) {
	      return 1;
	    } else if (x < y) {
	      return -1;
	    } else {
	      return 0;
	    }
	  });
	};
	sortWith = curry$(function(f, xs){
	  return xs.concat().sort(f);
	});
	sortBy = curry$(function(f, xs){
	  return xs.concat().sort(function(x, y){
	    if (f(x) > f(y)) {
	      return 1;
	    } else if (f(x) < f(y)) {
	      return -1;
	    } else {
	      return 0;
	    }
	  });
	});
	sum = function(xs){
	  var result, i$, len$, x;
	  result = 0;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    result += x;
	  }
	  return result;
	};
	product = function(xs){
	  var result, i$, len$, x;
	  result = 1;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    result *= x;
	  }
	  return result;
	};
	mean = average = function(xs){
	  var sum, i$, len$, x;
	  sum = 0;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    x = xs[i$];
	    sum += x;
	  }
	  return sum / xs.length;
	};
	maximum = function(xs){
	  var max, i$, ref$, len$, x;
	  max = xs[0];
	  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	    x = ref$[i$];
	    if (x > max) {
	      max = x;
	    }
	  }
	  return max;
	};
	minimum = function(xs){
	  var min, i$, ref$, len$, x;
	  min = xs[0];
	  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	    x = ref$[i$];
	    if (x < min) {
	      min = x;
	    }
	  }
	  return min;
	};
	maximumBy = curry$(function(f, xs){
	  var max, i$, ref$, len$, x;
	  max = xs[0];
	  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	    x = ref$[i$];
	    if (f(x) > f(max)) {
	      max = x;
	    }
	  }
	  return max;
	});
	minimumBy = curry$(function(f, xs){
	  var min, i$, ref$, len$, x;
	  min = xs[0];
	  for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
	    x = ref$[i$];
	    if (f(x) < f(min)) {
	      min = x;
	    }
	  }
	  return min;
	});
	scan = scanl = curry$(function(f, memo, xs){
	  var last, x;
	  last = memo;
	  return [memo].concat((function(){
	    var i$, ref$, len$, results$ = [];
	    for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
	      x = ref$[i$];
	      results$.push(last = f(last, x));
	    }
	    return results$;
	  }()));
	});
	scan1 = scanl1 = curry$(function(f, xs){
	  if (!xs.length) {
	    return;
	  }
	  return scan(f, xs[0], xs.slice(1));
	});
	scanr = curry$(function(f, memo, xs){
	  xs = xs.concat().reverse();
	  return scan(f, memo, xs).reverse();
	});
	scanr1 = curry$(function(f, xs){
	  if (!xs.length) {
	    return;
	  }
	  xs = xs.concat().reverse();
	  return scan(f, xs[0], xs.slice(1)).reverse();
	});
	slice = curry$(function(x, y, xs){
	  return xs.slice(x, y);
	});
	take = curry$(function(n, xs){
	  if (n <= 0) {
	    return xs.slice(0, 0);
	  } else {
	    return xs.slice(0, n);
	  }
	});
	drop = curry$(function(n, xs){
	  if (n <= 0) {
	    return xs;
	  } else {
	    return xs.slice(n);
	  }
	});
	splitAt = curry$(function(n, xs){
	  return [take(n, xs), drop(n, xs)];
	});
	takeWhile = curry$(function(p, xs){
	  var len, i;
	  len = xs.length;
	  if (!len) {
	    return xs;
	  }
	  i = 0;
	  while (i < len && p(xs[i])) {
	    i += 1;
	  }
	  return xs.slice(0, i);
	});
	dropWhile = curry$(function(p, xs){
	  var len, i;
	  len = xs.length;
	  if (!len) {
	    return xs;
	  }
	  i = 0;
	  while (i < len && p(xs[i])) {
	    i += 1;
	  }
	  return xs.slice(i);
	});
	span = curry$(function(p, xs){
	  return [takeWhile(p, xs), dropWhile(p, xs)];
	});
	breakList = curry$(function(p, xs){
	  return span(compose$(p, not$), xs);
	});
	zip = curry$(function(xs, ys){
	  var result, len, i$, len$, i, x;
	  result = [];
	  len = ys.length;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (i === len) {
	      break;
	    }
	    result.push([x, ys[i]]);
	  }
	  return result;
	});
	zipWith = curry$(function(f, xs, ys){
	  var result, len, i$, len$, i, x;
	  result = [];
	  len = ys.length;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (i === len) {
	      break;
	    }
	    result.push(f(x, ys[i]));
	  }
	  return result;
	});
	zipAll = function(){
	  var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
	  xss = slice$.call(arguments);
	  minLength = undefined;
	  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	    xs = xss[i$];
	    minLength <= (ref$ = xs.length) || (minLength = ref$);
	  }
	  for (i$ = 0; i$ < minLength; ++i$) {
	    i = i$;
	    lresult$ = [];
	    for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
	      xs = xss[j$];
	      lresult$.push(xs[i]);
	    }
	    results$.push(lresult$);
	  }
	  return results$;
	};
	zipAllWith = function(f){
	  var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
	  xss = slice$.call(arguments, 1);
	  minLength = undefined;
	  for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
	    xs = xss[i$];
	    minLength <= (ref$ = xs.length) || (minLength = ref$);
	  }
	  for (i$ = 0; i$ < minLength; ++i$) {
	    i = i$;
	    results$.push(f.apply(null, (fn$())));
	  }
	  return results$;
	  function fn$(){
	    var i$, ref$, len$, results$ = [];
	    for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
	      xs = ref$[i$];
	      results$.push(xs[i]);
	    }
	    return results$;
	  }
	};
	at = curry$(function(n, xs){
	  if (n < 0) {
	    return xs[xs.length + n];
	  } else {
	    return xs[n];
	  }
	});
	elemIndex = curry$(function(el, xs){
	  var i$, len$, i, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (x === el) {
	      return i;
	    }
	  }
	});
	elemIndices = curry$(function(el, xs){
	  var i$, len$, i, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (x === el) {
	      results$.push(i);
	    }
	  }
	  return results$;
	});
	findIndex = curry$(function(f, xs){
	  var i$, len$, i, x;
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (f(x)) {
	      return i;
	    }
	  }
	});
	findIndices = curry$(function(f, xs){
	  var i$, len$, i, x, results$ = [];
	  for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
	    i = i$;
	    x = xs[i$];
	    if (f(x)) {
	      results$.push(i);
	    }
	  }
	  return results$;
	});
	module.exports = {
	  each: each,
	  map: map,
	  filter: filter,
	  compact: compact,
	  reject: reject,
	  partition: partition,
	  find: find,
	  head: head,
	  first: first,
	  tail: tail,
	  last: last,
	  initial: initial,
	  empty: empty,
	  reverse: reverse,
	  difference: difference,
	  intersection: intersection,
	  union: union,
	  countBy: countBy,
	  groupBy: groupBy,
	  fold: fold,
	  fold1: fold1,
	  foldl: foldl,
	  foldl1: foldl1,
	  foldr: foldr,
	  foldr1: foldr1,
	  unfoldr: unfoldr,
	  andList: andList,
	  orList: orList,
	  any: any,
	  all: all,
	  unique: unique,
	  uniqueBy: uniqueBy,
	  sort: sort,
	  sortWith: sortWith,
	  sortBy: sortBy,
	  sum: sum,
	  product: product,
	  mean: mean,
	  average: average,
	  concat: concat,
	  concatMap: concatMap,
	  flatten: flatten,
	  maximum: maximum,
	  minimum: minimum,
	  maximumBy: maximumBy,
	  minimumBy: minimumBy,
	  scan: scan,
	  scan1: scan1,
	  scanl: scanl,
	  scanl1: scanl1,
	  scanr: scanr,
	  scanr1: scanr1,
	  slice: slice,
	  take: take,
	  drop: drop,
	  splitAt: splitAt,
	  takeWhile: takeWhile,
	  dropWhile: dropWhile,
	  span: span,
	  breakList: breakList,
	  zip: zip,
	  zipWith: zipWith,
	  zipAll: zipAll,
	  zipAllWith: zipAllWith,
	  at: at,
	  elemIndex: elemIndex,
	  elemIndices: elemIndices,
	  findIndex: findIndex,
	  findIndices: findIndices
	};
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}
	function in$(x, xs){
	  var i = -1, l = xs.length >>> 0;
	  while (++i < l) if (x === xs[i]) return true;
	  return false;
	}
	function compose$() {
	  var functions = arguments;
	  return function() {
	    var i, result;
	    result = functions[0].apply(this, arguments);
	    for (i = 1; i < functions.length; ++i) {
	      result = functions[i](result);
	    }
	    return result;
	  };
	}
	function not$(x){ return !x; }

/***/ },
/* 89 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
	values = function(object){
	  var i$, x, results$ = [];
	  for (i$ in object) {
	    x = object[i$];
	    results$.push(x);
	  }
	  return results$;
	};
	keys = function(object){
	  var x, results$ = [];
	  for (x in object) {
	    results$.push(x);
	  }
	  return results$;
	};
	pairsToObj = function(object){
	  var i$, len$, x, resultObj$ = {};
	  for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
	    x = object[i$];
	    resultObj$[x[0]] = x[1];
	  }
	  return resultObj$;
	};
	objToPairs = function(object){
	  var key, value, results$ = [];
	  for (key in object) {
	    value = object[key];
	    results$.push([key, value]);
	  }
	  return results$;
	};
	listsToObj = curry$(function(keys, values){
	  var i$, len$, i, key, resultObj$ = {};
	  for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
	    i = i$;
	    key = keys[i$];
	    resultObj$[key] = values[i];
	  }
	  return resultObj$;
	});
	objToLists = function(object){
	  var keys, values, key, value;
	  keys = [];
	  values = [];
	  for (key in object) {
	    value = object[key];
	    keys.push(key);
	    values.push(value);
	  }
	  return [keys, values];
	};
	empty = function(object){
	  var x;
	  for (x in object) {
	    return false;
	  }
	  return true;
	};
	each = curry$(function(f, object){
	  var i$, x;
	  for (i$ in object) {
	    x = object[i$];
	    f(x);
	  }
	  return object;
	});
	map = curry$(function(f, object){
	  var k, x, resultObj$ = {};
	  for (k in object) {
	    x = object[k];
	    resultObj$[k] = f(x);
	  }
	  return resultObj$;
	});
	compact = function(object){
	  var k, x, resultObj$ = {};
	  for (k in object) {
	    x = object[k];
	    if (x) {
	      resultObj$[k] = x;
	    }
	  }
	  return resultObj$;
	};
	filter = curry$(function(f, object){
	  var k, x, resultObj$ = {};
	  for (k in object) {
	    x = object[k];
	    if (f(x)) {
	      resultObj$[k] = x;
	    }
	  }
	  return resultObj$;
	});
	reject = curry$(function(f, object){
	  var k, x, resultObj$ = {};
	  for (k in object) {
	    x = object[k];
	    if (!f(x)) {
	      resultObj$[k] = x;
	    }
	  }
	  return resultObj$;
	});
	partition = curry$(function(f, object){
	  var passed, failed, k, x;
	  passed = {};
	  failed = {};
	  for (k in object) {
	    x = object[k];
	    (f(x) ? passed : failed)[k] = x;
	  }
	  return [passed, failed];
	});
	find = curry$(function(f, object){
	  var i$, x;
	  for (i$ in object) {
	    x = object[i$];
	    if (f(x)) {
	      return x;
	    }
	  }
	});
	module.exports = {
	  values: values,
	  keys: keys,
	  pairsToObj: pairsToObj,
	  objToPairs: objToPairs,
	  listsToObj: listsToObj,
	  objToLists: objToLists,
	  empty: empty,
	  each: each,
	  map: map,
	  filter: filter,
	  compact: compact,
	  reject: reject,
	  partition: partition,
	  find: find
	};
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}

/***/ },
/* 90 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
	split = curry$(function(sep, str){
	  return str.split(sep);
	});
	join = curry$(function(sep, xs){
	  return xs.join(sep);
	});
	lines = function(str){
	  if (!str.length) {
	    return [];
	  }
	  return str.split('\n');
	};
	unlines = function(it){
	  return it.join('\n');
	};
	words = function(str){
	  if (!str.length) {
	    return [];
	  }
	  return str.split(/[ ]+/);
	};
	unwords = function(it){
	  return it.join(' ');
	};
	chars = function(it){
	  return it.split('');
	};
	unchars = function(it){
	  return it.join('');
	};
	reverse = function(str){
	  return str.split('').reverse().join('');
	};
	repeat = curry$(function(n, str){
	  var result, i$;
	  result = '';
	  for (i$ = 0; i$ < n; ++i$) {
	    result += str;
	  }
	  return result;
	});
	capitalize = function(str){
	  return str.charAt(0).toUpperCase() + str.slice(1);
	};
	camelize = function(it){
	  return it.replace(/[-_]+(.)?/g, function(arg$, c){
	    return (c != null ? c : '').toUpperCase();
	  });
	};
	dasherize = function(str){
	  return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
	    return lower + "-" + (upper.length > 1
	      ? upper
	      : upper.toLowerCase());
	  }).replace(/^([A-Z]+)/, function(arg$, upper){
	    if (upper.length > 1) {
	      return upper + "-";
	    } else {
	      return upper.toLowerCase();
	    }
	  });
	};
	module.exports = {
	  split: split,
	  join: join,
	  lines: lines,
	  unlines: unlines,
	  words: words,
	  unwords: unwords,
	  chars: chars,
	  unchars: unchars,
	  reverse: reverse,
	  repeat: repeat,
	  capitalize: capitalize,
	  camelize: camelize,
	  dasherize: dasherize
	};
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}

/***/ },
/* 91 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
	max = curry$(function(x$, y$){
	  return x$ > y$ ? x$ : y$;
	});
	min = curry$(function(x$, y$){
	  return x$ < y$ ? x$ : y$;
	});
	negate = function(x){
	  return -x;
	};
	abs = Math.abs;
	signum = function(x){
	  if (x < 0) {
	    return -1;
	  } else if (x > 0) {
	    return 1;
	  } else {
	    return 0;
	  }
	};
	quot = curry$(function(x, y){
	  return ~~(x / y);
	});
	rem = curry$(function(x$, y$){
	  return x$ % y$;
	});
	div = curry$(function(x, y){
	  return Math.floor(x / y);
	});
	mod = curry$(function(x$, y$){
	  var ref$;
	  return (((x$) % (ref$ = y$) + ref$) % ref$);
	});
	recip = (function(it){
	  return 1 / it;
	});
	pi = Math.PI;
	tau = pi * 2;
	exp = Math.exp;
	sqrt = Math.sqrt;
	ln = Math.log;
	pow = curry$(function(x$, y$){
	  return Math.pow(x$, y$);
	});
	sin = Math.sin;
	tan = Math.tan;
	cos = Math.cos;
	asin = Math.asin;
	acos = Math.acos;
	atan = Math.atan;
	atan2 = curry$(function(x, y){
	  return Math.atan2(x, y);
	});
	truncate = function(x){
	  return ~~x;
	};
	round = Math.round;
	ceiling = Math.ceil;
	floor = Math.floor;
	isItNaN = function(x){
	  return x !== x;
	};
	even = function(x){
	  return x % 2 === 0;
	};
	odd = function(x){
	  return x % 2 !== 0;
	};
	gcd = curry$(function(x, y){
	  var z;
	  x = Math.abs(x);
	  y = Math.abs(y);
	  while (y !== 0) {
	    z = x % y;
	    x = y;
	    y = z;
	  }
	  return x;
	});
	lcm = curry$(function(x, y){
	  return Math.abs(Math.floor(x / gcd(x, y) * y));
	});
	module.exports = {
	  max: max,
	  min: min,
	  negate: negate,
	  abs: abs,
	  signum: signum,
	  quot: quot,
	  rem: rem,
	  div: div,
	  mod: mod,
	  recip: recip,
	  pi: pi,
	  tau: tau,
	  exp: exp,
	  sqrt: sqrt,
	  ln: ln,
	  pow: pow,
	  sin: sin,
	  tan: tan,
	  cos: cos,
	  acos: acos,
	  asin: asin,
	  atan: atan,
	  atan2: atan2,
	  truncate: truncate,
	  round: round,
	  ceiling: ceiling,
	  floor: floor,
	  isItNaN: isItNaN,
	  even: even,
	  odd: odd,
	  gcd: gcd,
	  lcm: lcm
	};
	function curry$(f, bound){
	  var context,
	  _curry = function(args) {
	    return f.length > 1 ? function(){
	      var params = args ? args.concat() : [];
	      context = bound ? context || this : this;
	      return params.push.apply(params, arguments) <
	          f.length && arguments.length ?
	        _curry.call(context, params) : f.apply(context, params);
	    } : f;
	  };
	  return _curry();
	}

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var parsedTypeCheck, types, toString$ = {}.toString;
	  parsedTypeCheck = __webpack_require__(93).parsedTypeCheck;
	  types = {
	    '*': function(value, options){
	      switch (toString$.call(value).slice(8, -1)) {
	      case 'Array':
	        return typeCast(value, {
	          type: 'Array'
	        }, options);
	      case 'Object':
	        return typeCast(value, {
	          type: 'Object'
	        }, options);
	      default:
	        return {
	          type: 'Just',
	          value: typesCast(value, [
	            {
	              type: 'Undefined'
	            }, {
	              type: 'Null'
	            }, {
	              type: 'NaN'
	            }, {
	              type: 'Boolean'
	            }, {
	              type: 'Number'
	            }, {
	              type: 'Date'
	            }, {
	              type: 'RegExp'
	            }, {
	              type: 'Array'
	            }, {
	              type: 'Object'
	            }, {
	              type: 'String'
	            }
	          ], (options.explicit = true, options))
	        };
	      }
	    },
	    Undefined: function(it){
	      if (it === 'undefined' || it === void 8) {
	        return {
	          type: 'Just',
	          value: void 8
	        };
	      } else {
	        return {
	          type: 'Nothing'
	        };
	      }
	    },
	    Null: function(it){
	      if (it === 'null') {
	        return {
	          type: 'Just',
	          value: null
	        };
	      } else {
	        return {
	          type: 'Nothing'
	        };
	      }
	    },
	    NaN: function(it){
	      if (it === 'NaN') {
	        return {
	          type: 'Just',
	          value: NaN
	        };
	      } else {
	        return {
	          type: 'Nothing'
	        };
	      }
	    },
	    Boolean: function(it){
	      if (it === 'true') {
	        return {
	          type: 'Just',
	          value: true
	        };
	      } else if (it === 'false') {
	        return {
	          type: 'Just',
	          value: false
	        };
	      } else {
	        return {
	          type: 'Nothing'
	        };
	      }
	    },
	    Number: function(it){
	      return {
	        type: 'Just',
	        value: +it
	      };
	    },
	    Int: function(it){
	      return {
	        type: 'Just',
	        value: +it
	      };
	    },
	    Float: function(it){
	      return {
	        type: 'Just',
	        value: +it
	      };
	    },
	    Date: function(value, options){
	      var that;
	      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
	        return {
	          type: 'Just',
	          value: new Date(+that[1] || that[1])
	        };
	      } else if (options.explicit) {
	        return {
	          type: 'Nothing'
	        };
	      } else {
	        return {
	          type: 'Just',
	          value: new Date(+value || value)
	        };
	      }
	    },
	    RegExp: function(value, options){
	      var that;
	      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
	        return {
	          type: 'Just',
	          value: new RegExp(that[1], that[2])
	        };
	      } else if (options.explicit) {
	        return {
	          type: 'Nothing'
	        };
	      } else {
	        return {
	          type: 'Just',
	          value: new RegExp(value)
	        };
	      }
	    },
	    Array: function(value, options){
	      return castArray(value, {
	        of: [{
	          type: '*'
	        }]
	      }, options);
	    },
	    Object: function(value, options){
	      return castFields(value, {
	        of: {}
	      }, options);
	    },
	    String: function(it){
	      var that;
	      if (toString$.call(it).slice(8, -1) !== 'String') {
	        return {
	          type: 'Nothing'
	        };
	      }
	      if (that = it.match(/^'([\s\S]*)'$/)) {
	        return {
	          type: 'Just',
	          value: that[1].replace(/\\'/g, "'")
	        };
	      } else if (that = it.match(/^"([\s\S]*)"$/)) {
	        return {
	          type: 'Just',
	          value: that[1].replace(/\\"/g, '"')
	        };
	      } else {
	        return {
	          type: 'Just',
	          value: it
	        };
	      }
	    }
	  };
	  function castArray(node, type, options){
	    var typeOf, element;
	    if (toString$.call(node).slice(8, -1) !== 'Array') {
	      return {
	        type: 'Nothing'
	      };
	    }
	    typeOf = type.of;
	    return {
	      type: 'Just',
	      value: (function(){
	        var i$, ref$, len$, results$ = [];
	        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
	          element = ref$[i$];
	          results$.push(typesCast(element, typeOf, options));
	        }
	        return results$;
	      }())
	    };
	  }
	  function castTuple(node, type, options){
	    var result, i, i$, ref$, len$, types, cast;
	    if (toString$.call(node).slice(8, -1) !== 'Array') {
	      return {
	        type: 'Nothing'
	      };
	    }
	    result = [];
	    i = 0;
	    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
	      types = ref$[i$];
	      cast = typesCast(node[i], types, options);
	      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
	        result.push(cast);
	      }
	      i++;
	    }
	    if (node.length <= i) {
	      return {
	        type: 'Just',
	        value: result
	      };
	    } else {
	      return {
	        type: 'Nothing'
	      };
	    }
	  }
	  function castFields(node, type, options){
	    var typeOf, key, value;
	    if (toString$.call(node).slice(8, -1) !== 'Object') {
	      return {
	        type: 'Nothing'
	      };
	    }
	    typeOf = type.of;
	    return {
	      type: 'Just',
	      value: (function(){
	        var ref$, resultObj$ = {};
	        for (key in ref$ = node) {
	          value = ref$[key];
	          resultObj$[typesCast(key, [{
	            type: 'String'
	          }], options)] = typesCast(value, typeOf[key] || [{
	            type: '*'
	          }], options);
	        }
	        return resultObj$;
	      }())
	    };
	  }
	  function typeCast(node, typeObj, options){
	    var type, structure, castFunc, ref$;
	    type = typeObj.type, structure = typeObj.structure;
	    if (type) {
	      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
	      if (!castFunc) {
	        throw new Error("Type not defined: " + type + ".");
	      }
	      return castFunc(node, options, typesCast);
	    } else {
	      switch (structure) {
	      case 'array':
	        return castArray(node, typeObj, options);
	      case 'tuple':
	        return castTuple(node, typeObj, options);
	      case 'fields':
	        return castFields(node, typeObj, options);
	      }
	    }
	  }
	  function typesCast(node, types, options){
	    var i$, len$, type, ref$, valueType, value;
	    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
	      type = types[i$];
	      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
	      if (valueType === 'Nothing') {
	        continue;
	      }
	      if (parsedTypeCheck([type], value, {
	        customTypes: options.customTypes
	      })) {
	        return value;
	      }
	    }
	    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
	  }
	  module.exports = typesCast;
	}).call(this);


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var VERSION, parseType, parsedTypeCheck, typeCheck;
	  VERSION = '0.3.2';
	  parseType = __webpack_require__(94);
	  parsedTypeCheck = __webpack_require__(95);
	  typeCheck = function(type, input, options){
	    return parsedTypeCheck(parseType(type), input, options);
	  };
	  module.exports = {
	    VERSION: VERSION,
	    typeCheck: typeCheck,
	    parsedTypeCheck: parsedTypeCheck,
	    parseType: parseType
	  };
	}).call(this);


/***/ },
/* 94 */
/***/ function(module, exports) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var identifierRegex, tokenRegex;
	  identifierRegex = /[\$\w]+/;
	  function peek(tokens){
	    var token;
	    token = tokens[0];
	    if (token == null) {
	      throw new Error('Unexpected end of input.');
	    }
	    return token;
	  }
	  function consumeIdent(tokens){
	    var token;
	    token = peek(tokens);
	    if (!identifierRegex.test(token)) {
	      throw new Error("Expected text, got '" + token + "' instead.");
	    }
	    return tokens.shift();
	  }
	  function consumeOp(tokens, op){
	    var token;
	    token = peek(tokens);
	    if (token !== op) {
	      throw new Error("Expected '" + op + "', got '" + token + "' instead.");
	    }
	    return tokens.shift();
	  }
	  function maybeConsumeOp(tokens, op){
	    var token;
	    token = tokens[0];
	    if (token === op) {
	      return tokens.shift();
	    } else {
	      return null;
	    }
	  }
	  function consumeArray(tokens){
	    var types;
	    consumeOp(tokens, '[');
	    if (peek(tokens) === ']') {
	      throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
	    }
	    types = consumeTypes(tokens);
	    consumeOp(tokens, ']');
	    return {
	      structure: 'array',
	      of: types
	    };
	  }
	  function consumeTuple(tokens){
	    var components;
	    components = [];
	    consumeOp(tokens, '(');
	    if (peek(tokens) === ')') {
	      throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
	    }
	    for (;;) {
	      components.push(consumeTypes(tokens));
	      maybeConsumeOp(tokens, ',');
	      if (')' === peek(tokens)) {
	        break;
	      }
	    }
	    consumeOp(tokens, ')');
	    return {
	      structure: 'tuple',
	      of: components
	    };
	  }
	  function consumeFields(tokens){
	    var fields, subset, ref$, key, types;
	    fields = {};
	    consumeOp(tokens, '{');
	    subset = false;
	    for (;;) {
	      if (maybeConsumeOp(tokens, '...')) {
	        subset = true;
	        break;
	      }
	      ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
	      fields[key] = types;
	      maybeConsumeOp(tokens, ',');
	      if ('}' === peek(tokens)) {
	        break;
	      }
	    }
	    consumeOp(tokens, '}');
	    return {
	      structure: 'fields',
	      of: fields,
	      subset: subset
	    };
	  }
	  function consumeField(tokens){
	    var key, types;
	    key = consumeIdent(tokens);
	    consumeOp(tokens, ':');
	    types = consumeTypes(tokens);
	    return [key, types];
	  }
	  function maybeConsumeStructure(tokens){
	    switch (tokens[0]) {
	    case '[':
	      return consumeArray(tokens);
	    case '(':
	      return consumeTuple(tokens);
	    case '{':
	      return consumeFields(tokens);
	    }
	  }
	  function consumeType(tokens){
	    var token, wildcard, type, structure;
	    token = peek(tokens);
	    wildcard = token === '*';
	    if (wildcard || identifierRegex.test(token)) {
	      type = wildcard
	        ? consumeOp(tokens, '*')
	        : consumeIdent(tokens);
	      structure = maybeConsumeStructure(tokens);
	      if (structure) {
	        return structure.type = type, structure;
	      } else {
	        return {
	          type: type
	        };
	      }
	    } else {
	      structure = maybeConsumeStructure(tokens);
	      if (!structure) {
	        throw new Error("Unexpected character: " + token);
	      }
	      return structure;
	    }
	  }
	  function consumeTypes(tokens){
	    var lookahead, types, typesSoFar, typeObj, type;
	    if ('::' === peek(tokens)) {
	      throw new Error("No comment before comment separator '::' found.");
	    }
	    lookahead = tokens[1];
	    if (lookahead != null && lookahead === '::') {
	      tokens.shift();
	      tokens.shift();
	    }
	    types = [];
	    typesSoFar = {};
	    if ('Maybe' === peek(tokens)) {
	      tokens.shift();
	      types = [
	        {
	          type: 'Undefined'
	        }, {
	          type: 'Null'
	        }
	      ];
	      typesSoFar = {
	        Undefined: true,
	        Null: true
	      };
	    }
	    for (;;) {
	      typeObj = consumeType(tokens), type = typeObj.type;
	      if (!typesSoFar[type]) {
	        types.push(typeObj);
	      }
	      typesSoFar[type] = true;
	      if (!maybeConsumeOp(tokens, '|')) {
	        break;
	      }
	    }
	    return types;
	  }
	  tokenRegex = RegExp('\\.\\.\\.|::|->|' + identifierRegex.source + '|\\S', 'g');
	  module.exports = function(input){
	    var tokens, e;
	    if (!input.length) {
	      throw new Error('No type specified.');
	    }
	    tokens = input.match(tokenRegex) || [];
	    if (in$('->', tokens)) {
	      throw new Error("Function types are not supported.\ To validate that something is a function, you may use 'Function'.");
	    }
	    try {
	      return consumeTypes(tokens);
	    } catch (e$) {
	      e = e$;
	      throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
	    }
	  };
	  function in$(x, xs){
	    var i = -1, l = xs.length >>> 0;
	    while (++i < l) if (x === xs[i]) return true;
	    return false;
	  }
	}).call(this);


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	// Generated by LiveScript 1.4.0
	(function(){
	  var ref$, any, all, isItNaN, types, defaultType, customTypes, toString$ = {}.toString;
	  ref$ = __webpack_require__(86), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
	  types = {
	    Number: {
	      typeOf: 'Number',
	      validate: function(it){
	        return !isItNaN(it);
	      }
	    },
	    NaN: {
	      typeOf: 'Number',
	      validate: isItNaN
	    },
	    Int: {
	      typeOf: 'Number',
	      validate: function(it){
	        return !isItNaN(it) && it % 1 === 0;
	      }
	    },
	    Float: {
	      typeOf: 'Number',
	      validate: function(it){
	        return !isItNaN(it);
	      }
	    },
	    Date: {
	      typeOf: 'Date',
	      validate: function(it){
	        return !isItNaN(it.getTime());
	      }
	    }
	  };
	  defaultType = {
	    array: 'Array',
	    tuple: 'Array'
	  };
	  function checkArray(input, type){
	    return all(function(it){
	      return checkMultiple(it, type.of);
	    }, input);
	  }
	  function checkTuple(input, type){
	    var i, i$, ref$, len$, types;
	    i = 0;
	    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
	      types = ref$[i$];
	      if (!checkMultiple(input[i], types)) {
	        return false;
	      }
	      i++;
	    }
	    return input.length <= i;
	  }
	  function checkFields(input, type){
	    var inputKeys, numInputKeys, k, numOfKeys, key, ref$, types;
	    inputKeys = {};
	    numInputKeys = 0;
	    for (k in input) {
	      inputKeys[k] = true;
	      numInputKeys++;
	    }
	    numOfKeys = 0;
	    for (key in ref$ = type.of) {
	      types = ref$[key];
	      if (!checkMultiple(input[key], types)) {
	        return false;
	      }
	      if (inputKeys[key]) {
	        numOfKeys++;
	      }
	    }
	    return type.subset || numInputKeys === numOfKeys;
	  }
	  function checkStructure(input, type){
	    if (!(input instanceof Object)) {
	      return false;
	    }
	    switch (type.structure) {
	    case 'fields':
	      return checkFields(input, type);
	    case 'array':
	      return checkArray(input, type);
	    case 'tuple':
	      return checkTuple(input, type);
	    }
	  }
	  function check(input, typeObj){
	    var type, structure, setting, that;
	    type = typeObj.type, structure = typeObj.structure;
	    if (type) {
	      if (type === '*') {
	        return true;
	      }
	      setting = customTypes[type] || types[type];
	      if (setting) {
	        return setting.typeOf === toString$.call(input).slice(8, -1) && setting.validate(input);
	      } else {
	        return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj));
	      }
	    } else if (structure) {
	      if (that = defaultType[structure]) {
	        if (that !== toString$.call(input).slice(8, -1)) {
	          return false;
	        }
	      }
	      return checkStructure(input, typeObj);
	    } else {
	      throw new Error("No type defined. Input: " + input + ".");
	    }
	  }
	  function checkMultiple(input, types){
	    if (toString$.call(types).slice(8, -1) !== 'Array') {
	      throw new Error("Types must be in an array. Input: " + input + ".");
	    }
	    return any(function(it){
	      return check(input, it);
	    }, types);
	  }
	  module.exports = function(parsedType, input, options){
	    options == null && (options = {});
	    customTypes = options.customTypes || {};
	    return checkMultiple(input, parsedType);
	  };
	}).call(this);


/***/ },
/* 96 */
/***/ function(module, exports) {

	module.exports = {
		"type": "Program",
		"body": [],
		"sourceType": "script",
		"range": [
			0,
			0
		],
		"loc": {
			"start": {
				"line": 0,
				"column": 0
			},
			"end": {
				"line": 0,
				"column": 0
			}
		},
		"comments": [],
		"tokens": []
	};

/***/ },
/* 97 */
/***/ function(module, exports) {

	module.exports = {
		"parser": "espree",
		"ecmaFeatures": {},
		"rules": {
			"no-alert": "off",
			"no-array-constructor": "off",
			"no-bitwise": "off",
			"no-caller": "off",
			"no-case-declarations": "error",
			"no-catch-shadow": "off",
			"no-class-assign": "error",
			"no-cond-assign": "error",
			"no-confusing-arrow": "off",
			"no-console": "error",
			"no-const-assign": "error",
			"no-constant-condition": "error",
			"no-continue": "off",
			"no-control-regex": "error",
			"no-debugger": "error",
			"no-delete-var": "error",
			"no-div-regex": "off",
			"no-dupe-args": "error",
			"no-dupe-class-members": "error",
			"no-dupe-keys": "error",
			"no-duplicate-case": "error",
			"no-duplicate-imports": "off",
			"no-else-return": "off",
			"no-empty": "error",
			"no-empty-character-class": "error",
			"no-empty-function": "off",
			"no-empty-pattern": "error",
			"no-eq-null": "off",
			"no-eval": "off",
			"no-ex-assign": "error",
			"no-extend-native": "off",
			"no-extra-bind": "off",
			"no-extra-boolean-cast": "error",
			"no-extra-label": "off",
			"no-extra-parens": "off",
			"no-extra-semi": "error",
			"no-fallthrough": "error",
			"no-floating-decimal": "off",
			"no-func-assign": "error",
			"no-global-assign": "error",
			"no-implicit-coercion": "off",
			"no-implicit-globals": "off",
			"no-implied-eval": "off",
			"no-inline-comments": "off",
			"no-inner-declarations": "error",
			"no-invalid-regexp": "error",
			"no-invalid-this": "off",
			"no-irregular-whitespace": "error",
			"no-iterator": "off",
			"no-label-var": "off",
			"no-labels": "off",
			"no-lone-blocks": "off",
			"no-lonely-if": "off",
			"no-loop-func": "off",
			"no-magic-numbers": "off",
			"no-mixed-operators": "off",
			"no-mixed-requires": "off",
			"no-mixed-spaces-and-tabs": "error",
			"no-multi-spaces": "off",
			"no-multi-str": "off",
			"no-multiple-empty-lines": "off",
			"no-native-reassign": "off",
			"no-negated-condition": "off",
			"no-negated-in-lhs": "off",
			"no-nested-ternary": "off",
			"no-new": "off",
			"no-new-func": "off",
			"no-new-object": "off",
			"no-new-require": "off",
			"no-new-symbol": "error",
			"no-new-wrappers": "off",
			"no-obj-calls": "error",
			"no-octal": "error",
			"no-octal-escape": "off",
			"no-param-reassign": "off",
			"no-path-concat": "off",
			"no-plusplus": "off",
			"no-process-env": "off",
			"no-process-exit": "off",
			"no-proto": "off",
			"no-prototype-builtins": "off",
			"no-redeclare": "error",
			"no-regex-spaces": "error",
			"no-restricted-globals": "off",
			"no-restricted-imports": "off",
			"no-restricted-modules": "off",
			"no-restricted-properties": "off",
			"no-restricted-syntax": "off",
			"no-return-assign": "off",
			"no-script-url": "off",
			"no-self-assign": "error",
			"no-self-compare": "off",
			"no-sequences": "off",
			"no-shadow": "off",
			"no-shadow-restricted-names": "off",
			"no-whitespace-before-property": "off",
			"no-spaced-func": "off",
			"no-sparse-arrays": "error",
			"no-sync": "off",
			"no-tabs": "off",
			"no-ternary": "off",
			"no-trailing-spaces": "off",
			"no-this-before-super": "error",
			"no-throw-literal": "off",
			"no-undef": "error",
			"no-undef-init": "off",
			"no-undefined": "off",
			"no-unexpected-multiline": "error",
			"no-underscore-dangle": "off",
			"no-unmodified-loop-condition": "off",
			"no-unneeded-ternary": "off",
			"no-unreachable": "error",
			"no-unsafe-finally": "error",
			"no-unsafe-negation": "error",
			"no-unused-expressions": "off",
			"no-unused-labels": "error",
			"no-unused-vars": "error",
			"no-use-before-define": "off",
			"no-useless-call": "off",
			"no-useless-computed-key": "off",
			"no-useless-concat": "off",
			"no-useless-constructor": "off",
			"no-useless-escape": "off",
			"no-useless-rename": "off",
			"no-useless-return": "off",
			"no-void": "off",
			"no-var": "off",
			"no-warning-comments": "off",
			"no-with": "off",
			"array-bracket-spacing": "off",
			"array-callback-return": "off",
			"arrow-body-style": "off",
			"arrow-parens": "off",
			"arrow-spacing": "off",
			"accessor-pairs": "off",
			"block-scoped-var": "off",
			"block-spacing": "off",
			"brace-style": "off",
			"callback-return": "off",
			"camelcase": "off",
			"class-methods-use-this": "off",
			"comma-dangle": "off",
			"comma-spacing": "off",
			"comma-style": "off",
			"complexity": "off",
			"computed-property-spacing": "off",
			"consistent-return": "off",
			"consistent-this": "off",
			"constructor-super": "error",
			"curly": "off",
			"default-case": "off",
			"dot-location": "off",
			"dot-notation": "off",
			"eol-last": "off",
			"eqeqeq": "off",
			"func-call-spacing": "off",
			"func-names": "off",
			"func-name-matching": "off",
			"func-style": "off",
			"generator-star-spacing": "off",
			"global-require": "off",
			"guard-for-in": "off",
			"handle-callback-err": "off",
			"id-blacklist": "off",
			"id-length": "off",
			"id-match": "off",
			"indent": "off",
			"init-declarations": "off",
			"jsx-quotes": "off",
			"key-spacing": "off",
			"keyword-spacing": "off",
			"linebreak-style": "off",
			"line-comment-position": "off",
			"lines-around-comment": "off",
			"lines-around-directive": "off",
			"max-depth": "off",
			"max-len": "off",
			"max-lines": "off",
			"max-nested-callbacks": "off",
			"max-params": "off",
			"max-statements": "off",
			"max-statements-per-line": "off",
			"multiline-ternary": "off",
			"new-cap": "off",
			"new-parens": "off",
			"newline-after-var": "off",
			"newline-before-return": "off",
			"newline-per-chained-call": "off",
			"object-curly-newline": "off",
			"object-curly-spacing": [
				"off",
				"never"
			],
			"object-property-newline": "off",
			"object-shorthand": "off",
			"one-var": "off",
			"one-var-declaration-per-line": "off",
			"operator-assignment": "off",
			"operator-linebreak": "off",
			"padded-blocks": "off",
			"prefer-arrow-callback": "off",
			"prefer-const": "off",
			"prefer-numeric-literals": "off",
			"prefer-reflect": "off",
			"prefer-rest-params": "off",
			"prefer-spread": "off",
			"prefer-template": "off",
			"quote-props": "off",
			"quotes": "off",
			"radix": "off",
			"require-jsdoc": "off",
			"require-yield": "error",
			"rest-spread-spacing": "off",
			"semi": "off",
			"semi-spacing": "off",
			"sort-keys": "off",
			"sort-imports": "off",
			"sort-vars": "off",
			"space-before-blocks": "off",
			"space-before-function-paren": "off",
			"space-in-parens": "off",
			"space-infix-ops": "off",
			"space-unary-ops": "off",
			"spaced-comment": "off",
			"strict": "off",
			"symbol-description": "off",
			"template-curly-spacing": "off",
			"unicode-bom": "off",
			"use-isnan": "error",
			"valid-jsdoc": "off",
			"valid-typeof": "error",
			"vars-on-top": "off",
			"wrap-iife": "off",
			"wrap-regex": "off",
			"no-template-curly-in-string": "off",
			"yield-star-spacing": "off",
			"yoda": "off"
		}
	};

/***/ },
/* 98 */
/***/ function(module, exports) {

	module.exports = {
		"rules": {
			"generator-star": [
				"generator-star-spacing"
			],
			"global-strict": [
				"strict"
			],
			"no-arrow-condition": [
				"no-confusing-arrow",
				"no-constant-condition"
			],
			"no-comma-dangle": [
				"comma-dangle"
			],
			"no-empty-class": [
				"no-empty-character-class"
			],
			"no-empty-label": [
				"no-labels"
			],
			"no-extra-strict": [
				"strict"
			],
			"no-reserved-keys": [
				"quote-props"
			],
			"no-space-before-semi": [
				"semi-spacing"
			],
			"no-wrap-func": [
				"no-extra-parens"
			],
			"space-after-function-name": [
				"space-before-function-paren"
			],
			"space-after-keywords": [
				"keyword-spacing"
			],
			"space-before-function-parentheses": [
				"space-before-function-paren"
			],
			"space-before-keywords": [
				"keyword-spacing"
			],
			"space-in-brackets": [
				"object-curly-spacing",
				"array-bracket-spacing",
				"computed-property-spacing"
			],
			"space-return-throw-case": [
				"keyword-spacing"
			],
			"space-unary-word-ops": [
				"space-unary-ops"
			],
			"spaced-line-comment": [
				"spaced-comment"
			]
		}
	};

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A class of the code path analyzer.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const assert = __webpack_require__(3),
	    CodePath = __webpack_require__(100),
	    CodePathSegment = __webpack_require__(102),
	    IdGenerator = __webpack_require__(108),
	    debug = __webpack_require__(103),
	    astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is a `case` node (not `default` node).
	 *
	 * @param {ASTNode} node - A `SwitchCase` node to check.
	 * @returns {boolean} `true` if the node is a `case` node (not `default` node).
	 */
	function isCaseNode(node) {
	    return Boolean(node.test);
	}
	
	/**
	 * Checks whether or not a given logical expression node goes different path
	 * between the `true` case and the `false` case.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a test of a choice statement.
	 */
	function isForkingByTrueOrFalse(node) {
	    const parent = node.parent;
	
	    switch (parent.type) {
	        case "ConditionalExpression":
	        case "IfStatement":
	        case "WhileStatement":
	        case "DoWhileStatement":
	        case "ForStatement":
	            return parent.test === node;
	
	        case "LogicalExpression":
	            return true;
	
	        default:
	            return false;
	    }
	}
	
	/**
	 * Gets the boolean value of a given literal node.
	 *
	 * This is used to detect infinity loops (e.g. `while (true) {}`).
	 * Statements preceded by an infinity loop are unreachable if the loop didn't
	 * have any `break` statement.
	 *
	 * @param {ASTNode} node - A node to get.
	 * @returns {boolean|undefined} a boolean value if the node is a Literal node,
	 *   otherwise `undefined`.
	 */
	function getBooleanValueIfSimpleConstant(node) {
	    if (node.type === "Literal") {
	        return Boolean(node.value);
	    }
	    return void 0;
	}
	
	/**
	 * Checks that a given identifier node is a reference or not.
	 *
	 * This is used to detect the first throwable node in a `try` block.
	 *
	 * @param {ASTNode} node - An Identifier node to check.
	 * @returns {boolean} `true` if the node is a reference.
	 */
	function isIdentifierReference(node) {
	    const parent = node.parent;
	
	    switch (parent.type) {
	        case "LabeledStatement":
	        case "BreakStatement":
	        case "ContinueStatement":
	        case "ArrayPattern":
	        case "RestElement":
	        case "ImportSpecifier":
	        case "ImportDefaultSpecifier":
	        case "ImportNamespaceSpecifier":
	        case "CatchClause":
	            return false;
	
	        case "FunctionDeclaration":
	        case "FunctionExpression":
	        case "ArrowFunctionExpression":
	        case "ClassDeclaration":
	        case "ClassExpression":
	        case "VariableDeclarator":
	            return parent.id !== node;
	
	        case "Property":
	        case "MethodDefinition":
	            return (
	                parent.key !== node ||
	                parent.computed ||
	                parent.shorthand
	            );
	
	        case "AssignmentPattern":
	            return parent.key !== node;
	
	        default:
	            return true;
	    }
	}
	
	/**
	 * Updates the current segment with the head segment.
	 * This is similar to local branches and tracking branches of git.
	 *
	 * To separate the current and the head is in order to not make useless segments.
	 *
	 * In this process, both "onCodePathSegmentStart" and "onCodePathSegmentEnd"
	 * events are fired.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function forwardCurrentToHead(analyzer, node) {
	    const codePath = analyzer.codePath;
	    const state = CodePath.getState(codePath);
	    const currentSegments = state.currentSegments;
	    const headSegments = state.headSegments;
	    const end = Math.max(currentSegments.length, headSegments.length);
	    let i, currentSegment, headSegment;
	
	    // Fires leaving events.
	    for (i = 0; i < end; ++i) {
	        currentSegment = currentSegments[i];
	        headSegment = headSegments[i];
	
	        if (currentSegment !== headSegment && currentSegment) {
	            debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
	
	            if (currentSegment.reachable) {
	                analyzer.emitter.emit(
	                    "onCodePathSegmentEnd",
	                    currentSegment,
	                    node);
	            }
	        }
	    }
	
	    // Update state.
	    state.currentSegments = headSegments;
	
	    // Fires entering events.
	    for (i = 0; i < end; ++i) {
	        currentSegment = currentSegments[i];
	        headSegment = headSegments[i];
	
	        if (currentSegment !== headSegment && headSegment) {
	            debug.dump(`onCodePathSegmentStart ${headSegment.id}`);
	
	            CodePathSegment.markUsed(headSegment);
	            if (headSegment.reachable) {
	                analyzer.emitter.emit(
	                    "onCodePathSegmentStart",
	                    headSegment,
	                    node);
	            }
	        }
	    }
	
	}
	
	/**
	 * Updates the current segment with empty.
	 * This is called at the last of functions or the program.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function leaveFromCurrentSegment(analyzer, node) {
	    const state = CodePath.getState(analyzer.codePath);
	    const currentSegments = state.currentSegments;
	
	    for (let i = 0; i < currentSegments.length; ++i) {
	        const currentSegment = currentSegments[i];
	
	        debug.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
	        if (currentSegment.reachable) {
	            analyzer.emitter.emit(
	                "onCodePathSegmentEnd",
	                currentSegment,
	                node);
	        }
	    }
	
	    state.currentSegments = [];
	}
	
	/**
	 * Updates the code path due to the position of a given node in the parent node
	 * thereof.
	 *
	 * For example, if the node is `parent.consequent`, this creates a fork from the
	 * current path.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function preprocess(analyzer, node) {
	    const codePath = analyzer.codePath;
	    const state = CodePath.getState(codePath);
	    const parent = node.parent;
	
	    switch (parent.type) {
	        case "LogicalExpression":
	            if (parent.right === node) {
	                state.makeLogicalRight();
	            }
	            break;
	
	        case "ConditionalExpression":
	        case "IfStatement":
	
	            /*
	             * Fork if this node is at `consequent`/`alternate`.
	             * `popForkContext()` exists at `IfStatement:exit` and
	             * `ConditionalExpression:exit`.
	             */
	            if (parent.consequent === node) {
	                state.makeIfConsequent();
	            } else if (parent.alternate === node) {
	                state.makeIfAlternate();
	            }
	            break;
	
	        case "SwitchCase":
	            if (parent.consequent[0] === node) {
	                state.makeSwitchCaseBody(false, !parent.test);
	            }
	            break;
	
	        case "TryStatement":
	            if (parent.handler === node) {
	                state.makeCatchBlock();
	            } else if (parent.finalizer === node) {
	                state.makeFinallyBlock();
	            }
	            break;
	
	        case "WhileStatement":
	            if (parent.test === node) {
	                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
	            } else {
	                assert(parent.body === node);
	                state.makeWhileBody();
	            }
	            break;
	
	        case "DoWhileStatement":
	            if (parent.body === node) {
	                state.makeDoWhileBody();
	            } else {
	                assert(parent.test === node);
	                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
	            }
	            break;
	
	        case "ForStatement":
	            if (parent.test === node) {
	                state.makeForTest(getBooleanValueIfSimpleConstant(node));
	            } else if (parent.update === node) {
	                state.makeForUpdate();
	            } else if (parent.body === node) {
	                state.makeForBody();
	            }
	            break;
	
	        case "ForInStatement":
	        case "ForOfStatement":
	            if (parent.left === node) {
	                state.makeForInOfLeft();
	            } else if (parent.right === node) {
	                state.makeForInOfRight();
	            } else {
	                assert(parent.body === node);
	                state.makeForInOfBody();
	            }
	            break;
	
	        case "AssignmentPattern":
	
	            /*
	             * Fork if this node is at `right`.
	             * `left` is executed always, so it uses the current path.
	             * `popForkContext()` exists at `AssignmentPattern:exit`.
	             */
	            if (parent.right === node) {
	                state.pushForkContext();
	                state.forkBypassPath();
	                state.forkPath();
	            }
	            break;
	
	        default:
	            break;
	    }
	}
	
	/**
	 * Updates the code path due to the type of a given node in entering.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function processCodePathToEnter(analyzer, node) {
	    let codePath = analyzer.codePath;
	    let state = codePath && CodePath.getState(codePath);
	    const parent = node.parent;
	
	    switch (node.type) {
	        case "Program":
	        case "FunctionDeclaration":
	        case "FunctionExpression":
	        case "ArrowFunctionExpression":
	            if (codePath) {
	
	                // Emits onCodePathSegmentStart events if updated.
	                forwardCurrentToHead(analyzer, node);
	                debug.dumpState(node, state, false);
	            }
	
	            // Create the code path of this scope.
	            codePath = analyzer.codePath = new CodePath(
	                analyzer.idGenerator.next(),
	                codePath,
	                analyzer.onLooped
	            );
	            state = CodePath.getState(codePath);
	
	            // Emits onCodePathStart events.
	            debug.dump(`onCodePathStart ${codePath.id}`);
	            analyzer.emitter.emit("onCodePathStart", codePath, node);
	            break;
	
	        case "LogicalExpression":
	            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
	            break;
	
	        case "ConditionalExpression":
	        case "IfStatement":
	            state.pushChoiceContext("test", false);
	            break;
	
	        case "SwitchStatement":
	            state.pushSwitchContext(
	                node.cases.some(isCaseNode),
	                astUtils.getLabel(node));
	            break;
	
	        case "TryStatement":
	            state.pushTryContext(Boolean(node.finalizer));
	            break;
	
	        case "SwitchCase":
	
	            /*
	             * Fork if this node is after the 2st node in `cases`.
	             * It's similar to `else` blocks.
	             * The next `test` node is processed in this path.
	             */
	            if (parent.discriminant !== node && parent.cases[0] !== node) {
	                state.forkPath();
	            }
	            break;
	
	        case "WhileStatement":
	        case "DoWhileStatement":
	        case "ForStatement":
	        case "ForInStatement":
	        case "ForOfStatement":
	            state.pushLoopContext(node.type, astUtils.getLabel(node));
	            break;
	
	        case "LabeledStatement":
	            if (!astUtils.isBreakableStatement(node.body)) {
	                state.pushBreakContext(false, node.label.name);
	            }
	            break;
	
	        default:
	            break;
	    }
	
	    // Emits onCodePathSegmentStart events if updated.
	    forwardCurrentToHead(analyzer, node);
	    debug.dumpState(node, state, false);
	}
	
	/**
	 * Updates the code path due to the type of a given node in leaving.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function processCodePathToExit(analyzer, node) {
	    const codePath = analyzer.codePath;
	    const state = CodePath.getState(codePath);
	    let dontForward = false;
	
	    switch (node.type) {
	        case "IfStatement":
	        case "ConditionalExpression":
	        case "LogicalExpression":
	            state.popChoiceContext();
	            break;
	
	        case "SwitchStatement":
	            state.popSwitchContext();
	            break;
	
	        case "SwitchCase":
	
	            /*
	             * This is the same as the process at the 1st `consequent` node in
	             * `preprocess` function.
	             * Must do if this `consequent` is empty.
	             */
	            if (node.consequent.length === 0) {
	                state.makeSwitchCaseBody(true, !node.test);
	            }
	            if (state.forkContext.reachable) {
	                dontForward = true;
	            }
	            break;
	
	        case "TryStatement":
	            state.popTryContext();
	            break;
	
	        case "BreakStatement":
	            forwardCurrentToHead(analyzer, node);
	            state.makeBreak(node.label && node.label.name);
	            dontForward = true;
	            break;
	
	        case "ContinueStatement":
	            forwardCurrentToHead(analyzer, node);
	            state.makeContinue(node.label && node.label.name);
	            dontForward = true;
	            break;
	
	        case "ReturnStatement":
	            forwardCurrentToHead(analyzer, node);
	            state.makeReturn();
	            dontForward = true;
	            break;
	
	        case "ThrowStatement":
	            forwardCurrentToHead(analyzer, node);
	            state.makeThrow();
	            dontForward = true;
	            break;
	
	        case "Identifier":
	            if (isIdentifierReference(node)) {
	                state.makeFirstThrowablePathInTryBlock();
	                dontForward = true;
	            }
	            break;
	
	        case "CallExpression":
	        case "MemberExpression":
	        case "NewExpression":
	            state.makeFirstThrowablePathInTryBlock();
	            break;
	
	        case "WhileStatement":
	        case "DoWhileStatement":
	        case "ForStatement":
	        case "ForInStatement":
	        case "ForOfStatement":
	            state.popLoopContext();
	            break;
	
	        case "AssignmentPattern":
	            state.popForkContext();
	            break;
	
	        case "LabeledStatement":
	            if (!astUtils.isBreakableStatement(node.body)) {
	                state.popBreakContext();
	            }
	            break;
	
	        default:
	            break;
	    }
	
	    /*
	     * Skip updating the current segment to avoid creating useless segments if
	     * the node type is the same as the parent node type.
	     */
	    if (!dontForward && (!node.parent || node.type !== node.parent.type)) {
	
	        // Emits onCodePathSegmentStart events if updated.
	        forwardCurrentToHead(analyzer, node);
	    }
	    debug.dumpState(node, state, true);
	}
	
	/**
	 * Updates the code path to finalize the current code path.
	 *
	 * @param {CodePathAnalyzer} analyzer - The instance.
	 * @param {ASTNode} node - The current AST node.
	 * @returns {void}
	 */
	function postprocess(analyzer, node) {
	    switch (node.type) {
	        case "Program":
	        case "FunctionDeclaration":
	        case "FunctionExpression":
	        case "ArrowFunctionExpression": {
	            let codePath = analyzer.codePath;
	
	            // Mark the current path as the final node.
	            CodePath.getState(codePath).makeFinal();
	
	            // Emits onCodePathSegmentEnd event of the current segments.
	            leaveFromCurrentSegment(analyzer, node);
	
	            // Emits onCodePathEnd event of this code path.
	            debug.dump(`onCodePathEnd ${codePath.id}`);
	            analyzer.emitter.emit("onCodePathEnd", codePath, node);
	            debug.dumpDot(codePath);
	
	            codePath = analyzer.codePath = analyzer.codePath.upper;
	            if (codePath) {
	                debug.dumpState(node, CodePath.getState(codePath), true);
	            }
	            break;
	        }
	
	        default:
	            break;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * The class to analyze code paths.
	 * This class implements the EventGenerator interface.
	 *
	 * @constructor
	 * @param {EventGenerator} eventGenerator - An event generator to wrap.
	 */
	function CodePathAnalyzer(eventGenerator) {
	    this.original = eventGenerator;
	    this.emitter = eventGenerator.emitter;
	    this.codePath = null;
	    this.idGenerator = new IdGenerator("s");
	    this.currentNode = null;
	    this.onLooped = this.onLooped.bind(this);
	}
	
	CodePathAnalyzer.prototype = {
	    constructor: CodePathAnalyzer,
	
	    /**
	     * Does the process to enter a given AST node.
	     * This updates state of analysis and calls `enterNode` of the wrapped.
	     *
	     * @param {ASTNode} node - A node which is entering.
	     * @returns {void}
	     */
	    enterNode(node) {
	        this.currentNode = node;
	
	        // Updates the code path due to node's position in its parent node.
	        if (node.parent) {
	            preprocess(this, node);
	        }
	
	        // Updates the code path.
	        // And emits onCodePathStart/onCodePathSegmentStart events.
	        processCodePathToEnter(this, node);
	
	        // Emits node events.
	        this.original.enterNode(node);
	
	        this.currentNode = null;
	    },
	
	    /**
	     * Does the process to leave a given AST node.
	     * This updates state of analysis and calls `leaveNode` of the wrapped.
	     *
	     * @param {ASTNode} node - A node which is leaving.
	     * @returns {void}
	     */
	    leaveNode(node) {
	        this.currentNode = node;
	
	        // Updates the code path.
	        // And emits onCodePathStart/onCodePathSegmentStart events.
	        processCodePathToExit(this, node);
	
	        // Emits node events.
	        this.original.leaveNode(node);
	
	        // Emits the last onCodePathStart/onCodePathSegmentStart events.
	        postprocess(this, node);
	
	        this.currentNode = null;
	    },
	
	    /**
	     * This is called on a code path looped.
	     * Then this raises a looped event.
	     *
	     * @param {CodePathSegment} fromSegment - A segment of prev.
	     * @param {CodePathSegment} toSegment - A segment of next.
	     * @returns {void}
	     */
	    onLooped(fromSegment, toSegment) {
	        if (fromSegment.reachable && toSegment.reachable) {
	            debug.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
	            this.emitter.emit(
	                "onCodePathSegmentLoop",
	                fromSegment,
	                toSegment,
	                this.currentNode
	            );
	        }
	    }
	};
	
	module.exports = CodePathAnalyzer;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A class of the code path.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const CodePathState = __webpack_require__(101);
	const IdGenerator = __webpack_require__(108);
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * A code path.
	 *
	 * @constructor
	 * @param {string} id - An identifier.
	 * @param {CodePath|null} upper - The code path of the upper function scope.
	 * @param {Function} onLooped - A callback function to notify looping.
	 */
	function CodePath(id, upper, onLooped) {
	
	    /**
	     * The identifier of this code path.
	     * Rules use it to store additional information of each rule.
	     * @type {string}
	     */
	    this.id = id;
	
	    /**
	     * The code path of the upper function scope.
	     * @type {CodePath|null}
	     */
	    this.upper = upper;
	
	    /**
	     * The code paths of nested function scopes.
	     * @type {CodePath[]}
	     */
	    this.childCodePaths = [];
	
	    // Initializes internal state.
	    Object.defineProperty(
	        this,
	        "internal",
	        {value: new CodePathState(new IdGenerator(`${id}_`), onLooped)});
	
	    // Adds this into `childCodePaths` of `upper`.
	    if (upper) {
	        upper.childCodePaths.push(this);
	    }
	}
	
	CodePath.prototype = {
	    constructor: CodePath,
	
	    /**
	     * The initial code path segment.
	     * @type {CodePathSegment}
	     */
	    get initialSegment() {
	        return this.internal.initialSegment;
	    },
	
	    /**
	     * Final code path segments.
	     * This array is a mix of `returnedSegments` and `thrownSegments`.
	     * @type {CodePathSegment[]}
	     */
	    get finalSegments() {
	        return this.internal.finalSegments;
	    },
	
	    /**
	     * Final code path segments which is with `return` statements.
	     * This array contains the last path segment if it's reachable.
	     * Since the reachable last path returns `undefined`.
	     * @type {CodePathSegment[]}
	     */
	    get returnedSegments() {
	        return this.internal.returnedForkContext;
	    },
	
	    /**
	     * Final code path segments which is with `throw` statements.
	     * @type {CodePathSegment[]}
	     */
	    get thrownSegments() {
	        return this.internal.thrownForkContext;
	    },
	
	    /**
	     * Current code path segments.
	     * @type {CodePathSegment[]}
	     */
	    get currentSegments() {
	        return this.internal.currentSegments;
	    },
	
	    /**
	     * Traverses all segments in this code path.
	     *
	     *     codePath.traverseSegments(function(segment, controller) {
	     *         // do something.
	     *     });
	     *
	     * This method enumerates segments in order from the head.
	     *
	     * The `controller` object has two methods.
	     *
	     * - `controller.skip()` - Skip the following segments in this branch.
	     * - `controller.break()` - Skip all following segments.
	     *
	     * @param {Object} [options] - Omittable.
	     * @param {CodePathSegment} [options.first] - The first segment to traverse.
	     * @param {CodePathSegment} [options.last] - The last segment to traverse.
	     * @param {Function} callback - A callback function.
	     * @returns {void}
	     */
	    traverseSegments(options, callback) {
	        if (typeof options === "function") {
	            callback = options;
	            options = null;
	        }
	
	        options = options || {};
	        const startSegment = options.first || this.internal.initialSegment;
	        const lastSegment = options.last;
	
	        let item = null;
	        let index = 0;
	        let end = 0;
	        let segment = null;
	        const visited = Object.create(null);
	        const stack = [[startSegment, 0]];
	        let skippedSegment = null;
	        let broken = false;
	        const controller = {
	            skip() {
	                if (stack.length <= 1) {
	                    broken = true;
	                } else {
	                    skippedSegment = stack[stack.length - 2][0];
	                }
	            },
	            break() {
	                broken = true;
	            }
	        };
	
	        /**
	         * Checks a given previous segment has been visited.
	         * @param {CodePathSegment} prevSegment - A previous segment to check.
	         * @returns {boolean} `true` if the segment has been visited.
	         */
	        function isVisited(prevSegment) {
	            return (
	                visited[prevSegment.id] ||
	                segment.isLoopedPrevSegment(prevSegment)
	            );
	        }
	
	        while (stack.length > 0) {
	            item = stack[stack.length - 1];
	            segment = item[0];
	            index = item[1];
	
	            if (index === 0) {
	
	                // Skip if this segment has been visited already.
	                if (visited[segment.id]) {
	                    stack.pop();
	                    continue;
	                }
	
	                // Skip if all previous segments have not been visited.
	                if (segment !== startSegment &&
	                    segment.prevSegments.length > 0 &&
	                    !segment.prevSegments.every(isVisited)
	                ) {
	                    stack.pop();
	                    continue;
	                }
	
	                // Reset the flag of skipping if all branches have been skipped.
	                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
	                    skippedSegment = null;
	                }
	                visited[segment.id] = true;
	
	                // Call the callback when the first time.
	                if (!skippedSegment) {
	                    callback.call(this, segment, controller); // eslint-disable-line callback-return
	                    if (segment === lastSegment) {
	                        controller.skip();
	                    }
	                    if (broken) {
	                        break;
	                    }
	                }
	            }
	
	            // Update the stack.
	            end = segment.nextSegments.length - 1;
	            if (index < end) {
	                item[1] += 1;
	                stack.push([segment.nextSegments[index], 0]);
	            } else if (index === end) {
	                item[0] = segment.nextSegments[index];
	                item[1] = 0;
	            } else {
	                stack.pop();
	            }
	        }
	    }
	};
	
	/**
	 * Gets the state of a given code path.
	 *
	 * @param {CodePath} codePath - A code path to get.
	 * @returns {CodePathState} The state of the code path.
	 */
	CodePath.getState = function getState(codePath) {
	    return codePath.internal;
	};
	
	module.exports = CodePath;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A class to manage state of generating a code path.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const CodePathSegment = __webpack_require__(102),
	    ForkContext = __webpack_require__(107);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Adds given segments into the `dest` array.
	 * If the `others` array does not includes the given segments, adds to the `all`
	 * array as well.
	 *
	 * This adds only reachable and used segments.
	 *
	 * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).
	 * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).
	 * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).
	 * @param {CodePathSegment[]} segments - Segments to add.
	 * @returns {void}
	 */
	function addToReturnedOrThrown(dest, others, all, segments) {
	    for (let i = 0; i < segments.length; ++i) {
	        const segment = segments[i];
	
	        dest.push(segment);
	        if (others.indexOf(segment) === -1) {
	            all.push(segment);
	        }
	    }
	}
	
	/**
	 * Gets a loop-context for a `continue` statement.
	 *
	 * @param {CodePathState} state - A state to get.
	 * @param {string} label - The label of a `continue` statement.
	 * @returns {LoopContext} A loop-context for a `continue` statement.
	 */
	function getContinueContext(state, label) {
	    if (!label) {
	        return state.loopContext;
	    }
	
	    let context = state.loopContext;
	
	    while (context) {
	        if (context.label === label) {
	            return context;
	        }
	        context = context.upper;
	    }
	
	    /* istanbul ignore next: foolproof (syntax error) */
	    return null;
	}
	
	/**
	 * Gets a context for a `break` statement.
	 *
	 * @param {CodePathState} state - A state to get.
	 * @param {string} label - The label of a `break` statement.
	 * @returns {LoopContext|SwitchContext} A context for a `break` statement.
	 */
	function getBreakContext(state, label) {
	    let context = state.breakContext;
	
	    while (context) {
	        if (label ? context.label === label : context.breakable) {
	            return context;
	        }
	        context = context.upper;
	    }
	
	    /* istanbul ignore next: foolproof (syntax error) */
	    return null;
	}
	
	/**
	 * Gets a context for a `return` statement.
	 *
	 * @param {CodePathState} state - A state to get.
	 * @returns {TryContext|CodePathState} A context for a `return` statement.
	 */
	function getReturnContext(state) {
	    let context = state.tryContext;
	
	    while (context) {
	        if (context.hasFinalizer && context.position !== "finally") {
	            return context;
	        }
	        context = context.upper;
	    }
	
	    return state;
	}
	
	/**
	 * Gets a context for a `throw` statement.
	 *
	 * @param {CodePathState} state - A state to get.
	 * @returns {TryContext|CodePathState} A context for a `throw` statement.
	 */
	function getThrowContext(state) {
	    let context = state.tryContext;
	
	    while (context) {
	        if (context.position === "try" ||
	            (context.hasFinalizer && context.position === "catch")
	        ) {
	            return context;
	        }
	        context = context.upper;
	    }
	
	    return state;
	}
	
	/**
	 * Removes a given element from a given array.
	 *
	 * @param {any[]} xs - An array to remove the specific element.
	 * @param {any} x - An element to be removed.
	 * @returns {void}
	 */
	function remove(xs, x) {
	    xs.splice(xs.indexOf(x), 1);
	}
	
	/**
	 * Disconnect given segments.
	 *
	 * This is used in a process for switch statements.
	 * If there is the "default" chunk before other cases, the order is different
	 * between node's and running's.
	 *
	 * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.
	 * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.
	 * @returns {void}
	 */
	function removeConnection(prevSegments, nextSegments) {
	    for (let i = 0; i < prevSegments.length; ++i) {
	        const prevSegment = prevSegments[i];
	        const nextSegment = nextSegments[i];
	
	        remove(prevSegment.nextSegments, nextSegment);
	        remove(prevSegment.allNextSegments, nextSegment);
	        remove(nextSegment.prevSegments, prevSegment);
	        remove(nextSegment.allPrevSegments, prevSegment);
	    }
	}
	
	/**
	 * Creates looping path.
	 *
	 * @param {CodePathState} state - The instance.
	 * @param {CodePathSegment[]} fromSegments - Segments which are source.
	 * @param {CodePathSegment[]} toSegments - Segments which are destination.
	 * @returns {void}
	 */
	function makeLooped(state, fromSegments, toSegments) {
	    const end = Math.min(fromSegments.length, toSegments.length);
	
	    for (let i = 0; i < end; ++i) {
	        const fromSegment = fromSegments[i];
	        const toSegment = toSegments[i];
	
	        if (toSegment.reachable) {
	            fromSegment.nextSegments.push(toSegment);
	        }
	        if (fromSegment.reachable) {
	            toSegment.prevSegments.push(fromSegment);
	        }
	        fromSegment.allNextSegments.push(toSegment);
	        toSegment.allPrevSegments.push(fromSegment);
	
	        if (toSegment.allPrevSegments.length >= 2) {
	            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
	        }
	
	        state.notifyLooped(fromSegment, toSegment);
	    }
	}
	
	/**
	 * Finalizes segments of `test` chunk of a ForStatement.
	 *
	 * - Adds `false` paths to paths which are leaving from the loop.
	 * - Sets `true` paths to paths which go to the body.
	 *
	 * @param {LoopContext} context - A loop context to modify.
	 * @param {ChoiceContext} choiceContext - A choice context of this loop.
	 * @param {CodePathSegment[]} head - The current head paths.
	 * @returns {void}
	 */
	function finalizeTestSegmentsOfFor(context, choiceContext, head) {
	    if (!choiceContext.processed) {
	        choiceContext.trueForkContext.add(head);
	        choiceContext.falseForkContext.add(head);
	    }
	
	    if (context.test !== true) {
	        context.brokenForkContext.addAll(choiceContext.falseForkContext);
	    }
	    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * A class which manages state to analyze code paths.
	 *
	 * @constructor
	 * @param {IdGenerator} idGenerator - An id generator to generate id for code
	 *   path segments.
	 * @param {Function} onLooped - A callback function to notify looping.
	 */
	function CodePathState(idGenerator, onLooped) {
	    this.idGenerator = idGenerator;
	    this.notifyLooped = onLooped;
	    this.forkContext = ForkContext.newRoot(idGenerator);
	    this.choiceContext = null;
	    this.switchContext = null;
	    this.tryContext = null;
	    this.loopContext = null;
	    this.breakContext = null;
	
	    this.currentSegments = [];
	    this.initialSegment = this.forkContext.head[0];
	
	    // returnedSegments and thrownSegments push elements into finalSegments also.
	    const final = this.finalSegments = [];
	    const returned = this.returnedForkContext = [];
	    const thrown = this.thrownForkContext = [];
	
	    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
	    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
	}
	
	CodePathState.prototype = {
	    constructor: CodePathState,
	
	    /**
	     * The head segments.
	     * @type {CodePathSegment[]}
	     */
	    get headSegments() {
	        return this.forkContext.head;
	    },
	
	    /**
	     * The parent forking context.
	     * This is used for the root of new forks.
	     * @type {ForkContext}
	     */
	    get parentForkContext() {
	        const current = this.forkContext;
	
	        return current && current.upper;
	    },
	
	    /**
	     * Creates and stacks new forking context.
	     *
	     * @param {boolean} forkLeavingPath - A flag which shows being in a
	     *   "finally" block.
	     * @returns {ForkContext} The created context.
	     */
	    pushForkContext(forkLeavingPath) {
	        this.forkContext = ForkContext.newEmpty(
	            this.forkContext,
	            forkLeavingPath
	        );
	
	        return this.forkContext;
	    },
	
	    /**
	     * Pops and merges the last forking context.
	     * @returns {ForkContext} The last context.
	     */
	    popForkContext() {
	        const lastContext = this.forkContext;
	
	        this.forkContext = lastContext.upper;
	        this.forkContext.replaceHead(lastContext.makeNext(0, -1));
	
	        return lastContext;
	    },
	
	    /**
	     * Creates a new path.
	     * @returns {void}
	     */
	    forkPath() {
	        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
	    },
	
	    /**
	     * Creates a bypass path.
	     * This is used for such as IfStatement which does not have "else" chunk.
	     *
	     * @returns {void}
	     */
	    forkBypassPath() {
	        this.forkContext.add(this.parentForkContext.head);
	    },
	
	    //--------------------------------------------------------------------------
	    // ConditionalExpression, LogicalExpression, IfStatement
	    //--------------------------------------------------------------------------
	
	    /**
	     * Creates a context for ConditionalExpression, LogicalExpression,
	     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.
	     *
	     * LogicalExpressions have cases that it goes different paths between the
	     * `true` case and the `false` case.
	     *
	     * For Example:
	     *
	     *     if (a || b) {
	     *         foo();
	     *     } else {
	     *         bar();
	     *     }
	     *
	     * In this case, `b` is evaluated always in the code path of the `else`
	     * block, but it's not so in the code path of the `if` block.
	     * So there are 3 paths.
	     *
	     *     a -> foo();
	     *     a -> b -> foo();
	     *     a -> b -> bar();
	     *
	     * @param {string} kind - A kind string.
	     *   If the new context is LogicalExpression's, this is `"&&"` or `"||"`.
	     *   If it's IfStatement's or ConditionalExpression's, this is `"test"`.
	     *   Otherwise, this is `"loop"`.
	     * @param {boolean} isForkingAsResult - A flag that shows that goes different
	     *   paths between `true` and `false`.
	     * @returns {void}
	     */
	    pushChoiceContext(kind, isForkingAsResult) {
	        this.choiceContext = {
	            upper: this.choiceContext,
	            kind,
	            isForkingAsResult,
	            trueForkContext: ForkContext.newEmpty(this.forkContext),
	            falseForkContext: ForkContext.newEmpty(this.forkContext),
	            processed: false
	        };
	    },
	
	    /**
	     * Pops the last choice context and finalizes it.
	     *
	     * @returns {ChoiceContext} The popped context.
	     */
	    popChoiceContext() {
	        const context = this.choiceContext;
	
	        this.choiceContext = context.upper;
	
	        const forkContext = this.forkContext;
	        const headSegments = forkContext.head;
	
	        switch (context.kind) {
	            case "&&":
	            case "||":
	
	                /*
	                 * If any result were not transferred from child contexts,
	                 * this sets the head segments to both cases.
	                 * The head segments are the path of the right-hand operand.
	                 */
	                if (!context.processed) {
	                    context.trueForkContext.add(headSegments);
	                    context.falseForkContext.add(headSegments);
	                }
	
	                /*
	                 * Transfers results to upper context if this context is in
	                 * test chunk.
	                 */
	                if (context.isForkingAsResult) {
	                    const parentContext = this.choiceContext;
	
	                    parentContext.trueForkContext.addAll(context.trueForkContext);
	                    parentContext.falseForkContext.addAll(context.falseForkContext);
	                    parentContext.processed = true;
	
	                    return context;
	                }
	
	                break;
	
	            case "test":
	                if (!context.processed) {
	
	                    /*
	                     * The head segments are the path of the `if` block here.
	                     * Updates the `true` path with the end of the `if` block.
	                     */
	                    context.trueForkContext.clear();
	                    context.trueForkContext.add(headSegments);
	                } else {
	
	                    /*
	                     * The head segments are the path of the `else` block here.
	                     * Updates the `false` path with the end of the `else`
	                     * block.
	                     */
	                    context.falseForkContext.clear();
	                    context.falseForkContext.add(headSegments);
	                }
	
	                break;
	
	            case "loop":
	
	                /*
	                 * Loops are addressed in popLoopContext().
	                 * This is called from popLoopContext().
	                 */
	                return context;
	
	            /* istanbul ignore next */
	            default:
	                throw new Error("unreachable");
	        }
	
	        // Merges all paths.
	        const prevForkContext = context.trueForkContext;
	
	        prevForkContext.addAll(context.falseForkContext);
	        forkContext.replaceHead(prevForkContext.makeNext(0, -1));
	
	        return context;
	    },
	
	    /**
	     * Makes a code path segment of the right-hand operand of a logical
	     * expression.
	     *
	     * @returns {void}
	     */
	    makeLogicalRight() {
	        const context = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        if (context.processed) {
	
	            /*
	             * This got segments already from the child choice context.
	             * Creates the next path from own true/false fork context.
	             */
	            const prevForkContext =
	                context.kind === "&&" ? context.trueForkContext :
	                /* kind === "||" */ context.falseForkContext;
	
	            forkContext.replaceHead(prevForkContext.makeNext(0, -1));
	            prevForkContext.clear();
	
	            context.processed = false;
	        } else {
	
	            /*
	             * This did not get segments from the child choice context.
	             * So addresses the head segments.
	             * The head segments are the path of the left-hand operand.
	             */
	            if (context.kind === "&&") {
	
	                // The path does short-circuit if false.
	                context.falseForkContext.add(forkContext.head);
	            } else {
	
	                // The path does short-circuit if true.
	                context.trueForkContext.add(forkContext.head);
	            }
	
	            forkContext.replaceHead(forkContext.makeNext(-1, -1));
	        }
	    },
	
	    /**
	     * Makes a code path segment of the `if` block.
	     *
	     * @returns {void}
	     */
	    makeIfConsequent() {
	        const context = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        /*
	         * If any result were not transferred from child contexts,
	         * this sets the head segments to both cases.
	         * The head segments are the path of the test expression.
	         */
	        if (!context.processed) {
	            context.trueForkContext.add(forkContext.head);
	            context.falseForkContext.add(forkContext.head);
	        }
	
	        context.processed = false;
	
	        // Creates new path from the `true` case.
	        forkContext.replaceHead(
	            context.trueForkContext.makeNext(0, -1)
	        );
	    },
	
	    /**
	     * Makes a code path segment of the `else` block.
	     *
	     * @returns {void}
	     */
	    makeIfAlternate() {
	        const context = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        /*
	         * The head segments are the path of the `if` block.
	         * Updates the `true` path with the end of the `if` block.
	         */
	        context.trueForkContext.clear();
	        context.trueForkContext.add(forkContext.head);
	        context.processed = true;
	
	        // Creates new path from the `false` case.
	        forkContext.replaceHead(
	            context.falseForkContext.makeNext(0, -1)
	        );
	    },
	
	    //--------------------------------------------------------------------------
	    // SwitchStatement
	    //--------------------------------------------------------------------------
	
	    /**
	     * Creates a context object of SwitchStatement and stacks it.
	     *
	     * @param {boolean} hasCase - `true` if the switch statement has one or more
	     *   case parts.
	     * @param {string|null} label - The label text.
	     * @returns {void}
	     */
	    pushSwitchContext(hasCase, label) {
	        this.switchContext = {
	            upper: this.switchContext,
	            hasCase,
	            defaultSegments: null,
	            defaultBodySegments: null,
	            foundDefault: false,
	            lastIsDefault: false,
	            countForks: 0
	        };
	
	        this.pushBreakContext(true, label);
	    },
	
	    /**
	     * Pops the last context of SwitchStatement and finalizes it.
	     *
	     * - Disposes all forking stack for `case` and `default`.
	     * - Creates the next code path segment from `context.brokenForkContext`.
	     * - If the last `SwitchCase` node is not a `default` part, creates a path
	     *   to the `default` body.
	     *
	     * @returns {void}
	     */
	    popSwitchContext() {
	        const context = this.switchContext;
	
	        this.switchContext = context.upper;
	
	        const forkContext = this.forkContext;
	        const brokenForkContext = this.popBreakContext().brokenForkContext;
	
	        if (context.countForks === 0) {
	
	            /*
	             * When there is only one `default` chunk and there is one or more
	             * `break` statements, even if forks are nothing, it needs to merge
	             * those.
	             */
	            if (!brokenForkContext.empty) {
	                brokenForkContext.add(forkContext.makeNext(-1, -1));
	                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
	            }
	
	            return;
	        }
	
	        const lastSegments = forkContext.head;
	
	        this.forkBypassPath();
	        const lastCaseSegments = forkContext.head;
	
	        /*
	         * `brokenForkContext` is used to make the next segment.
	         * It must add the last segment into `brokenForkContext`.
	         */
	        brokenForkContext.add(lastSegments);
	
	        /*
	         * A path which is failed in all case test should be connected to path
	         * of `default` chunk.
	         */
	        if (!context.lastIsDefault) {
	            if (context.defaultBodySegments) {
	
	                /*
	                 * Remove a link from `default` label to its chunk.
	                 * It's false route.
	                 */
	                removeConnection(context.defaultSegments, context.defaultBodySegments);
	                makeLooped(this, lastCaseSegments, context.defaultBodySegments);
	            } else {
	
	                /*
	                 * It handles the last case body as broken if `default` chunk
	                 * does not exist.
	                 */
	                brokenForkContext.add(lastCaseSegments);
	            }
	        }
	
	        // Pops the segment context stack until the entry segment.
	        for (let i = 0; i < context.countForks; ++i) {
	            this.forkContext = this.forkContext.upper;
	        }
	
	        /*
	         * Creates a path from all brokenForkContext paths.
	         * This is a path after switch statement.
	         */
	        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
	    },
	
	    /**
	     * Makes a code path segment for a `SwitchCase` node.
	     *
	     * @param {boolean} isEmpty - `true` if the body is empty.
	     * @param {boolean} isDefault - `true` if the body is the default case.
	     * @returns {void}
	     */
	    makeSwitchCaseBody(isEmpty, isDefault) {
	        const context = this.switchContext;
	
	        if (!context.hasCase) {
	            return;
	        }
	
	        /*
	         * Merge forks.
	         * The parent fork context has two segments.
	         * Those are from the current case and the body of the previous case.
	         */
	        const parentForkContext = this.forkContext;
	        const forkContext = this.pushForkContext();
	
	        forkContext.add(parentForkContext.makeNext(0, -1));
	
	        /*
	         * Save `default` chunk info.
	         * If the `default` label is not at the last, we must make a path from
	         * the last `case` to the `default` chunk.
	         */
	        if (isDefault) {
	            context.defaultSegments = parentForkContext.head;
	            if (isEmpty) {
	                context.foundDefault = true;
	            } else {
	                context.defaultBodySegments = forkContext.head;
	            }
	        } else {
	            if (!isEmpty && context.foundDefault) {
	                context.foundDefault = false;
	                context.defaultBodySegments = forkContext.head;
	            }
	        }
	
	        context.lastIsDefault = isDefault;
	        context.countForks += 1;
	    },
	
	    //--------------------------------------------------------------------------
	    // TryStatement
	    //--------------------------------------------------------------------------
	
	    /**
	     * Creates a context object of TryStatement and stacks it.
	     *
	     * @param {boolean} hasFinalizer - `true` if the try statement has a
	     *   `finally` block.
	     * @returns {void}
	     */
	    pushTryContext(hasFinalizer) {
	        this.tryContext = {
	            upper: this.tryContext,
	            position: "try",
	            hasFinalizer,
	
	            returnedForkContext: hasFinalizer
	                ? ForkContext.newEmpty(this.forkContext)
	                : null,
	
	            thrownForkContext: ForkContext.newEmpty(this.forkContext),
	            lastOfTryIsReachable: false,
	            lastOfCatchIsReachable: false
	        };
	    },
	
	    /**
	     * Pops the last context of TryStatement and finalizes it.
	     *
	     * @returns {void}
	     */
	    popTryContext() {
	        const context = this.tryContext;
	
	        this.tryContext = context.upper;
	
	        if (context.position === "catch") {
	
	            // Merges two paths from the `try` block and `catch` block merely.
	            this.popForkContext();
	            return;
	        }
	
	        /*
	         * The following process is executed only when there is the `finally`
	         * block.
	         */
	
	        const returned = context.returnedForkContext;
	        const thrown = context.thrownForkContext;
	
	        if (returned.empty && thrown.empty) {
	            return;
	        }
	
	        // Separate head to normal paths and leaving paths.
	        const headSegments = this.forkContext.head;
	
	        this.forkContext = this.forkContext.upper;
	        const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
	        const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
	
	        // Forwards the leaving path to upper contexts.
	        if (!returned.empty) {
	            getReturnContext(this).returnedForkContext.add(leavingSegments);
	        }
	        if (!thrown.empty) {
	            getThrowContext(this).thrownForkContext.add(leavingSegments);
	        }
	
	        // Sets the normal path as the next.
	        this.forkContext.replaceHead(normalSegments);
	
	        // If both paths of the `try` block and the `catch` block are
	        // unreachable, the next path becomes unreachable as well.
	        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {
	            this.forkContext.makeUnreachable();
	        }
	    },
	
	    /**
	     * Makes a code path segment for a `catch` block.
	     *
	     * @returns {void}
	     */
	    makeCatchBlock() {
	        const context = this.tryContext;
	        const forkContext = this.forkContext;
	        const thrown = context.thrownForkContext;
	
	        // Update state.
	        context.position = "catch";
	        context.thrownForkContext = ForkContext.newEmpty(forkContext);
	        context.lastOfTryIsReachable = forkContext.reachable;
	
	        // Merge thrown paths.
	        thrown.add(forkContext.head);
	        const thrownSegments = thrown.makeNext(0, -1);
	
	        // Fork to a bypass and the merged thrown path.
	        this.pushForkContext();
	        this.forkBypassPath();
	        this.forkContext.add(thrownSegments);
	    },
	
	    /**
	     * Makes a code path segment for a `finally` block.
	     *
	     * In the `finally` block, parallel paths are created. The parallel paths
	     * are used as leaving-paths. The leaving-paths are paths from `return`
	     * statements and `throw` statements in a `try` block or a `catch` block.
	     *
	     * @returns {void}
	     */
	    makeFinallyBlock() {
	        const context = this.tryContext;
	        let forkContext = this.forkContext;
	        const returned = context.returnedForkContext;
	        const thrown = context.thrownForkContext;
	        const headOfLeavingSegments = forkContext.head;
	
	        // Update state.
	        if (context.position === "catch") {
	
	            // Merges two paths from the `try` block and `catch` block.
	            this.popForkContext();
	            forkContext = this.forkContext;
	
	            context.lastOfCatchIsReachable = forkContext.reachable;
	        } else {
	            context.lastOfTryIsReachable = forkContext.reachable;
	        }
	        context.position = "finally";
	
	        if (returned.empty && thrown.empty) {
	
	            // This path does not leave.
	            return;
	        }
	
	        /*
	         * Create a parallel segment from merging returned and thrown.
	         * This segment will leave at the end of this finally block.
	         */
	        const segments = forkContext.makeNext(-1, -1);
	        let j;
	
	        for (let i = 0; i < forkContext.count; ++i) {
	            const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
	
	            for (j = 0; j < returned.segmentsList.length; ++j) {
	                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
	            }
	            for (j = 0; j < thrown.segmentsList.length; ++j) {
	                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
	            }
	
	            segments.push(CodePathSegment.newNext(
	                this.idGenerator.next(),
	                prevSegsOfLeavingSegment));
	        }
	
	        this.pushForkContext(true);
	        this.forkContext.add(segments);
	    },
	
	    /**
	     * Makes a code path segment from the first throwable node to the `catch`
	     * block or the `finally` block.
	     *
	     * @returns {void}
	     */
	    makeFirstThrowablePathInTryBlock() {
	        const forkContext = this.forkContext;
	
	        if (!forkContext.reachable) {
	            return;
	        }
	
	        const context = getThrowContext(this);
	
	        if (context === this ||
	            context.position !== "try" ||
	            !context.thrownForkContext.empty
	        ) {
	            return;
	        }
	
	        context.thrownForkContext.add(forkContext.head);
	        forkContext.replaceHead(forkContext.makeNext(-1, -1));
	    },
	
	    //--------------------------------------------------------------------------
	    // Loop Statements
	    //--------------------------------------------------------------------------
	
	    /**
	     * Creates a context object of a loop statement and stacks it.
	     *
	     * @param {string} type - The type of the node which was triggered. One of
	     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,
	     *   and `ForStatement`.
	     * @param {string|null} label - A label of the node which was triggered.
	     * @returns {void}
	     */
	    pushLoopContext(type, label) {
	        const forkContext = this.forkContext;
	        const breakContext = this.pushBreakContext(true, label);
	
	        switch (type) {
	            case "WhileStatement":
	                this.pushChoiceContext("loop", false);
	                this.loopContext = {
	                    upper: this.loopContext,
	                    type,
	                    label,
	                    test: void 0,
	                    continueDestSegments: null,
	                    brokenForkContext: breakContext.brokenForkContext
	                };
	                break;
	
	            case "DoWhileStatement":
	                this.pushChoiceContext("loop", false);
	                this.loopContext = {
	                    upper: this.loopContext,
	                    type,
	                    label,
	                    test: void 0,
	                    entrySegments: null,
	                    continueForkContext: ForkContext.newEmpty(forkContext),
	                    brokenForkContext: breakContext.brokenForkContext
	                };
	                break;
	
	            case "ForStatement":
	                this.pushChoiceContext("loop", false);
	                this.loopContext = {
	                    upper: this.loopContext,
	                    type,
	                    label,
	                    test: void 0,
	                    endOfInitSegments: null,
	                    testSegments: null,
	                    endOfTestSegments: null,
	                    updateSegments: null,
	                    endOfUpdateSegments: null,
	                    continueDestSegments: null,
	                    brokenForkContext: breakContext.brokenForkContext
	                };
	                break;
	
	            case "ForInStatement":
	            case "ForOfStatement":
	                this.loopContext = {
	                    upper: this.loopContext,
	                    type,
	                    label,
	                    prevSegments: null,
	                    leftSegments: null,
	                    endOfLeftSegments: null,
	                    continueDestSegments: null,
	                    brokenForkContext: breakContext.brokenForkContext
	                };
	                break;
	
	            /* istanbul ignore next */
	            default:
	                throw new Error(`unknown type: "${type}"`);
	        }
	    },
	
	    /**
	     * Pops the last context of a loop statement and finalizes it.
	     *
	     * @returns {void}
	     */
	    popLoopContext() {
	        const context = this.loopContext;
	
	        this.loopContext = context.upper;
	
	        const forkContext = this.forkContext;
	        const brokenForkContext = this.popBreakContext().brokenForkContext;
	        let choiceContext;
	
	        // Creates a looped path.
	        switch (context.type) {
	            case "WhileStatement":
	            case "ForStatement":
	                choiceContext = this.popChoiceContext();
	                makeLooped(
	                    this,
	                    forkContext.head,
	                    context.continueDestSegments);
	                break;
	
	            case "DoWhileStatement": {
	                choiceContext = this.popChoiceContext();
	
	                if (!choiceContext.processed) {
	                    choiceContext.trueForkContext.add(forkContext.head);
	                    choiceContext.falseForkContext.add(forkContext.head);
	                }
	                if (context.test !== true) {
	                    brokenForkContext.addAll(choiceContext.falseForkContext);
	                }
	
	                // `true` paths go to looping.
	                const segmentsList = choiceContext.trueForkContext.segmentsList;
	
	                for (let i = 0; i < segmentsList.length; ++i) {
	                    makeLooped(
	                        this,
	                        segmentsList[i],
	                        context.entrySegments);
	                }
	                break;
	            }
	
	            case "ForInStatement":
	            case "ForOfStatement":
	                brokenForkContext.add(forkContext.head);
	                makeLooped(
	                    this,
	                    forkContext.head,
	                    context.leftSegments);
	                break;
	
	            /* istanbul ignore next */
	            default:
	                throw new Error("unreachable");
	        }
	
	        // Go next.
	        if (brokenForkContext.empty) {
	            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
	        } else {
	            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
	        }
	    },
	
	    /**
	     * Makes a code path segment for the test part of a WhileStatement.
	     *
	     * @param {boolean|undefined} test - The test value (only when constant).
	     * @returns {void}
	     */
	    makeWhileTest(test) {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const testSegments = forkContext.makeNext(0, -1);
	
	        // Update state.
	        context.test = test;
	        context.continueDestSegments = testSegments;
	        forkContext.replaceHead(testSegments);
	    },
	
	    /**
	     * Makes a code path segment for the body part of a WhileStatement.
	     *
	     * @returns {void}
	     */
	    makeWhileBody() {
	        const context = this.loopContext;
	        const choiceContext = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        if (!choiceContext.processed) {
	            choiceContext.trueForkContext.add(forkContext.head);
	            choiceContext.falseForkContext.add(forkContext.head);
	        }
	
	        // Update state.
	        if (context.test !== true) {
	            context.brokenForkContext.addAll(choiceContext.falseForkContext);
	        }
	        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
	    },
	
	    /**
	     * Makes a code path segment for the body part of a DoWhileStatement.
	     *
	     * @returns {void}
	     */
	    makeDoWhileBody() {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const bodySegments = forkContext.makeNext(-1, -1);
	
	        // Update state.
	        context.entrySegments = bodySegments;
	        forkContext.replaceHead(bodySegments);
	    },
	
	    /**
	     * Makes a code path segment for the test part of a DoWhileStatement.
	     *
	     * @param {boolean|undefined} test - The test value (only when constant).
	     * @returns {void}
	     */
	    makeDoWhileTest(test) {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	
	        context.test = test;
	
	        // Creates paths of `continue` statements.
	        if (!context.continueForkContext.empty) {
	            context.continueForkContext.add(forkContext.head);
	            const testSegments = context.continueForkContext.makeNext(0, -1);
	
	            forkContext.replaceHead(testSegments);
	        }
	    },
	
	    /**
	     * Makes a code path segment for the test part of a ForStatement.
	     *
	     * @param {boolean|undefined} test - The test value (only when constant).
	     * @returns {void}
	     */
	    makeForTest(test) {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const endOfInitSegments = forkContext.head;
	        const testSegments = forkContext.makeNext(-1, -1);
	
	        // Update state.
	        context.test = test;
	        context.endOfInitSegments = endOfInitSegments;
	        context.continueDestSegments = context.testSegments = testSegments;
	        forkContext.replaceHead(testSegments);
	    },
	
	    /**
	     * Makes a code path segment for the update part of a ForStatement.
	     *
	     * @returns {void}
	     */
	    makeForUpdate() {
	        const context = this.loopContext;
	        const choiceContext = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        // Make the next paths of the test.
	        if (context.testSegments) {
	            finalizeTestSegmentsOfFor(
	                context,
	                choiceContext,
	                forkContext.head);
	        } else {
	            context.endOfInitSegments = forkContext.head;
	        }
	
	        // Update state.
	        const updateSegments = forkContext.makeDisconnected(-1, -1);
	
	        context.continueDestSegments = context.updateSegments = updateSegments;
	        forkContext.replaceHead(updateSegments);
	    },
	
	    /**
	     * Makes a code path segment for the body part of a ForStatement.
	     *
	     * @returns {void}
	     */
	    makeForBody() {
	        const context = this.loopContext;
	        const choiceContext = this.choiceContext;
	        const forkContext = this.forkContext;
	
	        // Update state.
	        if (context.updateSegments) {
	            context.endOfUpdateSegments = forkContext.head;
	
	            // `update` -> `test`
	            if (context.testSegments) {
	                makeLooped(
	                    this,
	                    context.endOfUpdateSegments,
	                    context.testSegments);
	            }
	        } else if (context.testSegments) {
	            finalizeTestSegmentsOfFor(
	                context,
	                choiceContext,
	                forkContext.head);
	        } else {
	            context.endOfInitSegments = forkContext.head;
	        }
	
	        let bodySegments = context.endOfTestSegments;
	
	        if (!bodySegments) {
	
	            /*
	             * If there is not the `test` part, the `body` path comes from the
	             * `init` part and the `update` part.
	             */
	            const prevForkContext = ForkContext.newEmpty(forkContext);
	
	            prevForkContext.add(context.endOfInitSegments);
	            if (context.endOfUpdateSegments) {
	                prevForkContext.add(context.endOfUpdateSegments);
	            }
	
	            bodySegments = prevForkContext.makeNext(0, -1);
	        }
	        context.continueDestSegments = context.continueDestSegments || bodySegments;
	        forkContext.replaceHead(bodySegments);
	    },
	
	    /**
	     * Makes a code path segment for the left part of a ForInStatement and a
	     * ForOfStatement.
	     *
	     * @returns {void}
	     */
	    makeForInOfLeft() {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const leftSegments = forkContext.makeDisconnected(-1, -1);
	
	        // Update state.
	        context.prevSegments = forkContext.head;
	        context.leftSegments = context.continueDestSegments = leftSegments;
	        forkContext.replaceHead(leftSegments);
	    },
	
	    /**
	     * Makes a code path segment for the right part of a ForInStatement and a
	     * ForOfStatement.
	     *
	     * @returns {void}
	     */
	    makeForInOfRight() {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const temp = ForkContext.newEmpty(forkContext);
	
	        temp.add(context.prevSegments);
	        const rightSegments = temp.makeNext(-1, -1);
	
	        // Update state.
	        context.endOfLeftSegments = forkContext.head;
	        forkContext.replaceHead(rightSegments);
	    },
	
	    /**
	     * Makes a code path segment for the body part of a ForInStatement and a
	     * ForOfStatement.
	     *
	     * @returns {void}
	     */
	    makeForInOfBody() {
	        const context = this.loopContext;
	        const forkContext = this.forkContext;
	        const temp = ForkContext.newEmpty(forkContext);
	
	        temp.add(context.endOfLeftSegments);
	        const bodySegments = temp.makeNext(-1, -1);
	
	        // Make a path: `right` -> `left`.
	        makeLooped(this, forkContext.head, context.leftSegments);
	
	        // Update state.
	        context.brokenForkContext.add(forkContext.head);
	        forkContext.replaceHead(bodySegments);
	    },
	
	    //--------------------------------------------------------------------------
	    // Control Statements
	    //--------------------------------------------------------------------------
	
	    /**
	     * Creates new context for BreakStatement.
	     *
	     * @param {boolean} breakable - The flag to indicate it can break by
	     *      an unlabeled BreakStatement.
	     * @param {string|null} label - The label of this context.
	     * @returns {Object} The new context.
	     */
	    pushBreakContext(breakable, label) {
	        this.breakContext = {
	            upper: this.breakContext,
	            breakable,
	            label,
	            brokenForkContext: ForkContext.newEmpty(this.forkContext)
	        };
	        return this.breakContext;
	    },
	
	    /**
	     * Removes the top item of the break context stack.
	     *
	     * @returns {Object} The removed context.
	     */
	    popBreakContext() {
	        const context = this.breakContext;
	        const forkContext = this.forkContext;
	
	        this.breakContext = context.upper;
	
	        // Process this context here for other than switches and loops.
	        if (!context.breakable) {
	            const brokenForkContext = context.brokenForkContext;
	
	            if (!brokenForkContext.empty) {
	                brokenForkContext.add(forkContext.head);
	                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
	            }
	        }
	
	        return context;
	    },
	
	    /**
	     * Makes a path for a `break` statement.
	     *
	     * It registers the head segment to a context of `break`.
	     * It makes new unreachable segment, then it set the head with the segment.
	     *
	     * @param {string} label - A label of the break statement.
	     * @returns {void}
	     */
	    makeBreak(label) {
	        const forkContext = this.forkContext;
	
	        if (!forkContext.reachable) {
	            return;
	        }
	
	        const context = getBreakContext(this, label);
	
	        /* istanbul ignore else: foolproof (syntax error) */
	        if (context) {
	            context.brokenForkContext.add(forkContext.head);
	        }
	
	        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
	    },
	
	    /**
	     * Makes a path for a `continue` statement.
	     *
	     * It makes a looping path.
	     * It makes new unreachable segment, then it set the head with the segment.
	     *
	     * @param {string} label - A label of the continue statement.
	     * @returns {void}
	     */
	    makeContinue(label) {
	        const forkContext = this.forkContext;
	
	        if (!forkContext.reachable) {
	            return;
	        }
	
	        const context = getContinueContext(this, label);
	
	        /* istanbul ignore else: foolproof (syntax error) */
	        if (context) {
	            if (context.continueDestSegments) {
	                makeLooped(this, forkContext.head, context.continueDestSegments);
	
	                // If the context is a for-in/of loop, this effects a break also.
	                if (context.type === "ForInStatement" ||
	                    context.type === "ForOfStatement"
	                ) {
	                    context.brokenForkContext.add(forkContext.head);
	                }
	            } else {
	                context.continueForkContext.add(forkContext.head);
	            }
	        }
	        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
	    },
	
	    /**
	     * Makes a path for a `return` statement.
	     *
	     * It registers the head segment to a context of `return`.
	     * It makes new unreachable segment, then it set the head with the segment.
	     *
	     * @returns {void}
	     */
	    makeReturn() {
	        const forkContext = this.forkContext;
	
	        if (forkContext.reachable) {
	            getReturnContext(this).returnedForkContext.add(forkContext.head);
	            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
	        }
	    },
	
	    /**
	     * Makes a path for a `throw` statement.
	     *
	     * It registers the head segment to a context of `throw`.
	     * It makes new unreachable segment, then it set the head with the segment.
	     *
	     * @returns {void}
	     */
	    makeThrow() {
	        const forkContext = this.forkContext;
	
	        if (forkContext.reachable) {
	            getThrowContext(this).thrownForkContext.add(forkContext.head);
	            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
	        }
	    },
	
	    /**
	     * Makes the final path.
	     * @returns {void}
	     */
	    makeFinal() {
	        const segments = this.currentSegments;
	
	        if (segments.length > 0 && segments[0].reachable) {
	            this.returnedForkContext.add(segments);
	        }
	    }
	};
	
	module.exports = CodePathState;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A class of the code path segment.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const debug = __webpack_require__(103);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Replaces unused segments with the previous segments of each unused segment.
	 *
	 * @param {CodePathSegment[]} segments - An array of segments to replace.
	 * @returns {CodePathSegment[]} The replaced array.
	 */
	function flattenUnusedSegments(segments) {
	    const done = Object.create(null);
	    const retv = [];
	
	    for (let i = 0; i < segments.length; ++i) {
	        const segment = segments[i];
	
	        // Ignores duplicated.
	        if (done[segment.id]) {
	            continue;
	        }
	
	        // Use previous segments if unused.
	        if (!segment.internal.used) {
	            for (let j = 0; j < segment.allPrevSegments.length; ++j) {
	                const prevSegment = segment.allPrevSegments[j];
	
	                if (!done[prevSegment.id]) {
	                    done[prevSegment.id] = true;
	                    retv.push(prevSegment);
	                }
	            }
	        } else {
	            done[segment.id] = true;
	            retv.push(segment);
	        }
	    }
	
	    return retv;
	}
	
	/**
	 * Checks whether or not a given segment is reachable.
	 *
	 * @param {CodePathSegment} segment - A segment to check.
	 * @returns {boolean} `true` if the segment is reachable.
	 */
	function isReachable(segment) {
	    return segment.reachable;
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * A code path segment.
	 *
	 * @constructor
	 * @param {string} id - An identifier.
	 * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
	 *   This array includes unreachable segments.
	 * @param {boolean} reachable - A flag which shows this is reachable.
	 */
	function CodePathSegment(id, allPrevSegments, reachable) {
	
	    /**
	     * The identifier of this code path.
	     * Rules use it to store additional information of each rule.
	     * @type {string}
	     */
	    this.id = id;
	
	    /**
	     * An array of the next segments.
	     * @type {CodePathSegment[]}
	     */
	    this.nextSegments = [];
	
	    /**
	     * An array of the previous segments.
	     * @type {CodePathSegment[]}
	     */
	    this.prevSegments = allPrevSegments.filter(isReachable);
	
	    /**
	     * An array of the next segments.
	     * This array includes unreachable segments.
	     * @type {CodePathSegment[]}
	     */
	    this.allNextSegments = [];
	
	    /**
	     * An array of the previous segments.
	     * This array includes unreachable segments.
	     * @type {CodePathSegment[]}
	     */
	    this.allPrevSegments = allPrevSegments;
	
	    /**
	     * A flag which shows this is reachable.
	     * @type {boolean}
	     */
	    this.reachable = reachable;
	
	    // Internal data.
	    Object.defineProperty(this, "internal", {value: {
	        used: false,
	        loopedPrevSegments: []
	    }});
	
	    /* istanbul ignore if */
	    if (debug.enabled) {
	        this.internal.nodes = [];
	        this.internal.exitNodes = [];
	    }
	}
	
	CodePathSegment.prototype = {
	    constructor: CodePathSegment,
	
	    /**
	     * Checks a given previous segment is coming from the end of a loop.
	     *
	     * @param {CodePathSegment} segment - A previous segment to check.
	     * @returns {boolean} `true` if the segment is coming from the end of a loop.
	     */
	    isLoopedPrevSegment(segment) {
	        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
	    }
	};
	
	/**
	 * Creates the root segment.
	 *
	 * @param {string} id - An identifier.
	 * @returns {CodePathSegment} The created segment.
	 */
	CodePathSegment.newRoot = function(id) {
	    return new CodePathSegment(id, [], true);
	};
	
	/**
	 * Creates a segment that follows given segments.
	 *
	 * @param {string} id - An identifier.
	 * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
	 * @returns {CodePathSegment} The created segment.
	 */
	CodePathSegment.newNext = function(id, allPrevSegments) {
	    return new CodePathSegment(
	        id,
	        flattenUnusedSegments(allPrevSegments),
	        allPrevSegments.some(isReachable));
	};
	
	/**
	 * Creates an unreachable segment that follows given segments.
	 *
	 * @param {string} id - An identifier.
	 * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
	 * @returns {CodePathSegment} The created segment.
	 */
	CodePathSegment.newUnreachable = function(id, allPrevSegments) {
	    const segment = new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);
	
	    // In `if (a) return a; foo();` case, the unreachable segment preceded by
	    // the return statement is not used but must not be remove.
	    CodePathSegment.markUsed(segment);
	
	    return segment;
	};
	
	/**
	 * Creates a segment that follows given segments.
	 * This factory method does not connect with `allPrevSegments`.
	 * But this inherits `reachable` flag.
	 *
	 * @param {string} id - An identifier.
	 * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.
	 * @returns {CodePathSegment} The created segment.
	 */
	CodePathSegment.newDisconnected = function(id, allPrevSegments) {
	    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
	};
	
	/**
	 * Makes a given segment being used.
	 *
	 * And this function registers the segment into the previous segments as a next.
	 *
	 * @param {CodePathSegment} segment - A segment to mark.
	 * @returns {void}
	 */
	CodePathSegment.markUsed = function(segment) {
	    if (segment.internal.used) {
	        return;
	    }
	    segment.internal.used = true;
	
	    let i;
	
	    if (segment.reachable) {
	        for (i = 0; i < segment.allPrevSegments.length; ++i) {
	            const prevSegment = segment.allPrevSegments[i];
	
	            prevSegment.allNextSegments.push(segment);
	            prevSegment.nextSegments.push(segment);
	        }
	    } else {
	        for (i = 0; i < segment.allPrevSegments.length; ++i) {
	            segment.allPrevSegments[i].allNextSegments.push(segment);
	        }
	    }
	};
	
	/**
	 * Marks a previous segment as looped.
	 *
	 * @param {CodePathSegment} segment - A segment.
	 * @param {CodePathSegment} prevSegment - A previous segment to mark.
	 * @returns {void}
	 */
	CodePathSegment.markPrevSegmentAsLooped = function(segment, prevSegment) {
	    segment.internal.loopedPrevSegments.push(prevSegment);
	};
	
	module.exports = CodePathSegment;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Helpers to debug for code path analysis.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const debug = __webpack_require__(104)("eslint:code-path");
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Gets id of a given segment.
	 * @param {CodePathSegment} segment - A segment to get.
	 * @returns {string} Id of the segment.
	 */
	/* istanbul ignore next */
	function getId(segment) { // eslint-disable-line require-jsdoc
	    return segment.id + (segment.reachable ? "" : "!");
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    /**
	     * A flag that debug dumping is enabled or not.
	     * @type {boolean}
	     */
	    enabled: debug.enabled,
	
	    /**
	     * Dumps given objects.
	     *
	     * @param {...any} args - objects to dump.
	     * @returns {void}
	     */
	    dump: debug,
	
	    /**
	     * Dumps the current analyzing state.
	     *
	     * @param {ASTNode} node - A node to dump.
	     * @param {CodePathState} state - A state to dump.
	     * @param {boolean} leaving - A flag whether or not it's leaving
	     * @returns {void}
	     */
	    dumpState: !debug.enabled ? debug : /* istanbul ignore next */ function(node, state, leaving) {
	        for (let i = 0; i < state.currentSegments.length; ++i) {
	            const segInternal = state.currentSegments[i].internal;
	
	            if (leaving) {
	                segInternal.exitNodes.push(node);
	            } else {
	                segInternal.nodes.push(node);
	            }
	        }
	
	        debug([
	            `${state.currentSegments.map(getId).join(",")})`,
	            `${node.type}${leaving ? ":exit" : ""}`
	        ].join(" "));
	    },
	
	    /**
	     * Dumps a DOT code of a given code path.
	     * The DOT code can be visialized with Graphvis.
	     *
	     * @param {CodePath} codePath - A code path to dump.
	     * @returns {void}
	     * @see http://www.graphviz.org
	     * @see http://www.webgraphviz.com
	     */
	    dumpDot: !debug.enabled ? debug : /* istanbul ignore next */ function(codePath) {
	        let text =
	            "\n" +
	            "digraph {\n" +
	            "node[shape=box,style=\"rounded,filled\",fillcolor=white];\n" +
	            "initial[label=\"\",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
	
	        if (codePath.returnedSegments.length > 0) {
	            text += "final[label=\"\",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n";
	        }
	        if (codePath.thrownSegments.length > 0) {
	            text += "thrown[label=\"\",shape=circle,width=0.3,height=0.3,fixedsize];\n";
	        }
	
	        const traceMap = Object.create(null);
	        const arrows = this.makeDotArrows(codePath, traceMap);
	
	        for (const id in traceMap) { // eslint-disable-line guard-for-in
	            const segment = traceMap[id];
	
	            text += `${id}[`;
	
	            if (segment.reachable) {
	                text += "label=\"";
	            } else {
	                text += "style=\"rounded,dashed,filled\",fillcolor=\"#FF9800\",label=\"<<unreachable>>\\n";
	            }
	
	            if (segment.internal.nodes.length > 0) {
	                text += segment.internal.nodes.map(function(node) {
	                    switch (node.type) {
	                        case "Identifier": return `${node.type} (${node.name})`;
	                        case "Literal": return `${node.type} (${node.value})`;
	                        default: return node.type;
	                    }
	                }).join("\\n");
	            } else if (segment.internal.exitNodes.length > 0) {
	                text += segment.internal.exitNodes.map(function(node) {
	                    switch (node.type) {
	                        case "Identifier": return `${node.type}:exit (${node.name})`;
	                        case "Literal": return `${node.type}:exit (${node.value})`;
	                        default: return `${node.type}:exit`;
	                    }
	                }).join("\\n");
	            } else {
	                text += "????";
	            }
	
	            text += "\"];\n";
	        }
	
	        text += `${arrows}\n`;
	        text += "}";
	        debug("DOT", text);
	    },
	
	    /**
	     * Makes a DOT code of a given code path.
	     * The DOT code can be visialized with Graphvis.
	     *
	     * @param {CodePath} codePath - A code path to make DOT.
	     * @param {Object} traceMap - Optional. A map to check whether or not segments had been done.
	     * @returns {string} A DOT code of the code path.
	     */
	    makeDotArrows(codePath, traceMap) {
	        const stack = [[codePath.initialSegment, 0]];
	        const done = traceMap || Object.create(null);
	        let lastId = codePath.initialSegment.id;
	        let text = `initial->${codePath.initialSegment.id}`;
	
	        while (stack.length > 0) {
	            const item = stack.pop();
	            const segment = item[0];
	            const index = item[1];
	
	            if (done[segment.id] && index === 0) {
	                continue;
	            }
	            done[segment.id] = segment;
	
	            const nextSegment = segment.allNextSegments[index];
	
	            if (!nextSegment) {
	                continue;
	            }
	
	            if (lastId === segment.id) {
	                text += `->${nextSegment.id}`;
	            } else {
	                text += `;\n${segment.id}->${nextSegment.id}`;
	            }
	            lastId = nextSegment.id;
	
	            stack.unshift([segment, 1 + index]);
	            stack.push([nextSegment, 0]);
	        }
	
	        codePath.returnedSegments.forEach(function(finalSegment) {
	            if (lastId === finalSegment.id) {
	                text += "->final";
	            } else {
	                text += `;\n${finalSegment.id}->final`;
	            }
	            lastId = null;
	        });
	
	        codePath.thrownSegments.forEach(function(finalSegment) {
	            if (lastId === finalSegment.id) {
	                text += "->thrown";
	            } else {
	                text += `;\n${finalSegment.id}->thrown`;
	            }
	            lastId = null;
	        });
	
	        return `${text};`;
	    }
	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(105);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  try {
	    return JSON.stringify(v);
	  } catch (err) {
	    return '[UnexpectedJSONParseError]: ' + err.message;
	  }
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    return exports.storage.debug;
	  } catch(e) {}
	
	  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	  if (typeof process !== 'undefined' && 'env' in process) {
	    return process.env.DEBUG;
	  }
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug.debug = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(106);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = new Array(arguments.length);
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i];
	    }
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    // apply env-specific formatting
	    args = exports.formatArgs.apply(self, args);
	
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000
	var m = s * 60
	var h = m * 60
	var d = h * 24
	var y = d * 365.25
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @throws {Error} throw an error if val is not a non-empty string or a number
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function (val, options) {
	  options = options || {}
	  var type = typeof val
	  if (type === 'string' && val.length > 0) {
	    return parse(val)
	  } else if (type === 'number' && isNaN(val) === false) {
	    return options.long ?
				fmtLong(val) :
				fmtShort(val)
	  }
	  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
	}
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = String(str)
	  if (str.length > 10000) {
	    return
	  }
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
	  if (!match) {
	    return
	  }
	  var n = parseFloat(match[1])
	  var type = (match[2] || 'ms').toLowerCase()
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n
	    default:
	      return undefined
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtShort(ms) {
	  if (ms >= d) {
	    return Math.round(ms / d) + 'd'
	  }
	  if (ms >= h) {
	    return Math.round(ms / h) + 'h'
	  }
	  if (ms >= m) {
	    return Math.round(ms / m) + 'm'
	  }
	  if (ms >= s) {
	    return Math.round(ms / s) + 's'
	  }
	  return ms + 'ms'
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function fmtLong(ms) {
	  return plural(ms, d, 'day') ||
	    plural(ms, h, 'hour') ||
	    plural(ms, m, 'minute') ||
	    plural(ms, s, 'second') ||
	    ms + ' ms'
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) {
	    return
	  }
	  if (ms < n * 1.5) {
	    return Math.floor(ms / n) + ' ' + name
	  }
	  return Math.ceil(ms / n) + ' ' + name + 's'
	}


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A class to operate forking.
	 *
	 * This is state of forking.
	 * This has a fork list and manages it.
	 *
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const assert = __webpack_require__(3),
	    CodePathSegment = __webpack_require__(102);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Gets whether or not a given segment is reachable.
	 *
	 * @param {CodePathSegment} segment - A segment to get.
	 * @returns {boolean} `true` if the segment is reachable.
	 */
	function isReachable(segment) {
	    return segment.reachable;
	}
	
	/**
	 * Creates new segments from the specific range of `context.segmentsList`.
	 *
	 * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and
	 * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.
	 * This `h` is from `b`, `d`, and `f`.
	 *
	 * @param {ForkContext} context - An instance.
	 * @param {number} begin - The first index of the previous segments.
	 * @param {number} end - The last index of the previous segments.
	 * @param {Function} create - A factory function of new segments.
	 * @returns {CodePathSegment[]} New segments.
	 */
	function makeSegments(context, begin, end, create) {
	    const list = context.segmentsList;
	
	    if (begin < 0) {
	        begin = list.length + begin;
	    }
	    if (end < 0) {
	        end = list.length + end;
	    }
	
	    const segments = [];
	
	    for (let i = 0; i < context.count; ++i) {
	        const allPrevSegments = [];
	
	        for (let j = begin; j <= end; ++j) {
	            allPrevSegments.push(list[j][i]);
	        }
	
	        segments.push(create(context.idGenerator.next(), allPrevSegments));
	    }
	
	    return segments;
	}
	
	/**
	 * `segments` becomes doubly in a `finally` block. Then if a code path exits by a
	 * control statement (such as `break`, `continue`) from the `finally` block, the
	 * destination's segments may be half of the source segments. In that case, this
	 * merges segments.
	 *
	 * @param {ForkContext} context - An instance.
	 * @param {CodePathSegment[]} segments - Segments to merge.
	 * @returns {CodePathSegment[]} The merged segments.
	 */
	function mergeExtraSegments(context, segments) {
	    while (segments.length > context.count) {
	        const merged = [];
	
	        for (let i = 0, length = segments.length / 2 | 0; i < length; ++i) {
	            merged.push(CodePathSegment.newNext(
	                context.idGenerator.next(),
	                [segments[i], segments[i + length]]
	            ));
	        }
	        segments = merged;
	    }
	    return segments;
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * A class to manage forking.
	 *
	 * @constructor
	 * @param {IdGenerator} idGenerator - An identifier generator for segments.
	 * @param {ForkContext|null} upper - An upper fork context.
	 * @param {number} count - A number of parallel segments.
	 */
	function ForkContext(idGenerator, upper, count) {
	    this.idGenerator = idGenerator;
	    this.upper = upper;
	    this.count = count;
	    this.segmentsList = [];
	}
	
	ForkContext.prototype = {
	    constructor: ForkContext,
	
	    /**
	     * The head segments.
	     * @type {CodePathSegment[]}
	     */
	    get head() {
	        const list = this.segmentsList;
	
	        return list.length === 0 ? [] : list[list.length - 1];
	    },
	
	    /**
	     * A flag which shows empty.
	     * @type {boolean}
	     */
	    get empty() {
	        return this.segmentsList.length === 0;
	    },
	
	    /**
	     * A flag which shows reachable.
	     * @type {boolean}
	     */
	    get reachable() {
	        const segments = this.head;
	
	        return segments.length > 0 && segments.some(isReachable);
	    },
	
	    /**
	     * Creates new segments from this context.
	     *
	     * @param {number} begin - The first index of previous segments.
	     * @param {number} end - The last index of previous segments.
	     * @returns {CodePathSegment[]} New segments.
	     */
	    makeNext(begin, end) {
	        return makeSegments(this, begin, end, CodePathSegment.newNext);
	    },
	
	    /**
	     * Creates new segments from this context.
	     * The new segments is always unreachable.
	     *
	     * @param {number} begin - The first index of previous segments.
	     * @param {number} end - The last index of previous segments.
	     * @returns {CodePathSegment[]} New segments.
	     */
	    makeUnreachable(begin, end) {
	        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
	    },
	
	    /**
	     * Creates new segments from this context.
	     * The new segments don't have connections for previous segments.
	     * But these inherit the reachable flag from this context.
	     *
	     * @param {number} begin - The first index of previous segments.
	     * @param {number} end - The last index of previous segments.
	     * @returns {CodePathSegment[]} New segments.
	     */
	    makeDisconnected(begin, end) {
	        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
	    },
	
	    /**
	     * Adds segments into this context.
	     * The added segments become the head.
	     *
	     * @param {CodePathSegment[]} segments - Segments to add.
	     * @returns {void}
	     */
	    add(segments) {
	        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
	
	        this.segmentsList.push(mergeExtraSegments(this, segments));
	    },
	
	    /**
	     * Replaces the head segments with given segments.
	     * The current head segments are removed.
	     *
	     * @param {CodePathSegment[]} segments - Segments to add.
	     * @returns {void}
	     */
	    replaceHead(segments) {
	        assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
	
	        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
	    },
	
	    /**
	     * Adds all segments of a given fork context into this context.
	     *
	     * @param {ForkContext} context - A fork context to add.
	     * @returns {void}
	     */
	    addAll(context) {
	        assert(context.count === this.count);
	
	        const source = context.segmentsList;
	
	        for (let i = 0; i < source.length; ++i) {
	            this.segmentsList.push(source[i]);
	        }
	    },
	
	    /**
	     * Clears all secments in this context.
	     *
	     * @returns {void}
	     */
	    clear() {
	        this.segmentsList = [];
	    }
	};
	
	/**
	 * Creates the root fork context.
	 *
	 * @param {IdGenerator} idGenerator - An identifier generator for segments.
	 * @returns {ForkContext} New fork context.
	 */
	ForkContext.newRoot = function(idGenerator) {
	    const context = new ForkContext(idGenerator, null, 1);
	
	    context.add([CodePathSegment.newRoot(idGenerator.next())]);
	
	    return context;
	};
	
	/**
	 * Creates an empty fork context preceded by a given context.
	 *
	 * @param {ForkContext} parentContext - The parent fork context.
	 * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.
	 * @returns {ForkContext} New fork context.
	 */
	ForkContext.newEmpty = function(parentContext, forkLeavingPath) {
	    return new ForkContext(
	        parentContext.idGenerator,
	        parentContext,
	        (forkLeavingPath ? 2 : 1) * parentContext.count);
	};
	
	module.exports = ForkContext;


/***/ },
/* 108 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A class of identifiers generator for code path segments.
	 *
	 * Each rule uses the identifier of code path segments to store additional
	 * information of the code path.
	 *
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * A generator for unique ids.
	 *
	 * @constructor
	 * @param {string} prefix - Optional. A prefix of generated ids.
	 */
	function IdGenerator(prefix) {
	    this.prefix = String(prefix);
	    this.n = 0;
	}
	
	/**
	 * Generates id.
	 *
	 * @returns {string} A generated id.
	 */
	IdGenerator.prototype.next = function() {
	    this.n = 1 + this.n | 0;
	
	    /* istanbul ignore if */
	    if (this.n < 0) {
	        this.n = 1;
	    }
	
	    return this.prefix + this.n;
	};
	
	module.exports = IdGenerator;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Common utils for AST.
	 * @author Gyandeep Singh
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const esutils = __webpack_require__(110);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;
	const anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/;
	const arrayOrTypedArrayPattern = /Array$/;
	const arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;
	const bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;
	const breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;
	const thisTagPattern = /^[\s*]*@this/m;
	
	/**
	 * Checks reference if is non initializer and writable.
	 * @param {Reference} reference - A reference to check.
	 * @param {int} index - The index of the reference in the references.
	 * @param {Reference[]} references - The array that the reference belongs to.
	 * @returns {boolean} Success/Failure
	 * @private
	 */
	function isModifyingReference(reference, index, references) {
	    const identifier = reference.identifier;
	
	    /*
	     * Destructuring assignments can have multiple default value, so
	     * possibly there are multiple writeable references for the same
	     * identifier.
	     */
	    const modifyingDifferentIdentifier = index === 0 ||
	        references[index - 1].identifier !== identifier;
	
	    return (identifier &&
	        reference.init === false &&
	        reference.isWrite() &&
	        modifyingDifferentIdentifier
	    );
	}
	
	/**
	 * Checks whether the given string starts with uppercase or not.
	 *
	 * @param {string} s - The string to check.
	 * @returns {boolean} `true` if the string starts with uppercase.
	 */
	function startsWithUpperCase(s) {
	    return s[0] !== s[0].toLocaleLowerCase();
	}
	
	/**
	 * Checks whether or not a node is a constructor.
	 * @param {ASTNode} node - A function node to check.
	 * @returns {boolean} Wehether or not a node is a constructor.
	 */
	function isES5Constructor(node) {
	    return (node.id && startsWithUpperCase(node.id.name));
	}
	
	/**
	 * Finds a function node from ancestors of a node.
	 * @param {ASTNode} node - A start node to find.
	 * @returns {Node|null} A found function node.
	 */
	function getUpperFunction(node) {
	    while (node) {
	        if (anyFunctionPattern.test(node.type)) {
	            return node;
	        }
	        node = node.parent;
	    }
	    return null;
	}
	
	/**
	 * Checks whether or not a node is `null` or `undefined`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a `null` or `undefined`.
	 * @public
	 */
	function isNullOrUndefined(node) {
	    return (
	        (node.type === "Literal" && node.value === null) ||
	        (node.type === "Identifier" && node.name === "undefined") ||
	        (node.type === "UnaryExpression" && node.operator === "void")
	    );
	}
	
	/**
	 * Checks whether or not a node is callee.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is callee.
	 */
	function isCallee(node) {
	    return node.parent.type === "CallExpression" && node.parent.callee === node;
	}
	
	/**
	 * Checks whether or not a node is `Reclect.apply`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a `Reclect.apply`.
	 */
	function isReflectApply(node) {
	    return (
	        node.type === "MemberExpression" &&
	        node.object.type === "Identifier" &&
	        node.object.name === "Reflect" &&
	        node.property.type === "Identifier" &&
	        node.property.name === "apply" &&
	        node.computed === false
	    );
	}
	
	/**
	 * Checks whether or not a node is `Array.from`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a `Array.from`.
	 */
	function isArrayFromMethod(node) {
	    return (
	        node.type === "MemberExpression" &&
	        node.object.type === "Identifier" &&
	        arrayOrTypedArrayPattern.test(node.object.name) &&
	        node.property.type === "Identifier" &&
	        node.property.name === "from" &&
	        node.computed === false
	    );
	}
	
	/**
	 * Checks whether or not a node is a method which has `thisArg`.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} Whether or not the node is a method which has `thisArg`.
	 */
	function isMethodWhichHasThisArg(node) {
	    while (node) {
	        if (node.type === "Identifier") {
	            return arrayMethodPattern.test(node.name);
	        }
	        if (node.type === "MemberExpression" && !node.computed) {
	            node = node.property;
	            continue;
	        }
	
	        break;
	    }
	
	    return false;
	}
	
	/**
	 * Checks whether or not a node has a `@this` tag in its comments.
	 * @param {ASTNode} node - A node to check.
	 * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
	 * @returns {boolean} Whether or not the node has a `@this` tag in its comments.
	 */
	function hasJSDocThisTag(node, sourceCode) {
	    const jsdocComment = sourceCode.getJSDocComment(node);
	
	    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
	        return true;
	    }
	
	    // Checks `@this` in its leading comments for callbacks,
	    // because callbacks don't have its JSDoc comment.
	    // e.g.
	    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });
	    return sourceCode.getComments(node).leading.some(function(comment) {
	        return thisTagPattern.test(comment.value);
	    });
	}
	
	/**
	 * Determines if a node is surrounded by parentheses.
	 * @param {SourceCode} sourceCode The ESLint source code object
	 * @param {ASTNode} node The node to be checked.
	 * @returns {boolean} True if the node is parenthesised.
	 * @private
	 */
	function isParenthesised(sourceCode, node) {
	    const previousToken = sourceCode.getTokenBefore(node),
	        nextToken = sourceCode.getTokenAfter(node);
	
	    return Boolean(previousToken && nextToken) &&
	        previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	        nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    /**
	     * Determines whether two adjacent tokens are on the same line.
	     * @param {Object} left - The left token object.
	     * @param {Object} right - The right token object.
	     * @returns {boolean} Whether or not the tokens are on the same line.
	     * @public
	     */
	    isTokenOnSameLine(left, right) {
	        return left.loc.end.line === right.loc.start.line;
	    },
	
	    isNullOrUndefined,
	    isCallee,
	    isES5Constructor,
	    getUpperFunction,
	    isArrayFromMethod,
	    isParenthesised,
	
	    /**
	     * Checks whether or not a given node is a string literal.
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} `true` if the node is a string literal.
	     */
	    isStringLiteral(node) {
	        return (
	            (node.type === "Literal" && typeof node.value === "string") ||
	            node.type === "TemplateLiteral"
	        );
	    },
	
	    /**
	     * Checks whether a given node is a breakable statement or not.
	     * The node is breakable if the node is one of the following type:
	     *
	     * - DoWhileStatement
	     * - ForInStatement
	     * - ForOfStatement
	     * - ForStatement
	     * - SwitchStatement
	     * - WhileStatement
	     *
	     * @param {ASTNode} node - A node to check.
	     * @returns {boolean} `true` if the node is breakable.
	     */
	    isBreakableStatement(node) {
	        return breakableTypePattern.test(node.type);
	    },
	
	    /**
	     * Gets the label if the parent node of a given node is a LabeledStatement.
	     *
	     * @param {ASTNode} node - A node to get.
	     * @returns {string|null} The label or `null`.
	     */
	    getLabel(node) {
	        if (node.parent.type === "LabeledStatement") {
	            return node.parent.label.name;
	        }
	        return null;
	    },
	
	    /**
	     * Gets references which are non initializer and writable.
	     * @param {Reference[]} references - An array of references.
	     * @returns {Reference[]} An array of only references which are non initializer and writable.
	     * @public
	     */
	    getModifyingReferences(references) {
	        return references.filter(isModifyingReference);
	    },
	
	    /**
	     * Validate that a string passed in is surrounded by the specified character
	     * @param  {string} val The text to check.
	     * @param  {string} character The character to see if it's surrounded by.
	     * @returns {boolean} True if the text is surrounded by the character, false if not.
	     * @private
	     */
	    isSurroundedBy(val, character) {
	        return val[0] === character && val[val.length - 1] === character;
	    },
	
	    /**
	     * Returns whether the provided node is an ESLint directive comment or not
	     * @param {LineComment|BlockComment} node The node to be checked
	     * @returns {boolean} `true` if the node is an ESLint directive comment
	     */
	    isDirectiveComment(node) {
	        const comment = node.value.trim();
	
	        return (
	            node.type === "Line" && comment.indexOf("eslint-") === 0 ||
	            node.type === "Block" && (
	                comment.indexOf("global ") === 0 ||
	                comment.indexOf("eslint ") === 0 ||
	                comment.indexOf("eslint-") === 0
	            )
	        );
	    },
	
	    /**
	     * Gets the trailing statement of a given node.
	     *
	     *     if (code)
	     *         consequent;
	     *
	     * When taking this `IfStatement`, returns `consequent;` statement.
	     *
	     * @param {ASTNode} A node to get.
	     * @returns {ASTNode|null} The trailing statement's node.
	     */
	    getTrailingStatement: esutils.ast.trailingStatement,
	
	    /**
	     * Finds the variable by a given name in a given scope and its upper scopes.
	     *
	     * @param {escope.Scope} initScope - A scope to start find.
	     * @param {string} name - A variable name to find.
	     * @returns {escope.Variable|null} A found variable or `null`.
	     */
	    getVariableByName(initScope, name) {
	        let scope = initScope;
	
	        while (scope) {
	            const variable = scope.set.get(name);
	
	            if (variable) {
	                return variable;
	            }
	
	            scope = scope.upper;
	        }
	
	        return null;
	    },
	
	    /**
	     * Checks whether or not a given function node is the default `this` binding.
	     *
	     * First, this checks the node:
	     *
	     * - The function name does not start with uppercase (it's a constructor).
	     * - The function does not have a JSDoc comment that has a @this tag.
	     *
	     * Next, this checks the location of the node.
	     * If the location is below, this judges `this` is valid.
	     *
	     * - The location is not on an object literal.
	     * - The location is not assigned to a variable which starts with an uppercase letter.
	     * - The location is not on an ES2015 class.
	     * - Its `bind`/`call`/`apply` method is not called directly.
	     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.
	     *
	     * @param {ASTNode} node - A function node to check.
	     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.
	     * @returns {boolean} The function node is the default `this` binding.
	     */
	    isDefaultThisBinding(node, sourceCode) {
	        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
	            return false;
	        }
	        const isAnonymous = node.id === null;
	
	        while (node) {
	            const parent = node.parent;
	
	            switch (parent.type) {
	
	                /*
	                 * Looks up the destination.
	                 * e.g., obj.foo = nativeFoo || function foo() { ... };
	                 */
	                case "LogicalExpression":
	                case "ConditionalExpression":
	                    node = parent;
	                    break;
	
	                // If the upper function is IIFE, checks the destination of the return value.
	                // e.g.
	                //   obj.foo = (function() {
	                //     // setup...
	                //     return function foo() { ... };
	                //   })();
	                case "ReturnStatement": {
	                    const func = getUpperFunction(parent);
	
	                    if (func === null || !isCallee(func)) {
	                        return true;
	                    }
	                    node = func.parent;
	                    break;
	                }
	
	                // e.g.
	                //   var obj = { foo() { ... } };
	                //   var obj = { foo: function() { ... } };
	                //   class A { constructor() { ... } }
	                //   class A { foo() { ... } }
	                //   class A { get foo() { ... } }
	                //   class A { set foo() { ... } }
	                //   class A { static foo() { ... } }
	                case "Property":
	                case "MethodDefinition":
	                    return parent.value !== node;
	
	                // e.g.
	                //   obj.foo = function foo() { ... };
	                //   Foo = function() { ... };
	                //   [obj.foo = function foo() { ... }] = a;
	                //   [Foo = function() { ... }] = a;
	                case "AssignmentExpression":
	                case "AssignmentPattern":
	                    if (parent.right === node) {
	                        if (parent.left.type === "MemberExpression") {
	                            return false;
	                        }
	                        if (isAnonymous &&
	                            parent.left.type === "Identifier" &&
	                            startsWithUpperCase(parent.left.name)
	                        ) {
	                            return false;
	                        }
	                    }
	                    return true;
	
	                // e.g.
	                //   var Foo = function() { ... };
	                case "VariableDeclarator":
	                    return !(
	                        isAnonymous &&
	                        parent.init === node &&
	                        parent.id.type === "Identifier" &&
	                        startsWithUpperCase(parent.id.name)
	                    );
	
	                // e.g.
	                //   var foo = function foo() { ... }.bind(obj);
	                //   (function foo() { ... }).call(obj);
	                //   (function foo() { ... }).apply(obj, []);
	                case "MemberExpression":
	                    return (
	                        parent.object !== node ||
	                        parent.property.type !== "Identifier" ||
	                        !bindOrCallOrApplyPattern.test(parent.property.name) ||
	                        !isCallee(parent) ||
	                        parent.parent.arguments.length === 0 ||
	                        isNullOrUndefined(parent.parent.arguments[0])
	                    );
	
	                // e.g.
	                //   Reflect.apply(function() {}, obj, []);
	                //   Array.from([], function() {}, obj);
	                //   list.forEach(function() {}, obj);
	                case "CallExpression":
	                    if (isReflectApply(parent.callee)) {
	                        return (
	                            parent.arguments.length !== 3 ||
	                            parent.arguments[0] !== node ||
	                            isNullOrUndefined(parent.arguments[1])
	                        );
	                    }
	                    if (isArrayFromMethod(parent.callee)) {
	                        return (
	                            parent.arguments.length !== 3 ||
	                            parent.arguments[1] !== node ||
	                            isNullOrUndefined(parent.arguments[2])
	                        );
	                    }
	                    if (isMethodWhichHasThisArg(parent.callee)) {
	                        return (
	                            parent.arguments.length !== 2 ||
	                            parent.arguments[0] !== node ||
	                            isNullOrUndefined(parent.arguments[1])
	                        );
	                    }
	                    return true;
	
	                // Otherwise `this` is default.
	                default:
	                    return true;
	            }
	        }
	
	        /* istanbul ignore next */
	        return true;
	    },
	
	    /**
	     * Get the precedence level based on the node type
	     * @param {ASTNode} node node to evaluate
	     * @returns {int} precedence level
	     * @private
	     */
	    getPrecedence(node) {
	        switch (node.type) {
	            case "SequenceExpression":
	                return 0;
	
	            case "AssignmentExpression":
	            case "ArrowFunctionExpression":
	            case "YieldExpression":
	                return 1;
	
	            case "ConditionalExpression":
	                return 3;
	
	            case "LogicalExpression":
	                switch (node.operator) {
	                    case "||":
	                        return 4;
	                    case "&&":
	                        return 5;
	
	                    // no default
	                }
	
	                /* falls through */
	
	            case "BinaryExpression":
	
	                switch (node.operator) {
	                    case "|":
	                        return 6;
	                    case "^":
	                        return 7;
	                    case "&":
	                        return 8;
	                    case "==":
	                    case "!=":
	                    case "===":
	                    case "!==":
	                        return 9;
	                    case "<":
	                    case "<=":
	                    case ">":
	                    case ">=":
	                    case "in":
	                    case "instanceof":
	                        return 10;
	                    case "<<":
	                    case ">>":
	                    case ">>>":
	                        return 11;
	                    case "+":
	                    case "-":
	                        return 12;
	                    case "*":
	                    case "/":
	                    case "%":
	                        return 13;
	
	                    // no default
	                }
	
	                /* falls through */
	
	            case "UnaryExpression":
	            case "AwaitExpression":
	                return 14;
	
	            case "UpdateExpression":
	                return 15;
	
	            case "CallExpression":
	
	                // IIFE is allowed to have parens in any position (#655)
	                if (node.callee.type === "FunctionExpression") {
	                    return -1;
	                }
	                return 16;
	
	            case "NewExpression":
	                return 17;
	
	            // no default
	        }
	        return 18;
	    },
	
	    /**
	     * Checks whether a given node is a loop node or not.
	     * The following types are loop nodes:
	     *
	     * - DoWhileStatement
	     * - ForInStatement
	     * - ForOfStatement
	     * - ForStatement
	     * - WhileStatement
	     *
	     * @param {ASTNode|null} node - A node to check.
	     * @returns {boolean} `true` if the node is a loop node.
	     */
	    isLoop(node) {
	        return Boolean(node && anyLoopPattern.test(node.type));
	    },
	
	    /**
	     * Checks whether a given node is a function node or not.
	     * The following types are function nodes:
	     *
	     * - ArrowFunctionExpression
	     * - FunctionDeclaration
	     * - FunctionExpression
	     *
	     * @param {ASTNode|null} node - A node to check.
	     * @returns {boolean} `true` if the node is a function node.
	     */
	    isFunction(node) {
	        return Boolean(node && anyFunctionPattern.test(node.type));
	    },
	
	    /**
	     * Gets the property name of a given node.
	     * The node can be a MemberExpression, a Property, or a MethodDefinition.
	     *
	     * If the name is dynamic, this returns `null`.
	     *
	     * For examples:
	     *
	     *     a.b           // => "b"
	     *     a["b"]        // => "b"
	     *     a['b']        // => "b"
	     *     a[`b`]        // => "b"
	     *     a[100]        // => "100"
	     *     a[b]          // => null
	     *     a["a" + "b"]  // => null
	     *     a[tag`b`]     // => null
	     *     a[`${b}`]     // => null
	     *
	     *     let a = {b: 1}            // => "b"
	     *     let a = {["b"]: 1}        // => "b"
	     *     let a = {['b']: 1}        // => "b"
	     *     let a = {[`b`]: 1}        // => "b"
	     *     let a = {[100]: 1}        // => "100"
	     *     let a = {[b]: 1}          // => null
	     *     let a = {["a" + "b"]: 1}  // => null
	     *     let a = {[tag`b`]: 1}     // => null
	     *     let a = {[`${b}`]: 1}     // => null
	     *
	     * @param {ASTNode} node - The node to get.
	     * @returns {string|null} The property name if static. Otherwise, null.
	     */
	    getStaticPropertyName(node) {
	        let prop;
	
	        switch (node && node.type) {
	            case "Property":
	            case "MethodDefinition":
	                prop = node.key;
	                break;
	
	            case "MemberExpression":
	                prop = node.property;
	                break;
	
	            // no default
	        }
	
	        switch (prop && prop.type) {
	            case "Literal":
	                return String(prop.value);
	
	            case "TemplateLiteral":
	                if (prop.expressions.length === 0 && prop.quasis.length === 1) {
	                    return prop.quasis[0].value.cooked;
	                }
	                break;
	
	            case "Identifier":
	                if (!node.computed) {
	                    return prop.name;
	                }
	                break;
	
	            // no default
	        }
	
	        return null;
	    },
	
	    /**
	     * Get directives from directive prologue of a Program or Function node.
	     * @param {ASTNode} node - The node to check.
	     * @returns {ASTNode[]} The directives found in the directive prologue.
	     */
	    getDirectivePrologue(node) {
	        const directives = [];
	
	        // Directive prologues only occur at the top of files or functions.
	        if (
	            node.type === "Program" ||
	            node.type === "FunctionDeclaration" ||
	            node.type === "FunctionExpression" ||
	
	            // Do not check arrow functions with implicit return.
	            // `() => "use strict";` returns the string `"use strict"`.
	            (node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement")
	        ) {
	            const statements = node.type === "Program" ? node.body : node.body.body;
	
	            for (const statement of statements) {
	                if (
	                    statement.type === "ExpressionStatement" &&
	                    statement.expression.type === "Literal"
	                ) {
	                    directives.push(statement);
	                } else {
	                    break;
	                }
	            }
	        }
	
	        return directives;
	    },
	
	
	    /**
	     * Determines whether this node is a decimal integer literal. If a node is a decimal integer literal, a dot added
	     after the node will be parsed as a decimal point, rather than a property-access dot.
	     * @param {ASTNode} node - The node to check.
	     * @returns {boolean} `true` if this node is a decimal integer.
	     * @example
	     *
	     * 5       // true
	     * 5.      // false
	     * 5.0     // false
	     * 05      // false
	     * 0x5     // false
	     * 0b101   // false
	     * 0o5     // false
	     * 5e0     // false
	     * '5'     // false
	     */
	    isDecimalInteger(node) {
	        return node.type === "Literal" && typeof node.value === "number" && /^(0|[1-9]\d*)$/.test(node.raw);
	    }
	};


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	
	(function () {
	    'use strict';
	
	    exports.ast = __webpack_require__(111);
	    exports.code = __webpack_require__(112);
	    exports.keyword = __webpack_require__(113);
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 111 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	(function () {
	    'use strict';
	
	    function isExpression(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'ArrayExpression':
	            case 'AssignmentExpression':
	            case 'BinaryExpression':
	            case 'CallExpression':
	            case 'ConditionalExpression':
	            case 'FunctionExpression':
	            case 'Identifier':
	            case 'Literal':
	            case 'LogicalExpression':
	            case 'MemberExpression':
	            case 'NewExpression':
	            case 'ObjectExpression':
	            case 'SequenceExpression':
	            case 'ThisExpression':
	            case 'UnaryExpression':
	            case 'UpdateExpression':
	                return true;
	        }
	        return false;
	    }
	
	    function isIterationStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'DoWhileStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'WhileStatement':
	                return true;
	        }
	        return false;
	    }
	
	    function isStatement(node) {
	        if (node == null) { return false; }
	        switch (node.type) {
	            case 'BlockStatement':
	            case 'BreakStatement':
	            case 'ContinueStatement':
	            case 'DebuggerStatement':
	            case 'DoWhileStatement':
	            case 'EmptyStatement':
	            case 'ExpressionStatement':
	            case 'ForInStatement':
	            case 'ForStatement':
	            case 'IfStatement':
	            case 'LabeledStatement':
	            case 'ReturnStatement':
	            case 'SwitchStatement':
	            case 'ThrowStatement':
	            case 'TryStatement':
	            case 'VariableDeclaration':
	            case 'WhileStatement':
	            case 'WithStatement':
	                return true;
	        }
	        return false;
	    }
	
	    function isSourceElement(node) {
	      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
	    }
	
	    function trailingStatement(node) {
	        switch (node.type) {
	        case 'IfStatement':
	            if (node.alternate != null) {
	                return node.alternate;
	            }
	            return node.consequent;
	
	        case 'LabeledStatement':
	        case 'ForStatement':
	        case 'ForInStatement':
	        case 'WhileStatement':
	        case 'WithStatement':
	            return node.body;
	        }
	        return null;
	    }
	
	    function isProblematicIfStatement(node) {
	        var current;
	
	        if (node.type !== 'IfStatement') {
	            return false;
	        }
	        if (node.alternate == null) {
	            return false;
	        }
	        current = node.consequent;
	        do {
	            if (current.type === 'IfStatement') {
	                if (current.alternate == null)  {
	                    return true;
	                }
	            }
	            current = trailingStatement(current);
	        } while (current);
	
	        return false;
	    }
	
	    module.exports = {
	        isExpression: isExpression,
	        isStatement: isStatement,
	        isIterationStatement: isIterationStatement,
	        isSourceElement: isSourceElement,
	        isProblematicIfStatement: isProblematicIfStatement,
	
	        trailingStatement: trailingStatement
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 112 */
/***/ function(module, exports) {

	/*
	  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
	  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	(function () {
	    'use strict';
	
	    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
	
	    // See `tools/generate-identifier-regex.js`.
	    ES5Regex = {
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
	        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
	    };
	
	    ES6Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };
	
	    function isDecimalDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39;  // 0..9
	    }
	
	    function isHexDigit(ch) {
	        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
	            0x61 <= ch && ch <= 0x66 ||     // a..f
	            0x41 <= ch && ch <= 0x46;       // A..F
	    }
	
	    function isOctalDigit(ch) {
	        return ch >= 0x30 && ch <= 0x37;  // 0..7
	    }
	
	    // 7.2 White Space
	
	    NON_ASCII_WHITESPACES = [
	        0x1680, 0x180E,
	        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
	        0x202F, 0x205F,
	        0x3000,
	        0xFEFF
	    ];
	
	    function isWhiteSpace(ch) {
	        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
	            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
	    }
	
	    // 7.3 Line Terminators
	
	    function isLineTerminator(ch) {
	        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
	    }
	
	    // 7.6 Identifier Names and Identifiers
	
	    function fromCodePoint(cp) {
	        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
	        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
	        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
	        return cu1 + cu2;
	    }
	
	    IDENTIFIER_START = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_START[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }
	
	    IDENTIFIER_PART = new Array(0x80);
	    for(ch = 0; ch < 0x80; ++ch) {
	        IDENTIFIER_PART[ch] =
	            ch >= 0x61 && ch <= 0x7A ||  // a..z
	            ch >= 0x41 && ch <= 0x5A ||  // A..Z
	            ch >= 0x30 && ch <= 0x39 ||  // 0..9
	            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
	    }
	
	    function isIdentifierStartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }
	
	    function isIdentifierPartES5(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }
	
	    function isIdentifierStartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
	    }
	
	    function isIdentifierPartES6(ch) {
	        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
	    }
	
	    module.exports = {
	        isDecimalDigit: isDecimalDigit,
	        isHexDigit: isHexDigit,
	        isOctalDigit: isOctalDigit,
	        isWhiteSpace: isWhiteSpace,
	        isLineTerminator: isLineTerminator,
	        isIdentifierStartES5: isIdentifierStartES5,
	        isIdentifierPartES5: isIdentifierPartES5,
	        isIdentifierStartES6: isIdentifierStartES6,
	        isIdentifierPartES6: isIdentifierPartES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/*
	  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
	
	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:
	
	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.
	
	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	
	(function () {
	    'use strict';
	
	    var code = __webpack_require__(112);
	
	    function isStrictModeReservedWordES6(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    function isKeywordES5(id, strict) {
	        // yield should not be treated as keyword under non-strict mode.
	        if (!strict && id === 'yield') {
	            return false;
	        }
	        return isKeywordES6(id, strict);
	    }
	
	    function isKeywordES6(id, strict) {
	        if (strict && isStrictModeReservedWordES6(id)) {
	            return true;
	        }
	
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }
	
	    function isReservedWordES5(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
	    }
	
	    function isReservedWordES6(id, strict) {
	        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
	    }
	
	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }
	
	    function isIdentifierNameES5(id) {
	        var i, iz, ch;
	
	        if (id.length === 0) { return false; }
	
	        ch = id.charCodeAt(0);
	        if (!code.isIdentifierStartES5(ch)) {
	            return false;
	        }
	
	        for (i = 1, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (!code.isIdentifierPartES5(ch)) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    function decodeUtf16(lead, trail) {
	        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
	    }
	
	    function isIdentifierNameES6(id) {
	        var i, iz, ch, lowCh, check;
	
	        if (id.length === 0) { return false; }
	
	        check = code.isIdentifierStartES6;
	        for (i = 0, iz = id.length; i < iz; ++i) {
	            ch = id.charCodeAt(i);
	            if (0xD800 <= ch && ch <= 0xDBFF) {
	                ++i;
	                if (i >= iz) { return false; }
	                lowCh = id.charCodeAt(i);
	                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
	                    return false;
	                }
	                ch = decodeUtf16(ch, lowCh);
	            }
	            if (!check(ch)) {
	                return false;
	            }
	            check = code.isIdentifierPartES6;
	        }
	        return true;
	    }
	
	    function isIdentifierES5(id, strict) {
	        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
	    }
	
	    function isIdentifierES6(id, strict) {
	        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
	    }
	
	    module.exports = {
	        isKeywordES5: isKeywordES5,
	        isKeywordES6: isKeywordES6,
	        isReservedWordES5: isReservedWordES5,
	        isReservedWordES6: isReservedWordES6,
	        isRestrictedWord: isRestrictedWord,
	        isIdentifierNameES5: isIdentifierNameES5,
	        isIdentifierNameES6: isIdentifierNameES6,
	        isIdentifierES5: isIdentifierES5,
	        isIdentifierES6: isIdentifierES6
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Config file operations. This file must be usable in the browser,
	 * so no Node-specific code can be here.
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const Environments = __webpack_require__(115);
	
	const debug = __webpack_require__(104)("eslint:config-ops");
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	const RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
	    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce(function(map, value, index) {
	        map[value] = index;
	        return map;
	    }, {}),
	    VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    /**
	     * Creates an empty configuration object suitable for merging as a base.
	     * @returns {Object} A configuration object.
	     */
	    createEmptyConfig() {
	        return {
	            globals: {},
	            env: {},
	            rules: {},
	            parserOptions: {}
	        };
	    },
	
	    /**
	     * Creates an environment config based on the specified environments.
	     * @param {Object<string,boolean>} env The environment settings.
	     * @returns {Object} A configuration object with the appropriate rules and globals
	     *      set.
	     */
	    createEnvironmentConfig(env) {
	
	        const envConfig = this.createEmptyConfig();
	
	        if (env) {
	
	            envConfig.env = env;
	
	            Object.keys(env).filter(function(name) {
	                return env[name];
	            }).forEach(function(name) {
	                const environment = Environments.get(name);
	
	                if (environment) {
	                    debug(`Creating config for environment ${name}`);
	                    if (environment.globals) {
	                        Object.assign(envConfig.globals, environment.globals);
	                    }
	
	                    if (environment.parserOptions) {
	                        Object.assign(envConfig.parserOptions, environment.parserOptions);
	                    }
	                }
	            });
	        }
	
	        return envConfig;
	    },
	
	    /**
	     * Given a config with environment settings, applies the globals and
	     * ecmaFeatures to the configuration and returns the result.
	     * @param {Object} config The configuration information.
	     * @returns {Object} The updated configuration information.
	     */
	    applyEnvironments(config) {
	        if (config.env && typeof config.env === "object") {
	            debug("Apply environment settings to config");
	            return this.merge(this.createEnvironmentConfig(config.env), config);
	        }
	
	        return config;
	    },
	
	    /**
	     * Merges two config objects. This will not only add missing keys, but will also modify values to match.
	     * @param {Object} target config object
	     * @param {Object} src config object. Overrides in this config object will take priority over base.
	     * @param {boolean} [combine] Whether to combine arrays or not
	     * @param {boolean} [isRule] Whether its a rule
	     * @returns {Object} merged config object.
	     */
	    merge: function deepmerge(target, src, combine, isRule) {
	
	        /*
	         The MIT License (MIT)
	
	         Copyright (c) 2012 Nicholas Fisher
	
	         Permission is hereby granted, free of charge, to any person obtaining a copy
	         of this software and associated documentation files (the "Software"), to deal
	         in the Software without restriction, including without limitation the rights
	         to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	         copies of the Software, and to permit persons to whom the Software is
	         furnished to do so, subject to the following conditions:
	
	         The above copyright notice and this permission notice shall be included in
	         all copies or substantial portions of the Software.
	
	         THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	         IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	         FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	         AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	         LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	         OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	         THE SOFTWARE.
	         */
	
	        /*
	         * This code is taken from deepmerge repo
	         * (https://github.com/KyleAMathews/deepmerge)
	         * and modified to meet our needs.
	         */
	        const array = Array.isArray(src) || Array.isArray(target);
	        let dst = array && [] || {};
	
	        combine = !!combine;
	        isRule = !!isRule;
	        if (array) {
	            target = target || [];
	
	            // src could be a string, so check for array
	            if (isRule && Array.isArray(src) && src.length > 1) {
	                dst = dst.concat(src);
	            } else {
	                dst = dst.concat(target);
	            }
	            if (typeof src !== "object" && !Array.isArray(src)) {
	                src = [src];
	            }
	            Object.keys(src).forEach(function(e, i) {
	                e = src[i];
	                if (typeof dst[i] === "undefined") {
	                    dst[i] = e;
	                } else if (typeof e === "object") {
	                    if (isRule) {
	                        dst[i] = e;
	                    } else {
	                        dst[i] = deepmerge(target[i], e, combine, isRule);
	                    }
	                } else {
	                    if (!combine) {
	                        dst[i] = e;
	                    } else {
	                        if (dst.indexOf(e) === -1) {
	                            dst.push(e);
	                        }
	                    }
	                }
	            });
	        } else {
	            if (target && typeof target === "object") {
	                Object.keys(target).forEach(function(key) {
	                    dst[key] = target[key];
	                });
	            }
	            Object.keys(src).forEach(function(key) {
	                if (Array.isArray(src[key]) || Array.isArray(target[key])) {
	                    dst[key] = deepmerge(target[key], src[key], key === "plugins", isRule);
	                } else if (typeof src[key] !== "object" || !src[key] || key === "exported" || key === "astGlobals") {
	                    dst[key] = src[key];
	                } else {
	                    dst[key] = deepmerge(target[key] || {}, src[key], combine, key === "rules");
	                }
	            });
	        }
	
	        return dst;
	    },
	
	    /**
	     * Converts new-style severity settings (off, warn, error) into old-style
	     * severity settings (0, 1, 2) for all rules. Assumption is that severity
	     * values have already been validated as correct.
	     * @param {Object} config The config object to normalize.
	     * @returns {void}
	     */
	    normalize(config) {
	
	        if (config.rules) {
	            Object.keys(config.rules).forEach(function(ruleId) {
	                const ruleConfig = config.rules[ruleId];
	
	                if (typeof ruleConfig === "string") {
	                    config.rules[ruleId] = RULE_SEVERITY[ruleConfig.toLowerCase()] || 0;
	                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "string") {
	                    ruleConfig[0] = RULE_SEVERITY[ruleConfig[0].toLowerCase()] || 0;
	                }
	            });
	        }
	    },
	
	    /**
	     * Converts old-style severity settings (0, 1, 2) into new-style
	     * severity settings (off, warn, error) for all rules. Assumption is that severity
	     * values have already been validated as correct.
	     * @param {Object} config The config object to normalize.
	     * @returns {void}
	     */
	    normalizeToStrings(config) {
	
	        if (config.rules) {
	            Object.keys(config.rules).forEach(function(ruleId) {
	                const ruleConfig = config.rules[ruleId];
	
	                if (typeof ruleConfig === "number") {
	                    config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
	                } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
	                    ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
	                }
	            });
	        }
	    },
	
	    /**
	     * Determines if the severity for the given rule configuration represents an error.
	     * @param {int|string|Array} ruleConfig The configuration for an individual rule.
	     * @returns {boolean} True if the rule represents an error, false if not.
	     */
	    isErrorSeverity(ruleConfig) {
	
	        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
	
	        if (typeof severity === "string") {
	            severity = RULE_SEVERITY[severity.toLowerCase()] || 0;
	        }
	
	        return (typeof severity === "number" && severity === 2);
	    },
	
	    /**
	     * Checks whether a given config has valid severity or not.
	     * @param {number|string|Array} ruleConfig - The configuration for an individual rule.
	     * @returns {boolean} `true` if the configuration has valid severity.
	     */
	    isValidSeverity(ruleConfig) {
	        let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
	
	        if (typeof severity === "string") {
	            severity = severity.toLowerCase();
	        }
	        return VALID_SEVERITIES.indexOf(severity) !== -1;
	    },
	
	    /**
	     * Checks whether every rule of a given config has valid severity or not.
	     * @param {Object} config - The configuration for rules.
	     * @returns {boolean} `true` if the configuration has valid severity.
	     */
	    isEverySeverityValid(config) {
	        return Object.keys(config).every(function(ruleId) {
	            return this.isValidSeverity(config[ruleId]);
	        }, this);
	    }
	};


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Environments manager
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const envs = __webpack_require__(116);
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	let environments = new Map();
	
	/**
	 * Loads the default environments.
	 * @returns {void}
	 * @private
	 */
	function load() {
	    Object.keys(envs).forEach(function(envName) {
	        environments.set(envName, envs[envName]);
	    });
	}
	
	// always load default environments upfront
	load();
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    load,
	
	    /**
	     * Gets the environment with the given name.
	     * @param {string} name The name of the environment to retrieve.
	     * @returns {Object?} The environment object or null if not found.
	     */
	    get(name) {
	        return environments.get(name) || null;
	    },
	
	    /**
	     * Defines an environment.
	     * @param {string} name The name of the environment.
	     * @param {Object} env The environment settings.
	     * @returns {void}
	     */
	    define(name, env) {
	        environments.set(name, env);
	    },
	
	    /**
	     * Imports all environments from a plugin.
	     * @param {Object} plugin The plugin object.
	     * @param {string} pluginName The name of the plugin.
	     * @returns {void}
	     */
	    importPlugin(plugin, pluginName) {
	        if (plugin.environments) {
	            Object.keys(plugin.environments).forEach(function(envName) {
	                this.define(`${pluginName}/${envName}`, plugin.environments[envName]);
	            }, this);
	        }
	    },
	
	    /**
	     * Resets all environments. Only use for tests!
	     * @returns {void}
	     */
	    testReset() {
	        environments = new Map();
	        load();
	    }
	};


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Defines environment settings and globals.
	 * @author Elan Shanker
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const globals = __webpack_require__(117);
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	    builtin: globals.es5,
	    browser: {
	        globals: globals.browser
	    },
	    node: {
	        globals: globals.node,
	        parserOptions: {
	            ecmaFeatures: {
	                globalReturn: true
	            }
	        }
	    },
	    commonjs: {
	        globals: globals.commonjs,
	        parserOptions: {
	            ecmaFeatures: {
	                globalReturn: true
	            }
	        }
	    },
	    "shared-node-browser": {
	        globals: globals["shared-node-browser"]
	    },
	    worker: {
	        globals: globals.worker
	    },
	    amd: {
	        globals: globals.amd
	    },
	    mocha: {
	        globals: globals.mocha
	    },
	    jasmine: {
	        globals: globals.jasmine
	    },
	    jest: {
	        globals: globals.jest
	    },
	    phantomjs: {
	        globals: globals.phantomjs
	    },
	    jquery: {
	        globals: globals.jquery
	    },
	    qunit: {
	        globals: globals.qunit
	    },
	    prototypejs: {
	        globals: globals.prototypejs
	    },
	    shelljs: {
	        globals: globals.shelljs
	    },
	    meteor: {
	        globals: globals.meteor
	    },
	    mongo: {
	        globals: globals.mongo
	    },
	    protractor: {
	        globals: globals.protractor
	    },
	    applescript: {
	        globals: globals.applescript
	    },
	    nashorn: {
	        globals: globals.nashorn
	    },
	    serviceworker: {
	        globals: globals.serviceworker
	    },
	    atomtest: {
	        globals: globals.atomtest
	    },
	    embertest: {
	        globals: globals.embertest
	    },
	    webextensions: {
	        globals: globals.webextensions
	    },
	    es6: {
	        globals: globals.es6,
	        parserOptions: {
	            ecmaVersion: 6
	        }
	    },
	    greasemonkey: {
	        globals: globals.greasemonkey
	    }
	};


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(118);


/***/ },
/* 118 */
/***/ function(module, exports) {

	module.exports = {
		"builtin": {
			"Array": false,
			"ArrayBuffer": false,
			"Boolean": false,
			"constructor": false,
			"DataView": false,
			"Date": false,
			"decodeURI": false,
			"decodeURIComponent": false,
			"encodeURI": false,
			"encodeURIComponent": false,
			"Error": false,
			"escape": false,
			"eval": false,
			"EvalError": false,
			"Float32Array": false,
			"Float64Array": false,
			"Function": false,
			"hasOwnProperty": false,
			"Infinity": false,
			"Int16Array": false,
			"Int32Array": false,
			"Int8Array": false,
			"isFinite": false,
			"isNaN": false,
			"isPrototypeOf": false,
			"JSON": false,
			"Map": false,
			"Math": false,
			"NaN": false,
			"Number": false,
			"Object": false,
			"parseFloat": false,
			"parseInt": false,
			"Promise": false,
			"propertyIsEnumerable": false,
			"Proxy": false,
			"RangeError": false,
			"ReferenceError": false,
			"Reflect": false,
			"RegExp": false,
			"Set": false,
			"String": false,
			"Symbol": false,
			"SyntaxError": false,
			"System": false,
			"toLocaleString": false,
			"toString": false,
			"TypeError": false,
			"Uint16Array": false,
			"Uint32Array": false,
			"Uint8Array": false,
			"Uint8ClampedArray": false,
			"undefined": false,
			"unescape": false,
			"URIError": false,
			"valueOf": false,
			"WeakMap": false,
			"WeakSet": false
		},
		"es5": {
			"Array": false,
			"Boolean": false,
			"constructor": false,
			"Date": false,
			"decodeURI": false,
			"decodeURIComponent": false,
			"encodeURI": false,
			"encodeURIComponent": false,
			"Error": false,
			"escape": false,
			"eval": false,
			"EvalError": false,
			"Function": false,
			"hasOwnProperty": false,
			"Infinity": false,
			"isFinite": false,
			"isNaN": false,
			"isPrototypeOf": false,
			"JSON": false,
			"Math": false,
			"NaN": false,
			"Number": false,
			"Object": false,
			"parseFloat": false,
			"parseInt": false,
			"propertyIsEnumerable": false,
			"RangeError": false,
			"ReferenceError": false,
			"RegExp": false,
			"String": false,
			"SyntaxError": false,
			"toLocaleString": false,
			"toString": false,
			"TypeError": false,
			"undefined": false,
			"unescape": false,
			"URIError": false,
			"valueOf": false
		},
		"es6": {
			"Array": false,
			"ArrayBuffer": false,
			"Boolean": false,
			"constructor": false,
			"DataView": false,
			"Date": false,
			"decodeURI": false,
			"decodeURIComponent": false,
			"encodeURI": false,
			"encodeURIComponent": false,
			"Error": false,
			"escape": false,
			"eval": false,
			"EvalError": false,
			"Float32Array": false,
			"Float64Array": false,
			"Function": false,
			"hasOwnProperty": false,
			"Infinity": false,
			"Int16Array": false,
			"Int32Array": false,
			"Int8Array": false,
			"isFinite": false,
			"isNaN": false,
			"isPrototypeOf": false,
			"JSON": false,
			"Map": false,
			"Math": false,
			"NaN": false,
			"Number": false,
			"Object": false,
			"parseFloat": false,
			"parseInt": false,
			"Promise": false,
			"propertyIsEnumerable": false,
			"Proxy": false,
			"RangeError": false,
			"ReferenceError": false,
			"Reflect": false,
			"RegExp": false,
			"Set": false,
			"String": false,
			"Symbol": false,
			"SyntaxError": false,
			"System": false,
			"toLocaleString": false,
			"toString": false,
			"TypeError": false,
			"Uint16Array": false,
			"Uint32Array": false,
			"Uint8Array": false,
			"Uint8ClampedArray": false,
			"undefined": false,
			"unescape": false,
			"URIError": false,
			"valueOf": false,
			"WeakMap": false,
			"WeakSet": false
		},
		"browser": {
			"addEventListener": false,
			"alert": false,
			"AnalyserNode": false,
			"Animation": false,
			"AnimationEffectReadOnly": false,
			"AnimationEffectTiming": false,
			"AnimationEffectTimingReadOnly": false,
			"AnimationEvent": false,
			"AnimationPlaybackEvent": false,
			"AnimationTimeline": false,
			"applicationCache": false,
			"ApplicationCache": false,
			"ApplicationCacheErrorEvent": false,
			"atob": false,
			"Attr": false,
			"Audio": false,
			"AudioBuffer": false,
			"AudioBufferSourceNode": false,
			"AudioContext": false,
			"AudioDestinationNode": false,
			"AudioListener": false,
			"AudioNode": false,
			"AudioParam": false,
			"AudioProcessingEvent": false,
			"AutocompleteErrorEvent": false,
			"BarProp": false,
			"BatteryManager": false,
			"BeforeUnloadEvent": false,
			"BiquadFilterNode": false,
			"Blob": false,
			"blur": false,
			"btoa": false,
			"Cache": false,
			"caches": false,
			"CacheStorage": false,
			"cancelAnimationFrame": false,
			"CanvasGradient": false,
			"CanvasPattern": false,
			"CanvasRenderingContext2D": false,
			"CDATASection": false,
			"ChannelMergerNode": false,
			"ChannelSplitterNode": false,
			"CharacterData": false,
			"clearInterval": false,
			"clearTimeout": false,
			"clientInformation": false,
			"ClientRect": false,
			"ClientRectList": false,
			"ClipboardEvent": false,
			"close": false,
			"closed": false,
			"CloseEvent": false,
			"Comment": false,
			"CompositionEvent": false,
			"confirm": false,
			"console": false,
			"ConvolverNode": false,
			"Credential": false,
			"CredentialsContainer": false,
			"crypto": false,
			"Crypto": false,
			"CryptoKey": false,
			"CSS": false,
			"CSSAnimation": false,
			"CSSFontFaceRule": false,
			"CSSImportRule": false,
			"CSSKeyframeRule": false,
			"CSSKeyframesRule": false,
			"CSSMediaRule": false,
			"CSSPageRule": false,
			"CSSRule": false,
			"CSSRuleList": false,
			"CSSStyleDeclaration": false,
			"CSSStyleRule": false,
			"CSSStyleSheet": false,
			"CSSSupportsRule": false,
			"CSSTransition": false,
			"CSSUnknownRule": false,
			"CSSViewportRule": false,
			"customElements": false,
			"CustomEvent": false,
			"DataTransfer": false,
			"DataTransferItem": false,
			"DataTransferItemList": false,
			"Debug": false,
			"defaultStatus": false,
			"defaultstatus": false,
			"DelayNode": false,
			"DeviceMotionEvent": false,
			"DeviceOrientationEvent": false,
			"devicePixelRatio": false,
			"dispatchEvent": false,
			"document": false,
			"Document": false,
			"DocumentFragment": false,
			"DocumentTimeline": false,
			"DocumentType": false,
			"DOMError": false,
			"DOMException": false,
			"DOMImplementation": false,
			"DOMParser": false,
			"DOMSettableTokenList": false,
			"DOMStringList": false,
			"DOMStringMap": false,
			"DOMTokenList": false,
			"DragEvent": false,
			"DynamicsCompressorNode": false,
			"Element": false,
			"ElementTimeControl": false,
			"ErrorEvent": false,
			"event": false,
			"Event": false,
			"EventSource": false,
			"EventTarget": false,
			"external": false,
			"FederatedCredential": false,
			"fetch": false,
			"File": false,
			"FileError": false,
			"FileList": false,
			"FileReader": false,
			"find": false,
			"focus": false,
			"FocusEvent": false,
			"FontFace": false,
			"FormData": false,
			"frameElement": false,
			"frames": false,
			"GainNode": false,
			"Gamepad": false,
			"GamepadButton": false,
			"GamepadEvent": false,
			"getComputedStyle": false,
			"getSelection": false,
			"HashChangeEvent": false,
			"Headers": false,
			"history": false,
			"History": false,
			"HTMLAllCollection": false,
			"HTMLAnchorElement": false,
			"HTMLAppletElement": false,
			"HTMLAreaElement": false,
			"HTMLAudioElement": false,
			"HTMLBaseElement": false,
			"HTMLBlockquoteElement": false,
			"HTMLBodyElement": false,
			"HTMLBRElement": false,
			"HTMLButtonElement": false,
			"HTMLCanvasElement": false,
			"HTMLCollection": false,
			"HTMLContentElement": false,
			"HTMLDataListElement": false,
			"HTMLDetailsElement": false,
			"HTMLDialogElement": false,
			"HTMLDirectoryElement": false,
			"HTMLDivElement": false,
			"HTMLDListElement": false,
			"HTMLDocument": false,
			"HTMLElement": false,
			"HTMLEmbedElement": false,
			"HTMLFieldSetElement": false,
			"HTMLFontElement": false,
			"HTMLFormControlsCollection": false,
			"HTMLFormElement": false,
			"HTMLFrameElement": false,
			"HTMLFrameSetElement": false,
			"HTMLHeadElement": false,
			"HTMLHeadingElement": false,
			"HTMLHRElement": false,
			"HTMLHtmlElement": false,
			"HTMLIFrameElement": false,
			"HTMLImageElement": false,
			"HTMLInputElement": false,
			"HTMLIsIndexElement": false,
			"HTMLKeygenElement": false,
			"HTMLLabelElement": false,
			"HTMLLayerElement": false,
			"HTMLLegendElement": false,
			"HTMLLIElement": false,
			"HTMLLinkElement": false,
			"HTMLMapElement": false,
			"HTMLMarqueeElement": false,
			"HTMLMediaElement": false,
			"HTMLMenuElement": false,
			"HTMLMetaElement": false,
			"HTMLMeterElement": false,
			"HTMLModElement": false,
			"HTMLObjectElement": false,
			"HTMLOListElement": false,
			"HTMLOptGroupElement": false,
			"HTMLOptionElement": false,
			"HTMLOptionsCollection": false,
			"HTMLOutputElement": false,
			"HTMLParagraphElement": false,
			"HTMLParamElement": false,
			"HTMLPictureElement": false,
			"HTMLPreElement": false,
			"HTMLProgressElement": false,
			"HTMLQuoteElement": false,
			"HTMLScriptElement": false,
			"HTMLSelectElement": false,
			"HTMLShadowElement": false,
			"HTMLSourceElement": false,
			"HTMLSpanElement": false,
			"HTMLStyleElement": false,
			"HTMLTableCaptionElement": false,
			"HTMLTableCellElement": false,
			"HTMLTableColElement": false,
			"HTMLTableElement": false,
			"HTMLTableRowElement": false,
			"HTMLTableSectionElement": false,
			"HTMLTemplateElement": false,
			"HTMLTextAreaElement": false,
			"HTMLTitleElement": false,
			"HTMLTrackElement": false,
			"HTMLUListElement": false,
			"HTMLUnknownElement": false,
			"HTMLVideoElement": false,
			"IDBCursor": false,
			"IDBCursorWithValue": false,
			"IDBDatabase": false,
			"IDBEnvironment": false,
			"IDBFactory": false,
			"IDBIndex": false,
			"IDBKeyRange": false,
			"IDBObjectStore": false,
			"IDBOpenDBRequest": false,
			"IDBRequest": false,
			"IDBTransaction": false,
			"IDBVersionChangeEvent": false,
			"Image": false,
			"ImageBitmap": false,
			"ImageData": false,
			"indexedDB": false,
			"innerHeight": false,
			"innerWidth": false,
			"InputEvent": false,
			"InputMethodContext": false,
			"IntersectionObserver": false,
			"IntersectionObserverEntry": false,
			"Intl": false,
			"KeyboardEvent": false,
			"KeyframeEffect": false,
			"KeyframeEffectReadOnly": false,
			"length": false,
			"localStorage": false,
			"location": false,
			"Location": false,
			"locationbar": false,
			"matchMedia": false,
			"MediaElementAudioSourceNode": false,
			"MediaEncryptedEvent": false,
			"MediaError": false,
			"MediaKeyError": false,
			"MediaKeyEvent": false,
			"MediaKeyMessageEvent": false,
			"MediaKeys": false,
			"MediaKeySession": false,
			"MediaKeyStatusMap": false,
			"MediaKeySystemAccess": false,
			"MediaList": false,
			"MediaQueryList": false,
			"MediaQueryListEvent": false,
			"MediaSource": false,
			"MediaStream": false,
			"MediaStreamAudioDestinationNode": false,
			"MediaStreamAudioSourceNode": false,
			"MediaStreamEvent": false,
			"MediaStreamTrack": false,
			"menubar": false,
			"MessageChannel": false,
			"MessageEvent": false,
			"MessagePort": false,
			"MIDIAccess": false,
			"MIDIConnectionEvent": false,
			"MIDIInput": false,
			"MIDIInputMap": false,
			"MIDIMessageEvent": false,
			"MIDIOutput": false,
			"MIDIOutputMap": false,
			"MIDIPort": false,
			"MimeType": false,
			"MimeTypeArray": false,
			"MouseEvent": false,
			"moveBy": false,
			"moveTo": false,
			"MutationEvent": false,
			"MutationObserver": false,
			"MutationRecord": false,
			"name": false,
			"NamedNodeMap": false,
			"navigator": false,
			"Navigator": false,
			"Node": false,
			"NodeFilter": false,
			"NodeIterator": false,
			"NodeList": false,
			"Notification": false,
			"OfflineAudioCompletionEvent": false,
			"OfflineAudioContext": false,
			"offscreenBuffering": false,
			"onbeforeunload": true,
			"onblur": true,
			"onerror": true,
			"onfocus": true,
			"onload": true,
			"onresize": true,
			"onunload": true,
			"open": false,
			"openDatabase": false,
			"opener": false,
			"opera": false,
			"Option": false,
			"OscillatorNode": false,
			"outerHeight": false,
			"outerWidth": false,
			"PageTransitionEvent": false,
			"pageXOffset": false,
			"pageYOffset": false,
			"parent": false,
			"PasswordCredential": false,
			"Path2D": false,
			"performance": false,
			"Performance": false,
			"PerformanceEntry": false,
			"PerformanceMark": false,
			"PerformanceMeasure": false,
			"PerformanceNavigation": false,
			"PerformanceResourceTiming": false,
			"PerformanceTiming": false,
			"PeriodicWave": false,
			"Permissions": false,
			"PermissionStatus": false,
			"personalbar": false,
			"Plugin": false,
			"PluginArray": false,
			"PopStateEvent": false,
			"postMessage": false,
			"print": false,
			"ProcessingInstruction": false,
			"ProgressEvent": false,
			"PromiseRejectionEvent": false,
			"prompt": false,
			"PushManager": false,
			"PushSubscription": false,
			"RadioNodeList": false,
			"Range": false,
			"ReadableByteStream": false,
			"ReadableStream": false,
			"removeEventListener": false,
			"Request": false,
			"requestAnimationFrame": false,
			"requestIdleCallback": false,
			"resizeBy": false,
			"resizeTo": false,
			"Response": false,
			"RTCIceCandidate": false,
			"RTCSessionDescription": false,
			"RTCPeerConnection": false,
			"screen": false,
			"Screen": false,
			"screenLeft": false,
			"ScreenOrientation": false,
			"screenTop": false,
			"screenX": false,
			"screenY": false,
			"ScriptProcessorNode": false,
			"scroll": false,
			"scrollbars": false,
			"scrollBy": false,
			"scrollTo": false,
			"scrollX": false,
			"scrollY": false,
			"SecurityPolicyViolationEvent": false,
			"Selection": false,
			"self": false,
			"ServiceWorker": false,
			"ServiceWorkerContainer": false,
			"ServiceWorkerRegistration": false,
			"sessionStorage": false,
			"setInterval": false,
			"setTimeout": false,
			"ShadowRoot": false,
			"SharedKeyframeList": false,
			"SharedWorker": false,
			"showModalDialog": false,
			"SiteBoundCredential": false,
			"speechSynthesis": false,
			"SpeechSynthesisEvent": false,
			"SpeechSynthesisUtterance": false,
			"status": false,
			"statusbar": false,
			"stop": false,
			"Storage": false,
			"StorageEvent": false,
			"styleMedia": false,
			"StyleSheet": false,
			"StyleSheetList": false,
			"SubtleCrypto": false,
			"SVGAElement": false,
			"SVGAltGlyphDefElement": false,
			"SVGAltGlyphElement": false,
			"SVGAltGlyphItemElement": false,
			"SVGAngle": false,
			"SVGAnimateColorElement": false,
			"SVGAnimatedAngle": false,
			"SVGAnimatedBoolean": false,
			"SVGAnimatedEnumeration": false,
			"SVGAnimatedInteger": false,
			"SVGAnimatedLength": false,
			"SVGAnimatedLengthList": false,
			"SVGAnimatedNumber": false,
			"SVGAnimatedNumberList": false,
			"SVGAnimatedPathData": false,
			"SVGAnimatedPoints": false,
			"SVGAnimatedPreserveAspectRatio": false,
			"SVGAnimatedRect": false,
			"SVGAnimatedString": false,
			"SVGAnimatedTransformList": false,
			"SVGAnimateElement": false,
			"SVGAnimateMotionElement": false,
			"SVGAnimateTransformElement": false,
			"SVGAnimationElement": false,
			"SVGCircleElement": false,
			"SVGClipPathElement": false,
			"SVGColor": false,
			"SVGColorProfileElement": false,
			"SVGColorProfileRule": false,
			"SVGComponentTransferFunctionElement": false,
			"SVGCSSRule": false,
			"SVGCursorElement": false,
			"SVGDefsElement": false,
			"SVGDescElement": false,
			"SVGDiscardElement": false,
			"SVGDocument": false,
			"SVGElement": false,
			"SVGElementInstance": false,
			"SVGElementInstanceList": false,
			"SVGEllipseElement": false,
			"SVGEvent": false,
			"SVGExternalResourcesRequired": false,
			"SVGFEBlendElement": false,
			"SVGFEColorMatrixElement": false,
			"SVGFEComponentTransferElement": false,
			"SVGFECompositeElement": false,
			"SVGFEConvolveMatrixElement": false,
			"SVGFEDiffuseLightingElement": false,
			"SVGFEDisplacementMapElement": false,
			"SVGFEDistantLightElement": false,
			"SVGFEDropShadowElement": false,
			"SVGFEFloodElement": false,
			"SVGFEFuncAElement": false,
			"SVGFEFuncBElement": false,
			"SVGFEFuncGElement": false,
			"SVGFEFuncRElement": false,
			"SVGFEGaussianBlurElement": false,
			"SVGFEImageElement": false,
			"SVGFEMergeElement": false,
			"SVGFEMergeNodeElement": false,
			"SVGFEMorphologyElement": false,
			"SVGFEOffsetElement": false,
			"SVGFEPointLightElement": false,
			"SVGFESpecularLightingElement": false,
			"SVGFESpotLightElement": false,
			"SVGFETileElement": false,
			"SVGFETurbulenceElement": false,
			"SVGFilterElement": false,
			"SVGFilterPrimitiveStandardAttributes": false,
			"SVGFitToViewBox": false,
			"SVGFontElement": false,
			"SVGFontFaceElement": false,
			"SVGFontFaceFormatElement": false,
			"SVGFontFaceNameElement": false,
			"SVGFontFaceSrcElement": false,
			"SVGFontFaceUriElement": false,
			"SVGForeignObjectElement": false,
			"SVGGElement": false,
			"SVGGeometryElement": false,
			"SVGGlyphElement": false,
			"SVGGlyphRefElement": false,
			"SVGGradientElement": false,
			"SVGGraphicsElement": false,
			"SVGHKernElement": false,
			"SVGICCColor": false,
			"SVGImageElement": false,
			"SVGLangSpace": false,
			"SVGLength": false,
			"SVGLengthList": false,
			"SVGLinearGradientElement": false,
			"SVGLineElement": false,
			"SVGLocatable": false,
			"SVGMarkerElement": false,
			"SVGMaskElement": false,
			"SVGMatrix": false,
			"SVGMetadataElement": false,
			"SVGMissingGlyphElement": false,
			"SVGMPathElement": false,
			"SVGNumber": false,
			"SVGNumberList": false,
			"SVGPaint": false,
			"SVGPathElement": false,
			"SVGPathSeg": false,
			"SVGPathSegArcAbs": false,
			"SVGPathSegArcRel": false,
			"SVGPathSegClosePath": false,
			"SVGPathSegCurvetoCubicAbs": false,
			"SVGPathSegCurvetoCubicRel": false,
			"SVGPathSegCurvetoCubicSmoothAbs": false,
			"SVGPathSegCurvetoCubicSmoothRel": false,
			"SVGPathSegCurvetoQuadraticAbs": false,
			"SVGPathSegCurvetoQuadraticRel": false,
			"SVGPathSegCurvetoQuadraticSmoothAbs": false,
			"SVGPathSegCurvetoQuadraticSmoothRel": false,
			"SVGPathSegLinetoAbs": false,
			"SVGPathSegLinetoHorizontalAbs": false,
			"SVGPathSegLinetoHorizontalRel": false,
			"SVGPathSegLinetoRel": false,
			"SVGPathSegLinetoVerticalAbs": false,
			"SVGPathSegLinetoVerticalRel": false,
			"SVGPathSegList": false,
			"SVGPathSegMovetoAbs": false,
			"SVGPathSegMovetoRel": false,
			"SVGPatternElement": false,
			"SVGPoint": false,
			"SVGPointList": false,
			"SVGPolygonElement": false,
			"SVGPolylineElement": false,
			"SVGPreserveAspectRatio": false,
			"SVGRadialGradientElement": false,
			"SVGRect": false,
			"SVGRectElement": false,
			"SVGRenderingIntent": false,
			"SVGScriptElement": false,
			"SVGSetElement": false,
			"SVGStopElement": false,
			"SVGStringList": false,
			"SVGStylable": false,
			"SVGStyleElement": false,
			"SVGSVGElement": false,
			"SVGSwitchElement": false,
			"SVGSymbolElement": false,
			"SVGTests": false,
			"SVGTextContentElement": false,
			"SVGTextElement": false,
			"SVGTextPathElement": false,
			"SVGTextPositioningElement": false,
			"SVGTitleElement": false,
			"SVGTransform": false,
			"SVGTransformable": false,
			"SVGTransformList": false,
			"SVGTRefElement": false,
			"SVGTSpanElement": false,
			"SVGUnitTypes": false,
			"SVGURIReference": false,
			"SVGUseElement": false,
			"SVGViewElement": false,
			"SVGViewSpec": false,
			"SVGVKernElement": false,
			"SVGZoomAndPan": false,
			"SVGZoomEvent": false,
			"Text": false,
			"TextDecoder": false,
			"TextEncoder": false,
			"TextEvent": false,
			"TextMetrics": false,
			"TextTrack": false,
			"TextTrackCue": false,
			"TextTrackCueList": false,
			"TextTrackList": false,
			"TimeEvent": false,
			"TimeRanges": false,
			"toolbar": false,
			"top": false,
			"Touch": false,
			"TouchEvent": false,
			"TouchList": false,
			"TrackEvent": false,
			"TransitionEvent": false,
			"TreeWalker": false,
			"UIEvent": false,
			"URL": false,
			"URLSearchParams": false,
			"ValidityState": false,
			"VTTCue": false,
			"WaveShaperNode": false,
			"WebGLActiveInfo": false,
			"WebGLBuffer": false,
			"WebGLContextEvent": false,
			"WebGLFramebuffer": false,
			"WebGLProgram": false,
			"WebGLRenderbuffer": false,
			"WebGLRenderingContext": false,
			"WebGLShader": false,
			"WebGLShaderPrecisionFormat": false,
			"WebGLTexture": false,
			"WebGLUniformLocation": false,
			"WebSocket": false,
			"WheelEvent": false,
			"window": false,
			"Window": false,
			"Worker": false,
			"XDomainRequest": false,
			"XMLDocument": false,
			"XMLHttpRequest": false,
			"XMLHttpRequestEventTarget": false,
			"XMLHttpRequestProgressEvent": false,
			"XMLHttpRequestUpload": false,
			"XMLSerializer": false,
			"XPathEvaluator": false,
			"XPathException": false,
			"XPathExpression": false,
			"XPathNamespace": false,
			"XPathNSResolver": false,
			"XPathResult": false,
			"XSLTProcessor": false
		},
		"worker": {
			"applicationCache": false,
			"atob": false,
			"Blob": false,
			"BroadcastChannel": false,
			"btoa": false,
			"Cache": false,
			"caches": false,
			"clearInterval": false,
			"clearTimeout": false,
			"close": true,
			"console": false,
			"fetch": false,
			"FileReaderSync": false,
			"FormData": false,
			"Headers": false,
			"IDBCursor": false,
			"IDBCursorWithValue": false,
			"IDBDatabase": false,
			"IDBFactory": false,
			"IDBIndex": false,
			"IDBKeyRange": false,
			"IDBObjectStore": false,
			"IDBOpenDBRequest": false,
			"IDBRequest": false,
			"IDBTransaction": false,
			"IDBVersionChangeEvent": false,
			"ImageData": false,
			"importScripts": true,
			"indexedDB": false,
			"location": false,
			"MessageChannel": false,
			"MessagePort": false,
			"name": false,
			"navigator": false,
			"Notification": false,
			"onclose": true,
			"onconnect": true,
			"onerror": true,
			"onlanguagechange": true,
			"onmessage": true,
			"onoffline": true,
			"ononline": true,
			"onrejectionhandled": true,
			"onunhandledrejection": true,
			"performance": false,
			"Performance": false,
			"PerformanceEntry": false,
			"PerformanceMark": false,
			"PerformanceMeasure": false,
			"PerformanceNavigation": false,
			"PerformanceResourceTiming": false,
			"PerformanceTiming": false,
			"postMessage": true,
			"Promise": false,
			"Request": false,
			"Response": false,
			"self": true,
			"ServiceWorkerRegistration": false,
			"setInterval": false,
			"setTimeout": false,
			"TextDecoder": false,
			"TextEncoder": false,
			"URL": false,
			"URLSearchParams": false,
			"WebSocket": false,
			"Worker": false,
			"XMLHttpRequest": false
		},
		"node": {
			"__dirname": false,
			"__filename": false,
			"arguments": false,
			"Buffer": false,
			"clearImmediate": false,
			"clearInterval": false,
			"clearTimeout": false,
			"console": false,
			"exports": true,
			"GLOBAL": false,
			"global": false,
			"Intl": false,
			"module": false,
			"process": false,
			"require": false,
			"root": false,
			"setImmediate": false,
			"setInterval": false,
			"setTimeout": false
		},
		"commonjs": {
			"exports": true,
			"module": false,
			"require": false,
			"global": false
		},
		"amd": {
			"define": false,
			"require": false
		},
		"mocha": {
			"after": false,
			"afterEach": false,
			"before": false,
			"beforeEach": false,
			"context": false,
			"describe": false,
			"it": false,
			"mocha": false,
			"run": false,
			"setup": false,
			"specify": false,
			"suite": false,
			"suiteSetup": false,
			"suiteTeardown": false,
			"teardown": false,
			"test": false,
			"xcontext": false,
			"xdescribe": false,
			"xit": false,
			"xspecify": false
		},
		"jasmine": {
			"afterAll": false,
			"afterEach": false,
			"beforeAll": false,
			"beforeEach": false,
			"describe": false,
			"expect": false,
			"fail": false,
			"fdescribe": false,
			"fit": false,
			"it": false,
			"jasmine": false,
			"pending": false,
			"runs": false,
			"spyOn": false,
			"waits": false,
			"waitsFor": false,
			"xdescribe": false,
			"xit": false
		},
		"jest": {
			"afterAll": false,
			"afterEach": false,
			"beforeAll": false,
			"beforeEach": false,
			"check": false,
			"describe": false,
			"expect": false,
			"gen": false,
			"it": false,
			"fit": false,
			"jest": false,
			"pit": false,
			"require": false,
			"test": false,
			"xdescribe": false,
			"xit": false,
			"xtest": false
		},
		"qunit": {
			"asyncTest": false,
			"deepEqual": false,
			"equal": false,
			"expect": false,
			"module": false,
			"notDeepEqual": false,
			"notEqual": false,
			"notOk": false,
			"notPropEqual": false,
			"notStrictEqual": false,
			"ok": false,
			"propEqual": false,
			"QUnit": false,
			"raises": false,
			"start": false,
			"stop": false,
			"strictEqual": false,
			"test": false,
			"throws": false
		},
		"phantomjs": {
			"console": true,
			"exports": true,
			"phantom": true,
			"require": true,
			"WebPage": true
		},
		"couch": {
			"emit": false,
			"exports": false,
			"getRow": false,
			"log": false,
			"module": false,
			"provides": false,
			"require": false,
			"respond": false,
			"send": false,
			"start": false,
			"sum": false
		},
		"rhino": {
			"defineClass": false,
			"deserialize": false,
			"gc": false,
			"help": false,
			"importClass": false,
			"importPackage": false,
			"java": false,
			"load": false,
			"loadClass": false,
			"Packages": false,
			"print": false,
			"quit": false,
			"readFile": false,
			"readUrl": false,
			"runCommand": false,
			"seal": false,
			"serialize": false,
			"spawn": false,
			"sync": false,
			"toint32": false,
			"version": false
		},
		"nashorn": {
			"__DIR__": false,
			"__FILE__": false,
			"__LINE__": false,
			"com": false,
			"edu": false,
			"exit": false,
			"Java": false,
			"java": false,
			"javafx": false,
			"JavaImporter": false,
			"javax": false,
			"JSAdapter": false,
			"load": false,
			"loadWithNewGlobal": false,
			"org": false,
			"Packages": false,
			"print": false,
			"quit": false
		},
		"wsh": {
			"ActiveXObject": true,
			"Enumerator": true,
			"GetObject": true,
			"ScriptEngine": true,
			"ScriptEngineBuildVersion": true,
			"ScriptEngineMajorVersion": true,
			"ScriptEngineMinorVersion": true,
			"VBArray": true,
			"WScript": true,
			"WSH": true,
			"XDomainRequest": true
		},
		"jquery": {
			"$": false,
			"jQuery": false
		},
		"yui": {
			"Y": false,
			"YUI": false,
			"YUI_config": false
		},
		"shelljs": {
			"cat": false,
			"cd": false,
			"chmod": false,
			"config": false,
			"cp": false,
			"dirs": false,
			"echo": false,
			"env": false,
			"error": false,
			"exec": false,
			"exit": false,
			"find": false,
			"grep": false,
			"ls": false,
			"ln": false,
			"mkdir": false,
			"mv": false,
			"popd": false,
			"pushd": false,
			"pwd": false,
			"rm": false,
			"sed": false,
			"set": false,
			"target": false,
			"tempdir": false,
			"test": false,
			"touch": false,
			"which": false
		},
		"prototypejs": {
			"$": false,
			"$$": false,
			"$A": false,
			"$break": false,
			"$continue": false,
			"$F": false,
			"$H": false,
			"$R": false,
			"$w": false,
			"Abstract": false,
			"Ajax": false,
			"Autocompleter": false,
			"Builder": false,
			"Class": false,
			"Control": false,
			"Draggable": false,
			"Draggables": false,
			"Droppables": false,
			"Effect": false,
			"Element": false,
			"Enumerable": false,
			"Event": false,
			"Field": false,
			"Form": false,
			"Hash": false,
			"Insertion": false,
			"ObjectRange": false,
			"PeriodicalExecuter": false,
			"Position": false,
			"Prototype": false,
			"Scriptaculous": false,
			"Selector": false,
			"Sortable": false,
			"SortableObserver": false,
			"Sound": false,
			"Template": false,
			"Toggle": false,
			"Try": false
		},
		"meteor": {
			"$": false,
			"_": false,
			"Accounts": false,
			"AccountsClient": false,
			"AccountsServer": false,
			"AccountsCommon": false,
			"App": false,
			"Assets": false,
			"Blaze": false,
			"check": false,
			"Cordova": false,
			"DDP": false,
			"DDPServer": false,
			"DDPRateLimiter": false,
			"Deps": false,
			"EJSON": false,
			"Email": false,
			"HTTP": false,
			"Log": false,
			"Match": false,
			"Meteor": false,
			"Mongo": false,
			"MongoInternals": false,
			"Npm": false,
			"Package": false,
			"Plugin": false,
			"process": false,
			"Random": false,
			"ReactiveDict": false,
			"ReactiveVar": false,
			"Router": false,
			"ServiceConfiguration": false,
			"Session": false,
			"share": false,
			"Spacebars": false,
			"Template": false,
			"Tinytest": false,
			"Tracker": false,
			"UI": false,
			"Utils": false,
			"WebApp": false,
			"WebAppInternals": false
		},
		"mongo": {
			"_isWindows": false,
			"_rand": false,
			"BulkWriteResult": false,
			"cat": false,
			"cd": false,
			"connect": false,
			"db": false,
			"getHostName": false,
			"getMemInfo": false,
			"hostname": false,
			"ISODate": false,
			"listFiles": false,
			"load": false,
			"ls": false,
			"md5sumFile": false,
			"mkdir": false,
			"Mongo": false,
			"NumberInt": false,
			"NumberLong": false,
			"ObjectId": false,
			"PlanCache": false,
			"print": false,
			"printjson": false,
			"pwd": false,
			"quit": false,
			"removeFile": false,
			"rs": false,
			"sh": false,
			"UUID": false,
			"version": false,
			"WriteResult": false
		},
		"applescript": {
			"$": false,
			"Application": false,
			"Automation": false,
			"console": false,
			"delay": false,
			"Library": false,
			"ObjC": false,
			"ObjectSpecifier": false,
			"Path": false,
			"Progress": false,
			"Ref": false
		},
		"serviceworker": {
			"caches": false,
			"Cache": false,
			"CacheStorage": false,
			"Client": false,
			"clients": false,
			"Clients": false,
			"ExtendableEvent": false,
			"ExtendableMessageEvent": false,
			"FetchEvent": false,
			"importScripts": false,
			"registration": false,
			"self": false,
			"ServiceWorker": false,
			"ServiceWorkerContainer": false,
			"ServiceWorkerGlobalScope": false,
			"ServiceWorkerMessageEvent": false,
			"ServiceWorkerRegistration": false,
			"skipWaiting": false,
			"WindowClient": false
		},
		"atomtest": {
			"advanceClock": false,
			"fakeClearInterval": false,
			"fakeClearTimeout": false,
			"fakeSetInterval": false,
			"fakeSetTimeout": false,
			"resetTimeouts": false,
			"waitsForPromise": false
		},
		"embertest": {
			"andThen": false,
			"click": false,
			"currentPath": false,
			"currentRouteName": false,
			"currentURL": false,
			"fillIn": false,
			"find": false,
			"findWithAssert": false,
			"keyEvent": false,
			"pauseTest": false,
			"triggerEvent": false,
			"visit": false
		},
		"protractor": {
			"$": false,
			"$$": false,
			"browser": false,
			"By": false,
			"by": false,
			"DartObject": false,
			"element": false,
			"protractor": false
		},
		"shared-node-browser": {
			"clearInterval": false,
			"clearTimeout": false,
			"console": false,
			"setInterval": false,
			"setTimeout": false
		},
		"webextensions": {
			"browser": false,
			"chrome": false,
			"opr": false
		},
		"greasemonkey": {
			"GM_addStyle": false,
			"GM_deleteValue": false,
			"GM_getResourceText": false,
			"GM_getResourceURL": false,
			"GM_getValue": false,
			"GM_info": false,
			"GM_listValues": false,
			"GM_log": false,
			"GM_openInTab": false,
			"GM_registerMenuCommand": false,
			"GM_setClipboard": false,
			"GM_setValue": false,
			"GM_xmlhttpRequest": false,
			"unsafeWindow": false
		}
	};

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates configs.
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const rules = __webpack_require__(120),
	    Environments = __webpack_require__(115),
	    schemaValidator = __webpack_require__(376),
	    util = __webpack_require__(4);
	
	const validators = {
	    rules: Object.create(null)
	};
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	/**
	 * Gets a complete options schema for a rule.
	 * @param {string} id The rule's unique name.
	 * @returns {Object} JSON Schema for the rule's options.
	 */
	function getRuleOptionsSchema(id) {
	    const rule = rules.get(id),
	        schema = rule && rule.schema || rule && rule.meta && rule.meta.schema;
	
	    // Given a tuple of schemas, insert warning level at the beginning
	    if (Array.isArray(schema)) {
	        if (schema.length) {
	            return {
	                type: "array",
	                items: schema,
	                minItems: 0,
	                maxItems: schema.length
	            };
	        } else {
	            return {
	                type: "array",
	                minItems: 0,
	                maxItems: 0
	            };
	        }
	    }
	
	    // Given a full schema, leave it alone
	    return schema || null;
	}
	
	/**
	 * Validates a rule's options against its schema.
	 * @param {string} id The rule's unique name.
	 * @param {array|number} options The given options for the rule.
	 * @param {string} source The name of the configuration source.
	 * @returns {void}
	 */
	function validateRuleOptions(id, options, source) {
	    const schema = getRuleOptionsSchema(id);
	    let validateRule = validators.rules[id],
	        severity,
	        localOptions,
	        validSeverity = true;
	
	    if (!validateRule && schema) {
	        validateRule = schemaValidator(schema, { verbose: true });
	        validators.rules[id] = validateRule;
	    }
	
	    // if it's not an array, it should be just a severity
	    if (Array.isArray(options)) {
	        localOptions = options.concat();    // clone
	        severity = localOptions.shift();
	    } else {
	        severity = options;
	        localOptions = [];
	    }
	
	    validSeverity = (
	        severity === 0 || severity === 1 || severity === 2 ||
	        (typeof severity === "string" && /^(?:off|warn|error)$/i.test(severity))
	    );
	
	    if (validateRule) {
	        validateRule(localOptions);
	    }
	
	    if ((validateRule && validateRule.errors) || !validSeverity) {
	        const message = [
	            source, ":\n",
	            "\tConfiguration for rule \"", id, "\" is invalid:\n"
	        ];
	
	        if (!validSeverity) {
	            message.push(
	                "\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '",
	                util.inspect(severity).replace(/'/g, "\"").replace(/\n/g, ""),
	                "').\n"
	            );
	        }
	
	        if (validateRule && validateRule.errors) {
	            validateRule.errors.forEach(function(error) {
	                message.push(
	                    "\tValue \"", error.value, "\" ", error.message, ".\n"
	                );
	            });
	        }
	
	        throw new Error(message.join(""));
	    }
	}
	
	/**
	 * Validates an environment object
	 * @param {Object} environment The environment config object to validate.
	 * @param {string} source The location to report with any errors.
	 * @returns {void}
	 */
	function validateEnvironment(environment, source) {
	
	    // not having an environment is ok
	    if (!environment) {
	        return;
	    }
	
	    if (Array.isArray(environment)) {
	        throw new Error("Environment must not be an array");
	    }
	
	    if (typeof environment === "object") {
	        Object.keys(environment).forEach(function(env) {
	            if (!Environments.get(env)) {
	                const message = [
	                    source, ":\n",
	                    "\tEnvironment key \"", env, "\" is unknown\n"
	                ];
	
	                throw new Error(message.join(""));
	            }
	        });
	    } else {
	        throw new Error("Environment must be an object");
	    }
	}
	
	/**
	 * Validates an entire config object.
	 * @param {Object} config The config object to validate.
	 * @param {string} source The location to report with any errors.
	 * @returns {void}
	 */
	function validate(config, source) {
	
	    if (typeof config.rules === "object") {
	        Object.keys(config.rules).forEach(function(id) {
	            validateRuleOptions(id, config.rules[id], source);
	        });
	    }
	
	    validateEnvironment(config.env, source);
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	    getRuleOptionsSchema,
	    validate,
	    validateRuleOptions
	};


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Defines a storage for rules.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const loadRules = __webpack_require__(121);
	
	//------------------------------------------------------------------------------
	// Privates
	//------------------------------------------------------------------------------
	
	let rules = Object.create(null);
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Registers a rule module for rule id in storage.
	 * @param {string} ruleId Rule id (file name).
	 * @param {Function} ruleModule Rule handler.
	 * @returns {void}
	 */
	function define(ruleId, ruleModule) {
	    rules[ruleId] = ruleModule;
	}
	
	/**
	 * Loads and registers all rules from passed rules directory.
	 * @param {string} [rulesDir] Path to rules directory, may be relative. Defaults to `lib/rules`.
	 * @param {string} cwd Current working directory
	 * @returns {void}
	 */
	function load(rulesDir, cwd) {
	    const newRules = loadRules(rulesDir, cwd);
	
	    Object.keys(newRules).forEach(function(ruleId) {
	        define(ruleId, newRules[ruleId]);
	    });
	}
	
	/**
	 * Registers all given rules of a plugin.
	 * @param {Object} plugin The plugin object to import.
	 * @param {string} pluginName The name of the plugin without prefix (`eslint-plugin-`).
	 * @returns {void}
	 */
	function importPlugin(plugin, pluginName) {
	    if (plugin.rules) {
	        Object.keys(plugin.rules).forEach(function(ruleId) {
	            const qualifiedRuleId = `${pluginName}/${ruleId}`,
	                rule = plugin.rules[ruleId];
	
	            define(qualifiedRuleId, rule);
	        });
	    }
	}
	
	/**
	 * Access rule handler by id (file name).
	 * @param {string} ruleId Rule id (file name).
	 * @returns {Function} Rule handler.
	 */
	function getHandler(ruleId) {
	    if (typeof rules[ruleId] === "string") {
	        return !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }());
	    } else {
	        return rules[ruleId];
	    }
	}
	
	/**
	 * Reset rules storage.
	 * Should be used only in tests.
	 * @returns {void}
	 */
	function testClear() {
	    rules = Object.create(null);
	}
	
	module.exports = {
	    define,
	    load,
	    importPlugin,
	    get: getHandler,
	    testClear,
	
	    /**
	     * Resets rules to its starting state. Use for tests only.
	     * @returns {void}
	     */
	    testReset() {
	        testClear();
	        load();
	    }
	};
	
	//------------------------------------------------------------------------------
	// Initialization
	//------------------------------------------------------------------------------
	
	// loads built-in rules
	load();


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	// An expanded form of eslint/lib/load-rules which loads rules from the file
	// system.  We expand it so webpack knows to include the rules in the bundle.
	module.exports = function() {
	  return {
	    'accessor-pairs': __webpack_require__(122),
	    'array-bracket-spacing': __webpack_require__(123),
	    'array-callback-return': __webpack_require__(124),
	    'arrow-body-style': __webpack_require__(125),
	    'arrow-parens': __webpack_require__(126),
	    'arrow-spacing': __webpack_require__(127),
	    'block-scoped-var': __webpack_require__(128),
	    'block-spacing': __webpack_require__(129),
	    'brace-style': __webpack_require__(130),
	    'callback-return': __webpack_require__(131),
	    camelcase: __webpack_require__(132),
	    'class-methods-use-this': __webpack_require__(133),
	    'comma-dangle': __webpack_require__(134),
	    'comma-spacing': __webpack_require__(137),
	    'comma-style': __webpack_require__(138),
	    complexity: __webpack_require__(139),
	    'computed-property-spacing': __webpack_require__(140),
	    'consistent-return': __webpack_require__(141),
	    'consistent-this': __webpack_require__(142),
	    'constructor-super': __webpack_require__(143),
	    curly: __webpack_require__(144),
	    'default-case': __webpack_require__(145),
	    'dot-location': __webpack_require__(146),
	    'dot-notation': __webpack_require__(147),
	    'eol-last': __webpack_require__(149),
	    eqeqeq: __webpack_require__(150),
	    'func-call-spacing': __webpack_require__(151),
	    'func-name-matching': __webpack_require__(152),
	    'func-names': __webpack_require__(153),
	    'func-style': __webpack_require__(154),
	    'generator-star-spacing': __webpack_require__(155),
	    'global-require': __webpack_require__(156),
	    'guard-for-in': __webpack_require__(157),
	    'handle-callback-err': __webpack_require__(158),
	    'id-blacklist': __webpack_require__(159),
	    'id-length': __webpack_require__(160),
	    'id-match': __webpack_require__(161),
	    indent: __webpack_require__(162),
	    'init-declarations': __webpack_require__(163),
	    'jsx-quotes': __webpack_require__(164),
	    'key-spacing': __webpack_require__(165),
	    'keyword-spacing': __webpack_require__(166),
	    'line-comment-position': __webpack_require__(167),
	    'linebreak-style': __webpack_require__(168),
	    'lines-around-comment': __webpack_require__(169),
	    'lines-around-directive': __webpack_require__(170),
	    'max-depth': __webpack_require__(171),
	    'max-len': __webpack_require__(172),
	    'max-lines': __webpack_require__(173),
	    'max-nested-callbacks': __webpack_require__(174),
	    'max-params': __webpack_require__(175),
	    'max-statements-per-line': __webpack_require__(176),
	    'max-statements': __webpack_require__(177),
	    'multiline-ternary': __webpack_require__(178),
	    'new-cap': __webpack_require__(179),
	    'new-parens': __webpack_require__(180),
	    'newline-after-var': __webpack_require__(181),
	    'newline-before-return': __webpack_require__(182),
	    'newline-per-chained-call': __webpack_require__(183),
	    'no-alert': __webpack_require__(184),
	    'no-array-constructor': __webpack_require__(185),
	    'no-bitwise': __webpack_require__(186),
	    'no-caller': __webpack_require__(187),
	    'no-case-declarations': __webpack_require__(188),
	    'no-catch-shadow': __webpack_require__(189),
	    'no-class-assign': __webpack_require__(190),
	    'no-cond-assign': __webpack_require__(191),
	    'no-confusing-arrow': __webpack_require__(192),
	    'no-console': __webpack_require__(193),
	    'no-const-assign': __webpack_require__(194),
	    'no-constant-condition': __webpack_require__(195),
	    'no-continue': __webpack_require__(196),
	    'no-control-regex': __webpack_require__(197),
	    'no-debugger': __webpack_require__(198),
	    'no-delete-var': __webpack_require__(199),
	    'no-div-regex': __webpack_require__(200),
	    'no-dupe-args': __webpack_require__(201),
	    'no-dupe-class-members': __webpack_require__(202),
	    'no-dupe-keys': __webpack_require__(203),
	    'no-duplicate-case': __webpack_require__(204),
	    'no-duplicate-imports': __webpack_require__(205),
	    'no-else-return': __webpack_require__(206),
	    'no-empty-character-class': __webpack_require__(207),
	    'no-empty-function': __webpack_require__(208),
	    'no-empty-pattern': __webpack_require__(209),
	    'no-empty': __webpack_require__(210),
	    'no-eq-null': __webpack_require__(211),
	    'no-eval': __webpack_require__(212),
	    'no-ex-assign': __webpack_require__(213),
	    'no-extend-native': __webpack_require__(214),
	    'no-extra-bind': __webpack_require__(215),
	    'no-extra-boolean-cast': __webpack_require__(216),
	    'no-extra-label': __webpack_require__(217),
	    'no-extra-parens': __webpack_require__(218),
	    'no-extra-semi': __webpack_require__(219),
	    'no-fallthrough': __webpack_require__(220),
	    'no-floating-decimal': __webpack_require__(221),
	    'no-func-assign': __webpack_require__(222),
	    'no-global-assign': __webpack_require__(223),
	    'no-implicit-coercion': __webpack_require__(224),
	    'no-implicit-globals': __webpack_require__(225),
	    'no-implied-eval': __webpack_require__(226),
	    'no-inline-comments': __webpack_require__(227),
	    'no-inner-declarations': __webpack_require__(228),
	    'no-invalid-regexp': __webpack_require__(229),
	    'no-invalid-this': __webpack_require__(239),
	    'no-irregular-whitespace': __webpack_require__(240),
	    'no-iterator': __webpack_require__(241),
	    'no-label-var': __webpack_require__(242),
	    'no-labels': __webpack_require__(243),
	    'no-lone-blocks': __webpack_require__(244),
	    'no-lonely-if': __webpack_require__(245),
	    'no-loop-func': __webpack_require__(246),
	    'no-magic-numbers': __webpack_require__(247),
	    'no-mixed-operators': __webpack_require__(248),
	    'no-mixed-requires': __webpack_require__(249),
	    'no-mixed-spaces-and-tabs': __webpack_require__(250),
	    'no-multi-spaces': __webpack_require__(251),
	    'no-multi-str': __webpack_require__(252),
	    'no-multiple-empty-lines': __webpack_require__(253),
	    'no-native-reassign': __webpack_require__(254),
	    'no-negated-condition': __webpack_require__(255),
	    'no-negated-in-lhs': __webpack_require__(256),
	    'no-nested-ternary': __webpack_require__(257),
	    'no-new-func': __webpack_require__(258),
	    'no-new-object': __webpack_require__(259),
	    'no-new-require': __webpack_require__(260),
	    'no-new-symbol': __webpack_require__(261),
	    'no-new-wrappers': __webpack_require__(262),
	    'no-new': __webpack_require__(263),
	    'no-obj-calls': __webpack_require__(264),
	    'no-octal-escape': __webpack_require__(265),
	    'no-octal': __webpack_require__(266),
	    'no-param-reassign': __webpack_require__(267),
	    'no-path-concat': __webpack_require__(268),
	    'no-plusplus': __webpack_require__(269),
	    'no-process-env': __webpack_require__(270),
	    'no-process-exit': __webpack_require__(271),
	    'no-proto': __webpack_require__(272),
	    'no-prototype-builtins': __webpack_require__(273),
	    'no-redeclare': __webpack_require__(274),
	    'no-regex-spaces': __webpack_require__(275),
	    'no-restricted-globals': __webpack_require__(276),
	    'no-restricted-imports': __webpack_require__(277),
	    'no-restricted-modules': __webpack_require__(278),
	    'no-restricted-properties': __webpack_require__(279),
	    'no-restricted-syntax': __webpack_require__(280),
	    'no-return-assign': __webpack_require__(281),
	    'no-script-url': __webpack_require__(282),
	    'no-self-assign': __webpack_require__(283),
	    'no-self-compare': __webpack_require__(284),
	    'no-sequences': __webpack_require__(285),
	    'no-shadow-restricted-names': __webpack_require__(286),
	    'no-shadow': __webpack_require__(287),
	    'no-spaced-func': __webpack_require__(288),
	    'no-sparse-arrays': __webpack_require__(289),
	    'no-sync': __webpack_require__(290),
	    'no-tabs': __webpack_require__(291),
	    'no-template-curly-in-string': __webpack_require__(292),
	    'no-ternary': __webpack_require__(293),
	    'no-this-before-super': __webpack_require__(294),
	    'no-throw-literal': __webpack_require__(295),
	    'no-trailing-spaces': __webpack_require__(296),
	    'no-undef-init': __webpack_require__(297),
	    'no-undef': __webpack_require__(298),
	    'no-undefined': __webpack_require__(299),
	    'no-underscore-dangle': __webpack_require__(300),
	    'no-unexpected-multiline': __webpack_require__(301),
	    'no-unmodified-loop-condition': __webpack_require__(302),
	    'no-unneeded-ternary': __webpack_require__(304),
	    'no-unreachable': __webpack_require__(305),
	    'no-unsafe-finally': __webpack_require__(306),
	    'no-unsafe-negation': __webpack_require__(307),
	    'no-unused-expressions': __webpack_require__(308),
	    'no-unused-labels': __webpack_require__(309),
	    'no-unused-vars': __webpack_require__(310),
	    'no-use-before-define': __webpack_require__(311),
	    'no-useless-call': __webpack_require__(312),
	    'no-useless-computed-key': __webpack_require__(313),
	    'no-useless-concat': __webpack_require__(314),
	    'no-useless-constructor': __webpack_require__(315),
	    'no-useless-escape': __webpack_require__(316),
	    'no-useless-rename': __webpack_require__(317),
	    'no-useless-return': __webpack_require__(318),
	    'no-var': __webpack_require__(319),
	    'no-void': __webpack_require__(320),
	    'no-warning-comments': __webpack_require__(321),
	    'no-whitespace-before-property':
	        __webpack_require__(322),
	    'no-with': __webpack_require__(323),
	    'object-curly-newline': __webpack_require__(324),
	    'object-curly-spacing': __webpack_require__(325),
	    'object-property-newline': __webpack_require__(326),
	    'object-shorthand': __webpack_require__(327),
	    'one-var-declaration-per-line':
	        __webpack_require__(328),
	    'one-var': __webpack_require__(329),
	    'operator-assignment': __webpack_require__(330),
	    'operator-linebreak': __webpack_require__(331),
	    'padded-blocks': __webpack_require__(332),
	    'prefer-arrow-callback': __webpack_require__(333),
	    'prefer-const': __webpack_require__(334),
	    'prefer-numeric-literals': __webpack_require__(335),
	    'prefer-reflect': __webpack_require__(336),
	    'prefer-rest-params': __webpack_require__(337),
	    'prefer-spread': __webpack_require__(338),
	    'prefer-template': __webpack_require__(339),
	    'quote-props': __webpack_require__(340),
	    quotes: __webpack_require__(341),
	    radix: __webpack_require__(342),
	    'require-jsdoc': __webpack_require__(343),
	    'require-yield': __webpack_require__(344),
	    'rest-spread-spacing': __webpack_require__(345),
	    'semi-spacing': __webpack_require__(346),
	    semi: __webpack_require__(347),
	    'sort-imports': __webpack_require__(348),
	    'sort-keys': __webpack_require__(349),
	    'sort-vars': __webpack_require__(351),
	    'space-before-blocks': __webpack_require__(352),
	    'space-before-function-paren':
	        __webpack_require__(353),
	    'space-in-parens': __webpack_require__(354),
	    'space-infix-ops': __webpack_require__(355),
	    'space-unary-ops': __webpack_require__(356),
	    'spaced-comment': __webpack_require__(357),
	    strict: __webpack_require__(358),
	    'symbol-description': __webpack_require__(359),
	    'template-curly-spacing': __webpack_require__(360),
	    'unicode-bom': __webpack_require__(361),
	    'use-isnan': __webpack_require__(362),
	    'valid-jsdoc': __webpack_require__(363),
	    'valid-typeof': __webpack_require__(369),
	    'vars-on-top': __webpack_require__(370),
	    'wrap-iife': __webpack_require__(371),
	    'wrap-regex': __webpack_require__(372),
	    'yield-star-spacing': __webpack_require__(373),
	    yoda: __webpack_require__(374),
	  };}


/***/ },
/* 122 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag wrapping non-iife in parens
	 * @author Gyandeep Singh
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is an `Identifier` node which was named a given name.
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - An expected name of the node.
	 * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
	 */
	function isIdentifier(node, name) {
	    return node.type === "Identifier" && node.name === name;
	}
	
	/**
	 * Checks whether or not a given node is an argument of a specified method call.
	 * @param {ASTNode} node - A node to check.
	 * @param {number} index - An expected index of the node in arguments.
	 * @param {string} object - An expected name of the object of the method.
	 * @param {string} property - An expected name of the method.
	 * @returns {boolean} `true` if the node is an argument of the specified method call.
	 */
	function isArgumentOfMethodCall(node, index, object, property) {
	    const parent = node.parent;
	
	    return (
	        parent.type === "CallExpression" &&
	        parent.callee.type === "MemberExpression" &&
	        parent.callee.computed === false &&
	        isIdentifier(parent.callee.object, object) &&
	        isIdentifier(parent.callee.property, property) &&
	        parent.arguments[index] === node
	    );
	}
	
	/**
	 * Checks whether or not a given node is a property descriptor.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a property descriptor.
	 */
	function isPropertyDescriptor(node) {
	
	    // Object.defineProperty(obj, "foo", {set: ...})
	    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") ||
	        isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")
	    ) {
	        return true;
	    }
	
	    /*
	     * Object.defineProperties(obj, {foo: {set: ...}})
	     * Object.create(proto, {foo: {set: ...}})
	     */
	    node = node.parent.parent;
	
	    return node.type === "ObjectExpression" && (
	        isArgumentOfMethodCall(node, 1, "Object", "create") ||
	        isArgumentOfMethodCall(node, 1, "Object", "defineProperties")
	    );
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce getter and setter pairs in objects",
	            category: "Best Practices",
	            recommended: false
	        },
	        schema: [{
	            type: "object",
	            properties: {
	                getWithoutSet: {
	                    type: "boolean"
	                },
	                setWithoutGet: {
	                    type: "boolean"
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	    create(context) {
	        const config = context.options[0] || {};
	        const checkGetWithoutSet = config.getWithoutSet === true;
	        const checkSetWithoutGet = config.setWithoutGet !== false;
	
	        /**
	         * Checks a object expression to see if it has setter and getter both present or none.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkLonelySetGet(node) {
	            let isSetPresent = false;
	            let isGetPresent = false;
	            const isDescriptor = isPropertyDescriptor(node);
	
	            for (let i = 0, end = node.properties.length; i < end; i++) {
	                const property = node.properties[i];
	
	                let propToCheck = "";
	
	                if (property.kind === "init") {
	                    if (isDescriptor && !property.computed) {
	                        propToCheck = property.key.name;
	                    }
	                } else {
	                    propToCheck = property.kind;
	                }
	
	                switch (propToCheck) {
	                    case "set":
	                        isSetPresent = true;
	                        break;
	
	                    case "get":
	                        isGetPresent = true;
	                        break;
	
	                    default:
	
	                        // Do nothing
	                }
	
	                if (isSetPresent && isGetPresent) {
	                    break;
	                }
	            }
	
	            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {
	                context.report(node, "Getter is not present.");
	            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {
	                context.report(node, "Setter is not present.");
	            }
	        }
	
	        return {
	            ObjectExpression(node) {
	                if (checkSetWithoutGet || checkGetWithoutSet) {
	                    checkLonelySetGet(node);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of array brackets.
	 * @author Jamund Ferguson
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing inside array brackets",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        fixable: "whitespace",
	        schema: [
	            {
	                enum: ["always", "never"]
	            },
	            {
	                type: "object",
	                properties: {
	                    singleValue: {
	                        type: "boolean"
	                    },
	                    objectsInArrays: {
	                        type: "boolean"
	                    },
	                    arraysInArrays: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	    create(context) {
	        const spaced = context.options[0] === "always",
	            sourceCode = context.getSourceCode();
	
	        /**
	         * Determines whether an option is set, relative to the spacing option.
	         * If spaced is "always", then check whether option is set to false.
	         * If spaced is "never", then check whether option is set to true.
	         * @param {Object} option - The option to exclude.
	         * @returns {boolean} Whether or not the property is excluded.
	         */
	        function isOptionSet(option) {
	            return context.options[1] ? context.options[1][option] === !spaced : false;
	        }
	
	        const options = {
	            spaced,
	            singleElementException: isOptionSet("singleValue"),
	            objectsInArraysException: isOptionSet("objectsInArrays"),
	            arraysInArraysException: isOptionSet("arraysInArrays")
	        };
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	        * Reports that there shouldn't be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportNoBeginningSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space after '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    const nextToken = sourceCode.getTokenAfter(token);
	
	                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there shouldn't be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportNoEndingSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space before '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    const previousToken = sourceCode.getTokenBefore(token);
	
	                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredBeginningSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required after '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextAfter(token, " ");
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredEndingSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required before '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextBefore(token, " ");
	                }
	            });
	        }
	
	        /**
	        * Determines if a node is an object type
	        * @param {ASTNode} node - The node to check.
	        * @returns {boolean} Whether or not the node is an object type.
	        */
	        function isObjectType(node) {
	            return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
	        }
	
	        /**
	        * Determines if a node is an array type
	        * @param {ASTNode} node - The node to check.
	        * @returns {boolean} Whether or not the node is an array type.
	        */
	        function isArrayType(node) {
	            return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
	        }
	
	        /**
	         * Validates the spacing around array brackets
	         * @param {ASTNode} node - The node we're checking for spacing
	         * @returns {void}
	         */
	        function validateArraySpacing(node) {
	            if (options.spaced && node.elements.length === 0) {
	                return;
	            }
	
	            const first = sourceCode.getFirstToken(node),
	                second = sourceCode.getFirstToken(node, 1),
	                last = node.typeAnnotation
	                    ? sourceCode.getTokenBefore(node.typeAnnotation)
	                    : sourceCode.getLastToken(node),
	                penultimate = sourceCode.getTokenBefore(last),
	                firstElement = node.elements[0],
	                lastElement = node.elements[node.elements.length - 1];
	
	            const openingBracketMustBeSpaced =
	                options.objectsInArraysException && isObjectType(firstElement) ||
	                options.arraysInArraysException && isArrayType(firstElement) ||
	                options.singleElementException && node.elements.length === 1
	                    ? !options.spaced : options.spaced;
	
	            const closingBracketMustBeSpaced =
	                options.objectsInArraysException && isObjectType(lastElement) ||
	                options.arraysInArraysException && isArrayType(lastElement) ||
	                options.singleElementException && node.elements.length === 1
	                    ? !options.spaced : options.spaced;
	
	            if (astUtils.isTokenOnSameLine(first, second)) {
	                if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
	                    reportRequiredBeginningSpace(node, first);
	                }
	                if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
	                    reportNoBeginningSpace(node, first);
	                }
	            }
	
	            if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
	                if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
	                    reportRequiredEndingSpace(node, last);
	                }
	                if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
	                    reportNoEndingSpace(node, last);
	                }
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ArrayPattern: validateArraySpacing,
	            ArrayExpression: validateArraySpacing
	        };
	    }
	};


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to enforce return statements in callbacks of array's methods
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;
	const TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;
	
	/**
	 * Checks a given code path segment is reachable.
	 *
	 * @param {CodePathSegment} segment - A segment to check.
	 * @returns {boolean} `true` if the segment is reachable.
	 */
	function isReachable(segment) {
	    return segment.reachable;
	}
	
	/**
	 * Gets a readable location.
	 *
	 * - FunctionExpression -> the function name or `function` keyword.
	 * - ArrowFunctionExpression -> `=>` token.
	 *
	 * @param {ASTNode} node - A function node to get.
	 * @param {SourceCode} sourceCode - A source code to get tokens.
	 * @returns {ASTNode|Token} The node or the token of a location.
	 */
	function getLocation(node, sourceCode) {
	    if (node.type === "ArrowFunctionExpression") {
	        return sourceCode.getTokenBefore(node.body);
	    }
	    return node.id || node;
	}
	
	/**
	 * Checks a given node is a MemberExpression node which has the specified name's
	 * property.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a MemberExpression node which has
	 *      the specified name's property
	 */
	function isTargetMethod(node) {
	    return (
	        node.type === "MemberExpression" &&
	        TARGET_METHODS.test(astUtils.getStaticPropertyName(node) || "")
	    );
	}
	
	/**
	 * Checks whether or not a given node is a function expression which is the
	 * callback of an array method.
	 *
	 * @param {ASTNode} node - A node to check. This is one of
	 *      FunctionExpression or ArrowFunctionExpression.
	 * @returns {boolean} `true` if the node is the callback of an array method.
	 */
	function isCallbackOfArrayMethod(node) {
	    while (node) {
	        const parent = node.parent;
	
	        switch (parent.type) {
	
	            /*
	             * Looks up the destination. e.g.,
	             * foo.every(nativeFoo || function foo() { ... });
	             */
	            case "LogicalExpression":
	            case "ConditionalExpression":
	                node = parent;
	                break;
	
	            // If the upper function is IIFE, checks the destination of the return value.
	            // e.g.
	            //   foo.every((function() {
	            //     // setup...
	            //     return function callback() { ... };
	            //   })());
	            case "ReturnStatement": {
	                const func = astUtils.getUpperFunction(parent);
	
	                if (func === null || !astUtils.isCallee(func)) {
	                    return false;
	                }
	                node = func.parent;
	                break;
	            }
	
	            // e.g.
	            //   Array.from([], function() {});
	            //   list.every(function() {});
	            case "CallExpression":
	                if (astUtils.isArrayFromMethod(parent.callee)) {
	                    return (
	                        parent.arguments.length >= 2 &&
	                        parent.arguments[1] === node
	                    );
	                }
	                if (isTargetMethod(parent.callee)) {
	                    return (
	                        parent.arguments.length >= 1 &&
	                        parent.arguments[0] === node
	                    );
	                }
	                return false;
	
	            // Otherwise this node is not target.
	            default:
	                return false;
	        }
	    }
	
	    /* istanbul ignore next: unreachable */
	    return false;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce `return` statements in callbacks of array methods",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let funcInfo = {
	            upper: null,
	            codePath: null,
	            hasReturn: false,
	            shouldCheck: false
	        };
	
	        /**
	         * Checks whether or not the last code path segment is reachable.
	         * Then reports this function if the segment is reachable.
	         *
	         * If the last code path segment is reachable, there are paths which are not
	         * returned or thrown.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {void}
	         */
	        function checkLastSegment(node) {
	            if (funcInfo.shouldCheck &&
	                funcInfo.codePath.currentSegments.some(isReachable)
	            ) {
	                context.report({
	                    node,
	                    loc: getLocation(node, context.getSourceCode()).loc.start,
	                    message: funcInfo.hasReturn
	                        ? "Expected to return a value at the end of this function."
	                        : "Expected to return a value in this function."
	                });
	            }
	        }
	
	        return {
	
	            // Stacks this function's information.
	            onCodePathStart(codePath, node) {
	                funcInfo = {
	                    upper: funcInfo,
	                    codePath,
	                    hasReturn: false,
	                    shouldCheck:
	                        TARGET_NODE_TYPE.test(node.type) &&
	                        node.body.type === "BlockStatement" &&
	                        isCallbackOfArrayMethod(node) &&
	                        !node.async &&
	                        !node.generator
	                };
	            },
	
	            // Pops this function's information.
	            onCodePathEnd() {
	                funcInfo = funcInfo.upper;
	            },
	
	            // Checks the return statement is valid.
	            ReturnStatement(node) {
	                if (funcInfo.shouldCheck) {
	                    funcInfo.hasReturn = true;
	
	                    if (!node.argument) {
	                        context.report({
	                            node,
	                            message: "Expected a return value."
	                        });
	                    }
	                }
	            },
	
	            // Reports a given function if the last path is reachable.
	            "FunctionExpression:exit": checkLastSegment,
	            "ArrowFunctionExpression:exit": checkLastSegment
	        };
	    }
	};


/***/ },
/* 125 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require braces in arrow function body.
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require braces around arrow function bodies",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "never"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["as-needed"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                requireReturnForObjectLiteral: {type: "boolean"}
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        },
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const options = context.options;
	        const always = options[0] === "always";
	        const asNeeded = !options[0] || options[0] === "as-needed";
	        const never = options[0] === "never";
	        const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Determines whether a arrow function body needs braces
	         * @param {ASTNode} node The arrow function node.
	         * @returns {void}
	         */
	        function validate(node) {
	            const arrowBody = node.body;
	
	            if (arrowBody.type === "BlockStatement") {
	                const blockBody = arrowBody.body;
	
	                if (blockBody.length !== 1 && !never) {
	                    return;
	                }
	
	                if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" &&
	                    blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
	                    return;
	                }
	
	                if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
	                    context.report({
	                        node,
	                        loc: arrowBody.loc.start,
	                        message: "Unexpected block statement surrounding arrow body.",
	                        fix(fixer) {
	                            if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument) {
	                                return null;
	                            }
	
	                            const sourceText = sourceCode.getText();
	                            const returnKeyword = sourceCode.getFirstToken(blockBody[0]);
	                            const firstValueToken = sourceCode.getTokenAfter(returnKeyword);
	                            let lastValueToken = sourceCode.getLastToken(blockBody[0]);
	
	                            if (lastValueToken.type === "Punctuator" && lastValueToken.value === ";") {
	
	                                /* The last token of the returned value is the last token of the ReturnExpression (if
	                                 * the ReturnExpression has no semicolon), or the second-to-last token (if the ReturnExpression
	                                 * has a semicolon).
	                                 */
	                                lastValueToken = sourceCode.getTokenBefore(lastValueToken);
	                            }
	
	                            const tokenAfterArrowBody = sourceCode.getTokenAfter(arrowBody);
	
	                            if (tokenAfterArrowBody && tokenAfterArrowBody.type === "Punctuator" && /^[([/`+-]/.test(tokenAfterArrowBody.value)) {
	
	                                // Don't do a fix if the next token would cause ASI issues when preceded by the returned value.
	                                return null;
	                            }
	
	                            const textBeforeReturn = sourceText.slice(arrowBody.range[0] + 1, returnKeyword.range[0]);
	                            const textBetweenReturnAndValue = sourceText.slice(returnKeyword.range[1], firstValueToken.range[0]);
	                            const rawReturnValueText = sourceText.slice(firstValueToken.range[0], lastValueToken.range[1]);
	                            const returnValueText = firstValueToken.value === "{" ? `(${rawReturnValueText})` : rawReturnValueText;
	                            const textAfterValue = sourceText.slice(lastValueToken.range[1], blockBody[0].range[1] - 1);
	                            const textAfterReturnStatement = sourceText.slice(blockBody[0].range[1], arrowBody.range[1] - 1);
	
	                            /*
	                             * For fixes that only contain spaces around the return value, remove the extra spaces.
	                             * This avoids ugly fixes that end up with extra spaces after the arrow, e.g. `() =>   0 ;`
	                             */
	                            return fixer.replaceText(
	                                arrowBody,
	                                (textBeforeReturn + textBetweenReturnAndValue).replace(/^ *$/, "") + returnValueText + (textAfterValue + textAfterReturnStatement).replace(/^ *$/, "")
	                            );
	                        }
	                    });
	                }
	            } else {
	                if (always || (asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression")) {
	                    context.report({
	                        node,
	                        loc: arrowBody.loc.start,
	                        message: "Expected block statement surrounding arrow body.",
	                        fix(fixer) {
	                            const lastTokenBeforeBody = sourceCode.getTokensBetween(sourceCode.getFirstToken(node), arrowBody)
	                                .reverse()
	                                .find(token => token.value !== "(");
	
	                            const firstBodyToken = sourceCode.getTokenAfter(lastTokenBeforeBody);
	
	                            return fixer.replaceTextRange(
	                                [firstBodyToken.range[0], node.range[1]],
	                                `{return ${sourceCode.getText().slice(firstBodyToken.range[0], node.range[1])}}`
	                            );
	                        }
	                    });
	                }
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: validate
	        };
	    }
	};


/***/ },
/* 126 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require parens in arrow function arguments.
	 * @author Jxck
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require parentheses around arrow function arguments",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: [
	            {
	                enum: ["always", "as-needed"]
	            },
	            {
	                type: "object",
	                properties: {
	                    requireForBlockBody: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const message = "Expected parentheses around arrow function argument.";
	        const asNeededMessage = "Unexpected parentheses around single function argument.";
	        const asNeeded = context.options[0] === "as-needed";
	        const requireForBlockBodyMessage = "Unexpected parentheses around single function argument having a body with no curly braces";
	        const requireForBlockBodyNoParensMessage = "Expected parentheses around arrow function argument having a body with curly braces.";
	        const requireForBlockBody = asNeeded && context.options[1] && context.options[1].requireForBlockBody === true;
	
	        const sourceCode = context.getSourceCode();
	
	
	        /**
	         * Determines whether a arrow function argument end with `)`
	         * @param {ASTNode} node The arrow function node.
	         * @returns {void}
	         */
	        function parens(node) {
	            const token = sourceCode.getFirstToken(node, node.async ? 1 : 0);
	
	            // "as-needed", { "requireForBlockBody": true }: x => x
	            if (
	                requireForBlockBody &&
	                node.params.length === 1 &&
	                node.params[0].type === "Identifier" &&
	                node.body.type !== "BlockStatement"
	            ) {
	                if (token.type === "Punctuator" && token.value === "(") {
	                    context.report({
	                        node,
	                        message: requireForBlockBodyMessage,
	                        fix(fixer) {
	                            const paramToken = context.getTokenAfter(token);
	                            const closingParenToken = context.getTokenAfter(paramToken);
	
	                            return fixer.replaceTextRange([
	                                token.range[0],
	                                closingParenToken.range[1]
	                            ], paramToken.value);
	                        }
	                    });
	                }
	                return;
	            }
	
	            if (
	                requireForBlockBody &&
	                node.body.type === "BlockStatement"
	            ) {
	                if (token.type !== "Punctuator" || token.value !== "(") {
	                    context.report({
	                        node,
	                        message: requireForBlockBodyNoParensMessage,
	                        fix(fixer) {
	                            return fixer.replaceText(token, `(${token.value})`);
	                        }
	                    });
	                }
	                return;
	            }
	
	            // "as-needed": x => x
	            if (asNeeded && node.params.length === 1 && node.params[0].type === "Identifier") {
	                if (token.type === "Punctuator" && token.value === "(") {
	                    context.report({
	                        node,
	                        message: asNeededMessage,
	                        fix(fixer) {
	                            const paramToken = context.getTokenAfter(token);
	                            const closingParenToken = context.getTokenAfter(paramToken);
	
	                            return fixer.replaceTextRange([
	                                token.range[0],
	                                closingParenToken.range[1]
	                            ], paramToken.value);
	                        }
	                    });
	                }
	                return;
	            }
	
	            if (token.type === "Identifier") {
	                const after = sourceCode.getTokenAfter(token);
	
	                // (x) => x
	                if (after.value !== ")") {
	                    context.report({
	                        node,
	                        message,
	                        fix(fixer) {
	                            return fixer.replaceText(token, `(${token.value})`);
	                        }
	                    });
	                }
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: parens
	        };
	    }
	};


/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to define spacing before/after arrow function's arrow.
	 * @author Jxck
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before and after the arrow in arrow functions",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    before: {
	                        type: "boolean"
	                    },
	                    after: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // merge rules with default
	        const rule = { before: true, after: true },
	            option = context.options[0] || {};
	
	        rule.before = option.before !== false;
	        rule.after = option.after !== false;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Get tokens of arrow(`=>`) and before/after arrow.
	         * @param {ASTNode} node The arrow function node.
	         * @returns {Object} Tokens of arrow and before/after arrow.
	         */
	        function getTokens(node) {
	            let arrow = sourceCode.getTokenBefore(node.body);
	
	            // skip '(' tokens.
	            while (arrow.value !== "=>") {
	                arrow = sourceCode.getTokenBefore(arrow);
	            }
	
	            return {
	                before: sourceCode.getTokenBefore(arrow),
	                arrow,
	                after: sourceCode.getTokenAfter(arrow)
	            };
	        }
	
	        /**
	         * Count spaces before/after arrow(`=>`) token.
	         * @param {Object} tokens Tokens before/after arrow.
	         * @returns {Object} count of space before/after arrow.
	         */
	        function countSpaces(tokens) {
	            const before = tokens.arrow.range[0] - tokens.before.range[1];
	            const after = tokens.after.range[0] - tokens.arrow.range[1];
	
	            return { before, after };
	        }
	
	        /**
	         * Determines whether space(s) before after arrow(`=>`) is satisfy rule.
	         * if before/after value is `true`, there should be space(s).
	         * if before/after value is `false`, there should be no space.
	         * @param {ASTNode} node The arrow function node.
	         * @returns {void}
	         */
	        function spaces(node) {
	            const tokens = getTokens(node);
	            const countSpace = countSpaces(tokens);
	
	            if (rule.before) {
	
	                // should be space(s) before arrow
	                if (countSpace.before === 0) {
	                    context.report({
	                        node: tokens.before,
	                        message: "Missing space before =>.",
	                        fix(fixer) {
	                            return fixer.insertTextBefore(tokens.arrow, " ");
	                        }
	                    });
	                }
	            } else {
	
	                // should be no space before arrow
	                if (countSpace.before > 0) {
	                    context.report({
	                        node: tokens.before,
	                        message: "Unexpected space before =>.",
	                        fix(fixer) {
	                            return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
	                        }
	                    });
	                }
	            }
	
	            if (rule.after) {
	
	                // should be space(s) after arrow
	                if (countSpace.after === 0) {
	                    context.report({
	                        node: tokens.after,
	                        message: "Missing space after =>.",
	                        fix(fixer) {
	                            return fixer.insertTextAfter(tokens.arrow, " ");
	                        }
	                    });
	                }
	            } else {
	
	                // should be no space after arrow
	                if (countSpace.after > 0) {
	                    context.report({
	                        node: tokens.after,
	                        message: "Unexpected space after =>.",
	                        fix(fixer) {
	                            return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
	                        }
	                    });
	                }
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: spaces
	        };
	    }
	};


/***/ },
/* 128 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for "block scoped" variables by binding context
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce the use of variables within the scope they are defined",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let stack = [];
	
	        /**
	         * Makes a block scope.
	         * @param {ASTNode} node - A node of a scope.
	         * @returns {void}
	         */
	        function enterScope(node) {
	            stack.push(node.range);
	        }
	
	        /**
	         * Pops the last block scope.
	         * @returns {void}
	         */
	        function exitScope() {
	            stack.pop();
	        }
	
	        /**
	         * Reports a given reference.
	         * @param {escope.Reference} reference - A reference to report.
	         * @returns {void}
	         */
	        function report(reference) {
	            const identifier = reference.identifier;
	
	            context.report(
	                identifier,
	                "'{{name}}' used outside of binding context.",
	                {name: identifier.name});
	        }
	
	        /**
	         * Finds and reports references which are outside of valid scopes.
	         * @param {ASTNode} node - A node to get variables.
	         * @returns {void}
	         */
	        function checkForVariables(node) {
	            if (node.kind !== "var") {
	                return;
	            }
	
	            // Defines a predicate to check whether or not a given reference is outside of valid scope.
	            const scopeRange = stack[stack.length - 1];
	
	            /**
	             * Check if a reference is out of scope
	             * @param {ASTNode} reference node to examine
	             * @returns {boolean} True is its outside the scope
	             * @private
	             */
	            function isOutsideOfScope(reference) {
	                const idRange = reference.identifier.range;
	
	                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
	            }
	
	            // Gets declared variables, and checks its references.
	            const variables = context.getDeclaredVariables(node);
	
	            for (let i = 0; i < variables.length; ++i) {
	
	                // Reports.
	                variables[i]
	                    .references
	                    .filter(isOutsideOfScope)
	                    .forEach(report);
	            }
	        }
	
	        return {
	            Program(node) {
	                stack = [node.range];
	            },
	
	            // Manages scopes.
	            BlockStatement: enterScope,
	            "BlockStatement:exit": exitScope,
	            ForStatement: enterScope,
	            "ForStatement:exit": exitScope,
	            ForInStatement: enterScope,
	            "ForInStatement:exit": exitScope,
	            ForOfStatement: enterScope,
	            "ForOfStatement:exit": exitScope,
	            SwitchStatement: enterScope,
	            "SwitchStatement:exit": exitScope,
	            CatchClause: enterScope,
	            "CatchClause:exit": exitScope,
	
	            // Finds and reports references which are outside of valid scope.
	            VariableDeclaration: checkForVariables
	        };
	
	    }
	};


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const util = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing inside single-line blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {enum: ["always", "never"]}
	        ]
	    },
	
	    create(context) {
	        const always = (context.options[0] !== "never"),
	            message = always ? "Requires a space" : "Unexpected space(s)",
	            sourceCode = context.getSourceCode();
	
	        /**
	         * Gets the open brace token from a given node.
	         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
	         * @returns {Token} The token of the open brace.
	         */
	        function getOpenBrace(node) {
	            if (node.type === "SwitchStatement") {
	                if (node.cases.length > 0) {
	                    return sourceCode.getTokenBefore(node.cases[0]);
	                }
	                return sourceCode.getLastToken(node, 1);
	            }
	            return sourceCode.getFirstToken(node);
	        }
	
	        /**
	         * Checks whether or not:
	         *   - given tokens are on same line.
	         *   - there is/isn't a space between given tokens.
	         * @param {Token} left - A token to check.
	         * @param {Token} right - The token which is next to `left`.
	         * @returns {boolean}
	         *    When the option is `"always"`, `true` if there are one or more spaces between given tokens.
	         *    When the option is `"never"`, `true` if there are not any spaces between given tokens.
	         *    If given tokens are not on same line, it's always `true`.
	         */
	        function isValid(left, right) {
	            return (
	                !util.isTokenOnSameLine(left, right) ||
	                sourceCode.isSpaceBetweenTokens(left, right) === always
	            );
	        }
	
	        /**
	         * Reports invalid spacing style inside braces.
	         * @param {ASTNode} node - A BlockStatement/SwitchStatement node to get.
	         * @returns {void}
	         */
	        function checkSpacingInsideBraces(node) {
	
	            // Gets braces and the first/last token of content.
	            const openBrace = getOpenBrace(node);
	            const closeBrace = sourceCode.getLastToken(node);
	            const firstToken = sourceCode.getTokenOrCommentAfter(openBrace);
	            const lastToken = sourceCode.getTokenOrCommentBefore(closeBrace);
	
	            // Skip if the node is invalid or empty.
	            if (openBrace.type !== "Punctuator" ||
	                openBrace.value !== "{" ||
	                closeBrace.type !== "Punctuator" ||
	                closeBrace.value !== "}" ||
	                firstToken === closeBrace
	            ) {
	                return;
	            }
	
	            // Skip line comments for option never
	            if (!always && firstToken.type === "Line") {
	                return;
	            }
	
	            // Check.
	            if (!isValid(openBrace, firstToken)) {
	                context.report({
	                    node,
	                    loc: openBrace.loc.start,
	                    message: "{{message}} after '{'.",
	                    data: {
	                        message
	                    },
	                    fix(fixer) {
	                        if (always) {
	                            return fixer.insertTextBefore(firstToken, " ");
	                        }
	
	                        return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
	                    }
	                });
	            }
	            if (!isValid(lastToken, closeBrace)) {
	                context.report({
	                    node,
	                    loc: closeBrace.loc.start,
	                    message: "{{message}} before '}'.",
	                    data: {
	                        message
	                    },
	                    fix(fixer) {
	                        if (always) {
	                            return fixer.insertTextAfter(lastToken, " ");
	                        }
	
	                        return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
	                    }
	                });
	            }
	        }
	
	        return {
	            BlockStatement: checkSpacingInsideBraces,
	            SwitchStatement: checkSpacingInsideBraces
	        };
	    }
	};


/***/ },
/* 130 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag block statements that do not use the one true brace style
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent brace style for blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["1tbs", "stroustrup", "allman"]
	            },
	            {
	                type: "object",
	                properties: {
	                    allowSingleLine: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ],
	
	        fixable: "whitespace"
	    },
	
	    create(context) {
	        const style = context.options[0] || "1tbs",
	            params = context.options[1] || {},
	            sourceCode = context.getSourceCode();
	
	        const OPEN_MESSAGE = "Opening curly brace does not appear on the same line as controlling statement.",
	            OPEN_MESSAGE_ALLMAN = "Opening curly brace appears on the same line as controlling statement.",
	            BODY_MESSAGE = "Statement inside of curly braces should be on next line.",
	            CLOSE_MESSAGE = "Closing curly brace does not appear on the same line as the subsequent block.",
	            CLOSE_MESSAGE_SINGLE = "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
	            CLOSE_MESSAGE_STROUSTRUP_ALLMAN = "Closing curly brace appears on the same line as the subsequent block.";
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Determines if a given node is a block statement.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node is a block statement, false if not.
	         * @private
	         */
	        function isBlock(node) {
	            return node && node.type === "BlockStatement";
	        }
	
	        /**
	         * Check if the token is an punctuator with a value of curly brace
	         * @param {Object} token - Token to check
	         * @returns {boolean} true if its a curly punctuator
	         * @private
	         */
	        function isCurlyPunctuator(token) {
	            return token.value === "{" || token.value === "}";
	        }
	
	        /**
	        * Reports a place where a newline unexpectedly appears
	        * @param {ASTNode} node The node to report
	        * @param {string} message The message to report
	        * @param {Token} firstToken The token before the unexpected newline
	        * @returns {void}
	        */
	        function reportExtraNewline(node, message, firstToken) {
	            context.report({
	                node,
	                message,
	                fix(fixer) {
	                    const secondToken = sourceCode.getTokenAfter(firstToken);
	                    const textBetween = sourceCode.getText().slice(firstToken.range[1], secondToken.range[0]);
	                    const NEWLINE_REGEX = /\r\n|\r|\n|\u2028|\u2029/g;
	
	                    // Don't do a fix if there is a comment between the tokens.
	                    return textBetween.trim() ? null : fixer.replaceTextRange([firstToken.range[1], secondToken.range[0]], textBetween.replace(NEWLINE_REGEX, ""));
	                }
	            });
	        }
	
	        /**
	         * Binds a list of properties to a function that verifies that the opening
	         * curly brace is on the same line as its controlling statement of a given
	         * node.
	         * @param {...string} The properties to check on the node.
	         * @returns {Function} A function that will perform the check on a node
	         * @private
	         */
	        function checkBlock() {
	            const blockProperties = arguments;
	
	            return function(node) {
	                Array.prototype.forEach.call(blockProperties, function(blockProp) {
	                    const block = node[blockProp];
	
	                    if (!isBlock(block)) {
	                        return;
	                    }
	
	                    const previousToken = sourceCode.getTokenBefore(block);
	                    const curlyToken = sourceCode.getFirstToken(block);
	                    const curlyTokenEnd = sourceCode.getLastToken(block);
	                    const allOnSameLine = previousToken.loc.start.line === curlyTokenEnd.loc.start.line;
	
	                    if (allOnSameLine && params.allowSingleLine) {
	                        return;
	                    }
	
	                    if (style !== "allman" && previousToken.loc.start.line !== curlyToken.loc.start.line) {
	                        reportExtraNewline(node, OPEN_MESSAGE, previousToken);
	                    } else if (style === "allman" && previousToken.loc.start.line === curlyToken.loc.start.line) {
	                        context.report({
	                            node,
	                            message: OPEN_MESSAGE_ALLMAN,
	                            fix: fixer => fixer.insertTextBefore(curlyToken, "\n")
	                        });
	                    }
	
	                    if (!block.body.length) {
	                        return;
	                    }
	
	                    if (curlyToken.loc.start.line === block.body[0].loc.start.line) {
	                        context.report({
	                            node: block.body[0],
	                            message: BODY_MESSAGE,
	                            fix: fixer => fixer.insertTextAfter(curlyToken, "\n")
	                        });
	                    }
	
	                    if (curlyTokenEnd.loc.start.line === block.body[block.body.length - 1].loc.start.line) {
	                        context.report({
	                            node: block.body[block.body.length - 1],
	                            message: CLOSE_MESSAGE_SINGLE,
	                            fix: fixer => fixer.insertTextBefore(curlyTokenEnd, "\n")
	                        });
	                    }
	                });
	            };
	        }
	
	        /**
	         * Enforces the configured brace style on IfStatements
	         * @param {ASTNode} node An IfStatement node.
	         * @returns {void}
	         * @private
	         */
	        function checkIfStatement(node) {
	            checkBlock("consequent", "alternate")(node);
	
	            if (node.alternate) {
	
	                const tokens = sourceCode.getTokensBefore(node.alternate, 2);
	
	                if (style === "1tbs") {
	                    if (tokens[0].loc.start.line !== tokens[1].loc.start.line &&
	                        node.consequent.type === "BlockStatement" &&
	                        isCurlyPunctuator(tokens[0])) {
	                        reportExtraNewline(node.alternate, CLOSE_MESSAGE, tokens[0]);
	                    }
	                } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
	                    context.report({
	                        node: node.alternate,
	                        message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
	                        fix: fixer => fixer.insertTextAfter(tokens[0], "\n")
	                    });
	                }
	
	            }
	        }
	
	        /**
	         * Enforces the configured brace style on TryStatements
	         * @param {ASTNode} node A TryStatement node.
	         * @returns {void}
	         * @private
	         */
	        function checkTryStatement(node) {
	            checkBlock("block", "finalizer")(node);
	
	            if (isBlock(node.finalizer)) {
	                const tokens = sourceCode.getTokensBefore(node.finalizer, 2);
	
	                if (style === "1tbs") {
	                    if (tokens[0].loc.start.line !== tokens[1].loc.start.line) {
	                        reportExtraNewline(node.finalizer, CLOSE_MESSAGE, tokens[0]);
	                    }
	                } else if (tokens[0].loc.start.line === tokens[1].loc.start.line) {
	                    context.report({
	                        node: node.finalizer,
	                        message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
	                        fix: fixer => fixer.insertTextAfter(tokens[0], "\n")
	                    });
	                }
	            }
	        }
	
	        /**
	         * Enforces the configured brace style on CatchClauses
	         * @param {ASTNode} node A CatchClause node.
	         * @returns {void}
	         * @private
	         */
	        function checkCatchClause(node) {
	            const previousToken = sourceCode.getTokenBefore(node),
	                firstToken = sourceCode.getFirstToken(node);
	
	            checkBlock("body")(node);
	
	            if (isBlock(node.body)) {
	                if (style === "1tbs") {
	                    if (previousToken.loc.start.line !== firstToken.loc.start.line) {
	                        reportExtraNewline(node, CLOSE_MESSAGE, previousToken);
	                    }
	                } else {
	                    if (previousToken.loc.start.line === firstToken.loc.start.line) {
	                        context.report({
	                            node,
	                            message: CLOSE_MESSAGE_STROUSTRUP_ALLMAN,
	                            fix: fixer => fixer.insertTextAfter(previousToken, "\n")
	                        });
	                    }
	                }
	            }
	        }
	
	        /**
	         * Enforces the configured brace style on SwitchStatements
	         * @param {ASTNode} node A SwitchStatement node.
	         * @returns {void}
	         * @private
	         */
	        function checkSwitchStatement(node) {
	            let tokens;
	
	            if (node.cases && node.cases.length) {
	                tokens = sourceCode.getTokensBefore(node.cases[0], 2);
	            } else {
	                tokens = sourceCode.getLastTokens(node, 3);
	            }
	
	            if (style !== "allman" && tokens[0].loc.start.line !== tokens[1].loc.start.line) {
	                reportExtraNewline(node, OPEN_MESSAGE, tokens[0]);
	            } else if (style === "allman" && tokens[0].loc.start.line === tokens[1].loc.start.line) {
	                context.report({
	                    node,
	                    message: OPEN_MESSAGE_ALLMAN,
	                    fix: fixer => fixer.insertTextBefore(tokens[1], "\n")
	                });
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            FunctionDeclaration: checkBlock("body"),
	            FunctionExpression: checkBlock("body"),
	            ArrowFunctionExpression: checkBlock("body"),
	            IfStatement: checkIfStatement,
	            TryStatement: checkTryStatement,
	            CatchClause: checkCatchClause,
	            DoWhileStatement: checkBlock("body"),
	            WhileStatement: checkBlock("body"),
	            WithStatement: checkBlock("body"),
	            ForStatement: checkBlock("body"),
	            ForInStatement: checkBlock("body"),
	            ForOfStatement: checkBlock("body"),
	            SwitchStatement: checkSwitchStatement
	        };
	
	    }
	};


/***/ },
/* 131 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Enforce return after a callback.
	 * @author Jamund Ferguson
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `return` statements after callbacks",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: [{
	            type: "array",
	            items: { type: "string" }
	        }]
	    },
	
	    create(context) {
	
	        const callbacks = context.options[0] || ["callback", "cb", "next"],
	            sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Find the closest parent matching a list of types.
	         * @param {ASTNode} node The node whose parents we are searching
	         * @param {Array} types The node types to match
	         * @returns {ASTNode} The matched node or undefined.
	         */
	        function findClosestParentOfType(node, types) {
	            if (!node.parent) {
	                return null;
	            }
	            if (types.indexOf(node.parent.type) === -1) {
	                return findClosestParentOfType(node.parent, types);
	            }
	            return node.parent;
	        }
	
	        /**
	         * Check to see if a node contains only identifers
	         * @param {ASTNode} node The node to check
	         * @returns {boolean} Whether or not the node contains only identifers
	         */
	        function containsOnlyIdentifiers(node) {
	            if (node.type === "Identifier") {
	                return true;
	            }
	
	            if (node.type === "MemberExpression") {
	                if (node.object.type === "Identifier") {
	                    return true;
	                } else if (node.object.type === "MemberExpression") {
	                    return containsOnlyIdentifiers(node.object);
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Check to see if a CallExpression is in our callback list.
	         * @param {ASTNode} node The node to check against our callback names list.
	         * @returns {boolean} Whether or not this function matches our callback name.
	         */
	        function isCallback(node) {
	            return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
	        }
	
	        /**
	         * Determines whether or not the callback is part of a callback expression.
	         * @param {ASTNode} node The callback node
	         * @param {ASTNode} parentNode The expression node
	         * @returns {boolean} Whether or not this is part of a callback expression
	         */
	        function isCallbackExpression(node, parentNode) {
	
	            // ensure the parent node exists and is an expression
	            if (!parentNode || parentNode.type !== "ExpressionStatement") {
	                return false;
	            }
	
	            // cb()
	            if (parentNode.expression === node) {
	                return true;
	            }
	
	            // special case for cb && cb() and similar
	            if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
	                if (parentNode.expression.right === node) {
	                    return true;
	                }
	            }
	
	            return false;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            CallExpression(node) {
	
	                // if we're not a callback we can return
	                if (!isCallback(node)) {
	                    return;
	                }
	
	                // find the closest block, return or loop
	                const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
	
	                // if our parent is a return we know we're ok
	                if (closestBlock.type === "ReturnStatement") {
	                    return;
	                }
	
	                // arrow functions don't always have blocks and implicitly return
	                if (closestBlock.type === "ArrowFunctionExpression") {
	                    return;
	                }
	
	                // block statements are part of functions and most if statements
	                if (closestBlock.type === "BlockStatement") {
	
	                    // find the last item in the block
	                    const lastItem = closestBlock.body[closestBlock.body.length - 1];
	
	                    // if the callback is the last thing in a block that might be ok
	                    if (isCallbackExpression(node, lastItem)) {
	
	                        const parentType = closestBlock.parent.type;
	
	                        // but only if the block is part of a function
	                        if (parentType === "FunctionExpression" ||
	                            parentType === "FunctionDeclaration" ||
	                            parentType === "ArrowFunctionExpression"
	                        ) {
	                            return;
	                        }
	
	                    }
	
	                    // ending a block with a return is also ok
	                    if (lastItem.type === "ReturnStatement") {
	
	                        // but only if the callback is immediately before
	                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
	                            return;
	                        }
	                    }
	
	                }
	
	                // as long as you're the child of a function at this point you should be asked to return
	                if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
	                    context.report(node, "Expected return with your callback function.");
	                }
	
	            }
	
	        };
	    }
	};


/***/ },
/* 132 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag non-camelcased identifiers
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce camelcase naming convention",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    properties: {
	                        enum: ["always", "never"]
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation
	        const reported = [];
	        const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
	
	        /**
	         * Checks if a string contains an underscore and isn't all upper-case
	         * @param {string} name The string to check.
	         * @returns {boolean} if the string is underscored
	         * @private
	         */
	        function isUnderscored(name) {
	
	            // if there's an underscore, it might be A_CONSTANT, which is okay
	            return name.indexOf("_") > -1 && name !== name.toUpperCase();
	        }
	
	        /**
	         * Reports an AST node as a rule violation.
	         * @param {ASTNode} node The node to report.
	         * @returns {void}
	         * @private
	         */
	        function report(node) {
	            if (reported.indexOf(node) < 0) {
	                reported.push(node);
	                context.report(node, "Identifier '{{name}}' is not in camel case.", { name: node.name });
	            }
	        }
	
	        const options = context.options[0] || {};
	        let properties = options.properties || "";
	
	        if (properties !== "always" && properties !== "never") {
	            properties = "always";
	        }
	
	        return {
	
	            Identifier(node) {
	
	                /*
	                 * Leading and trailing underscores are commonly used to flag
	                 * private/protected identifiers, strip them
	                 */
	                const name = node.name.replace(/^_+|_+$/g, ""),
	                    effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;
	
	                // MemberExpressions get special rules
	                if (node.parent.type === "MemberExpression") {
	
	                    // "never" check properties
	                    if (properties === "never") {
	                        return;
	                    }
	
	                    // Always report underscored object names
	                    if (node.parent.object.type === "Identifier" &&
	                            node.parent.object.name === node.name &&
	                            isUnderscored(name)) {
	                        report(node);
	
	                    // Report AssignmentExpressions only if they are the left side of the assignment
	                    } else if (effectiveParent.type === "AssignmentExpression" &&
	                            isUnderscored(name) &&
	                            (effectiveParent.right.type !== "MemberExpression" ||
	                            effectiveParent.left.type === "MemberExpression" &&
	                            effectiveParent.left.property.name === node.name)) {
	                        report(node);
	                    }
	
	                // Properties have their own rules
	                } else if (node.parent.type === "Property") {
	
	                    // "never" check properties
	                    if (properties === "never") {
	                        return;
	                    }
	
	                    if (node.parent.parent && node.parent.parent.type === "ObjectPattern" &&
	                            node.parent.key === node && node.parent.value !== node) {
	                        return;
	                    }
	
	                    if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
	                        report(node);
	                    }
	
	                // Check if it's an import specifier
	                } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].indexOf(node.parent.type) >= 0) {
	
	                    // Report only if the local imported identifier is underscored
	                    if (node.parent.local && node.parent.local.name === node.name && isUnderscored(name)) {
	                        report(node);
	                    }
	
	                // Report anything that is underscored that isn't a CallExpression
	                } else if (isUnderscored(name) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
	                    report(node);
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 133 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce that all class methods use 'this'.
	 * @author Patrick Williams
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce that class methods utilize `this`",
	            category: "Best Practices",
	            recommended: false
	        },
	        schema: [{
	            type: "object",
	            properties: {
	                exceptMethods: {
	                    type: "array",
	                    items: {
	                        type: "string"
	                    }
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	    create(context) {
	        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};
	        const exceptMethods = new Set(config.exceptMethods || []);
	
	        const stack = [];
	
	        /**
	         * Initializes the current context to false and pushes it onto the stack.
	         * These booleans represent whether 'this' has been used in the context.
	         * @returns {void}
	         * @private
	         */
	        function enterFunction() {
	            stack.push(false);
	        }
	
	        /**
	         * Check if the node is an instance method
	         * @param {ASTNode} node - node to check
	         * @returns {boolean} True if its an instance method
	         * @private
	         */
	        function isInstanceMethod(node) {
	            return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
	        }
	
	        /**
	         * Check if the node is an instance method not excluded by config
	         * @param {ASTNode} node - node to check
	         * @returns {boolean} True if it is an instance method, and not excluded by config
	         * @private
	         */
	        function isIncludedInstanceMethod(node) {
	            return isInstanceMethod(node) && !exceptMethods.has(node.key.name);
	        }
	
	        /**
	         * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
	         * Static methods and the constructor are exempt.
	         * Then pops the context off the stack.
	         * @param {ASTNode} node - A function node that was entered.
	         * @returns {void}
	         * @private
	         */
	        function exitFunction(node) {
	            const methodUsesThis = stack.pop();
	
	            if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
	                context.report({
	                    node,
	                    message: "Expected 'this' to be used by class method '{{classMethod}}'.",
	                    data: {
	                        classMethod: node.parent.key.name
	                    }
	                });
	            }
	        }
	
	        /**
	         * Mark the current context as having used 'this'.
	         * @returns {void}
	         * @private
	         */
	        function markThisUsed() {
	            if (stack.length) {
	                stack[stack.length - 1] = true;
	            }
	        }
	
	        return {
	            FunctionDeclaration: enterFunction,
	            "FunctionDeclaration:exit": exitFunction,
	            FunctionExpression: enterFunction,
	            "FunctionExpression:exit": exitFunction,
	            ThisExpression: markThisUsed,
	            Super: markThisUsed
	        };
	    }
	};


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to forbid or enforce dangling commas.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const DEFAULT_OPTIONS = Object.freeze({
	    arrays: "never",
	    objects: "never",
	    imports: "never",
	    exports: "never",
	    functions: "ignore",
	});
	
	/**
	 * Checks whether or not a trailing comma is allowed in a given node.
	 * If the `lastItem` is `RestElement` or `RestProperty`, it disallows trailing commas.
	 *
	 * @param {ASTNode} lastItem - The node of the last element in the given node.
	 * @returns {boolean} `true` if a trailing comma is allowed.
	 */
	function isTrailingCommaAllowed(lastItem) {
	    return !(
	        lastItem.type === "RestElement" ||
	        lastItem.type === "RestProperty" ||
	        lastItem.type === "ExperimentalRestProperty"
	    );
	}
	
	/**
	 * Normalize option value.
	 *
	 * @param {string|Object|undefined} optionValue - The 1st option value to normalize.
	 * @returns {Object} The normalized option value.
	 */
	function normalizeOptions(optionValue) {
	    if (typeof optionValue === "string") {
	        return {
	            arrays: optionValue,
	            objects: optionValue,
	            imports: optionValue,
	            exports: optionValue,
	
	            // For backward compatibility, always ignore functions.
	            functions: "ignore",
	        };
	    }
	    if (typeof optionValue === "object" && optionValue !== null) {
	        return {
	            arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
	            objects: optionValue.objects || DEFAULT_OPTIONS.objects,
	            imports: optionValue.imports || DEFAULT_OPTIONS.imports,
	            exports: optionValue.exports || DEFAULT_OPTIONS.exports,
	            functions: optionValue.functions || DEFAULT_OPTIONS.functions,
	        };
	    }
	
	    return DEFAULT_OPTIONS;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow trailing commas",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: [
	            {
	                defs: {
	                    value: {
	                        enum: [
	                            "always",
	                            "always-multiline",
	                            "only-multiline",
	                            "never"
	                        ]
	                    },
	                    valueWithIgnore: {
	                        anyOf: [
	                            {
	                                $ref: "#/defs/value"
	                            },
	                            {
	                                enum: ["ignore"]
	                            }
	                        ]
	                    }
	                },
	                anyOf: [
	                    {
	                        $ref: "#/defs/value"
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            arrays: {$refs: "#/defs/valueWithIgnore"},
	                            objects: {$refs: "#/defs/valueWithIgnore"},
	                            imports: {$refs: "#/defs/valueWithIgnore"},
	                            exports: {$refs: "#/defs/valueWithIgnore"},
	                            functions: {$refs: "#/defs/valueWithIgnore"}
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            },
	        ]
	    },
	
	    create(context) {
	        const options = normalizeOptions(context.options[0]);
	        const sourceCode = context.getSourceCode();
	        const UNEXPECTED_MESSAGE = "Unexpected trailing comma.";
	        const MISSING_MESSAGE = "Missing trailing comma.";
	
	        /**
	         * Gets the last item of the given node.
	         * @param {ASTNode} node - The node to get.
	         * @returns {ASTNode|null} The last node or null.
	         */
	        function getLastItem(node) {
	            switch (node.type) {
	                case "ObjectExpression":
	                case "ObjectPattern":
	                    return lodash.last(node.properties);
	                case "ArrayExpression":
	                case "ArrayPattern":
	                    return lodash.last(node.elements);
	                case "ImportDeclaration":
	                case "ExportNamedDeclaration":
	                    return lodash.last(node.specifiers);
	                case "FunctionDeclaration":
	                case "FunctionExpression":
	                case "ArrowFunctionExpression":
	                    return lodash.last(node.params);
	                case "CallExpression":
	                case "NewExpression":
	                    return lodash.last(node.arguments);
	                default:
	                    return null;
	            }
	        }
	
	        /**
	         * Gets the trailing comma token of the given node.
	         * If the trailing comma does not exist, this returns the token which is
	         * the insertion point of the trailing comma token.
	         *
	         * @param {ASTNode} node - The node to get.
	         * @param {ASTNode} lastItem - The last item of the node.
	         * @returns {Token} The trailing comma token or the insertion point.
	         */
	        function getTrailingToken(node, lastItem) {
	            switch (node.type) {
	                case "ObjectExpression":
	                case "ArrayExpression":
	                case "CallExpression":
	                case "NewExpression":
	                    return sourceCode.getLastToken(node, 1);
	                default: {
	                    const nextToken = sourceCode.getTokenAfter(lastItem);
	
	                    if (nextToken.value === ",") {
	                        return nextToken;
	                    }
	                    return sourceCode.getLastToken(lastItem);
	                }
	            }
	        }
	
	        /**
	         * Checks whether or not a given node is multiline.
	         * This rule handles a given node as multiline when the closing parenthesis
	         * and the last element are not on the same line.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} `true` if the node is multiline.
	         */
	        function isMultiline(node) {
	            const lastItem = getLastItem(node);
	
	            if (!lastItem) {
	                return false;
	            }
	
	            const penultimateToken = getTrailingToken(node, lastItem);
	            const lastToken = sourceCode.getTokenAfter(penultimateToken);
	
	            return lastToken.loc.end.line !== penultimateToken.loc.end.line;
	        }
	
	        /**
	         * Reports a trailing comma if it exists.
	         *
	         * @param {ASTNode} node - A node to check. Its type is one of
	         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
	         *   ImportDeclaration, and ExportNamedDeclaration.
	         * @returns {void}
	         */
	        function forbidTrailingComma(node) {
	            const lastItem = getLastItem(node);
	
	            if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
	                return;
	            }
	
	            const trailingToken = getTrailingToken(node, lastItem);
	
	            if (trailingToken.value === ",") {
	                context.report({
	                    node: lastItem,
	                    loc: trailingToken.loc.start,
	                    message: UNEXPECTED_MESSAGE,
	                    fix(fixer) {
	                        return fixer.remove(trailingToken);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Reports the last element of a given node if it does not have a trailing
	         * comma.
	         *
	         * If a given node is `ArrayPattern` which has `RestElement`, the trailing
	         * comma is disallowed, so report if it exists.
	         *
	         * @param {ASTNode} node - A node to check. Its type is one of
	         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
	         *   ImportDeclaration, and ExportNamedDeclaration.
	         * @returns {void}
	         */
	        function forceTrailingComma(node) {
	            const lastItem = getLastItem(node);
	
	            if (!lastItem || (node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier")) {
	                return;
	            }
	            if (!isTrailingCommaAllowed(lastItem)) {
	                forbidTrailingComma(node);
	                return;
	            }
	
	            const trailingToken = getTrailingToken(node, lastItem);
	
	            if (trailingToken.value !== ",") {
	                context.report({
	                    node: lastItem,
	                    loc: trailingToken.loc.end,
	                    message: MISSING_MESSAGE,
	                    fix(fixer) {
	                        return fixer.insertTextAfter(trailingToken, ",");
	                    }
	                });
	            }
	        }
	
	        /**
	         * If a given node is multiline, reports the last element of a given node
	         * when it does not have a trailing comma.
	         * Otherwise, reports a trailing comma if it exists.
	         *
	         * @param {ASTNode} node - A node to check. Its type is one of
	         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
	         *   ImportDeclaration, and ExportNamedDeclaration.
	         * @returns {void}
	         */
	        function forceTrailingCommaIfMultiline(node) {
	            if (isMultiline(node)) {
	                forceTrailingComma(node);
	            } else {
	                forbidTrailingComma(node);
	            }
	        }
	
	        /**
	         * Only if a given node is not multiline, reports the last element of a given node
	         * when it does not have a trailing comma.
	         * Otherwise, reports a trailing comma if it exists.
	         *
	         * @param {ASTNode} node - A node to check. Its type is one of
	         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,
	         *   ImportDeclaration, and ExportNamedDeclaration.
	         * @returns {void}
	         */
	        function allowTrailingCommaIfMultiline(node) {
	            if (!isMultiline(node)) {
	                forbidTrailingComma(node);
	            }
	        }
	
	        const predicate = {
	            always: forceTrailingComma,
	            "always-multiline": forceTrailingCommaIfMultiline,
	            "only-multiline": allowTrailingCommaIfMultiline,
	            never: forbidTrailingComma,
	            ignore: lodash.noop,
	        };
	
	        return {
	            ObjectExpression: predicate[options.objects],
	            ObjectPattern: predicate[options.objects],
	
	            ArrayExpression: predicate[options.arrays],
	            ArrayPattern: predicate[options.arrays],
	
	            ImportDeclaration: predicate[options.imports],
	
	            ExportNamedDeclaration: predicate[options.exports],
	
	            FunctionDeclaration: predicate[options.functions],
	            FunctionExpression: predicate[options.functions],
	            ArrowFunctionExpression: predicate[options.functions],
	            CallExpression: predicate[options.functions],
	            NewExpression: predicate[options.functions],
	        };
	    }
	};


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {
	
	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;
	
	  /** Used as the semantic version number. */
	  var VERSION = '4.17.2';
	
	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;
	
	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';
	
	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;
	
	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';
	
	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;
	
	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;
	
	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;
	
	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';
	
	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;
	
	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;
	
	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;
	
	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
	
	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];
	
	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';
	
	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';
	
	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
	
	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
	
	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;
	
	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      reLeadingDot = /^\./,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
	
	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);
	
	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;
	
	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;
	
	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
	
	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;
	
	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
	
	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;
	
	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
	
	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;
	
	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;
	
	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
	
	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;
	
	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
	
	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
	
	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';
	
	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
	      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';
	
	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');
	
	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');
	
	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');
	
	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');
	
	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');
	
	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
	
	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];
	
	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;
	
	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;
	
	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;
	
	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };
	
	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };
	
	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };
	
	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };
	
	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;
	
	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();
	
	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;
	
	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;
	
	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());
	
	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    // Don't return `map.set` because it's not chainable in IE 11.
	    map.set(pair[0], pair[1]);
	    return map;
	  }
	
	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    // Don't return `set.add` because it's not chainable in IE 11.
	    set.add(value);
	    return set;
	  }
	
	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }
	
	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	
	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }
	
	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }
	
	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);
	
	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }
	
	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;
	
	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }
	
	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }
	
	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;
	
	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }
	
	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');
	
	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }
	
	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }
	
	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);
	
	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }
	
	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }
	
	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }
	
	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }
	
	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }
	
	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;
	
	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }
	
	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;
	
	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);
	
	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }
	
	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }
	
	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }
	
	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }
	
	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;
	
	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;
	
	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }
	
	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;
	
	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);
	
	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);
	
	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }
	
	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }
	
	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }
	
	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }
	
	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];
	
	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }
	
	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);
	
	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }
	
	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }
	
	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];
	
	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }
	
	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }
	
	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);
	
	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }
	
	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;
	
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }
	
	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }
	
	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }
	
	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }
	
	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
	
	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }
	
	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }
	
	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }
	
	  /*--------------------------------------------------------------------------*/
	
	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
	
	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;
	
	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;
	
	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];
	
	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;
	
	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;
	
	    /** Used to generate unique IDs. */
	    var idCounter = 0;
	
	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());
	
	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;
	
	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);
	
	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;
	
	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );
	
	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;
	
	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());
	
	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
	
	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;
	
	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');
	
	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;
	
	    /** Used to lookup unminified function names. */
	    var realNames = {};
	
	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);
	
	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array of at least `200` elements
	     * and any iteratees accept only one argument. The heuristic for whether a
	     * section qualifies for shortcut fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }
	
	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());
	
	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }
	
	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }
	
	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB). Change the following template settings to use
	     * alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {
	
	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,
	
	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,
	
	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,
	
	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',
	
	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {
	
	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };
	
	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;
	
	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }
	
	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }
	
	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }
	
	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);
	
	      if (!isArr || arrLength < LARGE_ARRAY_SIZE ||
	          (arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];
	
	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;
	
	        var iterIndex = -1,
	            value = array[index];
	
	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);
	
	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }
	
	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }
	
	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	    }
	
	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }
	
	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }
	
	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      return index < 0 ? undefined : data[index][1];
	    }
	
	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }
	
	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);
	
	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }
	
	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;
	
	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }
	
	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }
	
	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }
	
	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }
	
	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }
	
	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;
	
	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }
	
	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;
	
	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }
	
	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }
	
	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }
	
	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }
	
	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }
	
	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);
	
	      this.size = data.size;
	      return result;
	    }
	
	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }
	
	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }
	
	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }
	
	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;
	
	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }
	
	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }
	
	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function assignInDefaults(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }
	
	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }
	
	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }
	
	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }
	
	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }
	
	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;
	
	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }
	
	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;
	
	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;
	
	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, baseClone, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);
	
	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);
	
	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }
	
	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];
	
	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }
	
	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;
	
	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);
	
	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);
	
	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;
	
	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);
	
	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;
	
	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;
	
	      predicate || (predicate = isFlattenable);
	      result || (result = []);
	
	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();
	
	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);
	
	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }
	
	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }
	
	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);
	
	      var index = 0,
	          length = path.length;
	
	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }
	
	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }
	
	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      value = Object(value);
	      return (symToStringTag && symToStringTag in value)
	        ? getRawTag(value)
	        : objectToString(value);
	    }
	
	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }
	
	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }
	
	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }
	
	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }
	
	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];
	
	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];
	
	      var index = -1,
	          seen = caches[0];
	
	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }
	
	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }
	
	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }
	
	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }
	
	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }
	
	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = arrayTag,
	          othTag = arrayTag;
	
	      if (!objIsArr) {
	        objTag = getTag(object);
	        objTag = objTag == argsTag ? objectTag : objTag;
	      }
	      if (!othIsArr) {
	        othTag = getTag(other);
	        othTag = othTag == argsTag ? objectTag : othTag;
	      }
	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;
	
	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;
	
	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }
	
	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }
	
	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;
	
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];
	
	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }
	
	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }
	
	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }
	
	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }
	
	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }
	
	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }
	
	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];
	
	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }
	
	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }
	
	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }
	
	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;
	
	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }
	
	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);
	
	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;
	
	      var isCommon = newValue === undefined;
	
	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
	
	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }
	
	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }
	
	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
	
	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });
	
	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }
	
	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      object = Object(object);
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }
	
	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};
	
	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);
	
	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }
	
	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;
	
	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;
	
	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }
	
	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }
	
	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);
	
	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);
	
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }
	
	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }
	
	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;
	
	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;
	
	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }
	
	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };
	
	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };
	
	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }
	
	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;
	
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;
	
	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;
	
	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }
	
	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;
	
	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];
	
	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }
	
	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);
	
	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;
	
	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);
	
	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }
	
	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }
	
	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;
	
	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;
	
	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }
	
	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }
	
	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;
	
	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}
	
	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }
	
	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }
	
	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);
	
	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;
	
	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }
	
	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};
	
	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }
	
	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }
	
	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }
	
	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }
	
	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;
	
	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }
	
	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };
	
	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
	
	      buffer.copy(result);
	      return result;
	    }
	
	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }
	
	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }
	
	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
	      return arrayReduce(array, addMapEntry, new map.constructor);
	    }
	
	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }
	
	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
	      return arrayReduce(array, addSetEntry, new set.constructor);
	    }
	
	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }
	
	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }
	
	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);
	
	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);
	
	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }
	
	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;
	
	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }
	
	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;
	
	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }
	
	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;
	
	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;
	
	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }
	
	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});
	
	      var index = -1,
	          length = props.length;
	
	      while (++index < length) {
	        var key = props[index];
	
	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;
	
	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }
	
	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }
	
	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }
	
	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};
	
	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }
	
	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;
	
	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;
	
	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }
	
	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);
	
	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }
	
	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;
	
	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);
	
	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;
	
	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);
	
	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);
	
	        return chr[methodName]() + trailing;
	      };
	    }
	
	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }
	
	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);
	
	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);
	
	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }
	
	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;
	
	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];
	
	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;
	
	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];
	
	          if (wrapper && args.length == 1 &&
	              isArray(value) && value.length >= LARGE_ARRAY_SIZE) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;
	
	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);
	
	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;
	
	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;
	
	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }
	
	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }
	
	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);
	
	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }
	
	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);
	
	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	
	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }
	
	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }
	
	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }
	
	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;
	
	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
	
	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];
	
	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }
	
	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));
	
	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }
	
	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };
	
	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }
	
	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;
	
	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;
	
	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);
	
	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];
	
	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] == null
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);
	
	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;
	
	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;
	
	      stack.set(array, other);
	      stack.set(other, array);
	
	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;
	
	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;
	
	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);
	
	        case errorTag:
	          return object.name == other.name && object.message == other.message;
	
	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');
	
	        case mapTag:
	          var convert = mapToArray;
	
	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);
	
	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;
	
	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;
	
	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }
	
	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = keys(object),
	          objLength = objProps.length,
	          othProps = keys(other),
	          othLength = othProps.length;
	
	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);
	
	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];
	
	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;
	
	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }
	
	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }
	
	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }
	
	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }
	
	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };
	
	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;
	
	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }
	
	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }
	
	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }
	
	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;
	
	      while (length--) {
	        var key = result[length],
	            value = object[key];
	
	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }
	
	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];
	
	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}
	
	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
	
	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };
	
	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;
	
	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';
	
	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;
	
	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;
	
	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }
	
	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }
	
	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length,
	          result = false;
	
	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }
	
	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);
	
	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }
	
	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }
	
	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, cloneFunc, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);
	
	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);
	
	        case dataViewTag:
	          return cloneDataView(object, isDeep);
	
	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);
	
	        case mapTag:
	          return cloneMap(object, isDeep, cloneFunc);
	
	        case numberTag:
	        case stringTag:
	          return new Ctor(object);
	
	        case regexpTag:
	          return cloneRegExp(object);
	
	        case setTag:
	          return cloneSet(object, isDeep, cloneFunc);
	
	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }
	
	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }
	
	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	    }
	
	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }
	
	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }
	
	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }
	
	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];
	
	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }
	
	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }
	
	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;
	
	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	      return value === proto;
	    }
	
	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }
	
	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }
	
	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });
	
	      var cache = result.cache;
	      return result;
	    }
	
	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
	
	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));
	
	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;
	
	      return data;
	    }
	
	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function mergeDefaults(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, mergeDefaults, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }
	
	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }
	
	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);
	
	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }
	
	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }
	
	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);
	
	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }
	
	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);
	
	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };
	
	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);
	
	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }
	
	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;
	
	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);
	
	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }
	
	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;
	
	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];
	
	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }
	
	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (reLeadingDot.test(string)) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });
	
	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }
	
	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }
	
	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }
	
	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));
	
	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }
	
	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];
	
	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }
	
	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;
	
	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }
	
	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }
	
	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }
	
	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }
	
	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }
	
	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }
	
	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }
	
	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }
	
	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};
	
	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }
	
	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }
	
	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }
	
	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }
	
	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });
	
	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);
	
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });
	
	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }
	
	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }
	
	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }
	
	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);
	
	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }
	
	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }
	
	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);
	
	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));
	
	      return result;
	    });
	
	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;
	
	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }
	
	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }
	
	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }
	
	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }
	
	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }
	
	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }
	
	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }
	
	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }
	
	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }
	
	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }
	
	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false},
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }
	
	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });
	
	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }
	
	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }
	
	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }
	
	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });
	
	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });
	
	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });
	
	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);
	
	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }
	
	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }
	
	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;
	
	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }
	
	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }
	
	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }
	
	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };
	
	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });
	
	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }
	
	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }
	
	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];
	
	      return { 'done': done, 'value': value };
	    }
	
	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }
	
	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;
	
	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }
	
	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }
	
	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });
	
	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);
	
	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);
	
	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }
	
	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }
	
	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });
	
	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;
	
	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }
	
	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];
	
	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });
	
	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });
	
	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }
	
	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });
	
	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }
	
	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;
	
	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }
	
	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }
	
	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }
	
	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }
	
	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }
	
	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }
	
	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }
	
	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }
	
	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });
	
	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }
	
	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }
	
	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	
	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;
	
	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }
	
	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }
	
	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            result = wait - timeSinceLastCall;
	
	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	      }
	
	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;
	
	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }
	
	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }
	
	      function trailingEdge(time) {
	        timerId = undefined;
	
	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }
	
	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }
	
	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }
	
	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);
	
	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;
	
	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }
	
	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });
	
	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }
	
	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;
	
	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }
	
	    // Expose `MapCache`.
	    memoize.Cache = MapCache;
	
	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }
	
	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }
	
	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
	
	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);
	
	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });
	
	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });
	
	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }
	
	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);
	
	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }
	
	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;
	
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }
	
	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }
	
	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }
	
	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }
	
	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }
	
	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }
	
	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }
	
	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);
	
	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });
	
	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };
	
	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;
	
	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
	
	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }
	
	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }
	
	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;
	
	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
	
	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }
	
	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }
	
	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are **not** supported.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }
	
	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }
	
	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }
	
	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }
	
	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }
	
	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }
	
	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }
	
	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
	
	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }
	
	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }
	
	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }
	
	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }
	
	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }
	
	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }
	
	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }
	
	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
	
	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }
	
	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
	
	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }
	
	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }
	
	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }
	
	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);
	
	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });
	
	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);
	
	      return func(value);
	    }
	
	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }
	
	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;
	
	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }
	
	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }
	
	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }
	
	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }
	
	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
	    }
	
	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });
	
	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });
	
	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });
	
	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });
	
	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);
	
	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }
	
	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(args) {
	      args.push(undefined, assignInDefaults);
	      return apply(assignInWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, mergeDefaults);
	      return apply(mergeWith, undefined, args);
	    });
	
	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }
	
	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }
	
	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }
	
	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }
	
	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }
	
	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }
	
	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }
	
	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }
	
	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }
	
	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));
	
	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);
	
	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);
	
	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }
	
	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }
	
	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);
	
	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }
	
	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });
	
	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });
	
	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });
	
	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }
	
	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });
	
	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }
	
	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);
	
	      var index = -1,
	          length = path.length;
	
	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }
	
	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }
	
	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }
	
	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);
	
	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);
	
	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);
	
	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }
	
	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }
	
	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }
	
	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }
	
	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }
	
	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }
	
	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }
	
	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });
	
	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }
	
	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('dj vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }
	
	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);
	
	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);
	
	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }
	
	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }
	
	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');
	
	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }
	
	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }
	
	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);
	
	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }
	
	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }
	
	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }
	
	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);
	
	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }
	
	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });
	
	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }
	
	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });
	
	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = baseClamp(toInteger(position), 0, string.length);
	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }
	
	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;
	
	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, assignInDefaults);
	
	      var imports = assignInWith({}, options.imports, settings.imports, assignInDefaults),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);
	
	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";
	
	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');
	
	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';
	
	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);
	
	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
	
	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;
	
	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });
	
	      source += "';\n";
	
	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');
	
	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';
	
	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });
	
	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }
	
	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }
	
	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }
	
	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;
	
	      return castSlice(strSymbols, start, end).join('');
	    }
	
	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
	
	      return castSlice(strSymbols, 0, end).join('');
	    }
	
	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));
	
	      return castSlice(strSymbols, start).join('');
	    }
	
	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;
	
	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);
	
	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);
	
	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;
	
	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }
	
	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }
	
	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });
	
	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');
	
	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;
	
	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });
	
	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });
	
	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();
	
	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });
	
	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }
	
	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }
	
	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }
	
	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();
	
	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);
	
	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }
	
	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }
	
	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });
	
	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);
	
	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);
	
	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);
	
	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });
	
	      return object;
	    }
	
	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }
	
	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }
	
	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }
	
	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);
	
	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);
	
	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);
	
	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }
	
	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }
	
	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();
	
	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);
	
	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }
	
	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }
	
	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }
	
	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }
	
	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }
	
	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);
	
	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;
	
	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }
	
	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }
	
	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);
	
	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');
	
	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);
	
	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');
	
	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }
	
	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }
	
	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }
	
	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }
	
	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }
	
	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);
	
	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');
	
	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);
	
	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }
	
	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;
	
	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;
	
	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);
	
	    /*------------------------------------------------------------------------*/
	
	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;
	
	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;
	
	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });
	
	    /*------------------------------------------------------------------------*/
	
	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;
	
	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });
	
	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        var filtered = this.__filtered__;
	        if (filtered && !index) {
	          return new LazyWrapper(this);
	        }
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
	
	        var result = this.clone();
	        if (filtered) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };
	
	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });
	
	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
	
	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });
	
	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');
	
	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });
	
	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };
	
	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };
	
	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };
	
	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });
	
	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };
	
	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);
	
	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };
	
	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };
	
	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };
	
	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);
	
	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);
	
	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };
	
	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;
	
	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });
	
	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);
	
	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });
	
	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);
	
	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });
	
	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];
	
	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;
	
	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
	
	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;
	
	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });
	
	  /*--------------------------------------------------------------------------*/
	
	  // Export lodash.
	  var _ = runInContext();
	
	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;
	
	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(136)(module)))

/***/ },
/* 136 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Comma spacing - validates spacing before and after comma
	 * @author Vignesh Anand aka vegetableman.
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before and after commas",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    before: {
	                        type: "boolean"
	                    },
	                    after: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const sourceCode = context.getSourceCode();
	        const tokensAndComments = sourceCode.tokensAndComments;
	
	        const options = {
	            before: context.options[0] ? !!context.options[0].before : false,
	            after: context.options[0] ? !!context.options[0].after : true
	        };
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        // list of comma tokens to ignore for the check of leading whitespace
	        const commaTokensToIgnore = [];
	
	        /**
	         * Determines if a given token is a comma operator.
	         * @param {ASTNode} token The token to check.
	         * @returns {boolean} True if the token is a comma, false if not.
	         * @private
	         */
	        function isComma(token) {
	            return !!token && (token.type === "Punctuator") && (token.value === ",");
	        }
	
	        /**
	         * Reports a spacing error with an appropriate message.
	         * @param {ASTNode} node The binary expression node to report.
	         * @param {string} dir Is the error "before" or "after" the comma?
	         * @param {ASTNode} otherNode The node at the left or right of `node`
	         * @returns {void}
	         * @private
	         */
	        function report(node, dir, otherNode) {
	            context.report({
	                node,
	                fix(fixer) {
	                    if (options[dir]) {
	                        if (dir === "before") {
	                            return fixer.insertTextBefore(node, " ");
	                        } else {
	                            return fixer.insertTextAfter(node, " ");
	                        }
	                    } else {
	                        let start, end;
	                        const newText = "";
	
	                        if (dir === "before") {
	                            start = otherNode.range[1];
	                            end = node.range[0];
	                        } else {
	                            start = node.range[1];
	                            end = otherNode.range[0];
	                        }
	
	                        return fixer.replaceTextRange([start, end], newText);
	                    }
	                },
	                message: options[dir] ?
	                  "A space is required {{dir}} ','." :
	                  "There should be no space {{dir}} ','.",
	                data: {
	                    dir
	                }
	            });
	        }
	
	        /**
	         * Validates the spacing around a comma token.
	         * @param {Object} tokens - The tokens to be validated.
	         * @param {Token} tokens.comma The token representing the comma.
	         * @param {Token} [tokens.left] The last token before the comma.
	         * @param {Token} [tokens.right] The first token after the comma.
	         * @param {Token|ASTNode} reportItem The item to use when reporting an error.
	         * @returns {void}
	         * @private
	         */
	        function validateCommaItemSpacing(tokens, reportItem) {
	            if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) &&
	                    (options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma))
	            ) {
	                report(reportItem, "before", tokens.left);
	            }
	
	            if (tokens.right && !options.after && tokens.right.type === "Line") {
	                return;
	            }
	
	            if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) &&
	                    (options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right))
	            ) {
	                report(reportItem, "after", tokens.right);
	            }
	        }
	
	        /**
	         * Adds null elements of the given ArrayExpression or ArrayPattern node to the ignore list.
	         * @param {ASTNode} node An ArrayExpression or ArrayPattern node.
	         * @returns {void}
	         */
	        function addNullElementsToIgnoreList(node) {
	            let previousToken = sourceCode.getFirstToken(node);
	
	            node.elements.forEach(function(element) {
	                let token;
	
	                if (element === null) {
	                    token = sourceCode.getTokenAfter(previousToken);
	
	                    if (isComma(token)) {
	                        commaTokensToIgnore.push(token);
	                    }
	                } else {
	                    token = sourceCode.getTokenAfter(element);
	                }
	
	                previousToken = token;
	            });
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            "Program:exit"() {
	                tokensAndComments.forEach(function(token, i) {
	
	                    if (!isComma(token)) {
	                        return;
	                    }
	
	                    if (token && token.type === "JSXText") {
	                        return;
	                    }
	
	                    const previousToken = tokensAndComments[i - 1];
	                    const nextToken = tokensAndComments[i + 1];
	
	                    validateCommaItemSpacing({
	                        comma: token,
	                        left: isComma(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
	                        right: isComma(nextToken) ? null : nextToken
	                    }, token);
	                });
	            },
	            ArrayExpression: addNullElementsToIgnoreList,
	            ArrayPattern: addNullElementsToIgnoreList
	
	        };
	
	    }
	};


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Comma style - enforces comma styles of two types: last and first
	 * @author Vignesh Anand aka vegetableman
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent comma style",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        fixable: "code",
	        schema: [
	            {
	                enum: ["first", "last"]
	            },
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "object",
	                        additionalProperties: {
	                            type: "boolean"
	                        }
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const style = context.options[0] || "last",
	            sourceCode = context.getSourceCode();
	        let exceptions = {};
	
	        if (context.options.length === 2 && context.options[1].hasOwnProperty("exceptions")) {
	            exceptions = context.options[1].exceptions;
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Determines if a given token is a comma operator.
	         * @param {ASTNode} token The token to check.
	         * @returns {boolean} True if the token is a comma, false if not.
	         * @private
	         */
	        function isComma(token) {
	            return !!token && (token.type === "Punctuator") && (token.value === ",");
	        }
	
	        /**
	         * Modified text based on the style
	         * @param {string} styleType Style type
	         * @param {string} text Source code text
	         * @returns {string} modified text
	         * @private
	         */
	        function getReplacedText(styleType, text) {
	            switch (styleType) {
	                case "between":
	                    return `,${text.replace("\n", "")}`;
	
	                case "first":
	                    return `${text},`;
	
	                case "last":
	                    return `,${text}`;
	
	                default:
	                    return "";
	            }
	        }
	
	        /**
	         * Determines the fixer function for a given style.
	         * @param {string} styleType comma style
	         * @param {ASTNode} previousItemToken The token to check.
	         * @param {ASTNode} commaToken The token to check.
	         * @param {ASTNode} currentItemToken The token to check.
	         * @returns {Function} Fixer function
	         * @private
	         */
	        function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
	            const text =
	                sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) +
	                sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
	            const range = [previousItemToken.range[1], currentItemToken.range[0]];
	
	            return function(fixer) {
	                return fixer.replaceTextRange(range, getReplacedText(styleType, text));
	            };
	        }
	
	        /**
	         * Validates the spacing around single items in lists.
	         * @param {Token} previousItemToken The last token from the previous item.
	         * @param {Token} commaToken The token representing the comma.
	         * @param {Token} currentItemToken The first token of the current item.
	         * @param {Token} reportItem The item to use when reporting an error.
	         * @returns {void}
	         * @private
	         */
	        function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
	
	            // if single line
	            if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
	                    astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
	
	                // do nothing.
	
	            } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
	                    !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
	
	                // lone comma
	                context.report({
	                    node: reportItem,
	                    loc: {
	                        line: commaToken.loc.end.line,
	                        column: commaToken.loc.start.column
	                    },
	                    message: "Bad line breaking before and after ','.",
	                    fix: getFixerFunction("between", previousItemToken, commaToken, currentItemToken)
	                });
	
	            } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
	
	                context.report({
	                    node: reportItem,
	                    message: "',' should be placed first.",
	                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
	                });
	
	            } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
	
	                context.report({
	                    node: reportItem,
	                    loc: {
	                        line: commaToken.loc.end.line,
	                        column: commaToken.loc.end.column
	                    },
	                    message: "',' should be placed last.",
	                    fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
	                });
	            }
	        }
	
	        /**
	         * Checks the comma placement with regards to a declaration/property/element
	         * @param {ASTNode} node The binary expression node to check
	         * @param {string} property The property of the node containing child nodes.
	         * @private
	         * @returns {void}
	         */
	        function validateComma(node, property) {
	            const items = node[property],
	                arrayLiteral = (node.type === "ArrayExpression");
	
	            if (items.length > 1 || arrayLiteral) {
	
	                // seed as opening [
	                let previousItemToken = sourceCode.getFirstToken(node);
	
	                items.forEach(function(item) {
	                    const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken,
	                        currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken),
	                        reportItem = item || currentItemToken,
	                        tokenBeforeComma = sourceCode.getTokenBefore(commaToken);
	
	                    // Check if previous token is wrapped in parentheses
	                    if (tokenBeforeComma && tokenBeforeComma.value === ")") {
	                        previousItemToken = tokenBeforeComma;
	                    }
	
	                    /*
	                     * This works by comparing three token locations:
	                     * - previousItemToken is the last token of the previous item
	                     * - commaToken is the location of the comma before the current item
	                     * - currentItemToken is the first token of the current item
	                     *
	                     * These values get switched around if item is undefined.
	                     * previousItemToken will refer to the last token not belonging
	                     * to the current item, which could be a comma or an opening
	                     * square bracket. currentItemToken could be a comma.
	                     *
	                     * All comparisons are done based on these tokens directly, so
	                     * they are always valid regardless of an undefined item.
	                     */
	                    if (isComma(commaToken)) {
	                        validateCommaItemSpacing(previousItemToken, commaToken,
	                                currentItemToken, reportItem);
	                    }
	
	                    previousItemToken = item ? sourceCode.getLastToken(item) : previousItemToken;
	                });
	
	                /*
	                 * Special case for array literals that have empty last items, such
	                 * as [ 1, 2, ]. These arrays only have two items show up in the
	                 * AST, so we need to look at the token to verify that there's no
	                 * dangling comma.
	                 */
	                if (arrayLiteral) {
	
	                    const lastToken = sourceCode.getLastToken(node),
	                        nextToLastToken = sourceCode.getTokenBefore(lastToken);
	
	                    if (isComma(nextToLastToken)) {
	                        validateCommaItemSpacing(
	                            sourceCode.getTokenBefore(nextToLastToken),
	                            nextToLastToken,
	                            lastToken,
	                            lastToken
	                        );
	                    }
	                }
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        const nodes = {};
	
	        if (!exceptions.VariableDeclaration) {
	            nodes.VariableDeclaration = function(node) {
	                validateComma(node, "declarations");
	            };
	        }
	        if (!exceptions.ObjectExpression) {
	            nodes.ObjectExpression = function(node) {
	                validateComma(node, "properties");
	            };
	        }
	        if (!exceptions.ArrayExpression) {
	            nodes.ArrayExpression = function(node) {
	                validateComma(node, "elements");
	            };
	        }
	
	        return nodes;
	    }
	};


/***/ },
/* 139 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Counts the cyclomatic complexity of each function of the script. See http://en.wikipedia.org/wiki/Cyclomatic_complexity.
	 * Counts the number of if, conditional, for, whilte, try, switch/case,
	 * @author Patrick Brosset
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum cyclomatic complexity allowed in a program",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            maximum: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const option = context.options[0];
	        let THRESHOLD = 20;
	
	        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
	            THRESHOLD = option.maximum;
	        }
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            THRESHOLD = option.max;
	        }
	        if (typeof option === "number") {
	            THRESHOLD = option;
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        // Using a stack to store complexity (handling nested functions)
	        const fns = [];
	
	        /**
	         * When parsing a new function, store it in our function stack
	         * @returns {void}
	         * @private
	         */
	        function startFunction() {
	            fns.push(1);
	        }
	
	        /**
	         * Evaluate the node at the end of function
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function endFunction(node) {
	            const complexity = fns.pop();
	            let name = "anonymous";
	
	            if (node.id) {
	                name = node.id.name;
	            } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property") {
	                name = node.parent.key.name;
	            }
	
	            if (complexity > THRESHOLD) {
	                context.report(node, "Function '{{name}}' has a complexity of {{complexity}}.", { name, complexity });
	            }
	        }
	
	        /**
	         * Increase the complexity of the function in context
	         * @returns {void}
	         * @private
	         */
	        function increaseComplexity() {
	            if (fns.length) {
	                fns[fns.length - 1]++;
	            }
	        }
	
	        /**
	         * Increase the switch complexity in context
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function increaseSwitchComplexity(node) {
	
	            // Avoiding `default`
	            if (node.test) {
	                increaseComplexity(node);
	            }
	        }
	
	        /**
	         * Increase the logical path complexity in context
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function increaseLogicalComplexity(node) {
	
	            // Avoiding &&
	            if (node.operator === "||") {
	                increaseComplexity(node);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            FunctionDeclaration: startFunction,
	            FunctionExpression: startFunction,
	            ArrowFunctionExpression: startFunction,
	            "FunctionDeclaration:exit": endFunction,
	            "FunctionExpression:exit": endFunction,
	            "ArrowFunctionExpression:exit": endFunction,
	
	            CatchClause: increaseComplexity,
	            ConditionalExpression: increaseComplexity,
	            LogicalExpression: increaseLogicalComplexity,
	            ForStatement: increaseComplexity,
	            ForInStatement: increaseComplexity,
	            ForOfStatement: increaseComplexity,
	            IfStatement: increaseComplexity,
	            SwitchCase: increaseSwitchComplexity,
	            WhileStatement: increaseComplexity,
	            DoWhileStatement: increaseComplexity
	        };
	
	    }
	};


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside computed properties.
	 * @author Jamund Ferguson
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing inside computed property brackets",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const propertyNameMustBeSpaced = context.options[0] === "always"; // default is "never"
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	        * Reports that there shouldn't be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @param {Token} tokenAfter - The token after `token`.
	        * @returns {void}
	        */
	        function reportNoBeginningSpace(node, token, tokenAfter) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space after '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there shouldn't be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @param {Token} tokenBefore - The token before `token`.
	        * @returns {void}
	        */
	        function reportNoEndingSpace(node, token, tokenBefore) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space before '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredBeginningSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required after '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextAfter(token, " ");
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredEndingSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required before '{{tokenValue}}'.",
	                data: {
	                    tokenValue: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextBefore(token, " ");
	                }
	            });
	        }
	
	        /**
	         * Returns a function that checks the spacing of a node on the property name
	         * that was passed in.
	         * @param {string} propertyName The property on the node to check for spacing
	         * @returns {Function} A function that will check spacing on a node
	         */
	        function checkSpacing(propertyName) {
	            return function(node) {
	                if (!node.computed) {
	                    return;
	                }
	
	                const property = node[propertyName];
	
	                const before = sourceCode.getTokenBefore(property),
	                    first = sourceCode.getFirstToken(property),
	                    last = sourceCode.getLastToken(property),
	                    after = sourceCode.getTokenAfter(property);
	
	                if (astUtils.isTokenOnSameLine(before, first)) {
	                    if (propertyNameMustBeSpaced) {
	                        if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
	                            reportRequiredBeginningSpace(node, before);
	                        }
	                    } else {
	                        if (sourceCode.isSpaceBetweenTokens(before, first)) {
	                            reportNoBeginningSpace(node, before, first);
	                        }
	                    }
	                }
	
	                if (astUtils.isTokenOnSameLine(last, after)) {
	                    if (propertyNameMustBeSpaced) {
	                        if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
	                            reportRequiredEndingSpace(node, after);
	                        }
	                    } else {
	                        if (sourceCode.isSpaceBetweenTokens(last, after)) {
	                            reportNoEndingSpace(node, after, last);
	                        }
	                    }
	                }
	            };
	        }
	
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Property: checkSpacing("key"),
	            MemberExpression: checkSpacing("property")
	        };
	
	    }
	};


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag consistent return values
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is an `Identifier` node which was named a given name.
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - An expected name of the node.
	 * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.
	 */
	function isIdentifier(node, name) {
	    return node.type === "Identifier" && node.name === name;
	}
	
	/**
	 * Checks whether or not a given code path segment is unreachable.
	 * @param {CodePathSegment} segment - A CodePathSegment to check.
	 * @returns {boolean} `true` if the segment is unreachable.
	 */
	function isUnreachable(segment) {
	    return !segment.reachable;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `return` statements to either always or never specify values",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                treatUndefinedAsUnspecified: {
	                    type: "boolean"
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
	        let funcInfo = null;
	
	        /**
	         * Checks whether of not the implicit returning is consistent if the last
	         * code path segment is reachable.
	         *
	         * @param {ASTNode} node - A program/function node to check.
	         * @returns {void}
	         */
	        function checkLastSegment(node) {
	            let loc, type;
	
	            /*
	             * Skip if it expected no return value or unreachable.
	             * When unreachable, all paths are returned or thrown.
	             */
	            if (!funcInfo.hasReturnValue ||
	                funcInfo.codePath.currentSegments.every(isUnreachable) ||
	                astUtils.isES5Constructor(node)
	            ) {
	                return;
	            }
	
	            // Adjust a location and a message.
	            if (node.type === "Program") {
	
	                // The head of program.
	                loc = {line: 1, column: 0};
	                type = "program";
	            } else if (node.type === "ArrowFunctionExpression") {
	
	                // `=>` token
	                loc = context.getSourceCode().getTokenBefore(node.body).loc.start;
	                type = "function";
	            } else if (
	                node.parent.type === "MethodDefinition" ||
	                (node.parent.type === "Property" && node.parent.method)
	            ) {
	
	                // Method name.
	                loc = node.parent.key.loc.start;
	                type = "method";
	            } else {
	
	                // Function name or `function` keyword.
	                loc = (node.id || node).loc.start;
	                type = "function";
	            }
	
	            // Reports.
	            context.report({
	                node,
	                loc,
	                message: "Expected to return a value at the end of this {{type}}.",
	                data: {type}
	            });
	        }
	
	        return {
	
	            // Initializes/Disposes state of each code path.
	            onCodePathStart(codePath) {
	                funcInfo = {
	                    upper: funcInfo,
	                    codePath,
	                    hasReturn: false,
	                    hasReturnValue: false,
	                    message: ""
	                };
	            },
	            onCodePathEnd() {
	                funcInfo = funcInfo.upper;
	            },
	
	            // Reports a given return statement if it's inconsistent.
	            ReturnStatement(node) {
	                const argument = node.argument;
	                let hasReturnValue = Boolean(argument);
	
	                if (treatUndefinedAsUnspecified && hasReturnValue) {
	                    hasReturnValue = !isIdentifier(argument, "undefined") && argument.operator !== "void";
	                }
	
	                if (!funcInfo.hasReturn) {
	                    funcInfo.hasReturn = true;
	                    funcInfo.hasReturnValue = hasReturnValue;
	                    funcInfo.message = "Expected {{which}} return value.";
	                    funcInfo.data = {
	                        which: hasReturnValue ? "a" : "no"
	                    };
	                } else if (funcInfo.hasReturnValue !== hasReturnValue) {
	                    context.report({
	                        node,
	                        message: funcInfo.message,
	                        data: funcInfo.data
	                    });
	                }
	            },
	
	            // Reports a given program/function if the implicit returning is not consistent.
	            "Program:exit": checkLastSegment,
	            "FunctionDeclaration:exit": checkLastSegment,
	            "FunctionExpression:exit": checkLastSegment,
	            "ArrowFunctionExpression:exit": checkLastSegment
	        };
	    }
	};


/***/ },
/* 142 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce consistent naming of "this" context variables
	 * @author Raphael Pigulla
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent naming when capturing the current execution context",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                type: "string",
	                minLength: 1
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	        let aliases = [];
	
	        if (context.options.length === 0) {
	            aliases.push("that");
	        } else {
	            aliases = context.options;
	        }
	
	        /**
	         * Reports that a variable declarator or assignment expression is assigning
	         * a non-'this' value to the specified alias.
	         * @param {ASTNode} node - The assigning node.
	         * @param {string} alias - the name of the alias that was incorrectly used.
	         * @returns {void}
	         */
	        function reportBadAssignment(node, alias) {
	            context.report(node,
	                "Designated alias '{{alias}}' is not assigned to 'this'.",
	                { alias });
	        }
	
	        /**
	         * Checks that an assignment to an identifier only assigns 'this' to the
	         * appropriate alias, and the alias is only assigned to 'this'.
	         * @param {ASTNode} node - The assigning node.
	         * @param {Identifier} name - The name of the variable assigned to.
	         * @param {Expression} value - The value of the assignment.
	         * @returns {void}
	         */
	        function checkAssignment(node, name, value) {
	            const isThis = value.type === "ThisExpression";
	
	            if (aliases.indexOf(name) !== -1) {
	                if (!isThis || node.operator && node.operator !== "=") {
	                    reportBadAssignment(node, name);
	                }
	            } else if (isThis) {
	                context.report(node,
	                    "Unexpected alias '{{name}}' for 'this'.", { name });
	            }
	        }
	
	        /**
	         * Ensures that a variable declaration of the alias in a program or function
	         * is assigned to the correct value.
	         * @param {string} alias alias the check the assignment of.
	         * @param {Object} scope scope of the current code we are checking.
	         * @private
	         * @returns {void}
	         */
	        function checkWasAssigned(alias, scope) {
	            const variable = scope.set.get(alias);
	
	            if (!variable) {
	                return;
	            }
	
	            if (variable.defs.some(function(def) {
	                return def.node.type === "VariableDeclarator" &&
	                def.node.init !== null;
	            })) {
	                return;
	            }
	
	            // The alias has been declared and not assigned: check it was
	            // assigned later in the same scope.
	            if (!variable.references.some(function(reference) {
	                const write = reference.writeExpr;
	
	                return (
	                    reference.from === scope &&
	                    write && write.type === "ThisExpression" &&
	                    write.parent.operator === "="
	                );
	            })) {
	                variable.defs.map(function(def) {
	                    return def.node;
	                }).forEach(function(node) {
	                    reportBadAssignment(node, alias);
	                });
	            }
	        }
	
	        /**
	         * Check each alias to ensure that is was assinged to the correct value.
	         * @returns {void}
	         */
	        function ensureWasAssigned() {
	            const scope = context.getScope();
	
	            aliases.forEach(function(alias) {
	                checkWasAssigned(alias, scope);
	            });
	        }
	
	        return {
	            "Program:exit": ensureWasAssigned,
	            "FunctionExpression:exit": ensureWasAssigned,
	            "FunctionDeclaration:exit": ensureWasAssigned,
	
	            VariableDeclarator(node) {
	                const id = node.id;
	                const isDestructuring =
	                    id.type === "ArrayPattern" || id.type === "ObjectPattern";
	
	                if (node.init !== null && !isDestructuring) {
	                    checkAssignment(node, id.name, node.init);
	                }
	            },
	
	            AssignmentExpression(node) {
	                if (node.left.type === "Identifier") {
	                    checkAssignment(node, node.left.name, node.right);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to verify `super()` callings in constructor.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether a given code path segment is reachable or not.
	 *
	 * @param {CodePathSegment} segment - A code path segment to check.
	 * @returns {boolean} `true` if the segment is reachable.
	 */
	function isReachable(segment) {
	    return segment.reachable;
	}
	
	/**
	 * Checks whether or not a given node is a constructor.
	 * @param {ASTNode} node - A node to check. This node type is one of
	 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
	 *   `ArrowFunctionExpression`.
	 * @returns {boolean} `true` if the node is a constructor.
	 */
	function isConstructorFunction(node) {
	    return (
	        node.type === "FunctionExpression" &&
	        node.parent.type === "MethodDefinition" &&
	        node.parent.kind === "constructor"
	    );
	}
	
	/**
	 * Checks whether a given node can be a constructor or not.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node can be a constructor.
	 */
	function isPossibleConstructor(node) {
	    if (!node) {
	        return false;
	    }
	
	    switch (node.type) {
	        case "ClassExpression":
	        case "FunctionExpression":
	        case "ThisExpression":
	        case "MemberExpression":
	        case "CallExpression":
	        case "NewExpression":
	        case "YieldExpression":
	        case "TaggedTemplateExpression":
	        case "MetaProperty":
	            return true;
	
	        case "Identifier":
	            return node.name !== "undefined";
	
	        case "AssignmentExpression":
	            return isPossibleConstructor(node.right);
	
	        case "LogicalExpression":
	            return (
	                isPossibleConstructor(node.left) ||
	                isPossibleConstructor(node.right)
	            );
	
	        case "ConditionalExpression":
	            return (
	                isPossibleConstructor(node.alternate) ||
	                isPossibleConstructor(node.consequent)
	            );
	
	        case "SequenceExpression": {
	            const lastExpression = node.expressions[node.expressions.length - 1];
	
	            return isPossibleConstructor(lastExpression);
	        }
	
	        default:
	            return false;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `super()` calls in constructors",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /*
	         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}
	         * Information for each constructor.
	         * - upper:      Information of the upper constructor.
	         * - hasExtends: A flag which shows whether own class has a valid `extends`
	         *               part.
	         * - scope:      The scope of own class.
	         * - codePath:   The code path object of the constructor.
	         */
	        let funcInfo = null;
	
	        /*
	         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}
	         * Information for each code path segment.
	         * - calledInSomePaths:  A flag of be called `super()` in some code paths.
	         * - calledInEveryPaths: A flag of be called `super()` in all code paths.
	         * - validNodes:
	         */
	        let segInfoMap = Object.create(null);
	
	        /**
	         * Gets the flag which shows `super()` is called in some paths.
	         * @param {CodePathSegment} segment - A code path segment to get.
	         * @returns {boolean} The flag which shows `super()` is called in some paths
	         */
	        function isCalledInSomePath(segment) {
	            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
	        }
	
	        /**
	         * Gets the flag which shows `super()` is called in all paths.
	         * @param {CodePathSegment} segment - A code path segment to get.
	         * @returns {boolean} The flag which shows `super()` is called in all paths.
	         */
	        function isCalledInEveryPath(segment) {
	
	            /*
	             * If specific segment is the looped segment of the current segment,
	             * skip the segment.
	             * If not skipped, this never becomes true after a loop.
	             */
	            if (segment.nextSegments.length === 1 &&
	                segment.nextSegments[0].isLoopedPrevSegment(segment)
	            ) {
	                return true;
	            }
	            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
	        }
	
	        return {
	
	            /**
	             * Stacks a constructor information.
	             * @param {CodePath} codePath - A code path which was started.
	             * @param {ASTNode} node - The current node.
	             * @returns {void}
	             */
	            onCodePathStart(codePath, node) {
	                if (isConstructorFunction(node)) {
	
	                    // Class > ClassBody > MethodDefinition > FunctionExpression
	                    const classNode = node.parent.parent.parent;
	                    const superClass = classNode.superClass;
	
	                    funcInfo = {
	                        upper: funcInfo,
	                        isConstructor: true,
	                        hasExtends: Boolean(superClass),
	                        superIsConstructor: isPossibleConstructor(superClass),
	                        codePath
	                    };
	                } else {
	                    funcInfo = {
	                        upper: funcInfo,
	                        isConstructor: false,
	                        hasExtends: false,
	                        superIsConstructor: false,
	                        codePath
	                    };
	                }
	            },
	
	            /**
	             * Pops a constructor information.
	             * And reports if `super()` lacked.
	             * @param {CodePath} codePath - A code path which was ended.
	             * @param {ASTNode} node - The current node.
	             * @returns {void}
	             */
	            onCodePathEnd(codePath, node) {
	                const hasExtends = funcInfo.hasExtends;
	
	                // Pop.
	                funcInfo = funcInfo.upper;
	
	                if (!hasExtends) {
	                    return;
	                }
	
	                // Reports if `super()` lacked.
	                const segments = codePath.returnedSegments;
	                const calledInEveryPaths = segments.every(isCalledInEveryPath);
	                const calledInSomePaths = segments.some(isCalledInSomePath);
	
	                if (!calledInEveryPaths) {
	                    context.report({
	                        message: calledInSomePaths ?
	                            "Lacked a call of 'super()' in some code paths." :
	                            "Expected to call 'super()'.",
	                        node: node.parent
	                    });
	                }
	            },
	
	            /**
	             * Initialize information of a given code path segment.
	             * @param {CodePathSegment} segment - A code path segment to initialize.
	             * @returns {void}
	             */
	            onCodePathSegmentStart(segment) {
	                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
	                    return;
	                }
	
	                // Initialize info.
	                const info = segInfoMap[segment.id] = {
	                    calledInSomePaths: false,
	                    calledInEveryPaths: false,
	                    validNodes: []
	                };
	
	                // When there are previous segments, aggregates these.
	                const prevSegments = segment.prevSegments;
	
	                if (prevSegments.length > 0) {
	                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
	                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
	                }
	            },
	
	            /**
	             * Update information of the code path segment when a code path was
	             * looped.
	             * @param {CodePathSegment} fromSegment - The code path segment of the
	             *      end of a loop.
	             * @param {CodePathSegment} toSegment - A code path segment of the head
	             *      of a loop.
	             * @returns {void}
	             */
	            onCodePathSegmentLoop(fromSegment, toSegment) {
	                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
	                    return;
	                }
	
	                // Update information inside of the loop.
	                const isRealLoop = toSegment.prevSegments.length >= 2;
	
	                funcInfo.codePath.traverseSegments(
	                    {first: toSegment, last: fromSegment},
	                    function(segment) {
	                        const info = segInfoMap[segment.id];
	                        const prevSegments = segment.prevSegments;
	
	                        // Updates flags.
	                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);
	                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
	
	                        // If flags become true anew, reports the valid nodes.
	                        if (info.calledInSomePaths || isRealLoop) {
	                            const nodes = info.validNodes;
	
	                            info.validNodes = [];
	
	                            for (let i = 0; i < nodes.length; ++i) {
	                                const node = nodes[i];
	
	                                context.report({
	                                    message: "Unexpected duplicate 'super()'.",
	                                    node
	                                });
	                            }
	                        }
	                    }
	                );
	            },
	
	            /**
	             * Checks for a call of `super()`.
	             * @param {ASTNode} node - A CallExpression node to check.
	             * @returns {void}
	             */
	            "CallExpression:exit"(node) {
	                if (!(funcInfo && funcInfo.isConstructor)) {
	                    return;
	                }
	
	                // Skips except `super()`.
	                if (node.callee.type !== "Super") {
	                    return;
	                }
	
	                // Reports if needed.
	                if (funcInfo.hasExtends) {
	                    const segments = funcInfo.codePath.currentSegments;
	                    let duplicate = false;
	                    let info = null;
	
	                    for (let i = 0; i < segments.length; ++i) {
	                        const segment = segments[i];
	
	                        if (segment.reachable) {
	                            info = segInfoMap[segment.id];
	
	                            duplicate = duplicate || info.calledInSomePaths;
	                            info.calledInSomePaths = info.calledInEveryPaths = true;
	                        }
	                    }
	
	                    if (info) {
	                        if (duplicate) {
	                            context.report({
	                                message: "Unexpected duplicate 'super()'.",
	                                node
	                            });
	                        } else if (!funcInfo.superIsConstructor) {
	                            context.report({
	                                message: "Unexpected 'super()' because 'super' is not a constructor.",
	                                node
	                            });
	                        } else {
	                            info.validNodes.push(node);
	                        }
	                    }
	                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
	                    context.report({
	                        message: "Unexpected 'super()'.",
	                        node
	                    });
	                }
	            },
	
	            /**
	             * Set the mark to the returned path as `super()` was called.
	             * @param {ASTNode} node - A ReturnStatement node to check.
	             * @returns {void}
	             */
	            ReturnStatement(node) {
	                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
	                    return;
	                }
	
	                // Skips if no argument.
	                if (!node.argument) {
	                    return;
	                }
	
	                // Returning argument is a substitute of 'super()'.
	                const segments = funcInfo.codePath.currentSegments;
	
	                for (let i = 0; i < segments.length; ++i) {
	                    const segment = segments[i];
	
	                    if (segment.reachable) {
	                        const info = segInfoMap[segment.id];
	
	                        info.calledInSomePaths = info.calledInEveryPaths = true;
	                    }
	                }
	            },
	
	            /**
	             * Resets state.
	             * @returns {void}
	             */
	            "Program:exit"() {
	                segInfoMap = Object.create(null);
	            }
	        };
	    }
	};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag statements without curly braces
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	const esUtils = __webpack_require__(110);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent brace style for all control statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["all"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["multi", "multi-line", "multi-or-nest"]
	                        },
	                        {
	                            enum: ["consistent"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        },
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const multiOnly = (context.options[0] === "multi");
	        const multiLine = (context.options[0] === "multi-line");
	        const multiOrNest = (context.options[0] === "multi-or-nest");
	        const consistent = (context.options[1] === "consistent");
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Determines if a given node is a one-liner that's on the same line as it's preceding code.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.
	         * @private
	         */
	        function isCollapsedOneLiner(node) {
	            const before = sourceCode.getTokenBefore(node),
	                last = sourceCode.getLastToken(node);
	
	            return before.loc.start.line === last.loc.end.line;
	        }
	
	        /**
	         * Determines if a given node is a one-liner.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node is a one-liner.
	         * @private
	         */
	        function isOneLiner(node) {
	            const first = sourceCode.getFirstToken(node),
	                last = sourceCode.getLastToken(node);
	
	            return first.loc.start.line === last.loc.end.line;
	        }
	
	        /**
	         * Gets the `else` keyword token of a given `IfStatement` node.
	         * @param {ASTNode} node - A `IfStatement` node to get.
	         * @returns {Token} The `else` keyword token.
	         */
	        function getElseKeyword(node) {
	            let token = sourceCode.getTokenAfter(node.consequent);
	
	            while (token.type !== "Keyword" || token.value !== "else") {
	                token = sourceCode.getTokenAfter(token);
	            }
	
	            return token;
	        }
	
	        /**
	         * Checks a given IfStatement node requires braces of the consequent chunk.
	         * This returns `true` when below:
	         *
	         * 1. The given node has the `alternate` node.
	         * 2. There is a `IfStatement` which doesn't have `alternate` node in the
	         *    trailing statement chain of the `consequent` node.
	         *
	         * @param {ASTNode} node - A IfStatement node to check.
	         * @returns {boolean} `true` if the node requires braces of the consequent chunk.
	         */
	        function requiresBraceOfConsequent(node) {
	            if (node.alternate && node.consequent.type === "BlockStatement") {
	                if (node.consequent.body.length >= 2) {
	                    return true;
	                }
	
	                node = node.consequent.body[0];
	                while (node) {
	                    if (node.type === "IfStatement" && !node.alternate) {
	                        return true;
	                    }
	                    node = astUtils.getTrailingStatement(node);
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Reports "Expected { after ..." error
	         * @param {ASTNode} node The node to report.
	         * @param {ASTNode} bodyNode The body node that is incorrectly missing curly brackets
	         * @param {string} name The name to report.
	         * @param {string} suffix Additional string to add to the end of a report.
	         * @returns {void}
	         * @private
	         */
	        function reportExpectedBraceError(node, bodyNode, name, suffix) {
	            context.report({
	                node,
	                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
	                message: "Expected { after '{{name}}'{{suffix}}.",
	                data: {
	                    name,
	                    suffix: (suffix ? ` ${suffix}` : "")
	                },
	                fix: fixer => fixer.replaceText(bodyNode, `{${sourceCode.getText(bodyNode)}}`)
	            });
	        }
	
	        /**
	        * Determines if a semicolon needs to be inserted after removing a set of curly brackets, in order to avoid a SyntaxError.
	        * @param {Token} closingBracket The } token
	        * @returns {boolean} `true` if a semicolon needs to be inserted after the last statement in the block.
	        */
	        function needsSemicolon(closingBracket) {
	            const tokenBefore = sourceCode.getTokenBefore(closingBracket);
	            const tokenAfter = sourceCode.getTokenAfter(closingBracket);
	            const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);
	
	            if (tokenBefore.value === ";") {
	
	                // If the last statement already has a semicolon, don't add another one.
	                return false;
	            }
	
	            if (!tokenAfter) {
	
	                // If there are no statements after this block, there is no need to add a semicolon.
	                return false;
	            }
	
	            if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
	
	                // If the last node surrounded by curly brackets is a BlockStatement (other than a FunctionExpression or an ArrowFunctionExpression),
	                // don't insert a semicolon. Otherwise, the semicolon would be parsed as a separate statement, which would cause
	                // a SyntaxError if it was followed by `else`.
	                return false;
	            }
	
	            if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
	
	                // If the next token is on the same line, insert a semicolon.
	                return true;
	            }
	
	            if (/^[([/`+-]/.test(tokenAfter.value)) {
	
	                // If the next token starts with a character that would disrupt ASI, insert a semicolon.
	                return true;
	            }
	
	            if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
	
	                // If the last token is ++ or --, insert a semicolon to avoid disrupting ASI.
	                return true;
	            }
	
	            // Otherwise, do not insert a semicolon.
	            return false;
	        }
	
	        /**
	         * Reports "Unnecessary { after ..." error
	         * @param {ASTNode} node The node to report.
	         * @param {ASTNode} bodyNode The block statement that is incorrectly surrounded by parens
	         * @param {string} name The name to report.
	         * @param {string} suffix Additional string to add to the end of a report.
	         * @returns {void}
	         * @private
	         */
	        function reportUnnecessaryBraceError(node, bodyNode, name, suffix) {
	            context.report({
	                node,
	                loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
	                message: "Unnecessary { after '{{name}}'{{suffix}}.",
	                data: {
	                    name,
	                    suffix: (suffix ? ` ${suffix}` : "")
	                },
	                fix(fixer) {
	
	                    // `do while` expressions sometimes need a space to be inserted after `do`.
	                    // e.g. `do{foo()} while (bar)` should be corrected to `do foo() while (bar)`
	                    const needsPrecedingSpace = node.type === "DoWhileStatement" &&
	                        sourceCode.getTokenBefore(bodyNode).end === bodyNode.start &&
	                        esUtils.code.isIdentifierPartES6(sourceCode.getText(bodyNode).charCodeAt(1));
	
	                    const openingBracket = sourceCode.getFirstToken(bodyNode);
	                    const closingBracket = sourceCode.getLastToken(bodyNode);
	                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);
	
	                    if (needsSemicolon(closingBracket)) {
	
	                        /*
	                         * If removing braces would cause a SyntaxError due to multiple statements on the same line (or
	                         * change the semantics of the code due to ASI), don't perform a fix.
	                         */
	                        return null;
	                    }
	
	                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) +
	                        sourceCode.getText(lastTokenInBlock) +
	                        sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
	
	                    return fixer.replaceText(bodyNode, (needsPrecedingSpace ? " " : "") + resultingBodyText);
	                }
	            });
	        }
	
	        /**
	         * Prepares to check the body of a node to see if it's a block statement.
	         * @param {ASTNode} node The node to report if there's a problem.
	         * @param {ASTNode} body The body node to check for blocks.
	         * @param {string} name The name to report if there's a problem.
	         * @param {string} suffix Additional string to add to the end of a report.
	         * @returns {Object} a prepared check object, with "actual", "expected", "check" properties.
	         *   "actual" will be `true` or `false` whether the body is already a block statement.
	         *   "expected" will be `true` or `false` if the body should be a block statement or not, or
	         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change
	         *   the final behavior of "check".
	         *   "check" will be a function reporting appropriate problems depending on the other
	         *   properties.
	         */
	        function prepareCheck(node, body, name, suffix) {
	            const hasBlock = (body.type === "BlockStatement");
	            let expected = null;
	
	            if (node.type === "IfStatement" && node.consequent === body && requiresBraceOfConsequent(node)) {
	                expected = true;
	            } else if (multiOnly) {
	                if (hasBlock && body.body.length === 1) {
	                    expected = false;
	                }
	            } else if (multiLine) {
	                if (!isCollapsedOneLiner(body)) {
	                    expected = true;
	                }
	            } else if (multiOrNest) {
	                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {
	                    expected = false;
	                } else if (!isOneLiner(body)) {
	                    expected = true;
	                }
	            } else {
	                expected = true;
	            }
	
	            return {
	                actual: hasBlock,
	                expected,
	                check() {
	                    if (this.expected !== null && this.expected !== this.actual) {
	                        if (this.expected) {
	                            reportExpectedBraceError(node, body, name, suffix);
	                        } else {
	                            reportUnnecessaryBraceError(node, body, name, suffix);
	                        }
	                    }
	                }
	            };
	        }
	
	        /**
	         * Prepares to check the bodies of a "if", "else if" and "else" chain.
	         * @param {ASTNode} node The first IfStatement node of the chain.
	         * @returns {Object[]} prepared checks for each body of the chain. See `prepareCheck` for more
	         *   information.
	         */
	        function prepareIfChecks(node) {
	            const preparedChecks = [];
	
	            do {
	                preparedChecks.push(prepareCheck(node, node.consequent, "if", "condition"));
	                if (node.alternate && node.alternate.type !== "IfStatement") {
	                    preparedChecks.push(prepareCheck(node, node.alternate, "else"));
	                    break;
	                }
	                node = node.alternate;
	            } while (node);
	
	            if (consistent) {
	
	                /*
	                 * If any node should have or already have braces, make sure they
	                 * all have braces.
	                 * If all nodes shouldn't have braces, make sure they don't.
	                 */
	                const expected = preparedChecks.some(function(preparedCheck) {
	                    if (preparedCheck.expected !== null) {
	                        return preparedCheck.expected;
	                    }
	                    return preparedCheck.actual;
	                });
	
	                preparedChecks.forEach(function(preparedCheck) {
	                    preparedCheck.expected = expected;
	                });
	            }
	
	            return preparedChecks;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            IfStatement(node) {
	                if (node.parent.type !== "IfStatement") {
	                    prepareIfChecks(node).forEach(function(preparedCheck) {
	                        preparedCheck.check();
	                    });
	                }
	            },
	
	            WhileStatement(node) {
	                prepareCheck(node, node.body, "while", "condition").check();
	            },
	
	            DoWhileStatement(node) {
	                prepareCheck(node, node.body, "do").check();
	            },
	
	            ForStatement(node) {
	                prepareCheck(node, node.body, "for", "condition").check();
	            },
	
	            ForInStatement(node) {
	                prepareCheck(node, node.body, "for-in").check();
	            },
	
	            ForOfStatement(node) {
	                prepareCheck(node, node.body, "for-of").check();
	            }
	        };
	    }
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	/**
	 * @fileoverview require default case in switch statements
	 * @author Aliaksei Shytkin
	 */
	"use strict";
	
	const DEFAULT_COMMENT_PATTERN = /^no default$/;
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `default` cases in `switch` statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                commentPattern: {
	                    type: "string"
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const commentPattern = options.commentPattern ?
	            new RegExp(options.commentPattern) :
	            DEFAULT_COMMENT_PATTERN;
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Shortcut to get last element of array
	         * @param  {*[]} collection Array
	         * @returns {*} Last element
	         */
	        function last(collection) {
	            return collection[collection.length - 1];
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            SwitchStatement(node) {
	
	                if (!node.cases.length) {
	
	                    /*
	                     * skip check of empty switch because there is no easy way
	                     * to extract comments inside it now
	                     */
	                    return;
	                }
	
	                const hasDefault = node.cases.some(function(v) {
	                    return v.test === null;
	                });
	
	                if (!hasDefault) {
	
	                    let comment;
	
	                    const lastCase = last(node.cases);
	                    const comments = sourceCode.getComments(lastCase).trailing;
	
	                    if (comments.length) {
	                        comment = last(comments);
	                    }
	
	                    if (!comment || !commentPattern.test(comment.value.trim())) {
	                        context.report(node, "Expected a default case.");
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates newlines before and after dots
	 * @author Greg Cochard
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent newlines before and after dots",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["object", "property"]
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const config = context.options[0];
	
	        // default to onObject if no preference is passed
	        const onObject = config === "object" || !config;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Reports if the dot between object and property is on the correct loccation.
	         * @param {ASTNode} obj The object owning the property.
	         * @param {ASTNode} prop The property of the object.
	         * @param {ASTNode} node The corresponding node of the token.
	         * @returns {void}
	         */
	        function checkDotLocation(obj, prop, node) {
	            const dot = sourceCode.getTokenBefore(prop);
	            const textBeforeDot = sourceCode.getText().slice(obj.range[1], dot.range[0]);
	            const textAfterDot = sourceCode.getText().slice(dot.range[1], prop.range[0]);
	
	            if (dot.type === "Punctuator" && dot.value === ".") {
	                if (onObject) {
	                    if (!astUtils.isTokenOnSameLine(obj, dot)) {
	                        const neededTextAfterObj = astUtils.isDecimalInteger(obj) ? " " : "";
	
	                        context.report({
	                            node,
	                            loc: dot.loc.start,
	                            message: "Expected dot to be on same line as object.",
	                            fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${neededTextAfterObj}.${textBeforeDot}${textAfterDot}`)
	                        });
	                    }
	                } else if (!astUtils.isTokenOnSameLine(dot, prop)) {
	                    context.report({
	                        node,
	                        loc: dot.loc.start,
	                        message: "Expected dot to be on same line as property.",
	                        fix: fixer => fixer.replaceTextRange([obj.range[1], prop.range[0]], `${textBeforeDot}${textAfterDot}.`)
	                    });
	                }
	            }
	        }
	
	        /**
	         * Checks the spacing of the dot within a member expression.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         */
	        function checkNode(node) {
	            checkDotLocation(node.object, node.property, node);
	        }
	
	        return {
	            MemberExpression: checkNode
	        };
	    }
	};


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to warn about using dot notation instead of square bracket notation when possible.
	 * @author Josh Perez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
	const keywords = __webpack_require__(148);
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce dot notation whenever possible",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowKeywords: {
	                        type: "boolean"
	                    },
	                    allowPattern: {
	                        type: "string"
	                    }
	                },
	                additionalProperties: false
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const allowKeywords = options.allowKeywords === void 0 || !!options.allowKeywords;
	        const sourceCode = context.getSourceCode();
	
	        let allowPattern;
	
	        if (options.allowPattern) {
	            allowPattern = new RegExp(options.allowPattern);
	        }
	
	        return {
	            MemberExpression(node) {
	                if (
	                    node.computed &&
	                    node.property.type === "Literal" &&
	                    validIdentifier.test(node.property.value) &&
	                    (allowKeywords || keywords.indexOf(String(node.property.value)) === -1)
	                ) {
	                    if (!(allowPattern && allowPattern.test(node.property.value))) {
	                        context.report({
	                            node: node.property,
	                            message: "[{{propertyValue}}] is better written in dot notation.",
	                            data: {
	                                propertyValue: JSON.stringify(node.property.value)
	                            },
	                            fix(fixer) {
	                                const leftBracket = sourceCode.getTokenBefore(node.property);
	                                const rightBracket = sourceCode.getTokenAfter(node.property);
	                                const textBeforeProperty = sourceCode.text.slice(leftBracket.range[1], node.property.range[0]);
	                                const textAfterProperty = sourceCode.text.slice(node.property.range[1], rightBracket.range[0]);
	
	                                if (textBeforeProperty.trim() || textAfterProperty.trim()) {
	
	                                    // Don't perform any fixes if there are comments inside the brackets.
	                                    return null;
	                                }
	
	                                return fixer.replaceTextRange(
	                                    [leftBracket.range[0], rightBracket.range[1]],
	                                    `.${node.property.value}`
	                                );
	                            }
	                        });
	                    }
	                }
	                if (
	                    !allowKeywords &&
	                    !node.computed &&
	                    keywords.indexOf(String(node.property.name)) !== -1
	                ) {
	                    context.report({
	                        node: node.property,
	                        message: ".{{propertyName}} is a syntax error.",
	                        data: {
	                            propertyName: node.property.name
	                        },
	                        fix(fixer) {
	                            const dot = sourceCode.getTokenBefore(node.property);
	                            const textAfterDot = sourceCode.text.slice(dot.range[1], node.property.range[0]);
	
	                            if (textAfterDot.trim()) {
	
	                                // Don't perform any fixes if there are comments between the dot and the property name.
	                                return null;
	                            }
	
	                            return fixer.replaceTextRange(
	                                [dot.range[0], node.property.range[1]],
	                                `[${textAfterDot}"${node.property.name}"]`
	                            );
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 148 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A shared list of ES3 keywords.
	 * @author Josh Perez
	 */
	"use strict";
	
	module.exports = [
	    "abstract",
	    "boolean",
	    "break",
	    "byte",
	    "case",
	    "catch",
	    "char",
	    "class",
	    "const",
	    "continue",
	    "debugger",
	    "default",
	    "delete",
	    "do",
	    "double",
	    "else",
	    "enum",
	    "export",
	    "extends",
	    "false",
	    "final",
	    "finally",
	    "float",
	    "for",
	    "function",
	    "goto",
	    "if",
	    "implements",
	    "import",
	    "in",
	    "instanceof",
	    "int",
	    "interface",
	    "long",
	    "native",
	    "new",
	    "null",
	    "package",
	    "private",
	    "protected",
	    "public",
	    "return",
	    "short",
	    "static",
	    "super",
	    "switch",
	    "synchronized",
	    "this",
	    "throw",
	    "throws",
	    "transient",
	    "true",
	    "try",
	    "typeof",
	    "var",
	    "void",
	    "volatile",
	    "while",
	    "with"
	];


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Require or disallow newline at the end of files
	 * @author Nodeca Team <https://github.com/nodeca>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow newline at the end of files",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        fixable: "whitespace",
	        schema: [
	            {
	                enum: ["always", "never", "unix", "windows"]
	            }
	        ]
	    },
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: function checkBadEOF(node) {
	                const sourceCode = context.getSourceCode(),
	                    src = sourceCode.getText(),
	                    location = {
	                        column: lodash.last(sourceCode.lines).length,
	                        line: sourceCode.lines.length
	                    },
	                    LF = "\n",
	                    CRLF = `\r${LF}`,
	                    endsWithNewline = lodash.endsWith(src, LF);
	
	                let mode = context.options[0] || "always",
	                    appendCRLF = false;
	
	                if (mode === "unix") {
	
	                    // `"unix"` should behave exactly as `"always"`
	                    mode = "always";
	                }
	                if (mode === "windows") {
	
	                    // `"windows"` should behave exactly as `"always"`, but append CRLF in the fixer for backwards compatibility
	                    mode = "always";
	                    appendCRLF = true;
	                }
	                if (mode === "always" && !endsWithNewline) {
	
	                    // File is not newline-terminated, but should be
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Newline required at end of file but not found.",
	                        fix(fixer) {
	                            return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
	                        }
	                    });
	                } else if (mode === "never" && endsWithNewline) {
	
	                    // File is newline-terminated, but shouldn't be
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Newline not allowed at end of file.",
	                        fix(fixer) {
	                            const finalEOLs = /(?:\r?\n)+$/,
	                                match = finalEOLs.exec(sourceCode.text),
	                                start = match.index,
	                                end = sourceCode.text.length;
	
	                            return fixer.replaceTextRange([start, end], "");
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements that use != and == instead of !== and ===
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require the use of `===` and `!==`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                null: {
	                                    enum: ["always", "never", "ignore"]
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    additionalItems: false
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["smart", "allow-null"]
	                        }
	                    ],
	                    additionalItems: false
	                }
	            ]
	        }
	    },
	
	    create(context) {
	        const config = context.options[0] || "always";
	        const options = context.options[1] || {};
	        const sourceCode = context.getSourceCode();
	
	        const nullOption = (config === "always") ?
	            options.null || "always" :
	            "ignore";
	        const enforceRuleForNull = (nullOption === "always");
	        const enforceInverseRuleForNull = (nullOption === "never");
	
	        /**
	         * Checks if an expression is a typeof expression
	         * @param  {ASTNode} node The node to check
	         * @returns {boolean} if the node is a typeof expression
	         */
	        function isTypeOf(node) {
	            return node.type === "UnaryExpression" && node.operator === "typeof";
	        }
	
	        /**
	         * Checks if either operand of a binary expression is a typeof operation
	         * @param {ASTNode} node The node to check
	         * @returns {boolean} if one of the operands is typeof
	         * @private
	         */
	        function isTypeOfBinary(node) {
	            return isTypeOf(node.left) || isTypeOf(node.right);
	        }
	
	        /**
	         * Checks if operands are literals of the same type (via typeof)
	         * @param {ASTNode} node The node to check
	         * @returns {boolean} if operands are of same type
	         * @private
	         */
	        function areLiteralsAndSameType(node) {
	            return node.left.type === "Literal" && node.right.type === "Literal" &&
	                    typeof node.left.value === typeof node.right.value;
	        }
	
	        /**
	         * Checks if one of the operands is a literal null
	         * @param {ASTNode} node The node to check
	         * @returns {boolean} if operands are null
	         * @private
	         */
	        function isNullCheck(node) {
	            return (node.right.type === "Literal" && node.right.value === null) ||
	                    (node.left.type === "Literal" && node.left.value === null);
	        }
	
	        /**
	         * Gets the location (line and column) of the binary expression's operator
	         * @param {ASTNode} node The binary expression node to check
	         * @param {string} operator The operator to find
	         * @returns {Object} { line, column } location of operator
	         * @private
	         */
	        function getOperatorLocation(node) {
	            const opToken = sourceCode.getTokenAfter(node.left);
	
	            return {line: opToken.loc.start.line, column: opToken.loc.start.column};
	        }
	
	        /**
	         * Reports a message for this rule.
	         * @param {ASTNode} node The binary expression node that was checked
	         * @param {string} message The message to report
	         * @returns {void}
	         * @private
	         */
	        function report(node, message) {
	            context.report({
	                node,
	                loc: getOperatorLocation(node),
	                message,
	                data: { op: node.operator.charAt(0) }
	            });
	        }
	
	        return {
	            BinaryExpression(node) {
	                const isNull = isNullCheck(node);
	
	                if (node.operator !== "==" && node.operator !== "!=") {
	                    if (enforceInverseRuleForNull && isNull) {
	                        report(node, "Expected '{{op}}=' and instead saw '{{op}}=='.");
	                    }
	                    return;
	                }
	
	                if (config === "smart" && (isTypeOfBinary(node) ||
	                        areLiteralsAndSameType(node) || isNull)) {
	                    return;
	                }
	
	                if (!enforceRuleForNull && isNull) {
	                    return;
	                }
	
	                report(node, "Expected '{{op}}==' and instead saw '{{op}}='.");
	            }
	        };
	
	    }
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to control spacing within function calls
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow spacing between function identifiers and their invocations",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["never"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                allowNewlines: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        }
	    },
	
	    create(context) {
	
	        const never = context.options[0] !== "always";
	        const allowNewlines = !never && context.options[1] && context.options[1].allowNewlines;
	        const sourceCode = context.getSourceCode();
	        const text = sourceCode.getText();
	
	        /**
	         * Check if open space is present in a function name
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkSpacing(node) {
	            const lastCalleeToken = sourceCode.getLastToken(node.callee);
	            let prevToken = lastCalleeToken;
	            let parenToken = sourceCode.getTokenAfter(lastCalleeToken);
	
	            // advances to an open parenthesis.
	            while (
	                parenToken &&
	                parenToken.range[1] < node.range[1] &&
	                parenToken.value !== "("
	            ) {
	                prevToken = parenToken;
	                parenToken = sourceCode.getTokenAfter(parenToken);
	            }
	
	            // Parens in NewExpression are optional
	            if (!(parenToken && parenToken.range[1] < node.range[1])) {
	                return;
	            }
	
	            const hasWhitespace = sourceCode.isSpaceBetweenTokens(prevToken, parenToken);
	            const hasNewline = hasWhitespace &&
	                /\n/.test(text.slice(prevToken.range[1], parenToken.range[0]).replace(/\/\*.*?\*\//g, ""));
	
	            /*
	             * never allowNewlines hasWhitespace hasNewline message
	             * F     F             F             F          Missing space between function name and paren.
	             * F     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
	             * F     F             T             T          Unexpected newline between function name and paren.
	             * F     F             T             F          (OK)
	             * F     T             T             F          (OK)
	             * F     T             T             T          (OK)
	             * F     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
	             * F     T             F             F          Missing space between function name and paren.
	             * T     T             F             F          (Invalid `never && allowNewlines`)
	             * T     T             F             T          (Invalid `!hasWhitespace && hasNewline`)
	             * T     T             T             T          (Invalid `never && allowNewlines`)
	             * T     T             T             F          (Invalid `never && allowNewlines`)
	             * T     F             T             F          Unexpected space between function name and paren.
	             * T     F             T             T          Unexpected space between function name and paren.
	             * T     F             F             T          (Invalid `!hasWhitespace && hasNewline`)
	             * T     F             F             F          (OK)
	             *
	             * T                   T                        Unexpected space between function name and paren.
	             * F                   F                        Missing space between function name and paren.
	             * F     F                           T          Unexpected newline between function name and paren.
	             */
	
	            if (never && hasWhitespace) {
	                context.report({
	                    node,
	                    loc: lastCalleeToken.loc.start,
	                    message: "Unexpected space between function name and paren.",
	                    fix(fixer) {
	                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
	                    }
	                });
	            } else if (!never && !hasWhitespace) {
	                context.report({
	                    node,
	                    loc: lastCalleeToken.loc.start,
	                    message: "Missing space between function name and paren.",
	                    fix(fixer) {
	                        return fixer.insertTextBefore(parenToken, " ");
	                    }
	                });
	            } else if (!never && !allowNewlines && hasNewline) {
	                context.report({
	                    node,
	                    loc: lastCalleeToken.loc.start,
	                    message: "Unexpected newline between function name and paren.",
	                    fix(fixer) {
	                        return fixer.replaceTextRange([prevToken.range[1], parenToken.range[0]], " ");
	                    }
	                });
	            }
	        }
	
	        return {
	            CallExpression: checkSpacing,
	            NewExpression: checkSpacing
	        };
	
	    }
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to require function names to match the name of the variable or property to which they are assigned.
	 * @author Annie Zhang, Pavel Strashkin
	 */
	
	"use strict";
	
	//--------------------------------------------------------------------------
	// Requirements
	//--------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	const esutils = __webpack_require__(110);
	
	//--------------------------------------------------------------------------
	// Helpers
	//--------------------------------------------------------------------------
	
	/**
	 * Determines if a pattern is `module.exports` or `module["exports"]`
	 * @param {ASTNode} pattern The left side of the AssignmentExpression
	 * @returns {boolean} True if the pattern is `module.exports` or `module["exports"]`
	 */
	function isModuleExports(pattern) {
	    if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
	
	        // module.exports
	        if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
	            return true;
	        }
	
	        // module["exports"]
	        if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
	            return true;
	        }
	    }
	    return false;
	}
	
	/**
	 * Determines if a string name is a valid identifier
	 * @param {string} name The string to be checked
	 * @param {int} ecmaVersion The ECMAScript version if specified in the parserOptions config
	 * @returns {boolean} True if the string is a valid identifier
	 */
	function isIdentifier(name, ecmaVersion) {
	    if (ecmaVersion >= 6) {
	        return esutils.keyword.isIdentifierES6(name);
	    }
	    return esutils.keyword.isIdentifierES5(name);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const alwaysOrNever = { enum: ["always", "never"] };
	const optionsObject = {
	    type: "object",
	    properties: {
	        includeCommonJSModuleExports: {
	            type: "boolean"
	        }
	    },
	    additionalProperties: false
	};
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require function names to match the name of the variable or property to which they are assigned",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [{
	                type: "array",
	                additionalItems: false,
	                items: [alwaysOrNever, optionsObject]
	            }, {
	                type: "array",
	                additionalItems: false,
	                items: [optionsObject]
	            }]
	        }
	    },
	
	    create(context) {
	        const options = (typeof context.options[0] === "object" ? context.options[0] : context.options[1]) || {};
	        const nameMatches = typeof context.options[0] === "string" ? context.options[0] : "always";
	        const includeModuleExports = options.includeCommonJSModuleExports;
	        const ecmaVersion = context.parserOptions && context.parserOptions.ecmaVersion ? context.parserOptions.ecmaVersion : 5;
	
	        /**
	         * Compares identifiers based on the nameMatches option
	         * @param {string} x the first identifier
	         * @param {string} y the second identifier
	         * @returns {boolean} whether the two identifiers should warn.
	         */
	        function shouldWarn(x, y) {
	            return (nameMatches === "always" && x !== y) || (nameMatches === "never" && x === y);
	        }
	
	        /**
	         * Reports
	         * @param {ASTNode} node The node to report
	         * @param {string} name The variable or property name
	         * @param {string} funcName The function name
	         * @param {boolean} isProp True if the reported node is a property assignment
	         * @returns {void}
	         */
	        function report(node, name, funcName, isProp) {
	            let message;
	
	            if (nameMatches === "always" && isProp) {
	                message = "Function name `{{funcName}}` should match property name `{{name}}`";
	            } else if (nameMatches === "always") {
	                message = "Function name `{{funcName}}` should match variable name `{{name}}`";
	            } else if (isProp) {
	                message = "Function name `{{funcName}}` should not match property name `{{name}}`";
	            } else {
	                message = "Function name `{{funcName}}` should not match variable name `{{name}}`";
	            }
	            context.report({
	                node,
	                message,
	                data: {
	                    name,
	                    funcName
	                }
	            });
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            VariableDeclarator(node) {
	                if (!node.init || node.init.type !== "FunctionExpression") {
	                    return;
	                }
	                if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
	                    report(node, node.id.name, node.init.id.name, false);
	                }
	            },
	
	            AssignmentExpression(node) {
	                if (node.right.type !== "FunctionExpression" ||
	                   (node.left.computed && node.left.property.type !== "Literal") ||
	                    (!includeModuleExports && isModuleExports(node.left))
	                   ) {
	                    return;
	                }
	
	                const isProp = node.left.type === "MemberExpression" ? true : false;
	                const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;
	
	                if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
	                    report(node, name, node.right.id.name, isProp);
	                }
	            },
	
	            Property(node) {
	                if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && node.key.type !== "Literal") {
	                    return;
	                }
	                if (node.key.type === "Identifier" && shouldWarn(node.key.name, node.value.id.name)) {
	                    report(node, node.key.name, node.value.id.name, true);
	                } else if (
	                    node.key.type === "Literal" &&
	                    isIdentifier(node.key.value, ecmaVersion) &&
	                    shouldWarn(node.key.value, node.value.id.name)
	                ) {
	                    report(node, node.key.value, node.value.id.name, true);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to warn when a function expression does not have a name.
	 * @author Kyle T. Nunery
	 */
	
	"use strict";
	
	/**
	 * Checks whether or not a given variable is a function name.
	 * @param {escope.Variable} variable - A variable to check.
	 * @returns {boolean} `true` if the variable is a function name.
	 */
	function isFunctionName(variable) {
	    return variable && variable.defs[0].type === "FunctionName";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow named `function` expressions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	        const never = context.options[0] === "never";
	
	        /**
	         * Determines whether the current FunctionExpression node is a get, set, or
	         * shorthand method in an object literal or a class.
	         * @returns {boolean} True if the node is a get, set, or shorthand method.
	         */
	        function isObjectOrClassMethod() {
	            const parent = context.getAncestors().pop();
	
	            return (parent.type === "MethodDefinition" || (
	                parent.type === "Property" && (
	                    parent.method ||
	                    parent.kind === "get" ||
	                    parent.kind === "set"
	                )
	            ));
	        }
	
	        return {
	            "FunctionExpression:exit"(node) {
	
	                // Skip recursive functions.
	                const nameVar = context.getDeclaredVariables(node)[0];
	
	                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
	                    return;
	                }
	
	                const name = node.id && node.id.name;
	
	                if (never) {
	                    if (name) {
	                        context.report(node, "Unexpected function expression name.");
	                    }
	                } else {
	                    if (!name && !isObjectOrClassMethod()) {
	                        context.report(node, "Missing function expression name.");
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 154 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce a particular function style
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce the consistent use of either `function` declarations or expressions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["declaration", "expression"]
	            },
	            {
	                type: "object",
	                properties: {
	                    allowArrowFunctions: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const style = context.options[0],
	            allowArrowFunctions = context.options[1] && context.options[1].allowArrowFunctions === true,
	            enforceDeclarations = (style === "declaration"),
	            stack = [];
	
	        const nodesToCheck = {
	            FunctionDeclaration(node) {
	                stack.push(false);
	
	                if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
	                    context.report(node, "Expected a function expression.");
	                }
	            },
	            "FunctionDeclaration:exit"() {
	                stack.pop();
	            },
	
	            FunctionExpression(node) {
	                stack.push(false);
	
	                if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
	                    context.report(node.parent, "Expected a function declaration.");
	                }
	            },
	            "FunctionExpression:exit"() {
	                stack.pop();
	            },
	
	            ThisExpression() {
	                if (stack.length > 0) {
	                    stack[stack.length - 1] = true;
	                }
	            }
	        };
	
	        if (!allowArrowFunctions) {
	            nodesToCheck.ArrowFunctionExpression = function() {
	                stack.push(false);
	            };
	
	            nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
	                const hasThisExpr = stack.pop();
	
	                if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
	                    context.report(node.parent, "Expected a function declaration.");
	                }
	            };
	        }
	
	        return nodesToCheck;
	
	    }
	};


/***/ },
/* 155 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check the spacing around the * in generator functions.
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing around `*` operators in generator functions",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["before", "after", "both", "neither"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            before: {type: "boolean"},
	                            after: {type: "boolean"}
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const mode = (function(option) {
	            if (!option || typeof option === "string") {
	                return {
	                    before: { before: true, after: false },
	                    after: { before: false, after: true },
	                    both: { before: true, after: true },
	                    neither: { before: false, after: false }
	                }[option || "before"];
	            }
	            return option;
	        }(context.options[0]));
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Gets `*` token from a given node.
	         *
	         * @param {ASTNode} node - A node to get `*` token. This is one of
	         *      FunctionDeclaration, FunctionExpression, Property, and
	         *      MethodDefinition.
	         * @returns {Token} `*` token.
	         */
	        function getStarToken(node) {
	            let token = sourceCode.getFirstToken(node);
	
	            while (token.value !== "*") {
	                token = sourceCode.getTokenAfter(token);
	            }
	
	            return token;
	        }
	
	        /**
	         * Checks the spacing between two tokens before or after the star token.
	         * @param {string} side Either "before" or "after".
	         * @param {Token} leftToken `function` keyword token if side is "before", or
	         *     star token if side is "after".
	         * @param {Token} rightToken Star token if side is "before", or identifier
	         *     token if side is "after".
	         * @returns {void}
	         */
	        function checkSpacing(side, leftToken, rightToken) {
	            if (!!(rightToken.range[0] - leftToken.range[1]) !== mode[side]) {
	                const after = leftToken.value === "*";
	                const spaceRequired = mode[side];
	                const node = after ? leftToken : rightToken;
	                const type = spaceRequired ? "Missing" : "Unexpected";
	                const message = "{{type}} space {{side}} *.";
	                const data = {
	                    type,
	                    side
	                };
	
	                context.report({
	                    node,
	                    message,
	                    data,
	                    fix(fixer) {
	                        if (spaceRequired) {
	                            if (after) {
	                                return fixer.insertTextAfter(node, " ");
	                            }
	                            return fixer.insertTextBefore(node, " ");
	                        }
	                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Enforces the spacing around the star if node is a generator function.
	         * @param {ASTNode} node A function expression or declaration node.
	         * @returns {void}
	         */
	        function checkFunction(node) {
	            let starToken;
	
	            if (!node.generator) {
	                return;
	            }
	
	            if (node.parent.method || node.parent.type === "MethodDefinition") {
	                starToken = getStarToken(node.parent);
	            } else {
	                starToken = getStarToken(node);
	            }
	
	            // Only check before when preceded by `function`|`static` keyword
	            const prevToken = sourceCode.getTokenBefore(starToken);
	
	            if (prevToken.value === "function" || prevToken.value === "static") {
	                checkSpacing("before", prevToken, starToken);
	            }
	
	            const nextToken = sourceCode.getTokenAfter(starToken);
	
	            checkSpacing("after", starToken, nextToken);
	        }
	
	        return {
	            FunctionDeclaration: checkFunction,
	            FunctionExpression: checkFunction
	        };
	
	    }
	};


/***/ },
/* 156 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule for disallowing require() outside of the top-level module context
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	const ACCEPTABLE_PARENTS = [
	    "AssignmentExpression",
	    "VariableDeclarator",
	    "MemberExpression",
	    "ExpressionStatement",
	    "CallExpression",
	    "ConditionalExpression",
	    "Program",
	    "VariableDeclaration"
	];
	
	/**
	 * Finds the escope reference in the given scope.
	 * @param {Object} scope The scope to search.
	 * @param {ASTNode} node The identifier node.
	 * @returns {Reference|null} Returns the found reference or null if none were found.
	 */
	function findReference(scope, node) {
	    const references = scope.references.filter(function(reference) {
	        return reference.identifier.range[0] === node.range[0] &&
	            reference.identifier.range[1] === node.range[1];
	    });
	
	    /* istanbul ignore else: correctly returns null */
	    if (references.length === 1) {
	        return references[0];
	    } else {
	        return null;
	    }
	}
	
	/**
	 * Checks if the given identifier node is shadowed in the given scope.
	 * @param {Object} scope The current scope.
	 * @param {ASTNode} node The identifier node to check.
	 * @returns {boolean} Whether or not the name is shadowed.
	 */
	function isShadowed(scope, node) {
	    const reference = findReference(scope, node);
	
	    return reference && reference.resolved && reference.resolved.defs.length > 0;
	}
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `require()` calls to be placed at top-level module scope",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        return {
	            CallExpression(node) {
	                const currentScope = context.getScope();
	
	                if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
	                    const isGoodRequire = context.getAncestors().every(function(parent) {
	                        return ACCEPTABLE_PARENTS.indexOf(parent.type) > -1;
	                    });
	
	                    if (!isGoodRequire) {
	                        context.report(node, "Unexpected require().");
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag for-in loops without if statements inside
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `for-in` loops to include an `if` statement",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            ForInStatement(node) {
	
	                /*
	                 * If the for-in statement has {}, then the real body is the body
	                 * of the BlockStatement. Otherwise, just use body as provided.
	                 */
	                const body = node.body.type === "BlockStatement" ? node.body.body[0] : node.body;
	
	                if (body && body.type !== "IfStatement") {
	                    context.report(node, "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 158 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Ensure handling of errors when we know they exist.
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require error handling in callbacks",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "string"
	            }
	        ]
	    },
	
	    create(context) {
	
	        const errorArgument = context.options[0] || "err";
	
	        /**
	         * Checks if the given argument should be interpreted as a regexp pattern.
	         * @param {string} stringToCheck The string which should be checked.
	         * @returns {boolean} Whether or not the string should be interpreted as a pattern.
	         */
	        function isPattern(stringToCheck) {
	            const firstChar = stringToCheck[0];
	
	            return firstChar === "^";
	        }
	
	        /**
	         * Checks if the given name matches the configured error argument.
	         * @param {string} name The name which should be compared.
	         * @returns {boolean} Whether or not the given name matches the configured error variable name.
	         */
	        function matchesConfiguredErrorName(name) {
	            if (isPattern(errorArgument)) {
	                const regexp = new RegExp(errorArgument);
	
	                return regexp.test(name);
	            }
	            return name === errorArgument;
	        }
	
	        /**
	         * Get the parameters of a given function scope.
	         * @param {Object} scope The function scope.
	         * @returns {array} All parameters of the given scope.
	         */
	        function getParameters(scope) {
	            return scope.variables.filter(function(variable) {
	                return variable.defs[0] && variable.defs[0].type === "Parameter";
	            });
	        }
	
	        /**
	         * Check to see if we're handling the error object properly.
	         * @param {ASTNode} node The AST node to check.
	         * @returns {void}
	         */
	        function checkForError(node) {
	            const scope = context.getScope(),
	                parameters = getParameters(scope),
	                firstParameter = parameters[0];
	
	            if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
	                if (firstParameter.references.length === 0) {
	                    context.report(node, "Expected error to be handled.");
	                }
	            }
	        }
	
	        return {
	            FunctionDeclaration: checkForError,
	            FunctionExpression: checkForError,
	            ArrowFunctionExpression: checkForError
	        };
	
	    }
	};


/***/ },
/* 159 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule that warns when identifier names that are
	 * blacklisted in the configuration are used.
	 * @author Keith Cirkel (http://keithcirkel.co.uk)
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified identifiers",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                type: "string"
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const blacklist = context.options;
	
	
	        /**
	         * Checks if a string matches the provided pattern
	         * @param {string} name The string to check.
	         * @returns {boolean} if the string is a match
	         * @private
	         */
	        function isInvalid(name) {
	            return blacklist.indexOf(name) !== -1;
	        }
	
	        /**
	         * Verifies if we should report an error or not based on the effective
	         * parent node and the identifier name.
	         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
	         * @param {string} name The identifier name of the identifier node
	         * @returns {boolean} whether an error should be reported or not
	         */
	        function shouldReport(effectiveParent, name) {
	            return effectiveParent.type !== "CallExpression"
	                && effectiveParent.type !== "NewExpression" &&
	                isInvalid(name);
	        }
	
	        /**
	         * Reports an AST node as a rule violation.
	         * @param {ASTNode} node The node to report.
	         * @returns {void}
	         * @private
	         */
	        function report(node) {
	            context.report(node, "Identifier '{{name}}' is blacklisted.", {
	                name: node.name
	            });
	        }
	
	        return {
	
	            Identifier(node) {
	                const name = node.name,
	                    effectiveParent = (node.parent.type === "MemberExpression") ? node.parent.parent : node.parent;
	
	                // MemberExpressions get special rules
	                if (node.parent.type === "MemberExpression") {
	
	                    // Always check object names
	                    if (node.parent.object.type === "Identifier" &&
	                        node.parent.object.name === node.name) {
	                        if (isInvalid(name)) {
	                            report(node);
	                        }
	
	                        // Report AssignmentExpressions only if they are the left side of the assignment
	                    } else if (effectiveParent.type === "AssignmentExpression" &&
	                        (effectiveParent.right.type !== "MemberExpression" ||
	                        effectiveParent.left.type === "MemberExpression" &&
	                        effectiveParent.left.property.name === node.name)) {
	                        if (isInvalid(name)) {
	                            report(node);
	                        }
	                    }
	
	                // Properties have their own rules
	                } else if (node.parent.type === "Property") {
	
	                    if (shouldReport(effectiveParent, name)) {
	                        report(node);
	                    }
	
	                // Report anything that is a match and not a CallExpression
	                } else if (shouldReport(effectiveParent, name)) {
	                    report(node);
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 160 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule that warns when identifier names are shorter or longer
	 * than the values provided in configuration.
	 * @author Burak Yigit Kaya aka BYK
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce minimum and maximum identifier lengths",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    min: {
	                        type: "number"
	                    },
	                    max: {
	                        type: "number"
	                    },
	                    exceptions: {
	                        type: "array",
	                        uniqueItems: true,
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    properties: {
	                        enum: ["always", "never"]
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const minLength = typeof options.min !== "undefined" ? options.min : 2;
	        const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
	        const properties = options.properties !== "never";
	        const exceptions = (options.exceptions ? options.exceptions : [])
	            .reduce(function(obj, item) {
	                obj[item] = true;
	
	                return obj;
	            }, {});
	
	        const SUPPORTED_EXPRESSIONS = {
	            MemberExpression: properties && function(parent) {
	                return !parent.computed && (
	
	                    // regular property assignment
	                    (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" ||
	
	                    // or the last identifier in an ObjectPattern destructuring
	                    parent.parent.type === "Property" && parent.parent.value === parent &&
	                    parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent)
	                );
	            },
	            AssignmentPattern(parent, node) {
	                return parent.left === node;
	            },
	            VariableDeclarator(parent, node) {
	                return parent.id === node;
	            },
	            Property: properties && function(parent, node) {
	                return parent.key === node;
	            },
	            ImportDefaultSpecifier: true,
	            RestElement: true,
	            FunctionExpression: true,
	            ArrowFunctionExpression: true,
	            ClassDeclaration: true,
	            FunctionDeclaration: true,
	            MethodDefinition: true,
	            CatchClause: true
	        };
	
	        return {
	            Identifier(node) {
	                const name = node.name;
	                const parent = node.parent;
	
	                const isShort = name.length < minLength;
	                const isLong = name.length > maxLength;
	
	                if (!(isShort || isLong) || exceptions[name]) {
	                    return;  // Nothing to report
	                }
	
	                const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
	
	                if (isValidExpression && (isValidExpression === true || isValidExpression(parent, node))) {
	                    context.report(
	                        node,
	                        isShort ?
	                            "Identifier name '{{name}}' is too short (< {{min}})." :
	                            "Identifier name '{{name}}' is too long (> {{max}}).",
	                        { name, min: minLength, max: maxLength }
	                    );
	                }
	            }
	        };
	    }
	};


/***/ },
/* 161 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag non-matching identifiers
	 * @author Matthieu Larcher
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require identifiers to match a specified regular expression",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "string"
	            },
	            {
	                type: "object",
	                properties: {
	                    properties: {
	                        type: "boolean"
	                    }
	                }
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const pattern = context.options[0] || "^.+$",
	            regexp = new RegExp(pattern);
	
	        const options = context.options[1] || {},
	            properties = !!options.properties,
	            onlyDeclarations = !!options.onlyDeclarations;
	
	        /**
	         * Checks if a string matches the provided pattern
	         * @param {string} name The string to check.
	         * @returns {boolean} if the string is a match
	         * @private
	         */
	        function isInvalid(name) {
	            return !regexp.test(name);
	        }
	
	        /**
	         * Verifies if we should report an error or not based on the effective
	         * parent node and the identifier name.
	         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported
	         * @param {string} name The identifier name of the identifier node
	         * @returns {boolean} whether an error should be reported or not
	         */
	        function shouldReport(effectiveParent, name) {
	            return effectiveParent.type !== "CallExpression"
	                && effectiveParent.type !== "NewExpression" &&
	                isInvalid(name);
	        }
	
	        /**
	         * Reports an AST node as a rule violation.
	         * @param {ASTNode} node The node to report.
	         * @returns {void}
	         * @private
	         */
	        function report(node) {
	            context.report(node, "Identifier '{{name}}' does not match the pattern '{{pattern}}'.", {
	                name: node.name,
	                pattern
	            });
	        }
	
	        return {
	
	            Identifier(node) {
	                const name = node.name,
	                    parent = node.parent,
	                    effectiveParent = (parent.type === "MemberExpression") ? parent.parent : parent;
	
	                if (parent.type === "MemberExpression") {
	
	                    if (!properties) {
	                        return;
	                    }
	
	                    // Always check object names
	                    if (parent.object.type === "Identifier" &&
	                        parent.object.name === name) {
	                        if (isInvalid(name)) {
	                            report(node);
	                        }
	
	                    // Report AssignmentExpressions only if they are the left side of the assignment
	                    } else if (effectiveParent.type === "AssignmentExpression" &&
	                        (effectiveParent.right.type !== "MemberExpression" ||
	                        effectiveParent.left.type === "MemberExpression" &&
	                        effectiveParent.left.property.name === name)) {
	                        if (isInvalid(name)) {
	                            report(node);
	                        }
	                    }
	
	                } else if (parent.type === "Property") {
	
	                    if (!properties || parent.key.name !== name) {
	                        return;
	                    }
	
	                    if (shouldReport(effectiveParent, name)) {
	                        report(node);
	                    }
	
	                } else {
	                    const isDeclaration = effectiveParent.type === "FunctionDeclaration" || effectiveParent.type === "VariableDeclarator";
	
	                    if (onlyDeclarations && !isDeclaration) {
	                        return;
	                    }
	
	                    if (shouldReport(effectiveParent, name)) {
	                        report(node);
	                    }
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * @fileoverview This option sets a specific tab width for your code
	 *
	 * This rule has been ported and modified from nodeca.
	 * @author Vitaly Puzrin
	 * @author Gyandeep Singh
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent indentation",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["tab"]
	                    },
	                    {
	                        type: "integer",
	                        minimum: 0
	                    }
	                ]
	            },
	            {
	                type: "object",
	                properties: {
	                    SwitchCase: {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    VariableDeclarator: {
	                        oneOf: [
	                            {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            {
	                                type: "object",
	                                properties: {
	                                    var: {
	                                        type: "integer",
	                                        minimum: 0
	                                    },
	                                    let: {
	                                        type: "integer",
	                                        minimum: 0
	                                    },
	                                    const: {
	                                        type: "integer",
	                                        minimum: 0
	                                    }
	                                }
	                            }
	                        ]
	                    },
	                    outerIIFEBody: {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    MemberExpression: {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    FunctionDeclaration: {
	                        type: "object",
	                        properties: {
	                            parameters: {
	                                oneOf: [
	                                    {
	                                        type: "integer",
	                                        minimum: 0
	                                    },
	                                    {
	                                        enum: ["first"]
	                                    }
	                                ]
	                            },
	                            body: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        }
	                    },
	                    FunctionExpression: {
	                        type: "object",
	                        properties: {
	                            parameters: {
	                                oneOf: [
	                                    {
	                                        type: "integer",
	                                        minimum: 0
	                                    },
	                                    {
	                                        enum: ["first"]
	                                    }
	                                ]
	                            },
	                            body: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        }
	                    },
	                    CallExpression: {
	                        type: "object",
	                        properties: {
	                            parameters: {
	                                oneOf: [
	                                    {
	                                        type: "integer",
	                                        minimum: 0
	                                    },
	                                    {
	                                        enum: ["first"]
	                                    }
	                                ]
	                            }
	                        }
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const DEFAULT_VARIABLE_INDENT = 1;
	        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
	        const DEFAULT_FUNCTION_BODY_INDENT = 1;
	
	        let indentType = "space";
	        let indentSize = 4;
	        const options = {
	            SwitchCase: 0,
	            VariableDeclarator: {
	                var: DEFAULT_VARIABLE_INDENT,
	                let: DEFAULT_VARIABLE_INDENT,
	                const: DEFAULT_VARIABLE_INDENT
	            },
	            outerIIFEBody: null,
	            FunctionDeclaration: {
	                parameters: DEFAULT_PARAMETER_INDENT,
	                body: DEFAULT_FUNCTION_BODY_INDENT
	            },
	            FunctionExpression: {
	                parameters: DEFAULT_PARAMETER_INDENT,
	                body: DEFAULT_FUNCTION_BODY_INDENT
	            },
	            CallExpression: {
	                arguments: DEFAULT_PARAMETER_INDENT
	            }
	        };
	
	        const sourceCode = context.getSourceCode();
	
	        if (context.options.length) {
	            if (context.options[0] === "tab") {
	                indentSize = 1;
	                indentType = "tab";
	            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === "number") {
	                indentSize = context.options[0];
	                indentType = "space";
	            }
	
	            if (context.options[1]) {
	                const opts = context.options[1];
	
	                options.SwitchCase = opts.SwitchCase || 0;
	                const variableDeclaratorRules = opts.VariableDeclarator;
	
	                if (typeof variableDeclaratorRules === "number") {
	                    options.VariableDeclarator = {
	                        var: variableDeclaratorRules,
	                        let: variableDeclaratorRules,
	                        const: variableDeclaratorRules
	                    };
	                } else if (typeof variableDeclaratorRules === "object") {
	                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);
	                }
	
	                if (typeof opts.outerIIFEBody === "number") {
	                    options.outerIIFEBody = opts.outerIIFEBody;
	                }
	
	                if (typeof opts.MemberExpression === "number") {
	                    options.MemberExpression = opts.MemberExpression;
	                }
	
	                if (typeof opts.FunctionDeclaration === "object") {
	                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
	                }
	
	                if (typeof opts.FunctionExpression === "object") {
	                    Object.assign(options.FunctionExpression, opts.FunctionExpression);
	                }
	
	                if (typeof opts.CallExpression === "object") {
	                    Object.assign(options.CallExpression, opts.CallExpression);
	                }
	            }
	        }
	
	        const caseIndentStore = {};
	
	        /**
	         * Creates an error message for a line, given the expected/actual indentation.
	         * @param {int} expectedAmount The expected amount of indentation characters for this line
	         * @param {int} actualSpaces The actual number of indentation spaces that were found on this line
	         * @param {int} actualTabs The actual number of indentation tabs that were found on this line
	         * @returns {string} An error message for this line
	         */
	        function createErrorMessage(expectedAmount, actualSpaces, actualTabs) {
	            const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`; // e.g. "2 tabs"
	            const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`; // e.g. "space"
	            const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`; // e.g. "tabs"
	            let foundStatement;
	
	            if (actualSpaces > 0 && actualTabs > 0) {
	                foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`; // e.g. "1 space and 2 tabs"
	            } else if (actualSpaces > 0) {
	
	                // Abbreviate the message if the expected indentation is also spaces.
	                // e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
	                foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
	            } else if (actualTabs > 0) {
	                foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
	            } else {
	                foundStatement = "0";
	            }
	
	            return `Expected indentation of ${expectedStatement} but found ${foundStatement}.`;
	        }
	
	        /**
	         * Reports a given indent violation
	         * @param {ASTNode} node Node violating the indent rule
	         * @param {int} needed Expected indentation character count
	         * @param {int} gottenSpaces Indentation space count in the actual node/code
	         * @param {int} gottenTabs Indentation tab count in the actual node/code
	         * @param {Object=} loc Error line and column location
	         * @param {boolean} isLastNodeCheck Is the error for last node check
	         * @param {int} lastNodeCheckEndOffset Number of charecters to skip from the end
	         * @returns {void}
	         */
	        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck, lastNodeCheckEndOffset) {
	            if (gottenSpaces && gottenTabs) {
	
	                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.
	                return;
	            }
	
	            lastNodeCheckEndOffset = lastNodeCheckEndOffset || 0;
	
	            const desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed - lastNodeCheckEndOffset);
	
	            const textRange = isLastNodeCheck
	                ? [node.range[1] - gottenSpaces - gottenTabs - 1, node.range[1] - 1 - lastNodeCheckEndOffset]
	                : [node.range[0] - gottenSpaces - gottenTabs, node.range[0]];
	
	            context.report({
	                node,
	                loc,
	                message: createErrorMessage(needed, gottenSpaces, gottenTabs),
	                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)
	            });
	        }
	
	        /**
	         * Get the actual indent of node
	         * @param {ASTNode|Token} node Node to examine
	         * @param {boolean} [byLastLine=false] get indent of node's last line
	         * @param {boolean} [excludeCommas=false] skip comma on start of line
	         * @returns {Object} The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also
	         contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and
	         `badChar` is the amount of the other indentation character.
	         */
	        function getNodeIndent(node, byLastLine) {
	            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
	            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
	            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t"));
	            const spaces = indentChars.filter(char => char === " ").length;
	            const tabs = indentChars.filter(char => char === "\t").length;
	
	            return {
	                space: spaces,
	                tab: tabs,
	                goodChar: indentType === "space" ? spaces : tabs,
	                badChar: indentType === "space" ? tabs : spaces
	            };
	        }
	
	        /**
	         * Checks node is the first in its own start line. By default it looks by start line.
	         * @param {ASTNode} node The node to check
	         * @param {boolean} [byEndLocation=false] Lookup based on start position or end
	         * @returns {boolean} true if its the first in the its start line
	         */
	        function isNodeFirstInLine(node, byEndLocation) {
	            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
	                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
	                endLine = firstToken ? firstToken.loc.end.line : -1;
	
	            return startLine !== endLine;
	        }
	
	        /**
	         * Check indent for node
	         * @param {ASTNode} node Node to check
	         * @param {int} neededIndent needed indent
	         * @param {boolean} [excludeCommas=false] skip comma on start of line
	         * @returns {void}
	         */
	        function checkNodeIndent(node, neededIndent) {
	            const actualIndent = getNodeIndent(node, false);
	
	            if (
	                node.type !== "ArrayExpression" &&
	                node.type !== "ObjectExpression" &&
	                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&
	                isNodeFirstInLine(node)
	            ) {
	                report(node, neededIndent, actualIndent.space, actualIndent.tab);
	            }
	
	            if (node.type === "IfStatement" && node.alternate) {
	                const elseToken = sourceCode.getTokenBefore(node.alternate);
	
	                checkNodeIndent(elseToken, neededIndent);
	
	                if (!isNodeFirstInLine(node.alternate)) {
	                    checkNodeIndent(node.alternate, neededIndent);
	                }
	            }
	
	            if (node.type === "TryStatement" && node.handler) {
	                const catchToken = sourceCode.getFirstToken(node.handler);
	
	                checkNodeIndent(catchToken, neededIndent);
	            }
	
	            if (node.type === "TryStatement" && node.finalizer) {
	                const finallyToken = sourceCode.getTokenBefore(node.finalizer);
	
	                checkNodeIndent(finallyToken, neededIndent);
	            }
	
	            if (node.type === "DoWhileStatement") {
	                const whileToken = sourceCode.getTokenAfter(node.body);
	
	                checkNodeIndent(whileToken, neededIndent);
	            }
	        }
	
	        /**
	         * Check indent for nodes list
	         * @param {ASTNode[]} nodes list of node objects
	         * @param {int} indent needed indent
	         * @param {boolean} [excludeCommas=false] skip comma on start of line
	         * @returns {void}
	         */
	        function checkNodesIndent(nodes, indent) {
	            nodes.forEach(node => checkNodeIndent(node, indent));
	        }
	
	        /**
	         * Check last node line indent this detects, that block closed correctly
	         * @param {ASTNode} node Node to examine
	         * @param {int} lastLineIndent needed indent
	         * @returns {void}
	         */
	        function checkLastNodeLineIndent(node, lastLineIndent) {
	            const lastToken = sourceCode.getLastToken(node);
	            const endIndent = getNodeIndent(lastToken, true);
	
	            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
	                report(
	                    node,
	                    lastLineIndent,
	                    endIndent.space,
	                    endIndent.tab,
	                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
	                    true
	                );
	            }
	        }
	
	        /**
	         * Check last node line indent this detects, that block closed correctly
	         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'
	         * @param {ASTNode} node Node to examine
	         * @param {int} firstLineIndent first line needed indent
	         * @returns {void}
	         */
	        function checkLastReturnStatementLineIndent(node, firstLineIndent) {
	            const nodeLastToken = sourceCode.getLastToken(node);
	            let lastNodeCheckEndOffset = 0;
	            let lastToken = nodeLastToken;
	
	            // in case if return statement ends with ');' we have traverse back to ')'
	            // otherwise we'll measure indent for ';' and replace ')'
	            while (lastToken.value !== ")") {
	                lastNodeCheckEndOffset++;
	                lastToken = sourceCode.getTokenBefore(lastToken);
	            }
	
	            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
	
	            if (textBeforeClosingParenthesis.trim()) {
	
	                // There are tokens before the closing paren, don't report this case
	                return;
	            }
	
	            const endIndent = getNodeIndent(lastToken, true);
	
	            if (endIndent.goodChar !== firstLineIndent) {
	                report(
	                    node,
	                    firstLineIndent,
	                    endIndent.space,
	                    endIndent.tab,
	                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },
	                    true,
	                    lastNodeCheckEndOffset
	                );
	            }
	        }
	
	        /**
	         * Check first node line indent is correct
	         * @param {ASTNode} node Node to examine
	         * @param {int} firstLineIndent needed indent
	         * @returns {void}
	         */
	        function checkFirstNodeLineIndent(node, firstLineIndent) {
	            const startIndent = getNodeIndent(node, false);
	
	            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
	                report(
	                    node,
	                    firstLineIndent,
	                    startIndent.space,
	                    startIndent.tab,
	                    { line: node.loc.start.line, column: node.loc.start.column }
	                );
	            }
	        }
	
	        /**
	         * Returns a parent node of given node based on a specified type
	         * if not present then return null
	         * @param {ASTNode} node node to examine
	         * @param {string} type type that is being looked for
	         * @param {string} stopAtList end points for the evaluating code
	         * @returns {ASTNode|void} if found then node otherwise null
	         */
	        function getParentNodeByType(node, type, stopAtList) {
	            let parent = node.parent;
	
	            if (!stopAtList) {
	                stopAtList = ["Program"];
	            }
	
	            while (parent.type !== type && stopAtList.indexOf(parent.type) === -1 && parent.type !== "Program") {
	                parent = parent.parent;
	            }
	
	            return parent.type === type ? parent : null;
	        }
	
	        /**
	         * Returns the VariableDeclarator based on the current node
	         * if not present then return null
	         * @param {ASTNode} node node to examine
	         * @returns {ASTNode|void} if found then node otherwise null
	         */
	        function getVariableDeclaratorNode(node) {
	            return getParentNodeByType(node, "VariableDeclarator");
	        }
	
	        /**
	         * Check to see if the node is part of the multi-line variable declaration.
	         * Also if its on the same line as the varNode
	         * @param {ASTNode} node node to check
	         * @param {ASTNode} varNode variable declaration node to check against
	         * @returns {boolean} True if all the above condition satisfy
	         */
	        function isNodeInVarOnTop(node, varNode) {
	            return varNode &&
	                varNode.parent.loc.start.line === node.loc.start.line &&
	                varNode.parent.declarations.length > 1;
	        }
	
	        /**
	         * Check to see if the argument before the callee node is multi-line and
	         * there should only be 1 argument before the callee node
	         * @param {ASTNode} node node to check
	         * @returns {boolean} True if arguments are multi-line
	         */
	        function isArgBeforeCalleeNodeMultiline(node) {
	            const parent = node.parent;
	
	            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
	                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
	            }
	
	            return false;
	        }
	
	        /**
	         * Check to see if the node is a file level IIFE
	         * @param {ASTNode} node The function node to check.
	         * @returns {boolean} True if the node is the outer IIFE
	         */
	        function isOuterIIFE(node) {
	            const parent = node.parent;
	            let stmt = parent.parent;
	
	            /*
	             * Verify that the node is an IIEF
	             */
	            if (
	                parent.type !== "CallExpression" ||
	                parent.callee !== node) {
	
	                return false;
	            }
	
	            /*
	             * Navigate legal ancestors to determine whether this IIEF is outer
	             */
	            while (
	                stmt.type === "UnaryExpression" && (
	                    stmt.operator === "!" ||
	                    stmt.operator === "~" ||
	                    stmt.operator === "+" ||
	                    stmt.operator === "-") ||
	                stmt.type === "AssignmentExpression" ||
	                stmt.type === "LogicalExpression" ||
	                stmt.type === "SequenceExpression" ||
	                stmt.type === "VariableDeclarator") {
	
	                stmt = stmt.parent;
	            }
	
	            return ((
	                    stmt.type === "ExpressionStatement" ||
	                    stmt.type === "VariableDeclaration") &&
	                stmt.parent && stmt.parent.type === "Program"
	            );
	        }
	
	        /**
	         * Check indent for function block content
	         * @param {ASTNode} node A BlockStatement node that is inside of a function.
	         * @returns {void}
	         */
	        function checkIndentInFunctionBlock(node) {
	
	            /*
	             * Search first caller in chain.
	             * Ex.:
	             *
	             * Models <- Identifier
	             *   .User
	             *   .find()
	             *   .exec(function() {
	             *   // function body
	             * });
	             *
	             * Looks for 'Models'
	             */
	            const calleeNode = node.parent; // FunctionExpression
	            let indent;
	
	            if (calleeNode.parent &&
	                (calleeNode.parent.type === "Property" ||
	                calleeNode.parent.type === "ArrayExpression")) {
	
	                // If function is part of array or object, comma can be put at left
	                indent = getNodeIndent(calleeNode, false, false).goodChar;
	            } else {
	
	                // If function is standalone, simple calculate indent
	                indent = getNodeIndent(calleeNode).goodChar;
	            }
	
	            if (calleeNode.parent.type === "CallExpression") {
	                const calleeParent = calleeNode.parent;
	
	                if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
	                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
	                        indent = getNodeIndent(calleeParent).goodChar;
	                    }
	                } else {
	                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&
	                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&
	                        !isNodeFirstInLine(calleeNode)) {
	                        indent = getNodeIndent(calleeParent).goodChar;
	                    }
	                }
	            }
	
	            // function body indent should be indent + indent size, unless this
	            // is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.
	            let functionOffset = indentSize;
	
	            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
	                functionOffset = options.outerIIFEBody * indentSize;
	            } else if (calleeNode.type === "FunctionExpression") {
	                functionOffset = options.FunctionExpression.body * indentSize;
	            } else if (calleeNode.type === "FunctionDeclaration") {
	                functionOffset = options.FunctionDeclaration.body * indentSize;
	            }
	            indent += functionOffset;
	
	            // check if the node is inside a variable
	            const parentVarNode = getVariableDeclaratorNode(node);
	
	            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
	                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
	            }
	
	            if (node.body.length > 0) {
	                checkNodesIndent(node.body, indent);
	            }
	
	            checkLastNodeLineIndent(node, indent - functionOffset);
	        }
	
	
	        /**
	         * Checks if the given node starts and ends on the same line
	         * @param {ASTNode} node The node to check
	         * @returns {boolean} Whether or not the block starts and ends on the same line.
	         */
	        function isSingleLineNode(node) {
	            const lastToken = sourceCode.getLastToken(node),
	                startLine = node.loc.start.line,
	                endLine = lastToken.loc.end.line;
	
	            return startLine === endLine;
	        }
	
	        /**
	         * Check to see if the first element inside an array is an object and on the same line as the node
	         * If the node is not an array then it will return false.
	         * @param {ASTNode} node node to check
	         * @returns {boolean} success/failure
	         */
	        function isFirstArrayElementOnSameLine(node) {
	            if (node.type === "ArrayExpression" && node.elements[0]) {
	                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === "ObjectExpression";
	            } else {
	                return false;
	            }
	        }
	
	        /**
	         * Check indent for array block content or object block content
	         * @param {ASTNode} node node to examine
	         * @returns {void}
	         */
	        function checkIndentInArrayOrObjectBlock(node) {
	
	            // Skip inline
	            if (isSingleLineNode(node)) {
	                return;
	            }
	
	            let elements = (node.type === "ArrayExpression") ? node.elements : node.properties;
	
	            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
	            elements = elements.filter(function(elem) {
	                return elem !== null;
	            });
	
	            let nodeIndent;
	            let elementsIndent;
	            const parentVarNode = getVariableDeclaratorNode(node);
	
	            // TODO - come up with a better strategy in future
	            if (isNodeFirstInLine(node)) {
	                const parent = node.parent;
	
	                nodeIndent = getNodeIndent(parent).goodChar;
	                if (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {
	                    if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
	                        if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
	                            nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);
	                        } else if (
	                            parent.type === "ObjectExpression" ||
	                            parent.type === "ArrayExpression" ||
	                            parent.type === "CallExpression" ||
	                            parent.type === "ArrowFunctionExpression" ||
	                            parent.type === "NewExpression" ||
	                            parent.type === "LogicalExpression"
	                        ) {
	                            nodeIndent = nodeIndent + indentSize;
	                        }
	                    }
	                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && parent.type !== "MemberExpression" && parent.type !== "ExpressionStatement" && parent.type !== "AssignmentExpression" && parent.type !== "Property") {
	                    nodeIndent = nodeIndent + indentSize;
	                }
	
	                elementsIndent = nodeIndent + indentSize;
	
	                checkFirstNodeLineIndent(node, nodeIndent);
	            } else {
	                nodeIndent = getNodeIndent(node).goodChar;
	                elementsIndent = nodeIndent + indentSize;
	            }
	
	            /*
	             * Check if the node is a multiple variable declaration; if so, then
	             * make sure indentation takes that into account.
	             */
	            if (isNodeInVarOnTop(node, parentVarNode)) {
	                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
	            }
	
	            checkNodesIndent(elements, elementsIndent);
	
	            if (elements.length > 0) {
	
	                // Skip last block line check if last item in same line
	                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
	                    return;
	                }
	            }
	
	            checkLastNodeLineIndent(node, elementsIndent - indentSize);
	        }
	
	        /**
	         * Check if the node or node body is a BlockStatement or not
	         * @param {ASTNode} node node to test
	         * @returns {boolean} True if it or its body is a block statement
	         */
	        function isNodeBodyBlock(node) {
	            return node.type === "BlockStatement" || node.type === "ClassBody" || (node.body && node.body.type === "BlockStatement") ||
	                (node.consequent && node.consequent.type === "BlockStatement");
	        }
	
	        /**
	         * Check indentation for blocks
	         * @param {ASTNode} node node to check
	         * @returns {void}
	         */
	        function blockIndentationCheck(node) {
	
	            // Skip inline blocks
	            if (isSingleLineNode(node)) {
	                return;
	            }
	
	            if (node.parent && (
	                    node.parent.type === "FunctionExpression" ||
	                    node.parent.type === "FunctionDeclaration" ||
	                    node.parent.type === "ArrowFunctionExpression"
	            )) {
	                checkIndentInFunctionBlock(node);
	                return;
	            }
	
	            let indent;
	            let nodesToCheck = [];
	
	            /*
	             * For this statements we should check indent from statement beginning,
	             * not from the beginning of the block.
	             */
	            const statementsWithProperties = [
	                "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"
	            ];
	
	            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
	                indent = getNodeIndent(node.parent).goodChar;
	            } else if (node.parent && node.parent.type === "CatchClause") {
	                indent = getNodeIndent(node.parent.parent).goodChar;
	            } else {
	                indent = getNodeIndent(node).goodChar;
	            }
	
	            if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
	                nodesToCheck = [node.consequent];
	            } else if (Array.isArray(node.body)) {
	                nodesToCheck = node.body;
	            } else {
	                nodesToCheck = [node.body];
	            }
	
	            if (nodesToCheck.length > 0) {
	                checkNodesIndent(nodesToCheck, indent + indentSize);
	            }
	
	            if (node.type === "BlockStatement") {
	                checkLastNodeLineIndent(node, indent);
	            }
	        }
	
	        /**
	         * Filter out the elements which are on the same line of each other or the node.
	         * basically have only 1 elements from each line except the variable declaration line.
	         * @param {ASTNode} node Variable declaration node
	         * @returns {ASTNode[]} Filtered elements
	         */
	        function filterOutSameLineVars(node) {
	            return node.declarations.reduce(function(finalCollection, elem) {
	                const lastElem = finalCollection[finalCollection.length - 1];
	
	                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
	                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
	                    finalCollection.push(elem);
	                }
	
	                return finalCollection;
	            }, []);
	        }
	
	        /**
	         * Check indentation for variable declarations
	         * @param {ASTNode} node node to examine
	         * @returns {void}
	         */
	        function checkIndentInVariableDeclarations(node) {
	            const elements = filterOutSameLineVars(node);
	            const nodeIndent = getNodeIndent(node).goodChar;
	            const lastElement = elements[elements.length - 1];
	
	            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
	
	            checkNodesIndent(elements, elementsIndent);
	
	            // Only check the last line if there is any token after the last item
	            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
	                return;
	            }
	
	            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);
	
	            if (tokenBeforeLastElement.value === ",") {
	
	                // Special case for comma-first syntax where the semicolon is indented
	                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
	            } else {
	                checkLastNodeLineIndent(node, elementsIndent - indentSize);
	            }
	        }
	
	        /**
	         * Check and decide whether to check for indentation for blockless nodes
	         * Scenarios are for or while statements without braces around them
	         * @param {ASTNode} node node to examine
	         * @returns {void}
	         */
	        function blockLessNodes(node) {
	            if (node.body.type !== "BlockStatement") {
	                blockIndentationCheck(node);
	            }
	        }
	
	        /**
	         * Returns the expected indentation for the case statement
	         * @param {ASTNode} node node to examine
	         * @param {int} [switchIndent] indent for switch statement
	         * @returns {int} indent size
	         */
	        function expectedCaseIndent(node, switchIndent) {
	            const switchNode = (node.type === "SwitchStatement") ? node : node.parent;
	            let caseIndent;
	
	            if (caseIndentStore[switchNode.loc.start.line]) {
	                return caseIndentStore[switchNode.loc.start.line];
	            } else {
	                if (typeof switchIndent === "undefined") {
	                    switchIndent = getNodeIndent(switchNode).goodChar;
	                }
	
	                if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
	                    caseIndent = switchIndent;
	                } else {
	                    caseIndent = switchIndent + (indentSize * options.SwitchCase);
	                }
	
	                caseIndentStore[switchNode.loc.start.line] = caseIndent;
	                return caseIndent;
	            }
	        }
	
	        /**
	         * Checks wether a return statement is wrapped in ()
	         * @param {ASTNode} node node to examine
	         * @returns {boolean} the result
	         */
	        function isWrappedInParenthesis(node) {
	            const regex = /^return\s*?\(\s*?\);*?/;
	
	            const statementWithoutArgument = sourceCode.getText(node).replace(
	                sourceCode.getText(node.argument), "");
	
	            return regex.test(statementWithoutArgument);
	        }
	
	        return {
	            Program(node) {
	                if (node.body.length > 0) {
	
	                    // Root nodes should have no indent
	                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);
	                }
	            },
	
	            ClassBody: blockIndentationCheck,
	
	            BlockStatement: blockIndentationCheck,
	
	            WhileStatement: blockLessNodes,
	
	            ForStatement: blockLessNodes,
	
	            ForInStatement: blockLessNodes,
	
	            ForOfStatement: blockLessNodes,
	
	            DoWhileStatement: blockLessNodes,
	
	            IfStatement(node) {
	                if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
	                    blockIndentationCheck(node);
	                }
	            },
	
	            VariableDeclaration(node) {
	                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
	                    checkIndentInVariableDeclarations(node);
	                }
	            },
	
	            ObjectExpression(node) {
	                checkIndentInArrayOrObjectBlock(node);
	            },
	
	            ArrayExpression(node) {
	                checkIndentInArrayOrObjectBlock(node);
	            },
	
	            MemberExpression(node) {
	
	                if (typeof options.MemberExpression === "undefined") {
	                    return;
	                }
	
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	
	                // The typical layout of variable declarations and assignments
	                // alter the expectation of correct indentation. Skip them.
	                // TODO: Add appropriate configuration options for variable
	                // declarations and assignments.
	                if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
	                    return;
	                }
	
	                if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
	                    return;
	                }
	
	                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
	
	                const checkNodes = [node.property];
	
	                const dot = context.getTokenBefore(node.property);
	
	                if (dot.type === "Punctuator" && dot.value === ".") {
	                    checkNodes.push(dot);
	                }
	
	                checkNodesIndent(checkNodes, propertyIndent);
	            },
	
	            SwitchStatement(node) {
	
	                // Switch is not a 'BlockStatement'
	                const switchIndent = getNodeIndent(node).goodChar;
	                const caseIndent = expectedCaseIndent(node, switchIndent);
	
	                checkNodesIndent(node.cases, caseIndent);
	
	
	                checkLastNodeLineIndent(node, switchIndent);
	            },
	
	            SwitchCase(node) {
	
	                // Skip inline cases
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	                const caseIndent = expectedCaseIndent(node);
	
	                checkNodesIndent(node.consequent, caseIndent + indentSize);
	            },
	
	            FunctionDeclaration(node) {
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	                if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
	                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
	                } else if (options.FunctionDeclaration.parameters !== null) {
	                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
	                }
	            },
	
	            FunctionExpression(node) {
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	                if (options.FunctionExpression.parameters === "first" && node.params.length) {
	                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
	                } else if (options.FunctionExpression.parameters !== null) {
	                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
	                }
	            },
	
	            ReturnStatement(node) {
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	
	                const firstLineIndent = getNodeIndent(node).goodChar;
	
	                // in case if return statement is wrapped in parenthesis
	                if (isWrappedInParenthesis(node)) {
	                    checkLastReturnStatementLineIndent(node, firstLineIndent);
	                } else {
	                    checkNodeIndent(node, firstLineIndent);
	                }
	            },
	
	            CallExpression(node) {
	                if (isSingleLineNode(node)) {
	                    return;
	                }
	                if (options.CallExpression.arguments === "first" && node.arguments.length) {
	                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
	                } else if (options.CallExpression.arguments !== null) {
	                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 163 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to control the style of variable initializations.
	 * @author Colin Ihrig
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is a for loop.
	 * @param {ASTNode} block - A node to check.
	 * @returns {boolean} `true` when the node is a for loop.
	 */
	function isForLoop(block) {
	    return block.type === "ForInStatement" ||
	    block.type === "ForOfStatement" ||
	    block.type === "ForStatement";
	}
	
	/**
	 * Checks whether or not a given declarator node has its initializer.
	 * @param {ASTNode} node - A declarator node to check.
	 * @returns {boolean} `true` when the node has its initializer.
	 */
	function isInitialized(node) {
	    const declaration = node.parent;
	    const block = declaration.parent;
	
	    if (isForLoop(block)) {
	        if (block.type === "ForStatement") {
	            return block.init === declaration;
	        }
	        return block.left === declaration;
	    }
	    return Boolean(node.init);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow initialization in variable declarations",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["never"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                ignoreForLoopInit: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        }
	    },
	
	    create(context) {
	
	        const MODE_ALWAYS = "always",
	            MODE_NEVER = "never";
	
	        const mode = context.options[0] || MODE_ALWAYS;
	        const params = context.options[1] || {};
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            "VariableDeclaration:exit"(node) {
	
	                const kind = node.kind,
	                    declarations = node.declarations;
	
	                for (let i = 0; i < declarations.length; ++i) {
	                    const declaration = declarations[i],
	                        id = declaration.id,
	                        initialized = isInitialized(declaration),
	                        isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
	
	                    if (id.type !== "Identifier") {
	                        continue;
	                    }
	
	                    if (mode === MODE_ALWAYS && !initialized) {
	                        context.report({
	                            node: declaration,
	                            message: "Variable '{{idName}}' should be initialized on declaration.",
	                            data: {
	                                idName: id.name
	                            }
	                        });
	                    } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
	                        context.report({
	                            node: declaration,
	                            message: "Variable '{{idName}}' should not be initialized on declaration.",
	                            data: {
	                                idName: id.name
	                            }
	                        });
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to ensure consistent quotes used in jsx syntax.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const QUOTE_SETTINGS = {
	    "prefer-double": {
	        quote: "\"",
	        description: "singlequote",
	        convert(str) {
	            return str.replace(/'/g, "\"");
	        }
	    },
	    "prefer-single": {
	        quote: "'",
	        description: "doublequote",
	        convert(str) {
	            return str.replace(/"/g, "'");
	        }
	    }
	};
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce the consistent use of either double or single quotes in JSX attributes",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: [ "prefer-single", "prefer-double" ]
	            }
	        ]
	    },
	
	    create(context) {
	        const quoteOption = context.options[0] || "prefer-double",
	            setting = QUOTE_SETTINGS[quoteOption];
	
	        /**
	         * Checks if the given string literal node uses the expected quotes
	         * @param {ASTNode} node - A string literal node.
	         * @returns {boolean} Whether or not the string literal used the expected quotes.
	         * @public
	         */
	        function usesExpectedQuotes(node) {
	            return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
	        }
	
	        return {
	            JSXAttribute(node) {
	                const attributeValue = node.value;
	
	                if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
	                    context.report({
	                        node: attributeValue,
	                        message: "Unexpected usage of {{description}}.",
	                        data: {
	                            description: setting.description
	                        },
	                        fix(fixer) {
	                            return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 165 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to specify spacing of object literal keys and values
	 * @author Brandon Mills
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether a string contains a line terminator as defined in
	 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
	 * @param {string} str String to test.
	 * @returns {boolean} True if str contains a line terminator.
	 */
	function containsLineTerminator(str) {
	    return /[\n\r\u2028\u2029]/.test(str);
	}
	
	/**
	 * Gets the last element of an array.
	 * @param {Array} arr An array.
	 * @returns {any} Last element of arr.
	 */
	function last(arr) {
	    return arr[arr.length - 1];
	}
	
	/**
	 * Checks whether a property is a member of the property group it follows.
	 * @param {ASTNode} lastMember The last Property known to be in the group.
	 * @param {ASTNode} candidate The next Property that might be in the group.
	 * @returns {boolean} True if the candidate property is part of the group.
	 */
	function continuesPropertyGroup(lastMember, candidate) {
	    const groupEndLine = lastMember.loc.start.line,
	        candidateStartLine = candidate.loc.start.line;
	
	    if (candidateStartLine - groupEndLine <= 1) {
	        return true;
	    }
	
	    // Check that the first comment is adjacent to the end of the group, the
	    // last comment is adjacent to the candidate property, and that successive
	    // comments are adjacent to each other.
	    const comments = candidate.leadingComments;
	
	    if (
	        comments &&
	        comments[0].loc.start.line - groupEndLine <= 1 &&
	        candidateStartLine - last(comments).loc.end.line <= 1
	    ) {
	        for (let i = 1; i < comments.length; i++) {
	            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    return false;
	}
	
	/**
	 * Checks whether a node is contained on a single line.
	 * @param {ASTNode} node AST Node being evaluated.
	 * @returns {boolean} True if the node is a single line.
	 */
	function isSingleLine(node) {
	    return (node.loc.end.line === node.loc.start.line);
	}
	
	/**
	 * Initializes a single option property from the configuration with defaults for undefined values
	 * @param {Object} toOptions Object to be initialized
	 * @param {Object} fromOptions Object to be initialized from
	 * @returns {Object} The object with correctly initialized options and values
	 */
	function initOptionProperty(toOptions, fromOptions) {
	    toOptions.mode = fromOptions.mode || "strict";
	
	    // Set value of beforeColon
	    if (typeof fromOptions.beforeColon !== "undefined") {
	        toOptions.beforeColon = +fromOptions.beforeColon;
	    } else {
	        toOptions.beforeColon = 0;
	    }
	
	    // Set value of afterColon
	    if (typeof fromOptions.afterColon !== "undefined") {
	        toOptions.afterColon = +fromOptions.afterColon;
	    } else {
	        toOptions.afterColon = 1;
	    }
	
	    // Set align if exists
	    if (typeof fromOptions.align !== "undefined") {
	        if (typeof fromOptions.align === "object") {
	            toOptions.align = fromOptions.align;
	        } else { // "string"
	            toOptions.align = {
	                on: fromOptions.align,
	                mode: toOptions.mode,
	                beforeColon: toOptions.beforeColon,
	                afterColon: toOptions.afterColon
	            };
	        }
	    }
	
	    return toOptions;
	}
	
	/**
	 * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
	 * @param {Object} toOptions Object to be initialized
	 * @param {Object} fromOptions Object to be initialized from
	 * @returns {Object} The object with correctly initialized options and values
	 */
	function initOptions(toOptions, fromOptions) {
	    if (typeof fromOptions.align === "object") {
	
	        // Initialize the alignment configuration
	        toOptions.align = initOptionProperty({}, fromOptions.align);
	        toOptions.align.on = fromOptions.align.on || "colon";
	        toOptions.align.mode = fromOptions.align.mode || "strict";
	
	        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));
	        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));
	
	    } else { // string or undefined
	        toOptions.multiLine = initOptionProperty({}, (fromOptions.multiLine || fromOptions));
	        toOptions.singleLine = initOptionProperty({}, (fromOptions.singleLine || fromOptions));
	
	        // If alignment options are defined in multiLine, pull them out into the general align configuration
	        if (toOptions.multiLine.align) {
	            toOptions.align = {
	                on: toOptions.multiLine.align.on,
	                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
	                beforeColon: toOptions.multiLine.align.beforeColon,
	                afterColon: toOptions.multiLine.align.afterColon
	            };
	        }
	    }
	
	    return toOptions;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const messages = {
	    key: "{{error}} space after {{computed}}key '{{key}}'.",
	    value: "{{error}} space before value for {{computed}}key '{{key}}'."
	};
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing between keys and values in object literal properties",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [{
	            anyOf: [
	                {
	                    type: "object",
	                    properties: {
	                        align: {
	                            anyOf: [
	                                {
	                                    enum: ["colon", "value"]
	                                },
	                                {
	                                    type: "object",
	                                    properties: {
	                                        mode: {
	                                            enum: ["strict", "minimum"]
	                                        },
	                                        on: {
	                                            enum: ["colon", "value"]
	                                        },
	                                        beforeColon: {
	                                            type: "boolean"
	                                        },
	                                        afterColon: {
	                                            type: "boolean"
	                                        }
	                                    },
	                                    additionalProperties: false
	                                }
	                            ]
	                        },
	                        mode: {
	                            enum: ["strict", "minimum"]
	                        },
	                        beforeColon: {
	                            type: "boolean"
	                        },
	                        afterColon: {
	                            type: "boolean"
	                        }
	                    },
	                    additionalProperties: false
	                },
	                {
	                    type: "object",
	                    properties: {
	                        singleLine: {
	                            type: "object",
	                            properties: {
	                                mode: {
	                                    enum: ["strict", "minimum"]
	                                },
	                                beforeColon: {
	                                    type: "boolean"
	                                },
	                                afterColon: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        },
	                        multiLine: {
	                            type: "object",
	                            properties: {
	                                align: {
	                                    anyOf: [
	                                        {
	                                            enum: ["colon", "value"]
	                                        },
	                                        {
	                                            type: "object",
	                                            properties: {
	                                                mode: {
	                                                    enum: ["strict", "minimum"]
	                                                },
	                                                on: {
	                                                    enum: ["colon", "value"]
	                                                },
	                                                beforeColon: {
	                                                    type: "boolean"
	                                                },
	                                                afterColon: {
	                                                    type: "boolean"
	                                                }
	                                            },
	                                            additionalProperties: false
	                                        }
	                                    ]
	                                },
	                                mode: {
	                                    enum: ["strict", "minimum"]
	                                },
	                                beforeColon: {
	                                    type: "boolean"
	                                },
	                                afterColon: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    },
	                    additionalProperties: false
	                },
	                {
	                    type: "object",
	                    properties: {
	                        singleLine: {
	                            type: "object",
	                            properties: {
	                                mode: {
	                                    enum: ["strict", "minimum"]
	                                },
	                                beforeColon: {
	                                    type: "boolean"
	                                },
	                                afterColon: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        },
	                        multiLine: {
	                            type: "object",
	                            properties: {
	                                mode: {
	                                    enum: ["strict", "minimum"]
	                                },
	                                beforeColon: {
	                                    type: "boolean"
	                                },
	                                afterColon: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        },
	                        align: {
	                            type: "object",
	                            properties: {
	                                mode: {
	                                    enum: ["strict", "minimum"]
	                                },
	                                on: {
	                                    enum: ["colon", "value"]
	                                },
	                                beforeColon: {
	                                    type: "boolean"
	                                },
	                                afterColon: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    },
	                    additionalProperties: false
	                }
	            ]
	        }]
	    },
	
	    create(context) {
	
	        /**
	         * OPTIONS
	         * "key-spacing": [2, {
	         *     beforeColon: false,
	         *     afterColon: true,
	         *     align: "colon" // Optional, or "value"
	         * }
	         */
	        const options = context.options[0] || {},
	            ruleOptions = initOptions({}, options),
	            multiLineOptions = ruleOptions.multiLine,
	            singleLineOptions = ruleOptions.singleLine,
	            alignmentOptions = ruleOptions.align || null;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Determines if the given property is key-value property.
	         * @param {ASTNode} property Property node to check.
	         * @returns {boolean} Whether the property is a key-value property.
	         */
	        function isKeyValueProperty(property) {
	            return !(
	                (property.method ||
	                property.shorthand ||
	                property.kind !== "init" || property.type !== "Property") // Could be "ExperimentalSpreadProperty" or "SpreadProperty"
	            );
	        }
	
	        /**
	         * Starting from the given a node (a property.key node here) looks forward
	         * until it finds the last token before a colon punctuator and returns it.
	         * @param {ASTNode} node The node to start looking from.
	         * @returns {ASTNode} The last token before a colon punctuator.
	         */
	        function getLastTokenBeforeColon(node) {
	            let prevNode;
	
	            while (node && (node.type !== "Punctuator" || node.value !== ":")) {
	                prevNode = node;
	                node = sourceCode.getTokenAfter(node);
	            }
	
	            return prevNode;
	        }
	
	        /**
	         * Starting from the given a node (a property.key node here) looks forward
	         * until it finds the colon punctuator and returns it.
	         * @param {ASTNode} node The node to start looking from.
	         * @returns {ASTNode} The colon punctuator.
	         */
	        function getNextColon(node) {
	
	            while (node && (node.type !== "Punctuator" || node.value !== ":")) {
	                node = sourceCode.getTokenAfter(node);
	            }
	
	            return node;
	        }
	
	        /**
	         * Gets an object literal property's key as the identifier name or string value.
	         * @param {ASTNode} property Property node whose key to retrieve.
	         * @returns {string} The property's key.
	         */
	        function getKey(property) {
	            const key = property.key;
	
	            if (property.computed) {
	                return sourceCode.getText().slice(key.range[0], key.range[1]);
	            }
	
	            return property.key.name || property.key.value;
	        }
	
	        /**
	         * Reports an appropriately-formatted error if spacing is incorrect on one
	         * side of the colon.
	         * @param {ASTNode} property Key-value pair in an object literal.
	         * @param {string} side Side being verified - either "key" or "value".
	         * @param {string} whitespace Actual whitespace string.
	         * @param {int} expected Expected whitespace length.
	         * @param {string} mode Value of the mode as "strict" or "minimum"
	         * @returns {void}
	         */
	        function report(property, side, whitespace, expected, mode) {
	            const diff = whitespace.length - expected,
	                nextColon = getNextColon(property.key),
	                tokenBeforeColon = sourceCode.getTokenBefore(nextColon),
	                tokenAfterColon = sourceCode.getTokenAfter(nextColon),
	                isKeySide = side === "key",
	                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,
	                isExtra = diff > 0,
	                diffAbs = Math.abs(diff),
	                spaces = Array(diffAbs + 1).join(" ");
	            let fix;
	
	            if ((
	                diff && mode === "strict" ||
	                diff < 0 && mode === "minimum" ||
	                diff > 0 && !expected && mode === "minimum") &&
	                !(expected && containsLineTerminator(whitespace))
	            ) {
	                if (isExtra) {
	                    let range;
	
	                    // Remove whitespace
	                    if (isKeySide) {
	                        range = [tokenBeforeColon.end, tokenBeforeColon.end + diffAbs];
	                    } else {
	                        range = [tokenAfterColon.start - diffAbs, tokenAfterColon.start];
	                    }
	                    fix = function(fixer) {
	                        return fixer.removeRange(range);
	                    };
	                } else {
	
	                    // Add whitespace
	                    if (isKeySide) {
	                        fix = function(fixer) {
	                            return fixer.insertTextAfter(tokenBeforeColon, spaces);
	                        };
	                    } else {
	                        fix = function(fixer) {
	                            return fixer.insertTextBefore(tokenAfterColon, spaces);
	                        };
	                    }
	                }
	
	                context.report({
	                    node: property[side],
	                    loc: locStart,
	                    message: messages[side],
	                    data: {
	                        error: isExtra ? "Extra" : "Missing",
	                        computed: property.computed ? "computed " : "",
	                        key: getKey(property)
	                    },
	                    fix
	                });
	            }
	        }
	
	        /**
	         * Gets the number of characters in a key, including quotes around string
	         * keys and braces around computed property keys.
	         * @param {ASTNode} property Property of on object literal.
	         * @returns {int} Width of the key.
	         */
	        function getKeyWidth(property) {
	            const startToken = sourceCode.getFirstToken(property);
	            const endToken = getLastTokenBeforeColon(property.key);
	
	            return endToken.range[1] - startToken.range[0];
	        }
	
	        /**
	         * Gets the whitespace around the colon in an object literal property.
	         * @param {ASTNode} property Property node from an object literal.
	         * @returns {Object} Whitespace before and after the property's colon.
	         */
	        function getPropertyWhitespace(property) {
	            const whitespace = /(\s*):(\s*)/.exec(sourceCode.getText().slice(
	                property.key.range[1], property.value.range[0]
	            ));
	
	            if (whitespace) {
	                return {
	                    beforeColon: whitespace[1],
	                    afterColon: whitespace[2]
	                };
	            }
	            return null;
	        }
	
	        /**
	         * Creates groups of properties.
	         * @param  {ASTNode} node ObjectExpression node being evaluated.
	         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.
	         */
	        function createGroups(node) {
	            if (node.properties.length === 1) {
	                return [node.properties];
	            }
	
	            return node.properties.reduce(function(groups, property) {
	                const currentGroup = last(groups),
	                    prev = last(currentGroup);
	
	                if (!prev || continuesPropertyGroup(prev, property)) {
	                    currentGroup.push(property);
	                } else {
	                    groups.push([property]);
	                }
	
	                return groups;
	            }, [
	                []
	            ]);
	        }
	
	        /**
	         * Verifies correct vertical alignment of a group of properties.
	         * @param {ASTNode[]} properties List of Property AST nodes.
	         * @returns {void}
	         */
	        function verifyGroupAlignment(properties) {
	            const length = properties.length,
	                widths = properties.map(getKeyWidth), // Width of keys, including quotes
	                align = alignmentOptions.on; // "value" or "colon"
	            let targetWidth = Math.max.apply(null, widths),
	                beforeColon, afterColon, mode;
	
	            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.
	                beforeColon = alignmentOptions.beforeColon;
	                afterColon = alignmentOptions.afterColon;
	                mode = alignmentOptions.mode;
	            } else {
	                beforeColon = multiLineOptions.beforeColon;
	                afterColon = multiLineOptions.afterColon;
	                mode = alignmentOptions.mode;
	            }
	
	            // Conditionally include one space before or after colon
	            targetWidth += (align === "colon" ? beforeColon : afterColon);
	
	            for (let i = 0; i < length; i++) {
	                const property = properties[i];
	                const whitespace = getPropertyWhitespace(property);
	
	                if (whitespace) { // Object literal getters/setters lack a colon
	                    const width = widths[i];
	
	                    if (align === "value") {
	                        report(property, "key", whitespace.beforeColon, beforeColon, mode);
	                        report(property, "value", whitespace.afterColon, targetWidth - width, mode);
	                    } else { // align = "colon"
	                        report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
	                        report(property, "value", whitespace.afterColon, afterColon, mode);
	                    }
	                }
	            }
	        }
	
	        /**
	         * Verifies vertical alignment, taking into account groups of properties.
	         * @param  {ASTNode} node ObjectExpression node being evaluated.
	         * @returns {void}
	         */
	        function verifyAlignment(node) {
	            createGroups(node).forEach(function(group) {
	                verifyGroupAlignment(group.filter(isKeyValueProperty));
	            });
	        }
	
	        /**
	         * Verifies spacing of property conforms to specified options.
	         * @param  {ASTNode} node Property node being evaluated.
	         * @param {Object} lineOptions Configured singleLine or multiLine options
	         * @returns {void}
	         */
	        function verifySpacing(node, lineOptions) {
	            const actual = getPropertyWhitespace(node);
	
	            if (actual) { // Object literal getters/setters lack colons
	                report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
	                report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
	            }
	        }
	
	        /**
	         * Verifies spacing of each property in a list.
	         * @param  {ASTNode[]} properties List of Property AST nodes.
	         * @returns {void}
	         */
	        function verifyListSpacing(properties) {
	            const length = properties.length;
	
	            for (let i = 0; i < length; i++) {
	                verifySpacing(properties[i], singleLineOptions);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        if (alignmentOptions) { // Verify vertical alignment
	
	            return {
	                ObjectExpression(node) {
	                    if (isSingleLine(node)) {
	                        verifyListSpacing(node.properties.filter(isKeyValueProperty));
	                    } else {
	                        verifyAlignment(node);
	                    }
	                }
	            };
	
	        } else { // Obey beforeColon and afterColon in each property as configured
	
	            return {
	                Property(node) {
	                    verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
	                }
	            };
	
	        }
	
	    }
	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to enforce spacing before and after keywords.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109),
	    keywords = __webpack_require__(148);
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const PREV_TOKEN = /^[)\]}>]$/;
	const NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/;
	const PREV_TOKEN_M = /^[)\]}>*]$/;
	const NEXT_TOKEN_M = /^[{*]$/;
	const TEMPLATE_OPEN_PAREN = /\$\{$/;
	const TEMPLATE_CLOSE_PAREN = /^\}/;
	const CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;
	const KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
	
	// check duplications.
	(function() {
	    KEYS.sort();
	    for (let i = 1; i < KEYS.length; ++i) {
	        if (KEYS[i] === KEYS[i - 1]) {
	            throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
	        }
	    }
	}());
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given token is a "Template" token ends with "${".
	 *
	 * @param {Token} token - A token to check.
	 * @returns {boolean} `true` if the token is a "Template" token ends with "${".
	 */
	function isOpenParenOfTemplate(token) {
	    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
	}
	
	/**
	 * Checks whether or not a given token is a "Template" token starts with "}".
	 *
	 * @param {Token} token - A token to check.
	 * @returns {boolean} `true` if the token is a "Template" token starts with "}".
	 */
	function isCloseParenOfTemplate(token) {
	    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before and after keywords",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    before: {type: "boolean"},
	                    after: {type: "boolean"},
	                    overrides: {
	                        type: "object",
	                        properties: KEYS.reduce(function(retv, key) {
	                            retv[key] = {
	                                type: "object",
	                                properties: {
	                                    before: {type: "boolean"},
	                                    after: {type: "boolean"}
	                                },
	                                additionalProperties: false
	                            };
	                            return retv;
	                        }, {}),
	                        additionalProperties: false
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Reports a given token if there are not space(s) before the token.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
	         *      token to check.
	         * @returns {void}
	         */
	        function expectSpaceBefore(token, pattern) {
	            pattern = pattern || PREV_TOKEN;
	
	            const prevToken = sourceCode.getTokenBefore(token);
	
	            if (prevToken &&
	                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
	                !isOpenParenOfTemplate(prevToken) &&
	                astUtils.isTokenOnSameLine(prevToken, token) &&
	                !sourceCode.isSpaceBetweenTokens(prevToken, token)
	            ) {
	                context.report({
	                    loc: token.loc.start,
	                    message: "Expected space(s) before \"{{value}}\".",
	                    data: token,
	                    fix(fixer) {
	                        return fixer.insertTextBefore(token, " ");
	                    }
	                });
	            }
	        }
	
	        /**
	         * Reports a given token if there are space(s) before the token.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
	         *      token to check.
	         * @returns {void}
	         */
	        function unexpectSpaceBefore(token, pattern) {
	            pattern = pattern || PREV_TOKEN;
	
	            const prevToken = sourceCode.getTokenBefore(token);
	
	            if (prevToken &&
	                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&
	                !isOpenParenOfTemplate(prevToken) &&
	                astUtils.isTokenOnSameLine(prevToken, token) &&
	                sourceCode.isSpaceBetweenTokens(prevToken, token)
	            ) {
	                context.report({
	                    loc: token.loc.start,
	                    message: "Unexpected space(s) before \"{{value}}\".",
	                    data: token,
	                    fix(fixer) {
	                        return fixer.removeRange([prevToken.range[1], token.range[0]]);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Reports a given token if there are not space(s) after the token.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
	         *      token to check.
	         * @returns {void}
	         */
	        function expectSpaceAfter(token, pattern) {
	            pattern = pattern || NEXT_TOKEN;
	
	            const nextToken = sourceCode.getTokenAfter(token);
	
	            if (nextToken &&
	                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
	                !isCloseParenOfTemplate(nextToken) &&
	                astUtils.isTokenOnSameLine(token, nextToken) &&
	                !sourceCode.isSpaceBetweenTokens(token, nextToken)
	            ) {
	                context.report({
	                    loc: token.loc.start,
	                    message: "Expected space(s) after \"{{value}}\".",
	                    data: token,
	                    fix(fixer) {
	                        return fixer.insertTextAfter(token, " ");
	                    }
	                });
	            }
	        }
	
	        /**
	         * Reports a given token if there are space(s) after the token.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
	         *      token to check.
	         * @returns {void}
	         */
	        function unexpectSpaceAfter(token, pattern) {
	            pattern = pattern || NEXT_TOKEN;
	
	            const nextToken = sourceCode.getTokenAfter(token);
	
	            if (nextToken &&
	                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&
	                !isCloseParenOfTemplate(nextToken) &&
	                astUtils.isTokenOnSameLine(token, nextToken) &&
	                sourceCode.isSpaceBetweenTokens(token, nextToken)
	            ) {
	                context.report({
	                    loc: token.loc.start,
	                    message: "Unexpected space(s) after \"{{value}}\".",
	                    data: token,
	                    fix(fixer) {
	                        return fixer.removeRange([token.range[1], nextToken.range[0]]);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Parses the option object and determines check methods for each keyword.
	         *
	         * @param {Object|undefined} options - The option object to parse.
	         * @returns {Object} - Normalized option object.
	         *      Keys are keywords (there are for every keyword).
	         *      Values are instances of `{"before": function, "after": function}`.
	         */
	        function parseOptions(options) {
	            const before = !options || options.before !== false;
	            const after = !options || options.after !== false;
	            const defaultValue = {
	                before: before ? expectSpaceBefore : unexpectSpaceBefore,
	                after: after ? expectSpaceAfter : unexpectSpaceAfter
	            };
	            const overrides = (options && options.overrides) || {};
	            const retv = Object.create(null);
	
	            for (let i = 0; i < KEYS.length; ++i) {
	                const key = KEYS[i];
	                const override = overrides[key];
	
	                if (override) {
	                    const thisBefore = ("before" in override) ? override.before : before;
	                    const thisAfter = ("after" in override) ? override.after : after;
	
	                    retv[key] = {
	                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
	                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
	                    };
	                } else {
	                    retv[key] = defaultValue;
	                }
	            }
	
	            return retv;
	        }
	
	        const checkMethodMap = parseOptions(context.options[0]);
	
	        /**
	         * Reports a given token if usage of spacing followed by the token is
	         * invalid.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous
	         *      token to check.
	         * @returns {void}
	         */
	        function checkSpacingBefore(token, pattern) {
	            checkMethodMap[token.value].before(token, pattern);
	        }
	
	        /**
	         * Reports a given token if usage of spacing preceded by the token is
	         * invalid.
	         *
	         * @param {Token} token - A token to report.
	         * @param {RegExp|undefined} pattern - Optional. A pattern of the next
	         *      token to check.
	         * @returns {void}
	         */
	        function checkSpacingAfter(token, pattern) {
	            checkMethodMap[token.value].after(token, pattern);
	        }
	
	        /**
	         * Reports a given token if usage of spacing around the token is invalid.
	         *
	         * @param {Token} token - A token to report.
	         * @returns {void}
	         */
	        function checkSpacingAround(token) {
	            checkSpacingBefore(token);
	            checkSpacingAfter(token);
	        }
	
	        /**
	         * Reports the first token of a given node if the first token is a keyword
	         * and usage of spacing around the token is invalid.
	         *
	         * @param {ASTNode|null} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingAroundFirstToken(node) {
	            const firstToken = node && sourceCode.getFirstToken(node);
	
	            if (firstToken && firstToken.type === "Keyword") {
	                checkSpacingAround(firstToken);
	            }
	        }
	
	        /**
	         * Reports the first token of a given node if the first token is a keyword
	         * and usage of spacing followed by the token is invalid.
	         *
	         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.
	         * Other rules are handling usage of spacing preceded by those keywords.
	         *
	         * @param {ASTNode|null} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingBeforeFirstToken(node) {
	            const firstToken = node && sourceCode.getFirstToken(node);
	
	            if (firstToken && firstToken.type === "Keyword") {
	                checkSpacingBefore(firstToken);
	            }
	        }
	
	        /**
	         * Reports the previous token of a given node if the token is a keyword and
	         * usage of spacing around the token is invalid.
	         *
	         * @param {ASTNode|null} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingAroundTokenBefore(node) {
	            if (node) {
	                let token = sourceCode.getTokenBefore(node);
	
	                while (token.type !== "Keyword") {
	                    token = sourceCode.getTokenBefore(token);
	                }
	
	                checkSpacingAround(token);
	            }
	        }
	
	        /**
	         * Reports `async` or `function` keywords of a given node if usage of
	         * spacing around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForFunction(node) {
	            const firstToken = node && sourceCode.getFirstToken(node);
	
	            if (firstToken &&
	                (firstToken.type === "Keyword" || firstToken.value === "async")
	            ) {
	                checkSpacingBefore(firstToken);
	            }
	        }
	
	        /**
	         * Reports `class` and `extends` keywords of a given node if usage of
	         * spacing around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForClass(node) {
	            checkSpacingAroundFirstToken(node);
	            checkSpacingAroundTokenBefore(node.superClass);
	        }
	
	        /**
	         * Reports `if` and `else` keywords of a given node if usage of spacing
	         * around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForIfStatement(node) {
	            checkSpacingAroundFirstToken(node);
	            checkSpacingAroundTokenBefore(node.alternate);
	        }
	
	        /**
	         * Reports `try`, `catch`, and `finally` keywords of a given node if usage
	         * of spacing around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForTryStatement(node) {
	            checkSpacingAroundFirstToken(node);
	            checkSpacingAroundFirstToken(node.handler);
	            checkSpacingAroundTokenBefore(node.finalizer);
	        }
	
	        /**
	         * Reports `do` and `while` keywords of a given node if usage of spacing
	         * around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForDoWhileStatement(node) {
	            checkSpacingAroundFirstToken(node);
	            checkSpacingAroundTokenBefore(node.test);
	        }
	
	        /**
	         * Reports `for` and `in` keywords of a given node if usage of spacing
	         * around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForForInStatement(node) {
	            checkSpacingAroundFirstToken(node);
	            checkSpacingAroundTokenBefore(node.right);
	        }
	
	        /**
	         * Reports `for` and `of` keywords of a given node if usage of spacing
	         * around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForForOfStatement(node) {
	            checkSpacingAroundFirstToken(node);
	
	            // `of` is not a keyword token.
	            let token = sourceCode.getTokenBefore(node.right);
	
	            while (token.value !== "of") {
	                token = sourceCode.getTokenBefore(token);
	            }
	            checkSpacingAround(token);
	        }
	
	        /**
	         * Reports `import`, `export`, `as`, and `from` keywords of a given node if
	         * usage of spacing around those keywords is invalid.
	         *
	         * This rule handles the `*` token in module declarations.
	         *
	         *     import*as A from "./a"; /*error Expected space(s) after "import".
	         *                               error Expected space(s) before "as".
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForModuleDeclaration(node) {
	            const firstToken = sourceCode.getFirstToken(node);
	
	            checkSpacingBefore(firstToken, PREV_TOKEN_M);
	            checkSpacingAfter(firstToken, NEXT_TOKEN_M);
	
	            if (node.source) {
	                const fromToken = sourceCode.getTokenBefore(node.source);
	
	                checkSpacingBefore(fromToken, PREV_TOKEN_M);
	                checkSpacingAfter(fromToken, NEXT_TOKEN_M);
	            }
	        }
	
	        /**
	         * Reports `as` keyword of a given node if usage of spacing around this
	         * keyword is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForImportNamespaceSpecifier(node) {
	            const asToken = sourceCode.getFirstToken(node, 1);
	
	            checkSpacingBefore(asToken, PREV_TOKEN_M);
	        }
	
	        /**
	         * Reports `static`, `get`, and `set` keywords of a given node if usage of
	         * spacing around those keywords is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForProperty(node) {
	            if (node.static) {
	                checkSpacingAroundFirstToken(node);
	            }
	            if (node.kind === "get" ||
	                node.kind === "set" ||
	                (
	                    (node.method || node.type === "MethodDefinition") &&
	                    node.value.async
	                )
	            ) {
	                const token = sourceCode.getFirstToken(
	                    node,
	                    node.static ? 1 : 0
	                );
	
	                checkSpacingAround(token);
	            }
	        }
	
	        /**
	         * Reports `await` keyword of a given node if usage of spacing before
	         * this keyword is invalid.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function checkSpacingForAwaitExpression(node) {
	            checkSpacingBefore(sourceCode.getFirstToken(node));
	        }
	
	        return {
	
	            // Statements
	            DebuggerStatement: checkSpacingAroundFirstToken,
	            WithStatement: checkSpacingAroundFirstToken,
	
	            // Statements - Control flow
	            BreakStatement: checkSpacingAroundFirstToken,
	            ContinueStatement: checkSpacingAroundFirstToken,
	            ReturnStatement: checkSpacingAroundFirstToken,
	            ThrowStatement: checkSpacingAroundFirstToken,
	            TryStatement: checkSpacingForTryStatement,
	
	            // Statements - Choice
	            IfStatement: checkSpacingForIfStatement,
	            SwitchStatement: checkSpacingAroundFirstToken,
	            SwitchCase: checkSpacingAroundFirstToken,
	
	            // Statements - Loops
	            DoWhileStatement: checkSpacingForDoWhileStatement,
	            ForInStatement: checkSpacingForForInStatement,
	            ForOfStatement: checkSpacingForForOfStatement,
	            ForStatement: checkSpacingAroundFirstToken,
	            WhileStatement: checkSpacingAroundFirstToken,
	
	            // Statements - Declarations
	            ClassDeclaration: checkSpacingForClass,
	            ExportNamedDeclaration: checkSpacingForModuleDeclaration,
	            ExportDefaultDeclaration: checkSpacingAroundFirstToken,
	            ExportAllDeclaration: checkSpacingForModuleDeclaration,
	            FunctionDeclaration: checkSpacingForFunction,
	            ImportDeclaration: checkSpacingForModuleDeclaration,
	            VariableDeclaration: checkSpacingAroundFirstToken,
	
	            // Expressions
	            ArrowFunctionExpression: checkSpacingForFunction,
	            AwaitExpression: checkSpacingForAwaitExpression,
	            ClassExpression: checkSpacingForClass,
	            FunctionExpression: checkSpacingForFunction,
	            NewExpression: checkSpacingBeforeFirstToken,
	            Super: checkSpacingBeforeFirstToken,
	            ThisExpression: checkSpacingBeforeFirstToken,
	            UnaryExpression: checkSpacingBeforeFirstToken,
	            YieldExpression: checkSpacingBeforeFirstToken,
	
	            // Others
	            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
	            MethodDefinition: checkSpacingForProperty,
	            Property: checkSpacingForProperty
	        };
	    }
	};


/***/ },
/* 167 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce the position of line comments
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce position of line comments",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["above", "beside"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            position: {
	                                enum: ["above", "beside"]
	                            },
	                            ignorePattern: {
	                                type: "string"
	                            },
	                            applyDefaultPatterns: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const DEFAULT_IGNORE_PATTERN = "^\\s*(?:eslint|jshint\\s+|jslint\\s+|istanbul\\s+|globals?\\s+|exported\\s+|jscs|falls?\\s?through)";
	        const options = context.options[0];
	
	        let above,
	            ignorePattern,
	            applyDefaultPatterns = true;
	
	        if (!options || typeof options === "string") {
	            above = !options || options === "above";
	
	        } else {
	            above = options.position === "above";
	            ignorePattern = options.ignorePattern;
	            applyDefaultPatterns = options.applyDefaultPatterns !== false;
	        }
	
	        const defaultIgnoreRegExp = new RegExp(DEFAULT_IGNORE_PATTERN);
	        const customIgnoreRegExp = new RegExp(ignorePattern);
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            LineComment(node) {
	                if (applyDefaultPatterns && defaultIgnoreRegExp.test(node.value)) {
	                    return;
	                }
	
	                if (ignorePattern && customIgnoreRegExp.test(node.value)) {
	                    return;
	                }
	
	                const previous = sourceCode.getTokenOrCommentBefore(node);
	                const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;
	
	                if (above) {
	                    if (isOnSameLine) {
	                        context.report({
	                            node,
	                            message: "Expected comment to be above code."
	                        });
	                    }
	                } else {
	                    if (!isOnSameLine) {
	                        context.report({
	                            node,
	                            message: "Expected comment to be beside code."
	                        });
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 168 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce a single linebreak style.
	 * @author Erik Mueller
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent linebreak style",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["unix", "windows"]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const EXPECTED_LF_MSG = "Expected linebreaks to be 'LF' but found 'CRLF'.",
	            EXPECTED_CRLF_MSG = "Expected linebreaks to be 'CRLF' but found 'LF'.";
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Builds a fix function that replaces text at the specified range in the source text.
	         * @param {int[]} range The range to replace
	         * @param {string} text The text to insert.
	         * @returns {Function} Fixer function
	         * @private
	         */
	        function createFix(range, text) {
	            return function(fixer) {
	                return fixer.replaceTextRange(range, text);
	            };
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: function checkForlinebreakStyle(node) {
	                const linebreakStyle = context.options[0] || "unix",
	                    expectedLF = linebreakStyle === "unix",
	                    expectedLFChars = expectedLF ? "\n" : "\r\n",
	                    source = sourceCode.getText(),
	                    pattern = /\r\n|\r|\n|\u2028|\u2029/g;
	                let match;
	
	                let i = 0;
	
	                while ((match = pattern.exec(source)) !== null) {
	                    i++;
	                    if (match[0] === expectedLFChars) {
	                        continue;
	                    }
	
	                    const index = match.index;
	                    const range = [index, index + match[0].length];
	
	                    context.report({
	                        node,
	                        loc: {
	                            line: i,
	                            column: sourceCode.lines[i - 1].length
	                        },
	                        message: expectedLF ? EXPECTED_LF_MSG : EXPECTED_CRLF_MSG,
	                        fix: createFix(range, expectedLFChars)
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Enforces empty lines around comments.
	 * @author Jamund Ferguson
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135),
	    astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Return an array with with any line numbers that are empty.
	 * @param {Array} lines An array of each line of the file.
	 * @returns {Array} An array of line numbers.
	 */
	function getEmptyLineNums(lines) {
	    const emptyLines = lines.map(function(line, i) {
	        return {
	            code: line.trim(),
	            num: i + 1
	        };
	    }).filter(function(line) {
	        return !line.code;
	    }).map(function(line) {
	        return line.num;
	    });
	
	    return emptyLines;
	}
	
	/**
	 * Return an array with with any line numbers that contain comments.
	 * @param {Array} comments An array of comment nodes.
	 * @returns {Array} An array of line numbers.
	 */
	function getCommentLineNums(comments) {
	    const lines = [];
	
	    comments.forEach(function(token) {
	        const start = token.loc.start.line;
	        const end = token.loc.end.line;
	
	        lines.push(start, end);
	    });
	    return lines;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require empty lines around comments",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    beforeBlockComment: {
	                        type: "boolean"
	                    },
	                    afterBlockComment: {
	                        type: "boolean"
	                    },
	                    beforeLineComment: {
	                        type: "boolean"
	                    },
	                    afterLineComment: {
	                        type: "boolean"
	                    },
	                    allowBlockStart: {
	                        type: "boolean"
	                    },
	                    allowBlockEnd: {
	                        type: "boolean"
	                    },
	                    allowObjectStart: {
	                        type: "boolean"
	                    },
	                    allowObjectEnd: {
	                        type: "boolean"
	                    },
	                    allowArrayStart: {
	                        type: "boolean"
	                    },
	                    allowArrayEnd: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const options = context.options[0] ? Object.assign({}, context.options[0]) : {};
	
	        options.beforeLineComment = options.beforeLineComment || false;
	        options.afterLineComment = options.afterLineComment || false;
	        options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
	        options.afterBlockComment = options.afterBlockComment || false;
	        options.allowBlockStart = options.allowBlockStart || false;
	        options.allowBlockEnd = options.allowBlockEnd || false;
	
	        const sourceCode = context.getSourceCode();
	
	        const lines = sourceCode.lines,
	            numLines = lines.length + 1,
	            comments = sourceCode.getAllComments(),
	            commentLines = getCommentLineNums(comments),
	            emptyLines = getEmptyLineNums(lines),
	            commentAndEmptyLines = commentLines.concat(emptyLines);
	
	        /**
	         * Returns whether or not a token is a comment node type
	         * @param {Token} token The token to check
	         * @returns {boolean} True if the token is a comment node
	         */
	        function isCommentNodeType(token) {
	            return token && (token.type === "Block" || token.type === "Line");
	        }
	
	        /**
	         * Returns whether or not comments are on lines starting with or ending with code
	         * @param {ASTNode} node The comment node to check.
	         * @returns {boolean} True if the comment is not alone.
	         */
	        function codeAroundComment(node) {
	            let token;
	
	            token = node;
	            do {
	                token = sourceCode.getTokenOrCommentBefore(token);
	            } while (isCommentNodeType(token));
	
	            if (token && astUtils.isTokenOnSameLine(token, node)) {
	                return true;
	            }
	
	            token = node;
	            do {
	                token = sourceCode.getTokenOrCommentAfter(token);
	            } while (isCommentNodeType(token));
	
	            if (token && astUtils.isTokenOnSameLine(node, token)) {
	                return true;
	            }
	
	            return false;
	        }
	
	        /**
	         * Returns whether or not comments are inside a node type or not.
	         * @param {ASTNode} node The Comment node.
	         * @param {ASTNode} parent The Comment parent node.
	         * @param {string} nodeType The parent type to check against.
	         * @returns {boolean} True if the comment is inside nodeType.
	         */
	        function isCommentInsideNodeType(node, parent, nodeType) {
	            return parent.type === nodeType ||
	                (parent.body && parent.body.type === nodeType) ||
	                (parent.consequent && parent.consequent.type === nodeType);
	        }
	
	        /**
	         * Returns whether or not comments are at the parent start or not.
	         * @param {ASTNode} node The Comment node.
	         * @param {string} nodeType The parent type to check against.
	         * @returns {boolean} True if the comment is at parent start.
	         */
	        function isCommentAtParentStart(node, nodeType) {
	            const ancestors = context.getAncestors();
	            let parent;
	
	            if (ancestors.length) {
	                parent = ancestors.pop();
	            }
	
	            return parent && isCommentInsideNodeType(node, parent, nodeType) &&
	                    node.loc.start.line - parent.loc.start.line === 1;
	        }
	
	        /**
	         * Returns whether or not comments are at the parent end or not.
	         * @param {ASTNode} node The Comment node.
	         * @param {string} nodeType The parent type to check against.
	         * @returns {boolean} True if the comment is at parent end.
	         */
	        function isCommentAtParentEnd(node, nodeType) {
	            const ancestors = context.getAncestors();
	            let parent;
	
	            if (ancestors.length) {
	                parent = ancestors.pop();
	            }
	
	            return parent && isCommentInsideNodeType(node, parent, nodeType) &&
	                    parent.loc.end.line - node.loc.end.line === 1;
	        }
	
	        /**
	         * Returns whether or not comments are at the block start or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at block start.
	         */
	        function isCommentAtBlockStart(node) {
	            return isCommentAtParentStart(node, "ClassBody") || isCommentAtParentStart(node, "BlockStatement") || isCommentAtParentStart(node, "SwitchCase");
	        }
	
	        /**
	         * Returns whether or not comments are at the block end or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at block end.
	         */
	        function isCommentAtBlockEnd(node) {
	            return isCommentAtParentEnd(node, "ClassBody") || isCommentAtParentEnd(node, "BlockStatement") || isCommentAtParentEnd(node, "SwitchCase") || isCommentAtParentEnd(node, "SwitchStatement");
	        }
	
	        /**
	         * Returns whether or not comments are at the object start or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at object start.
	         */
	        function isCommentAtObjectStart(node) {
	            return isCommentAtParentStart(node, "ObjectExpression") || isCommentAtParentStart(node, "ObjectPattern");
	        }
	
	        /**
	         * Returns whether or not comments are at the object end or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at object end.
	         */
	        function isCommentAtObjectEnd(node) {
	            return isCommentAtParentEnd(node, "ObjectExpression") || isCommentAtParentEnd(node, "ObjectPattern");
	        }
	
	        /**
	         * Returns whether or not comments are at the array start or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at array start.
	         */
	        function isCommentAtArrayStart(node) {
	            return isCommentAtParentStart(node, "ArrayExpression") || isCommentAtParentStart(node, "ArrayPattern");
	        }
	
	        /**
	         * Returns whether or not comments are at the array end or not.
	         * @param {ASTNode} node The Comment node.
	         * @returns {boolean} True if the comment is at array end.
	         */
	        function isCommentAtArrayEnd(node) {
	            return isCommentAtParentEnd(node, "ArrayExpression") || isCommentAtParentEnd(node, "ArrayPattern");
	        }
	
	        /**
	         * Checks if a comment node has lines around it (ignores inline comments)
	         * @param {ASTNode} node The Comment node.
	         * @param {Object} opts Options to determine the newline.
	         * @param {boolean} opts.after Should have a newline after this line.
	         * @param {boolean} opts.before Should have a newline before this line.
	         * @returns {void}
	         */
	        function checkForEmptyLine(node, opts) {
	            let after = opts.after,
	                before = opts.before;
	
	            const prevLineNum = node.loc.start.line - 1,
	                nextLineNum = node.loc.end.line + 1,
	                commentIsNotAlone = codeAroundComment(node);
	
	            const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),
	                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),
	                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),
	                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),
	                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),
	                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);
	
	            const exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;
	            const exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;
	
	            // ignore top of the file and bottom of the file
	            if (prevLineNum < 1) {
	                before = false;
	            }
	            if (nextLineNum >= numLines) {
	                after = false;
	            }
	
	            // we ignore all inline comments
	            if (commentIsNotAlone) {
	                return;
	            }
	
	            const previousTokenOrComment = sourceCode.getTokenOrCommentBefore(node);
	            const nextTokenOrComment = sourceCode.getTokenOrCommentAfter(node);
	
	            // check for newline before
	            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&
	                    !(isCommentNodeType(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, node))) {
	                const lineStart = node.range[0] - node.loc.start.column;
	                const range = [lineStart, lineStart];
	
	                context.report({
	                    node,
	                    message: "Expected line before comment.",
	                    fix(fixer) {
	                        return fixer.insertTextBeforeRange(range, "\n");
	                    }
	                });
	            }
	
	            // check for newline after
	            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&
	                    !(isCommentNodeType(nextTokenOrComment) && astUtils.isTokenOnSameLine(node, nextTokenOrComment))) {
	                context.report({
	                    node,
	                    message: "Expected line after comment.",
	                    fix(fixer) {
	                        return fixer.insertTextAfter(node, "\n");
	                    }
	                });
	            }
	
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            LineComment(node) {
	                if (options.beforeLineComment || options.afterLineComment) {
	                    checkForEmptyLine(node, {
	                        after: options.afterLineComment,
	                        before: options.beforeLineComment
	                    });
	                }
	            },
	
	            BlockComment(node) {
	                if (options.beforeBlockComment || options.afterBlockComment) {
	                    checkForEmptyLine(node, {
	                        after: options.afterBlockComment,
	                        before: options.beforeBlockComment
	                    });
	                }
	            }
	
	        };
	    }
	};


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Require or disallow newlines around directives.
	 * @author Kai Cataldo
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow newlines around directives",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        schema: [{
	            oneOf: [
	                {
	                    enum: ["always", "never"]
	                },
	                {
	                    type: "object",
	                    properties: {
	                        before: {
	                            enum: ["always", "never"]
	                        },
	                        after: {
	                            enum: ["always", "never"]
	                        },
	                    },
	                    additionalProperties: false,
	                    minProperties: 2
	                }
	            ]
	        }],
	        fixable: "whitespace"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const config = context.options[0] || "always";
	        const expectLineBefore = typeof config === "string" ? config : config.before;
	        const expectLineAfter = typeof config === "string" ? config : config.after;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Check if node is preceded by a blank newline.
	         * @param {ASTNode} node Node to check.
	         * @returns {boolean} Whether or not the passed in node is preceded by a blank newline.
	         */
	        function hasNewlineBefore(node) {
	            const tokenBefore = sourceCode.getTokenOrCommentBefore(node);
	            const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
	
	            return node.loc.start.line - tokenLineBefore >= 2;
	        }
	
	        /**
	         * Check if node is followed by a blank newline.
	         * @param {ASTNode} node Node to check.
	         * @returns {boolean} Whether or not the passed in node is followed by a blank newline.
	         */
	        function hasNewlineAfter(node) {
	            const tokenAfter = sourceCode.getTokenOrCommentAfter(node);
	
	            return tokenAfter.loc.start.line - node.loc.end.line >= 2;
	        }
	
	        /**
	         * Report errors for newlines around directives.
	         * @param {ASTNode} node Node to check.
	         * @param {string} location Whether the error was found before or after the directive.
	         * @param {boolean} expected Whether or not a newline was expected or unexpected.
	         * @returns {void}
	         */
	        function reportError(node, location, expected) {
	            context.report({
	                node,
	                message: "{{expected}} newline {{location}} \"{{value}}\" directive.",
	                data: {
	                    expected: expected ? "Expected" : "Unexpected",
	                    value: node.expression.value,
	                    location
	                },
	                fix(fixer) {
	                    if (expected) {
	                        return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(node, "\n");
	                    }
	                    return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [node.range[1], node.range[1] + 1]);
	                }
	            });
	        }
	
	        /**
	         * Check lines around directives in node
	         * @param {ASTNode} node - node to check
	         * @returns {void}
	         */
	        function checkDirectives(node) {
	            const directives = astUtils.getDirectivePrologue(node);
	
	            if (!directives.length) {
	                return;
	            }
	
	            const firstDirective = directives[0];
	            const hasTokenOrCommentBefore = !!sourceCode.getTokenOrCommentBefore(firstDirective);
	
	            // Only check before the first directive if it is preceded by a comment or if it is at the top of
	            // the file and expectLineBefore is set to "never". This is to not force a newline at the top of
	            // the file if there are no comments as well as for compatibility with padded-blocks.
	            if (
	                firstDirective.leadingComments && firstDirective.leadingComments.length ||
	
	                // Shebangs are not added to leading comments but are accounted for by the following.
	                node.type === "Program" && hasTokenOrCommentBefore
	            ) {
	                if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
	                    reportError(firstDirective, "before", true);
	                }
	
	                if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
	                    reportError(firstDirective, "before", false);
	                }
	            } else if (
	                node.type === "Program" &&
	                expectLineBefore === "never" &&
	                !hasTokenOrCommentBefore &&
	                hasNewlineBefore(firstDirective)
	            ) {
	                reportError(firstDirective, "before", false);
	            }
	
	            const lastDirective = directives[directives.length - 1];
	            const statements = node.type === "Program" ? node.body : node.body.body;
	
	            // Do not check after the last directive if the body only
	            // contains a directive prologue and isn't followed by a comment to ensure
	            // this rule behaves well with padded-blocks.
	            if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
	                return;
	            }
	
	            if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
	                reportError(lastDirective, "after", true);
	            }
	
	            if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
	                reportError(lastDirective, "after", false);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: checkDirectives,
	            FunctionDeclaration: checkDirectives,
	            FunctionExpression: checkDirectives,
	            ArrowFunctionExpression: checkDirectives
	        };
	    }
	};


/***/ },
/* 171 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to set the maximum depth block can be nested in a function.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum depth that blocks can be nested",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            maximum: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const functionStack = [],
	            option = context.options[0];
	        let maxDepth = 4;
	
	        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
	            maxDepth = option.maximum;
	        }
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            maxDepth = option.max;
	        }
	        if (typeof option === "number") {
	            maxDepth = option;
	        }
	
	        /**
	         * When parsing a new function, store it in our function stack
	         * @returns {void}
	         * @private
	         */
	        function startFunction() {
	            functionStack.push(0);
	        }
	
	        /**
	         * When parsing is done then pop out the reference
	         * @returns {void}
	         * @private
	         */
	        function endFunction() {
	            functionStack.pop();
	        }
	
	        /**
	         * Save the block and Evaluate the node
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function pushBlock(node) {
	            const len = ++functionStack[functionStack.length - 1];
	
	            if (len > maxDepth) {
	                context.report(node, "Blocks are nested too deeply ({{depth}}).",
	                        { depth: len });
	            }
	        }
	
	        /**
	         * Pop the saved block
	         * @returns {void}
	         * @private
	         */
	        function popBlock() {
	            functionStack[functionStack.length - 1]--;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: startFunction,
	            FunctionDeclaration: startFunction,
	            FunctionExpression: startFunction,
	            ArrowFunctionExpression: startFunction,
	
	            IfStatement(node) {
	                if (node.parent.type !== "IfStatement") {
	                    pushBlock(node);
	                }
	            },
	            SwitchStatement: pushBlock,
	            TryStatement: pushBlock,
	            DoWhileStatement: pushBlock,
	            WhileStatement: pushBlock,
	            WithStatement: pushBlock,
	            ForStatement: pushBlock,
	            ForInStatement: pushBlock,
	            ForOfStatement: pushBlock,
	
	            "IfStatement:exit": popBlock,
	            "SwitchStatement:exit": popBlock,
	            "TryStatement:exit": popBlock,
	            "DoWhileStatement:exit": popBlock,
	            "WhileStatement:exit": popBlock,
	            "WithStatement:exit": popBlock,
	            "ForStatement:exit": popBlock,
	            "ForInStatement:exit": popBlock,
	            "ForOfStatement:exit": popBlock,
	
	            "FunctionDeclaration:exit": endFunction,
	            "FunctionExpression:exit": endFunction,
	            "ArrowFunctionExpression:exit": endFunction,
	            "Program:exit": endFunction
	        };
	
	    }
	};


/***/ },
/* 172 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for max length on a line.
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const OPTIONS_SCHEMA = {
	    type: "object",
	    properties: {
	        code: {
	            type: "integer",
	            minimum: 0
	        },
	        comments: {
	            type: "integer",
	            minimum: 0
	        },
	        tabWidth: {
	            type: "integer",
	            minimum: 0
	        },
	        ignorePattern: {
	            type: "string"
	        },
	        ignoreComments: {
	            type: "boolean"
	        },
	        ignoreStrings: {
	            type: "boolean"
	        },
	        ignoreUrls: {
	            type: "boolean"
	        },
	        ignoreTemplateLiterals: {
	            type: "boolean"
	        },
	        ignoreRegExpLiterals: {
	            type: "boolean"
	        },
	        ignoreTrailingComments: {
	            type: "boolean"
	        }
	    },
	    additionalProperties: false
	};
	
	const OPTIONS_OR_INTEGER_SCHEMA = {
	    anyOf: [
	        OPTIONS_SCHEMA,
	        {
	            type: "integer",
	            minimum: 0
	        }
	    ]
	};
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum line length",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            OPTIONS_OR_INTEGER_SCHEMA,
	            OPTIONS_OR_INTEGER_SCHEMA,
	            OPTIONS_SCHEMA
	        ]
	    },
	
	    create(context) {
	
	        /*
	         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:
	         * - They're matching an entire string that we know is a URI
	         * - We're matching part of a string where we think there *might* be a URL
	         * - We're only concerned about URLs, as picking out any URI would cause
	         *   too many false positives
	         * - We don't care about matching the entire URL, any small segment is fine
	         */
	        const URL_REGEXP = /[^:/?#]:\/\/[^?#]/;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Computes the length of a line that may contain tabs. The width of each
	         * tab will be the number of spaces to the next tab stop.
	         * @param {string} line The line.
	         * @param {int} tabWidth The width of each tab stop in spaces.
	         * @returns {int} The computed line length.
	         * @private
	         */
	        function computeLineLength(line, tabWidth) {
	            let extraCharacterCount = 0;
	
	            line.replace(/\t/g, function(match, offset) {
	                const totalOffset = offset + extraCharacterCount,
	                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,
	                    spaceCount = tabWidth - previousTabStopOffset;
	
	                extraCharacterCount += spaceCount - 1;  // -1 for the replaced tab
	            });
	            return Array.from(line).length + extraCharacterCount;
	        }
	
	        // The options object must be the last option specified
	        const lastOption = context.options[context.options.length - 1];
	        const options = typeof lastOption === "object" ? Object.create(lastOption) : {};
	
	        // but max code length
	        if (typeof context.options[0] === "number") {
	            options.code = context.options[0];
	        }
	
	        // and tabWidth can be optionally specified directly as integers.
	        if (typeof context.options[1] === "number") {
	            options.tabWidth = context.options[1];
	        }
	
	        const maxLength = options.code || 80,
	            tabWidth = options.tabWidth || 4,
	            ignoreComments = options.ignoreComments || false,
	            ignoreStrings = options.ignoreStrings || false,
	            ignoreTemplateLiterals = options.ignoreTemplateLiterals || false,
	            ignoreRegExpLiterals = options.ignoreRegExpLiterals || false,
	            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,
	            ignoreUrls = options.ignoreUrls || false,
	            maxCommentLength = options.comments;
	        let ignorePattern = options.ignorePattern || null;
	
	        if (ignorePattern) {
	            ignorePattern = new RegExp(ignorePattern);
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Tells if a given comment is trailing: it starts on the current line and
	         * extends to or past the end of the current line.
	         * @param {string} line The source line we want to check for a trailing comment on
	         * @param {number} lineNumber The one-indexed line number for line
	         * @param {ASTNode} comment The comment to inspect
	         * @returns {boolean} If the comment is trailing on the given line
	         */
	        function isTrailingComment(line, lineNumber, comment) {
	            return comment &&
	                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&
	                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
	        }
	
	        /**
	         * Tells if a comment encompasses the entire line.
	         * @param {string} line The source line with a trailing comment
	         * @param {number} lineNumber The one-indexed line number this is on
	         * @param {ASTNode} comment The comment to remove
	         * @returns {boolean} If the comment covers the entire line
	         */
	        function isFullLineComment(line, lineNumber, comment) {
	            const start = comment.loc.start,
	                end = comment.loc.end,
	                isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
	
	            return comment &&
	                (start.line < lineNumber || (start.line === lineNumber && isFirstTokenOnLine)) &&
	                (end.line > lineNumber || (end.line === lineNumber && end.column === line.length));
	        }
	
	        /**
	         * Gets the line after the comment and any remaining trailing whitespace is
	         * stripped.
	         * @param {string} line The source line with a trailing comment
	         * @param {number} lineNumber The one-indexed line number this is on
	         * @param {ASTNode} comment The comment to remove
	         * @returns {string} Line without comment and trailing whitepace
	         */
	        function stripTrailingComment(line, lineNumber, comment) {
	
	            // loc.column is zero-indexed
	            return line.slice(0, comment.loc.start.column).replace(/\s+$/, "");
	        }
	
	        /**
	         * Ensure that an array exists at [key] on `object`, and add `value` to it.
	         *
	         * @param {Object} object the object to mutate
	         * @param {string} key the object's key
	         * @param {*} value the value to add
	         * @returns {void}
	         * @private
	         */
	        function ensureArrayAndPush(object, key, value) {
	            if (!Array.isArray(object[key])) {
	                object[key] = [];
	            }
	            object[key].push(value);
	        }
	
	        /**
	         * Retrieves an array containing all strings (" or ') in the source code.
	         *
	         * @returns {ASTNode[]} An array of string nodes.
	         */
	        function getAllStrings() {
	            return sourceCode.ast.tokens.filter(function(token) {
	                return token.type === "String";
	            });
	        }
	
	        /**
	         * Retrieves an array containing all template literals in the source code.
	         *
	         * @returns {ASTNode[]} An array of template literal nodes.
	         */
	        function getAllTemplateLiterals() {
	            return sourceCode.ast.tokens.filter(function(token) {
	                return token.type === "Template";
	            });
	        }
	
	
	        /**
	         * Retrieves an array containing all RegExp literals in the source code.
	         *
	         * @returns {ASTNode[]} An array of RegExp literal nodes.
	         */
	        function getAllRegExpLiterals() {
	            return sourceCode.ast.tokens.filter(function(token) {
	                return token.type === "RegularExpression";
	            });
	        }
	
	
	        /**
	         * A reducer to group an AST node by line number, both start and end.
	         *
	         * @param {Object} acc the accumulator
	         * @param {ASTNode} node the AST node in question
	         * @returns {Object} the modified accumulator
	         * @private
	         */
	        function groupByLineNumber(acc, node) {
	            for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {
	                ensureArrayAndPush(acc, i, node);
	            }
	            return acc;
	        }
	
	        /**
	         * Check the program for max length
	         * @param {ASTNode} node Node to examine
	         * @returns {void}
	         * @private
	         */
	        function checkProgramForMaxLength(node) {
	
	            // split (honors line-ending)
	            const lines = sourceCode.lines,
	
	                // list of comments to ignore
	                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [];
	
	                // we iterate over comments in parallel with the lines
	            let commentsIndex = 0;
	
	            const strings = getAllStrings(sourceCode);
	            const stringsByLine = strings.reduce(groupByLineNumber, {});
	
	            const templateLiterals = getAllTemplateLiterals(sourceCode);
	            const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});
	
	            const regExpLiterals = getAllRegExpLiterals(sourceCode);
	            const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});
	
	            lines.forEach(function(line, i) {
	
	                // i is zero-indexed, line numbers are one-indexed
	                const lineNumber = i + 1;
	
	                /*
	                 * if we're checking comment length; we need to know whether this
	                 * line is a comment
	                 */
	                let lineIsComment = false;
	
	                /*
	                 * We can short-circuit the comment checks if we're already out of
	                 * comments to check.
	                 */
	                if (commentsIndex < comments.length) {
	                    let comment = null;
	
	                    // iterate over comments until we find one past the current line
	                    do {
	                        comment = comments[++commentsIndex];
	                    } while (comment && comment.loc.start.line <= lineNumber);
	
	                    // and step back by one
	                    comment = comments[--commentsIndex];
	
	                    if (isFullLineComment(line, lineNumber, comment)) {
	                        lineIsComment = true;
	                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
	                        line = stripTrailingComment(line, lineNumber, comment);
	                    }
	                }
	                if (ignorePattern && ignorePattern.test(line) ||
	                    ignoreUrls && URL_REGEXP.test(line) ||
	                    ignoreStrings && stringsByLine[lineNumber] ||
	                    ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] ||
	                    ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]
	                ) {
	
	                    // ignore this line
	                    return;
	                }
	
	                const lineLength = computeLineLength(line, tabWidth);
	
	                if (lineIsComment && ignoreComments) {
	                    return;
	                }
	
	                if (lineIsComment && lineLength > maxCommentLength) {
	                    context.report({
	                        node,
	                        loc: { line: lineNumber, column: 0 },
	                        message: "Line {{lineNumber}} exceeds the maximum comment line length of {{maxCommentLength}}.",
	                        data: {
	                            lineNumber: i + 1,
	                            maxCommentLength
	                        }
	                    });
	                } else if (lineLength > maxLength) {
	                    context.report({
	                        node,
	                        loc: { line: lineNumber, column: 0 },
	                        message: "Line {{lineNumber}} exceeds the maximum line length of {{maxLength}}.",
	                        data: {
	                            lineNumber: i + 1,
	                            maxLength
	                        }
	                    });
	                }
	            });
	        }
	
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: checkProgramForMaxLength
	        };
	
	    }
	};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview enforce a maximum file length
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum number of lines per file",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            skipComments: {
	                                type: "boolean"
	                            },
	                            skipBlankLines: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const option = context.options[0];
	        let max = 300;
	
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            max = option.max;
	        }
	
	        if (typeof option === "number") {
	            max = option;
	        }
	
	        const skipComments = option && option.skipComments;
	        const skipBlankLines = option && option.skipBlankLines;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Returns whether or not a token is a comment node type
	         * @param {Token} token The token to check
	         * @returns {boolean} True if the token is a comment node
	         */
	        function isCommentNodeType(token) {
	            return token && (token.type === "Block" || token.type === "Line");
	        }
	
	        /**
	         * Returns the line numbers of a comment that don't have any code on the same line
	         * @param {Node} comment The comment node to check
	         * @returns {int[]} The line numbers
	         */
	        function getLinesWithoutCode(comment) {
	            let start = comment.loc.start.line;
	            let end = comment.loc.end.line;
	
	            let token;
	
	            token = comment;
	            do {
	                token = sourceCode.getTokenOrCommentBefore(token);
	            } while (isCommentNodeType(token));
	
	            if (token && astUtils.isTokenOnSameLine(token, comment)) {
	                start += 1;
	            }
	
	            token = comment;
	            do {
	                token = sourceCode.getTokenOrCommentAfter(token);
	            } while (isCommentNodeType(token));
	
	            if (token && astUtils.isTokenOnSameLine(comment, token)) {
	                end -= 1;
	            }
	
	            if (start <= end) {
	                return lodash.range(start, end + 1);
	            }
	            return [];
	        }
	
	        return {
	            "Program:exit"() {
	                let lines = sourceCode.lines.map(function(text, i) {
	                    return { lineNumber: i + 1, text };
	                });
	
	                if (skipBlankLines) {
	                    lines = lines.filter(function(l) {
	                        return l.text.trim() !== "";
	                    });
	                }
	
	                if (skipComments) {
	                    const comments = sourceCode.getAllComments();
	
	                    const commentLines = lodash.flatten(comments.map(function(comment) {
	                        return getLinesWithoutCode(comment);
	                    }));
	
	                    lines = lines.filter(function(l) {
	                        return !lodash.includes(commentLines, l.lineNumber);
	                    });
	                }
	
	                if (lines.length > max) {
	                    context.report({
	                        loc: { line: 1, column: 0 },
	                        message: "File must be at most {{max}} lines long. It's {{actual}} lines long.",
	                        data: {
	                            max,
	                            actual: lines.length,
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 174 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce a maximum number of nested callbacks.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum depth that callbacks can be nested",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            maximum: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Constants
	        //--------------------------------------------------------------------------
	        const option = context.options[0];
	        let THRESHOLD = 10;
	
	        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
	            THRESHOLD = option.maximum;
	        }
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            THRESHOLD = option.max;
	        }
	        if (typeof option === "number") {
	            THRESHOLD = option;
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const callbackStack = [];
	
	        /**
	         * Checks a given function node for too many callbacks.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkFunction(node) {
	            const parent = node.parent;
	
	            if (parent.type === "CallExpression") {
	                callbackStack.push(node);
	            }
	
	            if (callbackStack.length > THRESHOLD) {
	                const opts = {num: callbackStack.length, max: THRESHOLD};
	
	                context.report(node, "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}.", opts);
	            }
	        }
	
	        /**
	         * Pops the call stack.
	         * @returns {void}
	         * @private
	         */
	        function popStack() {
	            callbackStack.pop();
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            ArrowFunctionExpression: checkFunction,
	            "ArrowFunctionExpression:exit": popStack,
	
	            FunctionExpression: checkFunction,
	            "FunctionExpression:exit": popStack
	        };
	
	    }
	};


/***/ },
/* 175 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when a function has too many parameters
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum number of parameters in function definitions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            maximum: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const option = context.options[0];
	        let numParams = 3;
	
	        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
	            numParams = option.maximum;
	        }
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            numParams = option.max;
	        }
	        if (typeof option === "number") {
	            numParams = option;
	        }
	
	        /**
	         * Checks a function to see if it has too many parameters.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkFunction(node) {
	            if (node.params.length > numParams) {
	                context.report(node, "This function has too many parameters ({{count}}). Maximum allowed is {{max}}.", {
	                    count: node.params.length,
	                    max: numParams
	                });
	            }
	        }
	
	        return {
	            FunctionDeclaration: checkFunction,
	            ArrowFunctionExpression: checkFunction,
	            FunctionExpression: checkFunction
	        };
	
	    }
	};


/***/ },
/* 176 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Specify the maximum number of statements allowed per line.
	 * @author Kenneth Williams
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum number of statements allowed per line",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    max: {
	                        type: "integer",
	                        minimum: 1
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const sourceCode = context.getSourceCode(),
	            options = context.options[0] || {},
	            maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1,
	            message = "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}.";
	
	        let lastStatementLine = 0,
	            numberOfStatementsOnThisLine = 0,
	            firstExtraStatement;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;
	
	        /**
	         * Reports with the first extra statement, and clears it.
	         *
	         * @returns {void}
	         */
	        function reportFirstExtraStatementAndClear() {
	            if (firstExtraStatement) {
	                context.report({
	                    node: firstExtraStatement,
	                    message,
	                    data: {
	                        numberOfStatementsOnThisLine,
	                        maxStatementsPerLine,
	                        statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements",
	                    }
	                });
	            }
	            firstExtraStatement = null;
	        }
	
	        /**
	         * Gets the actual last token of a given node.
	         *
	         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.
	         * @returns {Token} The actual last token.
	         */
	        function getActualLastToken(node) {
	            let lastToken = sourceCode.getLastToken(node);
	
	            if (lastToken.value === ";") {
	                lastToken = sourceCode.getTokenBefore(lastToken);
	            }
	            return lastToken;
	        }
	
	        /**
	         * Addresses a given node.
	         * It updates the state of this rule, then reports the node if the node violated this rule.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {void}
	         */
	        function enterStatement(node) {
	            const line = node.loc.start.line;
	
	            // Skip to allow non-block statements if this is direct child of control statements.
	            // `if (a) foo();` is counted as 1.
	            // But `if (a) foo(); else foo();` should be counted as 2.
	            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&
	                node.parent.alternate !== node
	            ) {
	                return;
	            }
	
	            // Update state.
	            if (line === lastStatementLine) {
	                numberOfStatementsOnThisLine += 1;
	            } else {
	                reportFirstExtraStatementAndClear();
	                numberOfStatementsOnThisLine = 1;
	                lastStatementLine = line;
	            }
	
	            // Reports if the node violated this rule.
	            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
	                firstExtraStatement = firstExtraStatement || node;
	            }
	        }
	
	        /**
	         * Updates the state of this rule with the end line of leaving node to check with the next statement.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {void}
	         */
	        function leaveStatement(node) {
	            const line = getActualLastToken(node).loc.end.line;
	
	            // Update state.
	            if (line !== lastStatementLine) {
	                reportFirstExtraStatementAndClear();
	                numberOfStatementsOnThisLine = 1;
	                lastStatementLine = line;
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            BreakStatement: enterStatement,
	            ClassDeclaration: enterStatement,
	            ContinueStatement: enterStatement,
	            DebuggerStatement: enterStatement,
	            DoWhileStatement: enterStatement,
	            ExpressionStatement: enterStatement,
	            ForInStatement: enterStatement,
	            ForOfStatement: enterStatement,
	            ForStatement: enterStatement,
	            FunctionDeclaration: enterStatement,
	            IfStatement: enterStatement,
	            ImportDeclaration: enterStatement,
	            LabeledStatement: enterStatement,
	            ReturnStatement: enterStatement,
	            SwitchStatement: enterStatement,
	            ThrowStatement: enterStatement,
	            TryStatement: enterStatement,
	            VariableDeclaration: enterStatement,
	            WhileStatement: enterStatement,
	            WithStatement: enterStatement,
	            ExportNamedDeclaration: enterStatement,
	            ExportDefaultDeclaration: enterStatement,
	            ExportAllDeclaration: enterStatement,
	
	            "BreakStatement:exit": leaveStatement,
	            "ClassDeclaration:exit": leaveStatement,
	            "ContinueStatement:exit": leaveStatement,
	            "DebuggerStatement:exit": leaveStatement,
	            "DoWhileStatement:exit": leaveStatement,
	            "ExpressionStatement:exit": leaveStatement,
	            "ForInStatement:exit": leaveStatement,
	            "ForOfStatement:exit": leaveStatement,
	            "ForStatement:exit": leaveStatement,
	            "FunctionDeclaration:exit": leaveStatement,
	            "IfStatement:exit": leaveStatement,
	            "ImportDeclaration:exit": leaveStatement,
	            "LabeledStatement:exit": leaveStatement,
	            "ReturnStatement:exit": leaveStatement,
	            "SwitchStatement:exit": leaveStatement,
	            "ThrowStatement:exit": leaveStatement,
	            "TryStatement:exit": leaveStatement,
	            "VariableDeclaration:exit": leaveStatement,
	            "WhileStatement:exit": leaveStatement,
	            "WithStatement:exit": leaveStatement,
	            "ExportNamedDeclaration:exit": leaveStatement,
	            "ExportDefaultDeclaration:exit": leaveStatement,
	            "ExportAllDeclaration:exit": leaveStatement,
	            "Program:exit": reportFirstExtraStatementAndClear
	        };
	    }
	};


/***/ },
/* 177 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to set the maximum number of statements in a function.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce a maximum number of statements allowed in function blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            maximum: {
	                                type: "integer",
	                                minimum: 0
	                            },
	                            max: {
	                                type: "integer",
	                                minimum: 0
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            },
	            {
	                type: "object",
	                properties: {
	                    ignoreTopLevelFunctions: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const functionStack = [],
	            option = context.options[0],
	            ignoreTopLevelFunctions = context.options[1] && context.options[1].ignoreTopLevelFunctions || false,
	            topLevelFunctions = [];
	        let maxStatements = 10;
	
	        if (typeof option === "object" && option.hasOwnProperty("maximum") && typeof option.maximum === "number") {
	            maxStatements = option.maximum;
	        }
	        if (typeof option === "object" && option.hasOwnProperty("max") && typeof option.max === "number") {
	            maxStatements = option.max;
	        }
	        if (typeof option === "number") {
	            maxStatements = option;
	        }
	
	        /**
	         * Reports a node if it has too many statements
	         * @param {ASTNode} node node to evaluate
	         * @param {int} count Number of statements in node
	         * @param {int} max Maximum number of statements allowed
	         * @returns {void}
	         * @private
	         */
	        function reportIfTooManyStatements(node, count, max) {
	            if (count > max) {
	                context.report(
	                    node,
	                    "This function has too many statements ({{count}}). Maximum allowed is {{max}}.",
	                    { count, max });
	            }
	        }
	
	        /**
	         * When parsing a new function, store it in our function stack
	         * @returns {void}
	         * @private
	         */
	        function startFunction() {
	            functionStack.push(0);
	        }
	
	        /**
	         * Evaluate the node at the end of function
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function endFunction(node) {
	            const count = functionStack.pop();
	
	            if (ignoreTopLevelFunctions && functionStack.length === 0) {
	                topLevelFunctions.push({ node, count});
	            } else {
	                reportIfTooManyStatements(node, count, maxStatements);
	            }
	        }
	
	        /**
	         * Increment the count of the functions
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function countStatements(node) {
	            functionStack[functionStack.length - 1] += node.body.length;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            FunctionDeclaration: startFunction,
	            FunctionExpression: startFunction,
	            ArrowFunctionExpression: startFunction,
	
	            BlockStatement: countStatements,
	
	            "FunctionDeclaration:exit": endFunction,
	            "FunctionExpression:exit": endFunction,
	            "ArrowFunctionExpression:exit": endFunction,
	
	            "Program:exit"() {
	                if (topLevelFunctions.length === 1) {
	                    return;
	                }
	
	                topLevelFunctions.forEach(function(element) {
	                    const count = element.count;
	                    const node = element.node;
	
	                    reportIfTooManyStatements(node, count, maxStatements);
	                });
	            }
	        };
	
	    }
	};


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Enforce newlines between operands of ternary expressions
	 * @author Kai Cataldo
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce newlines between operands of ternary expressions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	        const multiline = context.options[0] !== "never";
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Tests whether node is preceded by supplied tokens
	         * @param {ASTNode} node - node to check
	         * @param {ASTNode} parentNode - parent of node to report
	         * @param {boolean} expected - whether newline was expected or not
	         * @returns {void}
	         * @private
	         */
	        function reportError(node, parentNode, expected) {
	            context.report({
	                node,
	                message: "{{expected}} newline between {{typeOfError}} of ternary expression.",
	                data: {
	                    expected: expected ? "Expected" : "Unexpected",
	                    typeOfError: node === parentNode.test ? "test and consequent" : "consequent and alternate"
	                }
	            });
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ConditionalExpression(node) {
	                const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(node.test, node.consequent);
	                const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(node.consequent, node.alternate);
	
	                if (!multiline) {
	                    if (!areTestAndConsequentOnSameLine) {
	                        reportError(node.test, node, false);
	                    }
	
	                    if (!areConsequentAndAlternateOnSameLine) {
	                        reportError(node.consequent, node, false);
	                    }
	                } else {
	                    if (areTestAndConsequentOnSameLine) {
	                        reportError(node.test, node, true);
	                    }
	
	                    if (areConsequentAndAlternateOnSameLine) {
	                        reportError(node.consequent, node, true);
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 179 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of constructors without capital letters
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const CAPS_ALLOWED = [
	    "Array",
	    "Boolean",
	    "Date",
	    "Error",
	    "Function",
	    "Number",
	    "Object",
	    "RegExp",
	    "String",
	    "Symbol"
	];
	
	/**
	 * Ensure that if the key is provided, it must be an array.
	 * @param {Object} obj Object to check with `key`.
	 * @param {string} key Object key to check on `obj`.
	 * @param {*} fallback If obj[key] is not present, this will be returned.
	 * @returns {string[]} Returns obj[key] if it's an Array, otherwise `fallback`
	 */
	function checkArray(obj, key, fallback) {
	
	    /* istanbul ignore if */
	    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
	        throw new TypeError(`${key}, if provided, must be an Array`);
	    }
	    return obj[key] || fallback;
	}
	
	/**
	 * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
	 * @param {Object} map Accumulator object for the reduce.
	 * @param {string} key Object key to set to `true`.
	 * @returns {Object} Returns the updated Object for further reduction.
	 */
	function invert(map, key) {
	    map[key] = true;
	    return map;
	}
	
	/**
	 * Creates an object with the cap is new exceptions as its keys and true as their values.
	 * @param {Object} config Rule configuration
	 * @returns {Object} Object with cap is new exceptions.
	 */
	function calculateCapIsNewExceptions(config) {
	    let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);
	
	    if (capIsNewExceptions !== CAPS_ALLOWED) {
	        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
	    }
	
	    return capIsNewExceptions.reduce(invert, {});
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require constructor names to begin with a capital letter",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    newIsCap: {
	                        type: "boolean"
	                    },
	                    capIsNew: {
	                        type: "boolean"
	                    },
	                    newIsCapExceptions: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    newIsCapExceptionPattern: {
	                        type: "string"
	                    },
	                    capIsNewExceptions: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    capIsNewExceptionPattern: {
	                        type: "string"
	                    },
	                    properties: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const config = context.options[0] ? Object.assign({}, context.options[0]) : {};
	
	        config.newIsCap = config.newIsCap !== false;
	        config.capIsNew = config.capIsNew !== false;
	        const skipProperties = config.properties === false;
	
	        const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
	        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern) : null;
	
	        const capIsNewExceptions = calculateCapIsNewExceptions(config);
	        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern) : null;
	
	        const listeners = {};
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Get exact callee name from expression
	         * @param {ASTNode} node CallExpression or NewExpression node
	         * @returns {string} name
	         */
	        function extractNameFromExpression(node) {
	
	            let name = "";
	
	            if (node.callee.type === "MemberExpression") {
	                const property = node.callee.property;
	
	                if (property.type === "Literal" && (typeof property.value === "string")) {
	                    name = property.value;
	                } else if (property.type === "Identifier" && !node.callee.computed) {
	                    name = property.name;
	                }
	            } else {
	                name = node.callee.name;
	            }
	            return name;
	        }
	
	        /**
	         * Returns the capitalization state of the string -
	         * Whether the first character is uppercase, lowercase, or non-alphabetic
	         * @param {string} str String
	         * @returns {string} capitalization state: "non-alpha", "lower", or "upper"
	         */
	        function getCap(str) {
	            const firstChar = str.charAt(0);
	
	            const firstCharLower = firstChar.toLowerCase();
	            const firstCharUpper = firstChar.toUpperCase();
	
	            if (firstCharLower === firstCharUpper) {
	
	                // char has no uppercase variant, so it's non-alphabetic
	                return "non-alpha";
	            } else if (firstChar === firstCharLower) {
	                return "lower";
	            } else {
	                return "upper";
	            }
	        }
	
	        /**
	         * Check if capitalization is allowed for a CallExpression
	         * @param {Object} allowedMap Object mapping calleeName to a Boolean
	         * @param {ASTNode} node CallExpression node
	         * @param {string} calleeName Capitalized callee name from a CallExpression
	         * @param {Object} pattern RegExp object from options pattern
	         * @returns {boolean} Returns true if the callee may be capitalized
	         */
	        function isCapAllowed(allowedMap, node, calleeName, pattern) {
	            const sourceText = sourceCode.getText(node.callee);
	
	            if (allowedMap[calleeName] || allowedMap[sourceText]) {
	                return true;
	            }
	
	            if (pattern && pattern.test(sourceText)) {
	                return true;
	            }
	
	            if (calleeName === "UTC" && node.callee.type === "MemberExpression") {
	
	                // allow if callee is Date.UTC
	                return node.callee.object.type === "Identifier" &&
	                    node.callee.object.name === "Date";
	            }
	
	            return skipProperties && node.callee.type === "MemberExpression";
	        }
	
	        /**
	         * Reports the given message for the given node. The location will be the start of the property or the callee.
	         * @param {ASTNode} node CallExpression or NewExpression node.
	         * @param {string} message The message to report.
	         * @returns {void}
	         */
	        function report(node, message) {
	            let callee = node.callee;
	
	            if (callee.type === "MemberExpression") {
	                callee = callee.property;
	            }
	
	            context.report(node, callee.loc.start, message);
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        if (config.newIsCap) {
	            listeners.NewExpression = function(node) {
	
	                const constructorName = extractNameFromExpression(node);
	
	                if (constructorName) {
	                    const capitalization = getCap(constructorName);
	                    const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);
	
	                    if (!isAllowed) {
	                        report(node, "A constructor name should not start with a lowercase letter.");
	                    }
	                }
	            };
	        }
	
	        if (config.capIsNew) {
	            listeners.CallExpression = function(node) {
	
	                const calleeName = extractNameFromExpression(node);
	
	                if (calleeName) {
	                    const capitalization = getCap(calleeName);
	                    const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);
	
	                    if (!isAllowed) {
	                        report(node, "A function with a name starting with an uppercase letter should only be used as a constructor.");
	                    }
	                }
	            };
	        }
	
	        return listeners;
	    }
	};


/***/ },
/* 180 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using constructor without parentheses
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether the given token is an opening parenthesis or not.
	 *
	 * @param {Token} token - The token to check.
	 * @returns {boolean} `true` if the token is an opening parenthesis.
	 */
	function isOpeningParen(token) {
	    return token.type === "Punctuator" && token.value === "(";
	}
	
	/**
	 * Checks whether the given token is an closing parenthesis or not.
	 *
	 * @param {Token} token - The token to check.
	 * @returns {boolean} `true` if the token is an closing parenthesis.
	 */
	function isClosingParen(token) {
	    return token.type === "Punctuator" && token.value === ")";
	}
	
	/**
	 * Checks whether the given node is inside of another given node.
	 *
	 * @param {ASTNode|Token} inner - The inner node to check.
	 * @param {ASTNode|Token} outer - The outer node to check.
	 * @returns {boolean} `true` if the `inner` is in `outer`.
	 */
	function isInRange(inner, outer) {
	    const ir = inner.range;
	    const or = outer.range;
	
	    return or[0] <= ir[0] && ir[1] <= or[1];
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require parentheses when invoking a constructor with no arguments",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            NewExpression(node) {
	                let token = sourceCode.getTokenAfter(node.callee);
	
	                // Skip ')'
	                while (token && isClosingParen(token)) {
	                    token = sourceCode.getTokenAfter(token);
	                }
	
	                if (!(token && isOpeningParen(token) && isInRange(token, node))) {
	                    context.report({
	                        node,
	                        message: "Missing '()' invoking a constructor.",
	                        fix: fixer => fixer.insertTextAfter(node, "()")
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 181 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check empty newline after "var" statement
	 * @author Gopal Venkatesan
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow an empty line after variable declarations",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["never", "always"]
	            }
	        ],
	
	        fixable: "whitespace"
	    },
	
	    create(context) {
	
	        const ALWAYS_MESSAGE = "Expected blank line after variable declarations.",
	            NEVER_MESSAGE = "Unexpected blank line after variable declarations.";
	
	        const sourceCode = context.getSourceCode();
	
	        // Default `mode` to "always".
	        const mode = context.options[0] === "never" ? "never" : "always";
	
	        // Cache starting and ending line numbers of comments for faster lookup
	        const commentEndLine = sourceCode.getAllComments().reduce(function(result, token) {
	            result[token.loc.start.line] = token.loc.end.line;
	            return result;
	        }, {});
	
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Gets a token from the given node to compare line to the next statement.
	         *
	         * In general, the token is the last token of the node. However, the token is the second last token if the following conditions satisfy.
	         *
	         * - The last token is semicolon.
	         * - The semicolon is on a different line from the previous token of the semicolon.
	         *
	         * This behavior would address semicolon-less style code. e.g.:
	         *
	         *     var foo = 1
	         *
	         *     ;(a || b).doSomething()
	         *
	         * @param {ASTNode} node - The node to get.
	         * @returns {Token} The token to compare line to the next statement.
	         */
	        function getLastToken(node) {
	            const lastToken = sourceCode.getLastToken(node);
	
	            if (lastToken.type === "Punctuator" && lastToken.value === ";") {
	                const prevToken = sourceCode.getTokenBefore(lastToken);
	
	                if (prevToken.loc.end.line !== lastToken.loc.start.line) {
	                    return prevToken;
	                }
	            }
	
	            return lastToken;
	        }
	
	        /**
	         * Determine if provided keyword is a variable declaration
	         * @private
	         * @param {string} keyword - keyword to test
	         * @returns {boolean} True if `keyword` is a type of var
	         */
	        function isVar(keyword) {
	            return keyword === "var" || keyword === "let" || keyword === "const";
	        }
	
	        /**
	         * Determine if provided keyword is a variant of for specifiers
	         * @private
	         * @param {string} keyword - keyword to test
	         * @returns {boolean} True if `keyword` is a variant of for specifier
	         */
	        function isForTypeSpecifier(keyword) {
	            return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
	        }
	
	        /**
	         * Determine if provided keyword is an export specifiers
	         * @private
	         * @param {string} nodeType - nodeType to test
	         * @returns {boolean} True if `nodeType` is an export specifier
	         */
	        function isExportSpecifier(nodeType) {
	            return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" ||
	                nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
	        }
	
	        /**
	         * Determine if provided node is the last of their parent block.
	         * @private
	         * @param {ASTNode} node - node to test
	         * @returns {boolean} True if `node` is last of their parent block.
	         */
	        function isLastNode(node) {
	            const token = sourceCode.getTokenAfter(node);
	
	            return !token || (token.type === "Punctuator" && token.value === "}");
	        }
	
	        /**
	        * Gets the last line of a group of consecutive comments
	        * @param {number} commentStartLine The starting line of the group
	        * @returns {number} The number of the last comment line of the group
	        */
	        function getLastCommentLineOfBlock(commentStartLine) {
	            const currentCommentEnd = commentEndLine[commentStartLine];
	
	            return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
	        }
	
	        /**
	         * Determine if a token starts more than one line after a comment ends
	         * @param  {token}   token            The token being checked
	         * @param {integer}  commentStartLine The line number on which the comment starts
	         * @returns {boolean}                 True if `token` does not start immediately after a comment
	         */
	        function hasBlankLineAfterComment(token, commentStartLine) {
	            return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
	        }
	
	        /**
	         * Checks that a blank line exists after a variable declaration when mode is
	         * set to "always", or checks that there is no blank line when mode is set
	         * to "never"
	         * @private
	         * @param {ASTNode} node - `VariableDeclaration` node to test
	         * @returns {void}
	         */
	        function checkForBlankLine(node) {
	
	            /*
	             * lastToken is the last token on the node's line. It will usually also be the last token of the node, but it will
	             * sometimes be second-last if there is a semicolon on a different line.
	             */
	            const lastToken = getLastToken(node),
	
	                /*
	                 * If lastToken is the last token of the node, nextToken should be the token after the node. Otherwise, nextToken
	                 * is the last token of the node.
	                 */
	                nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node),
	                nextLineNum = lastToken.loc.end.line + 1;
	
	            // Ignore if there is no following statement
	            if (!nextToken) {
	                return;
	            }
	
	            // Ignore if parent of node is a for variant
	            if (isForTypeSpecifier(node.parent.type)) {
	                return;
	            }
	
	            // Ignore if parent of node is an export specifier
	            if (isExportSpecifier(node.parent.type)) {
	                return;
	            }
	
	            // Some coding styles use multiple `var` statements, so do nothing if
	            // the next token is a `var` statement.
	            if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
	                return;
	            }
	
	            // Ignore if it is last statement in a block
	            if (isLastNode(node)) {
	                return;
	            }
	
	            // Next statement is not a `var`...
	            const noNextLineToken = nextToken.loc.start.line > nextLineNum;
	            const hasNextLineComment = (typeof commentEndLine[nextLineNum] !== "undefined");
	
	            if (mode === "never" && noNextLineToken && !hasNextLineComment) {
	                context.report({
	                    node,
	                    message: NEVER_MESSAGE,
	                    data: { identifier: node.name },
	                    fix(fixer) {
	                        const NEWLINE_REGEX = /\r\n|\r|\n|\u2028|\u2029/;
	                        const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(NEWLINE_REGEX);
	
	                        return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}\n${linesBetween[linesBetween.length - 1]}`);
	                    }
	                });
	            }
	
	            // Token on the next line, or comment without blank line
	            if (
	                mode === "always" && (
	                    !noNextLineToken ||
	                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)
	                )
	            ) {
	                context.report({
	                    node,
	                    message: ALWAYS_MESSAGE,
	                    data: { identifier: node.name },
	                    fix(fixer) {
	                        if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
	                            return fixer.insertTextBefore(nextToken, "\n\n");
	                        }
	
	                        return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
	                    }
	                });
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            VariableDeclaration: checkForBlankLine
	        };
	
	    }
	};


/***/ },
/* 182 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require newlines before `return` statement
	 * @author Kai Cataldo
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require an empty line before `return` statements",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        fixable: "whitespace",
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Tests whether node is preceded by supplied tokens
	         * @param {ASTNode} node - node to check
	         * @param {array} testTokens - array of tokens to test against
	         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens
	         * @private
	         */
	        function isPrecededByTokens(node, testTokens) {
	            const tokenBefore = sourceCode.getTokenBefore(node);
	
	            return testTokens.some(function(token) {
	                return tokenBefore.value === token;
	            });
	        }
	
	        /**
	         * Checks whether node is the first node after statement or in block
	         * @param {ASTNode} node - node to check
	         * @returns {boolean} Whether or not the node is the first node after statement or in block
	         * @private
	         */
	        function isFirstNode(node) {
	            const parentType = node.parent.type;
	
	            if (node.parent.body) {
	                return Array.isArray(node.parent.body)
	                  ? node.parent.body[0] === node
	                  : node.parent.body === node;
	            }
	
	            if (parentType === "IfStatement") {
	                return isPrecededByTokens(node, ["else", ")"]);
	            } else if (parentType === "DoWhileStatement") {
	                return isPrecededByTokens(node, ["do"]);
	            } else if (parentType === "SwitchCase") {
	                return isPrecededByTokens(node, [":"]);
	            } else {
	                return isPrecededByTokens(node, [")"]);
	            }
	        }
	
	        /**
	         * Returns the number of lines of comments that precede the node
	         * @param {ASTNode} node - node to check for overlapping comments
	         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments
	         * @returns {number} Number of lines of comments that precede the node
	         * @private
	         */
	        function calcCommentLines(node, lineNumTokenBefore) {
	            const comments = sourceCode.getComments(node).leading;
	            let numLinesComments = 0;
	
	            if (!comments.length) {
	                return numLinesComments;
	            }
	
	            comments.forEach(function(comment) {
	                numLinesComments++;
	
	                if (comment.type === "Block") {
	                    numLinesComments += comment.loc.end.line - comment.loc.start.line;
	                }
	
	                // avoid counting lines with inline comments twice
	                if (comment.loc.start.line === lineNumTokenBefore) {
	                    numLinesComments--;
	                }
	
	                if (comment.loc.end.line === node.loc.start.line) {
	                    numLinesComments--;
	                }
	            });
	
	            return numLinesComments;
	        }
	
	        /**
	         * Returns the line number of the token before the node that is passed in as an argument
	         * @param {ASTNode} node - The node to use as the start of the calculation
	         * @returns {number} Line number of the token before `node`
	         * @private
	         */
	        function getLineNumberOfTokenBefore(node) {
	            const tokenBefore = sourceCode.getTokenBefore(node);
	            let lineNumTokenBefore;
	
	            /**
	             * Global return (at the beginning of a script) is a special case.
	             * If there is no token before `return`, then we expect no line
	             * break before the return. Comments are allowed to occupy lines
	             * before the global return, just no blank lines.
	             * Setting lineNumTokenBefore to zero in that case results in the
	             * desired behavior.
	             */
	            if (tokenBefore) {
	                lineNumTokenBefore = tokenBefore.loc.end.line;
	            } else {
	                lineNumTokenBefore = 0;     // global return at beginning of script
	            }
	
	            return lineNumTokenBefore;
	        }
	
	        /**
	         * Checks whether node is preceded by a newline
	         * @param {ASTNode} node - node to check
	         * @returns {boolean} Whether or not the node is preceded by a newline
	         * @private
	         */
	        function hasNewlineBefore(node) {
	            const lineNumNode = node.loc.start.line;
	            const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
	            const commentLines = calcCommentLines(node, lineNumTokenBefore);
	
	            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;
	        }
	
	        /**
	         * Checks whether it is safe to apply a fix to a given return statement.
	         *
	         * The fix is not considered safe if the given return statement has leading comments,
	         * as we cannot safely determine if the newline should be added before or after the comments.
	         * For more information, see: https://github.com/eslint/eslint/issues/5958#issuecomment-222767211
	         *
	         * @param {ASTNode} node - The return statement node to check.
	         * @returns {boolean} `true` if it can fix the node.
	         * @private
	         */
	        function canFix(node) {
	            const leadingComments = sourceCode.getComments(node).leading;
	            const lastLeadingComment = leadingComments[leadingComments.length - 1];
	            const tokenBefore = sourceCode.getTokenBefore(node);
	
	            if (leadingComments.length === 0) {
	                return true;
	            }
	
	            // if the last leading comment ends in the same line as the previous token and
	            // does not share a line with the `return` node, we can consider it safe to fix.
	            // Example:
	            // function a() {
	            //     var b; //comment
	            //     return;
	            // }
	            if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line &&
	                lastLeadingComment.loc.end.line !== node.loc.start.line) {
	                return true;
	            }
	
	            return false;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ReturnStatement(node) {
	                if (!isFirstNode(node) && !hasNewlineBefore(node)) {
	                    context.report({
	                        node,
	                        message: "Expected newline before return statement.",
	                        fix(fixer) {
	                            if (canFix(node)) {
	                                const tokenBefore = sourceCode.getTokenBefore(node);
	                                const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
	
	                                return fixer.insertTextBefore(node, newlines);
	                            }
	                            return null;
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 183 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to ensure newline per method call when chaining calls
	 * @author Rajendra Patil
	 * @author Burak Yigit Kaya
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require a newline after each call in a method chain",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                ignoreChainWithDepth: {
	                    type: "integer",
	                    minimum: 1,
	                    maximum: 10
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	
	        const options = context.options[0] || {},
	            ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Gets the property text of a given MemberExpression node.
	         * If the text is multiline, this returns only the first line.
	         *
	         * @param {ASTNode} node - A MemberExpression node to get.
	         * @returns {string} The property text of the node.
	         */
	        function getPropertyText(node) {
	            const prefix = node.computed ? "[" : ".";
	            const lines = sourceCode.getText(node.property).split(/\r\n|\r|\n/g);
	            const suffix = node.computed && lines.length === 1 ? "]" : "";
	
	            return prefix + lines[0] + suffix;
	        }
	
	        return {
	            "CallExpression:exit"(node) {
	                if (!node.callee || node.callee.type !== "MemberExpression") {
	                    return;
	                }
	
	                const callee = node.callee;
	                let parent = callee.object;
	                let depth = 1;
	
	                while (parent && parent.callee) {
	                    depth += 1;
	                    parent = parent.callee.object;
	                }
	
	                if (depth > ignoreChainWithDepth && callee.property.loc.start.line === callee.object.loc.end.line) {
	                    context.report({
	                        node: callee.property,
	                        loc: callee.property.loc.start,
	                        message: "Expected line break before `{{callee}}`.",
	                        data: {
	                            callee: getPropertyText(callee)
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of alert, confirm, prompt
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const getPropertyName = __webpack_require__(109).getStaticPropertyName;
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks if the given name is a prohibited identifier.
	 * @param {string} name The name to check
	 * @returns {boolean} Whether or not the name is prohibited.
	 */
	function isProhibitedIdentifier(name) {
	    return /^(alert|confirm|prompt)$/.test(name);
	}
	
	/**
	 * Reports the given node and identifier name.
	 * @param {RuleContext} context The ESLint rule context.
	 * @param {ASTNode} node The node to report on.
	 * @param {string} identifierName The name of the identifier.
	 * @returns {void}
	 */
	function report(context, node, identifierName) {
	    context.report(node, "Unexpected {{name}}.", { name: identifierName });
	}
	
	/**
	 * Finds the escope reference in the given scope.
	 * @param {Object} scope The scope to search.
	 * @param {ASTNode} node The identifier node.
	 * @returns {Reference|null} Returns the found reference or null if none were found.
	 */
	function findReference(scope, node) {
	    const references = scope.references.filter(function(reference) {
	        return reference.identifier.range[0] === node.range[0] &&
	            reference.identifier.range[1] === node.range[1];
	    });
	
	    if (references.length === 1) {
	        return references[0];
	    }
	    return null;
	}
	
	/**
	 * Checks if the given identifier node is shadowed in the given scope.
	 * @param {Object} scope The current scope.
	 * @param {Object} globalScope The global scope.
	 * @param {string} node The identifier node to check
	 * @returns {boolean} Whether or not the name is shadowed.
	 */
	function isShadowed(scope, globalScope, node) {
	    const reference = findReference(scope, node);
	
	    return reference && reference.resolved && reference.resolved.defs.length > 0;
	}
	
	/**
	 * Checks if the given identifier node is a ThisExpression in the global scope or the global window property.
	 * @param {Object} scope The current scope.
	 * @param {Object} globalScope The global scope.
	 * @param {string} node The identifier node to check
	 * @returns {boolean} Whether or not the node is a reference to the global object.
	 */
	function isGlobalThisReferenceOrGlobalWindow(scope, globalScope, node) {
	    if (scope.type === "global" && node.type === "ThisExpression") {
	        return true;
	    } else if (node.name === "window") {
	        return !isShadowed(scope, globalScope, node);
	    }
	
	    return false;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `alert`, `confirm`, and `prompt`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let globalScope;
	
	        return {
	
	            Program() {
	                globalScope = context.getScope();
	            },
	
	            CallExpression(node) {
	                const callee = node.callee,
	                    currentScope = context.getScope();
	
	                // without window.
	                if (callee.type === "Identifier") {
	                    const identifierName = callee.name;
	
	                    if (!isShadowed(currentScope, globalScope, callee) && isProhibitedIdentifier(callee.name)) {
	                        report(context, node, identifierName);
	                    }
	
	                } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, globalScope, callee.object)) {
	                    const identifierName = getPropertyName(callee);
	
	                    if (isProhibitedIdentifier(identifierName)) {
	                        report(context, node, identifierName);
	                    }
	                }
	
	            }
	        };
	
	    }
	};


/***/ },
/* 185 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow construction of dense arrays using the Array constructor
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `Array` constructors",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Disallow construction of dense arrays using the Array constructor
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function check(node) {
	            if (
	                node.arguments.length !== 1 &&
	                node.callee.type === "Identifier" &&
	                node.callee.name === "Array"
	            ) {
	                context.report(node, "The array literal notation [] is preferrable.");
	            }
	        }
	
	        return {
	            CallExpression: check,
	            NewExpression: check
	        };
	
	    }
	};


/***/ },
/* 186 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag bitwise identifiers
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//
	// Set of bitwise operators.
	//
	const BITWISE_OPERATORS = [
	    "^", "|", "&", "<<", ">>", ">>>",
	    "^=", "|=", "&=", "<<=", ">>=", ">>>=",
	    "~"
	];
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow bitwise operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allow: {
	                        type: "array",
	                        items: {
	                            enum: BITWISE_OPERATORS
	                        },
	                        uniqueItems: true
	                    },
	                    int32Hint: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const allowed = options.allow || [];
	        const int32Hint = options.int32Hint === true;
	
	        /**
	         * Reports an unexpected use of a bitwise operator.
	         * @param   {ASTNode} node Node which contains the bitwise operator.
	         * @returns {void}
	         */
	        function report(node) {
	            context.report(node, "Unexpected use of '{{operator}}'.", { operator: node.operator });
	        }
	
	        /**
	         * Checks if the given node has a bitwise operator.
	         * @param   {ASTNode} node The node to check.
	         * @returns {boolean} Whether or not the node has a bitwise operator.
	         */
	        function hasBitwiseOperator(node) {
	            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
	        }
	
	        /**
	         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.
	         * @param   {ASTNode} node The node to check.
	         * @returns {boolean} Whether or not the node has a bitwise operator.
	         */
	        function allowedOperator(node) {
	            return allowed.indexOf(node.operator) !== -1;
	        }
	
	        /**
	         * Checks if the given bitwise operator is used for integer typecasting, i.e. "|0"
	         * @param   {ASTNode} node The node to check.
	         * @returns {boolean} whether the node is used in integer typecasting.
	         */
	        function isInt32Hint(node) {
	            return int32Hint && node.operator === "|" && node.right &&
	              node.right.type === "Literal" && node.right.value === 0;
	        }
	
	        /**
	         * Report if the given node contains a bitwise operator.
	         * @param   {ASTNode} node The node to check.
	         * @returns {void}
	         */
	        function checkNodeForBitwiseOperator(node) {
	            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
	                report(node);
	            }
	        }
	
	        return {
	            AssignmentExpression: checkNodeForBitwiseOperator,
	            BinaryExpression: checkNodeForBitwiseOperator,
	            UnaryExpression: checkNodeForBitwiseOperator
	        };
	
	    }
	};


/***/ },
/* 187 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of arguments.callee and arguments.caller.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `arguments.caller` or `arguments.callee`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            MemberExpression(node) {
	                const objectName = node.object.name,
	                    propertyName = node.property.name;
	
	                if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/)) {
	                    context.report(node, "Avoid arguments.{{property}}.", { property: propertyName });
	                }
	
	            }
	        };
	
	    }
	};


/***/ },
/* 188 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of an lexical declarations inside a case clause
	 * @author Erik Arvidsson
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow lexical declarations in case clauses",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Checks whether or not a node is a lexical declaration.
	         * @param {ASTNode} node A direct child statement of a switch case.
	         * @returns {boolean} Whether or not the node is a lexical declaration.
	         */
	        function isLexicalDeclaration(node) {
	            switch (node.type) {
	                case "FunctionDeclaration":
	                case "ClassDeclaration":
	                    return true;
	                case "VariableDeclaration":
	                    return node.kind !== "var";
	                default:
	                    return false;
	            }
	        }
	
	        return {
	            SwitchCase(node) {
	                for (let i = 0; i < node.consequent.length; i++) {
	                    const statement = node.consequent[i];
	
	                    if (isLexicalDeclaration(statement)) {
	                        context.report({
	                            node,
	                            message: "Unexpected lexical declaration in case block."
	                        });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag variable leak in CatchClauses in IE 8 and earlier
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Check if the parameters are been shadowed
	         * @param {Object} scope current scope
	         * @param {string} name parameter name
	         * @returns {boolean} True is its been shadowed
	         */
	        function paramIsShadowing(scope, name) {
	            return astUtils.getVariableByName(scope, name) !== null;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	
	            CatchClause(node) {
	                let scope = context.getScope();
	
	                // When blockBindings is enabled, CatchClause creates its own scope
	                // so start from one upper scope to exclude the current node
	                if (scope.block === node) {
	                    scope = scope.upper;
	                }
	
	                if (paramIsShadowing(scope, node.param.name)) {
	                    context.report(node, "Value of '{{name}}' may be overwritten in IE 8 and earlier.",
	                            { name: node.param.name });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow modifying variables of class declarations
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow reassigning class members",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	                context.report(
	                    reference.identifier,
	                    "'{{name}}' is a class.",
	                    {name: reference.identifier.name});
	
	            });
	        }
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {ASTNode} node - A ClassDeclaration/ClassExpression node to check.
	         * @returns {void}
	         */
	        function checkForClass(node) {
	            context.getDeclaredVariables(node).forEach(checkVariable);
	        }
	
	        return {
	            ClassDeclaration: checkForClass,
	            ClassExpression: checkForClass
	        };
	
	    }
	};


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag assignment in a conditional statement's test expression
	 * @author Stephen Murray <spmurrayzzz>
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	const NODE_DESCRIPTIONS = {
	    DoWhileStatement: "a 'do...while' statement",
	    ForStatement: "a 'for' statement",
	    IfStatement: "an 'if' statement",
	    WhileStatement: "a 'while' statement"
	};
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow assignment operators in conditional expressions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                enum: ["except-parens", "always"]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const prohibitAssign = (context.options[0] || "except-parens");
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Check whether an AST node is the test expression for a conditional statement.
	         * @param {!Object} node The node to test.
	         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.
	         */
	        function isConditionalTestExpression(node) {
	            return node.parent &&
	                node.parent.test &&
	                node === node.parent.test;
	        }
	
	        /**
	         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.
	         * @param {!Object} node The node to use at the start of the search.
	         * @returns {?Object} The closest ancestor node that represents a conditional statement.
	         */
	        function findConditionalAncestor(node) {
	            let currentAncestor = node;
	
	            do {
	                if (isConditionalTestExpression(currentAncestor)) {
	                    return currentAncestor.parent;
	                }
	            } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));
	
	            return null;
	        }
	
	        /**
	         * Check whether the code represented by an AST node is enclosed in parentheses.
	         * @param {!Object} node The node to test.
	         * @returns {boolean} `true` if the code is enclosed in parentheses; otherwise, `false`.
	         */
	        function isParenthesised(node) {
	            const previousToken = sourceCode.getTokenBefore(node),
	                nextToken = sourceCode.getTokenAfter(node);
	
	            return previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	                nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	        }
	
	        /**
	         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.
	         * @param {!Object} node The node to test.
	         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.
	         */
	        function isParenthesisedTwice(node) {
	            const previousToken = sourceCode.getTokenBefore(node, 1),
	                nextToken = sourceCode.getTokenAfter(node, 1);
	
	            return isParenthesised(node) &&
	                previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	                nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	        }
	
	        /**
	         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.
	         * @param {!Object} node The node for the conditional statement.
	         * @returns {void}
	         */
	        function testForAssign(node) {
	            if (node.test &&
	                (node.test.type === "AssignmentExpression") &&
	                (node.type === "ForStatement" ?
	                    !isParenthesised(node.test) :
	                    !isParenthesisedTwice(node.test)
	                )
	            ) {
	
	                // must match JSHint's error message
	                context.report({
	                    node,
	                    loc: node.test.loc.start,
	                    message: "Expected a conditional expression and instead saw an assignment."
	                });
	            }
	        }
	
	        /**
	         * Check whether an assignment expression is descended from a conditional statement's test expression.
	         * @param {!Object} node The node for the assignment expression.
	         * @returns {void}
	         */
	        function testForConditionalAncestor(node) {
	            const ancestor = findConditionalAncestor(node);
	
	            if (ancestor) {
	                context.report(ancestor, "Unexpected assignment within {{type}}.", {
	                    type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
	                });
	            }
	        }
	
	        if (prohibitAssign === "always") {
	            return {
	                AssignmentExpression: testForConditionalAncestor
	            };
	        }
	
	        return {
	            DoWhileStatement: testForAssign,
	            ForStatement: testForAssign,
	            IfStatement: testForAssign,
	            WhileStatement: testForAssign
	        };
	
	    }
	};


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to warn against using arrow functions when they could be
	 * confused with comparisions
	 * @author Jxck <https://github.com/Jxck>
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a node is a conditional expression.
	 * @param {ASTNode} node - node to test
	 * @returns {boolean} `true` if the node is a conditional expression.
	 */
	function isConditional(node) {
	    return node && node.type === "ConditionalExpression";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow arrow functions where they could be confused with comparisons",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                allowParens: {type: "boolean"}
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const config = context.options[0] || {};
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Reports if an arrow function contains an ambiguous conditional.
	         * @param {ASTNode} node - A node to check and report.
	         * @returns {void}
	         */
	        function checkArrowFunc(node) {
	            const body = node.body;
	
	            if (isConditional(body) && !(config.allowParens && astUtils.isParenthesised(sourceCode, body))) {
	                context.report(node, "Arrow function used ambiguously with a conditional expression.");
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: checkArrowFunc
	        };
	    }
	};


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of console object
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `console`",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allow: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        },
	                        minItems: 1,
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const allowed = options.allow || [];
	
	        /**
	         * Checks whether the given reference is 'console' or not.
	         *
	         * @param {escope.Reference} reference - The reference to check.
	         * @returns {boolean} `true` if the reference is 'console'.
	         */
	        function isConsole(reference) {
	            const id = reference.identifier;
	
	            return id && id.name === "console";
	        }
	
	        /**
	         * Checks whether the property name of the given MemberExpression node
	         * is allowed by options or not.
	         *
	         * @param {ASTNode} node - The MemberExpression node to check.
	         * @returns {boolean} `true` if the property name of the node is allowed.
	         */
	        function isAllowed(node) {
	            const propertyName = astUtils.getStaticPropertyName(node);
	
	            return propertyName && allowed.indexOf(propertyName) !== -1;
	        }
	
	        /**
	         * Checks whether the given reference is a member access which is not
	         * allowed by options or not.
	         *
	         * @param {escope.Reference} reference - The reference to check.
	         * @returns {boolean} `true` if the reference is a member access which
	         *      is not allowed by options.
	         */
	        function isMemberAccessExceptAllowed(reference) {
	            const node = reference.identifier;
	            const parent = node.parent;
	
	            return (
	                parent.type === "MemberExpression" &&
	                parent.object === node &&
	                !isAllowed(parent)
	            );
	        }
	
	        /**
	         * Reports the given reference as a violation.
	         *
	         * @param {escope.Reference} reference - The reference to report.
	         * @returns {void}
	         */
	        function report(reference) {
	            const node = reference.identifier.parent;
	
	            context.report({
	                node,
	                loc: node.loc,
	                message: "Unexpected console statement."
	            });
	        }
	
	        return {
	            "Program:exit"() {
	                const scope = context.getScope();
	                const consoleVar = astUtils.getVariableByName(scope, "console");
	                const shadowed = consoleVar && consoleVar.defs.length > 0;
	
	                /* 'scope.through' includes all references to undefined
	                 * variables. If the variable 'console' is not defined, it uses
	                 * 'scope.through'.
	                 */
	                const references = consoleVar
	                    ? consoleVar.references
	                    : scope.through.filter(isConsole);
	
	                if (!shadowed) {
	                    references
	                        .filter(isMemberAccessExceptAllowed)
	                        .forEach(report);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow modifying variables that are declared using `const`
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow reassigning `const` variables",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	                context.report(
	                    reference.identifier,
	                    "'{{name}}' is constant.",
	                    {name: reference.identifier.name});
	            });
	        }
	
	        return {
	            VariableDeclaration(node) {
	                if (node.kind === "const") {
	                    context.getDeclaredVariables(node).forEach(checkVariable);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 195 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use constant conditions
	 * @author Christian Schulz <http://rndm.de>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow constant expressions in conditions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    checkLoops: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {},
	            checkLoops = options.checkLoops !== false;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	
	        /**
	         * Checks if a branch node of LogicalExpression short circuits the whole condition
	         * @param {ASTNode} node The branch of main condition which needs to be checked
	         * @param {string} operator The operator of the main LogicalExpression.
	         * @returns {boolean} true when condition short circuits whole condition
	         */
	        function isLogicalIdentity(node, operator) {
	            switch (node.type) {
	                case "Literal":
	                    return (operator === "||" && node.value === true) ||
	                           (operator === "&&" && node.value === false);
	
	                case "UnaryExpression":
	                    return (operator === "&&" && node.operator === "void");
	
	                case "LogicalExpression":
	                    return isLogicalIdentity(node.left, node.operator) ||
	                             isLogicalIdentity(node.right, node.operator);
	
	                // no default
	            }
	            return false;
	        }
	
	        /**
	         * Checks if a node has a constant truthiness value.
	         * @param {ASTNode} node The AST node to check.
	         * @param {boolean} inBooleanPosition `false` if checking branch of a condition.
	         *  `true` in all other cases
	         * @returns {Bool} true when node's truthiness is constant
	         * @private
	         */
	        function isConstant(node, inBooleanPosition) {
	            switch (node.type) {
	                case "Literal":
	                case "ArrowFunctionExpression":
	                case "FunctionExpression":
	                case "ObjectExpression":
	                case "ArrayExpression":
	                    return true;
	
	                case "UnaryExpression":
	                    if (node.operator === "void") {
	                        return true;
	                    }
	
	                    return (node.operator === "typeof" && inBooleanPosition) ||
	                        isConstant(node.argument, true);
	
	                case "BinaryExpression":
	                    return isConstant(node.left, false) &&
	                            isConstant(node.right, false) &&
	                            node.operator !== "in";
	
	                case "LogicalExpression": {
	                    const isLeftConstant = isConstant(node.left, inBooleanPosition);
	                    const isRightConstant = isConstant(node.right, inBooleanPosition);
	                    const isLeftShortCircuit = (isLeftConstant && isLogicalIdentity(node.left, node.operator));
	                    const isRightShortCircuit = (isRightConstant && isLogicalIdentity(node.right, node.operator));
	
	                    return (isLeftConstant && isRightConstant) || isLeftShortCircuit || isRightShortCircuit;
	                }
	
	                case "AssignmentExpression":
	                    return (node.operator === "=") && isConstant(node.right, inBooleanPosition);
	
	                case "SequenceExpression":
	                    return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
	
	                // no default
	            }
	            return false;
	        }
	
	        /**
	         * Reports when the given node contains a constant condition.
	         * @param {ASTNode} node The AST node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkConstantCondition(node) {
	            if (node.test && isConstant(node.test, true)) {
	                context.report(node, "Unexpected constant condition.");
	            }
	        }
	
	        /**
	         * Checks node when checkLoops option is enabled
	         * @param {ASTNode} node The AST node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkLoop(node) {
	            if (checkLoops) {
	                checkConstantCondition(node);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ConditionalExpression: checkConstantCondition,
	            IfStatement: checkConstantCondition,
	            WhileStatement: checkLoop,
	            DoWhileStatement: checkLoop,
	            ForStatement: checkLoop
	        };
	
	    }
	};


/***/ },
/* 196 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of continue statement
	 * @author Borislav Zhivkov
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `continue` statements",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            ContinueStatement(node) {
	                context.report(node, "Unexpected use of continue statement.");
	            }
	        };
	
	    }
	};


/***/ },
/* 197 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to forbid control charactes from regular expressions.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow control characters in regular expressions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Get the regex expression
	         * @param {ASTNode} node node to evaluate
	         * @returns {*} Regex if found else null
	         * @private
	         */
	        function getRegExp(node) {
	            if (node.value instanceof RegExp) {
	                return node.value;
	            } else if (typeof node.value === "string") {
	
	                const parent = context.getAncestors().pop();
	
	                if ((parent.type === "NewExpression" || parent.type === "CallExpression") &&
	                    parent.callee.type === "Identifier" && parent.callee.name === "RegExp"
	                ) {
	
	                    // there could be an invalid regular expression string
	                    try {
	                        return new RegExp(node.value);
	                    } catch (ex) {
	                        return null;
	                    }
	                }
	            }
	
	            return null;
	        }
	
	
	        const controlChar = /[\x00-\x1f]/g; // eslint-disable-line no-control-regex
	        const consecutiveSlashes = /\\+/g;
	        const consecutiveSlashesAtEnd = /\\+$/g;
	        const stringControlChar = /\\x[01][0-9a-f]/ig;
	        const stringControlCharWithoutSlash = /x[01][0-9a-f]/ig;
	
	        /**
	         * Return a list of the control characters in the given regex string
	         * @param {string} regexStr regex as string to check
	         * @returns {array} returns a list of found control characters on given string
	         * @private
	         */
	        function getControlCharacters(regexStr) {
	
	            // check control characters, if RegExp object used
	            const controlChars = regexStr.match(controlChar) || [];
	
	            let stringControlChars = [];
	
	            // check substr, if regex literal used
	            const subStrIndex = regexStr.search(stringControlChar);
	
	            if (subStrIndex > -1) {
	
	                // is it escaped, check backslash count
	                const possibleEscapeCharacters = regexStr.slice(0, subStrIndex).match(consecutiveSlashesAtEnd);
	
	                const hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);
	
	                if (hasControlChars) {
	                    stringControlChars = regexStr.slice(subStrIndex, -1)
	                        .split(consecutiveSlashes)
	                        .filter(Boolean)
	                        .map(function(x) {
	                            const match = x.match(stringControlCharWithoutSlash) || [x];
	
	                            return `\\${match[0]}`;
	                        });
	                }
	            }
	
	            return controlChars.map(function(x) {
	                const hexCode = `0${x.charCodeAt(0).toString(16)}`.slice(-2);
	
	                return `\\x${hexCode}`;
	            }).concat(stringControlChars);
	        }
	
	        return {
	            Literal(node) {
	                const regex = getRegExp(node);
	
	                if (regex) {
	                    const computedValue = regex.toString();
	
	                    const controlCharacters = getControlCharacters(computedValue);
	
	                    if (controlCharacters.length > 0) {
	                        context.report({
	                            node,
	                            message: "Unexpected control character(s) in regular expression: {{controlChars}}.",
	                            data: {
	                                controlChars: controlCharacters.join(", ")
	                            }
	                        });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 198 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of a debugger statement
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `debugger`",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            DebuggerStatement(node) {
	                context.report(node, "Unexpected 'debugger' statement.");
	            }
	        };
	
	    }
	};


/***/ },
/* 199 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when deleting variables
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow deleting variables",
	            category: "Variables",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            UnaryExpression(node) {
	                if (node.operator === "delete" && node.argument.type === "Identifier") {
	                    context.report(node, "Variables should not be deleted.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 200 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for ambiguous div operator in regexes
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow division operators explicitly at the beginning of regular expressions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	
	            Literal(node) {
	                const token = sourceCode.getFirstToken(node);
	
	                if (token.type === "RegularExpression" && token.value[1] === "=") {
	                    context.report(node, "A regular expression literal can be confused with '/='.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 201 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag duplicate arguments
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow duplicate arguments in `function` definitions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Checks whether or not a given definition is a parameter's.
	         * @param {escope.DefEntry} def - A definition to check.
	         * @returns {boolean} `true` if the definition is a parameter's.
	         */
	        function isParameter(def) {
	            return def.type === "Parameter";
	        }
	
	        /**
	         * Determines if a given node has duplicate parameters.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkParams(node) {
	            const variables = context.getDeclaredVariables(node);
	
	            for (let i = 0; i < variables.length; ++i) {
	                const variable = variables[i];
	
	                // Checks and reports duplications.
	                const defs = variable.defs.filter(isParameter);
	
	                if (defs.length >= 2) {
	                    context.report({
	                        node,
	                        message: "Duplicate param '{{name}}'.",
	                        data: {name: variable.name}
	                    });
	                }
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            FunctionDeclaration: checkParams,
	            FunctionExpression: checkParams
	        };
	
	    }
	};


/***/ },
/* 202 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow duplicate name in class members.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow duplicate class members",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let stack = [];
	
	        /**
	         * Gets state of a given member name.
	         * @param {string} name - A name of a member.
	         * @param {boolean} isStatic - A flag which specifies that is a static member.
	         * @returns {Object} A state of a given member name.
	         *   - retv.init {boolean} A flag which shows the name is declared as normal member.
	         *   - retv.get {boolean} A flag which shows the name is declared as getter.
	         *   - retv.set {boolean} A flag which shows the name is declared as setter.
	         */
	        function getState(name, isStatic) {
	            const stateMap = stack[stack.length - 1];
	            const key = `$${name}`; // to avoid "__proto__".
	
	            if (!stateMap[key]) {
	                stateMap[key] = {
	                    nonStatic: {init: false, get: false, set: false},
	                    static: {init: false, get: false, set: false}
	                };
	            }
	
	            return stateMap[key][isStatic ? "static" : "nonStatic"];
	        }
	
	        /**
	         * Gets the name text of a given node.
	         *
	         * @param {ASTNode} node - A node to get the name.
	         * @returns {string} The name text of the node.
	         */
	        function getName(node) {
	            switch (node.type) {
	                case "Identifier": return node.name;
	                case "Literal": return String(node.value);
	
	                /* istanbul ignore next: syntax error */
	                default: return "";
	            }
	        }
	
	        return {
	
	            // Initializes the stack of state of member declarations.
	            Program() {
	                stack = [];
	            },
	
	            // Initializes state of member declarations for the class.
	            ClassBody() {
	                stack.push(Object.create(null));
	            },
	
	            // Disposes the state for the class.
	            "ClassBody:exit"() {
	                stack.pop();
	            },
	
	            // Reports the node if its name has been declared already.
	            MethodDefinition(node) {
	                if (node.computed) {
	                    return;
	                }
	
	                const name = getName(node.key);
	                const state = getState(name, node.static);
	                let isDuplicate = false;
	
	                if (node.kind === "get") {
	                    isDuplicate = (state.init || state.get);
	                    state.get = true;
	                } else if (node.kind === "set") {
	                    isDuplicate = (state.init || state.set);
	                    state.set = true;
	                } else {
	                    isDuplicate = (state.init || state.get || state.set);
	                    state.init = true;
	                }
	
	                if (isDuplicate) {
	                    context.report(node, "Duplicate name '{{name}}'.", {name});
	                }
	            }
	        };
	    }
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of duplicate keys in an object.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const GET_KIND = /^(?:init|get)$/;
	const SET_KIND = /^(?:init|set)$/;
	
	/**
	 * The class which stores properties' information of an object.
	 */
	class ObjectInfo {
	
	    /**
	     * @param {ObjectInfo|null} upper - The information of the outer object.
	     * @param {ASTNode} node - The ObjectExpression node of this information.
	     */
	    constructor(upper, node) {
	        this.upper = upper;
	        this.node = node;
	        this.properties = new Map();
	    }
	
	    /**
	     * Gets the information of the given Property node.
	     * @param {ASTNode} node - The Property node to get.
	     * @returns {{get: boolean, set: boolean}} The information of the property.
	     */
	    getPropertyInfo(node) {
	        const name = astUtils.getStaticPropertyName(node);
	
	        if (!this.properties.has(name)) {
	            this.properties.set(name, {get: false, set: false});
	        }
	        return this.properties.get(name);
	    }
	
	    /**
	     * Checks whether the given property has been defined already or not.
	     * @param {ASTNode} node - The Property node to check.
	     * @returns {boolean} `true` if the property has been defined.
	     */
	    isPropertyDefined(node) {
	        const entry = this.getPropertyInfo(node);
	
	        return (
	            (GET_KIND.test(node.kind) && entry.get) ||
	            (SET_KIND.test(node.kind) && entry.set)
	        );
	    }
	
	    /**
	     * Defines the given property.
	     * @param {ASTNode} node - The Property node to define.
	     * @returns {void}
	     */
	    defineProperty(node) {
	        const entry = this.getPropertyInfo(node);
	
	        if (GET_KIND.test(node.kind)) {
	            entry.get = true;
	        }
	        if (SET_KIND.test(node.kind)) {
	            entry.set = true;
	        }
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow duplicate keys in object literals",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let info = null;
	
	        return {
	            ObjectExpression(node) {
	                info = new ObjectInfo(info, node);
	            },
	            "ObjectExpression:exit"() {
	                info = info.upper;
	            },
	
	            Property(node) {
	                const name = astUtils.getStaticPropertyName(node);
	
	                // Skip destructuring.
	                if (node.parent.type !== "ObjectExpression") {
	                    return;
	                }
	
	                // Skip if the name is not static.
	                if (!name) {
	                    return;
	                }
	
	                // Reports if the name is defined already.
	                if (info.isPropertyDefined(node)) {
	                    context.report({
	                        node: info.node,
	                        loc: node.key.loc,
	                        message: "Duplicate key '{{name}}'.",
	                        data: {name},
	                    });
	                }
	
	                // Update info.
	                info.defineProperty(node);
	            }
	        };
	    }
	};


/***/ },
/* 204 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow a duplicate case label.
	 * @author Dieter Oberkofler
	 * @author Burak Yigit Kaya
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow duplicate case labels",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            SwitchStatement(node) {
	                const mapping = {};
	
	                node.cases.forEach(function(switchCase) {
	                    const key = sourceCode.getText(switchCase.test);
	
	                    if (mapping[key]) {
	                        context.report(switchCase, "Duplicate case label.");
	                    } else {
	                        mapping[key] = switchCase;
	                    }
	                });
	            }
	        };
	    }
	};


/***/ },
/* 205 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Restrict usage of duplicate imports.
	 * @author Simen Bekkhus
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	/**
	 * Returns the name of the module imported or re-exported.
	 *
	 * @param {ASTNode} node - A node to get.
	 * @returns {string} the name of the module, or empty string if no name.
	 */
	function getValue(node) {
	    if (node && node.source && node.source.value) {
	        return node.source.value.trim();
	    }
	
	    return "";
	}
	
	/**
	 * Checks if the name of the import or export exists in the given array, and reports if so.
	 *
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @param {ASTNode} node - A node to get.
	 * @param {string} value - The name of the imported or exported module.
	 * @param {string[]} array - The array containing other imports or exports in the file.
	 * @param {string} message - A message to be reported after the name of the module
	 *
	 * @returns {void} No return value
	 */
	function checkAndReport(context, node, value, array, message) {
	    if (array.indexOf(value) !== -1) {
	        context.report({
	            node,
	            message: "'{{module}}' {{message}}",
	            data: {
	                module: value,
	                message
	            }
	        });
	    }
	}
	
	/**
	 * @callback nodeCallback
	 * @param {ASTNode} node - A node to handle.
	 */
	
	/**
	 * Returns a function handling the imports of a given file
	 *
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @param {boolean} includeExports - Whether or not to check for exports in addition to imports.
	 * @param {string[]} importsInFile - The array containing other imports in the file.
	 * @param {string[]} exportsInFile - The array containing other exports in the file.
	 *
	 * @returns {nodeCallback} A function passed to ESLint to handle the statement.
	 */
	function handleImports(context, includeExports, importsInFile, exportsInFile) {
	    return function(node) {
	        const value = getValue(node);
	
	        if (value) {
	            checkAndReport(context, node, value, importsInFile, "import is duplicated.");
	
	            if (includeExports) {
	                checkAndReport(context, node, value, exportsInFile, "import is duplicated as export.");
	            }
	
	            importsInFile.push(value);
	        }
	    };
	}
	
	/**
	 * Returns a function handling the exports of a given file
	 *
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @param {string[]} importsInFile - The array containing other imports in the file.
	 * @param {string[]} exportsInFile - The array containing other exports in the file.
	 *
	 * @returns {nodeCallback} A function passed to ESLint to handle the statement.
	 */
	function handleExports(context, importsInFile, exportsInFile) {
	    return function(node) {
	        const value = getValue(node);
	
	        if (value) {
	            checkAndReport(context, node, value, exportsInFile, "export is duplicated.");
	            checkAndReport(context, node, value, importsInFile, "export is duplicated as import.");
	
	            exportsInFile.push(value);
	        }
	    };
	}
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow duplicate module imports",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                includeExports: {
	                    type: "boolean"
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const includeExports = (context.options[0] || {}).includeExports,
	            importsInFile = [],
	            exportsInFile = [];
	
	        const handlers = {
	            ImportDeclaration: handleImports(context, includeExports, importsInFile, exportsInFile)
	        };
	
	        if (includeExports) {
	            handlers.ExportNamedDeclaration = handleExports(context, importsInFile, exportsInFile);
	            handlers.ExportAllDeclaration = handleExports(context, importsInFile, exportsInFile);
	        }
	
	        return handlers;
	    }
	};


/***/ },
/* 206 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag `else` after a `return` in `if`
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `else` blocks after `return` statements in `if` statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Display the context report if rule is violated
	         *
	         * @param {Node} node The 'else' node
	         * @returns {void}
	         */
	        function displayReport(node) {
	            context.report(node, "Unnecessary 'else' after 'return'.");
	        }
	
	        /**
	         * Check to see if the node is a ReturnStatement
	         *
	         * @param {Node} node The node being evaluated
	         * @returns {boolean} True if node is a return
	         */
	        function checkForReturn(node) {
	            return node.type === "ReturnStatement";
	        }
	
	        /**
	         * Naive return checking, does not iterate through the whole
	         * BlockStatement because we make the assumption that the ReturnStatement
	         * will be the last node in the body of the BlockStatement.
	         *
	         * @param {Node} node The consequent/alternate node
	         * @returns {boolean} True if it has a return
	         */
	        function naiveHasReturn(node) {
	            if (node.type === "BlockStatement") {
	                const body = node.body,
	                    lastChildNode = body[body.length - 1];
	
	                return lastChildNode && checkForReturn(lastChildNode);
	            }
	            return checkForReturn(node);
	        }
	
	        /**
	         * Check to see if the node is valid for evaluation,
	         * meaning it has an else and not an else-if
	         *
	         * @param {Node} node The node being evaluated
	         * @returns {boolean} True if the node is valid
	         */
	        function hasElse(node) {
	            return node.alternate && node.consequent && node.alternate.type !== "IfStatement";
	        }
	
	        /**
	         * If the consequent is an IfStatement, check to see if it has an else
	         * and both its consequent and alternate path return, meaning this is
	         * a nested case of rule violation.  If-Else not considered currently.
	         *
	         * @param {Node} node The consequent node
	         * @returns {boolean} True if this is a nested rule violation
	         */
	        function checkForIf(node) {
	            return node.type === "IfStatement" && hasElse(node) &&
	                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
	        }
	
	        /**
	         * Check the consequent/body node to make sure it is not
	         * a ReturnStatement or an IfStatement that returns on both
	         * code paths.
	         *
	         * @param {Node} node The consequent or body node
	         * @param {Node} alternate The alternate node
	         * @returns {boolean} `true` if it is a Return/If node that always returns.
	         */
	        function checkForReturnOrIf(node) {
	            return checkForReturn(node) || checkForIf(node);
	        }
	
	
	        /**
	         * Check whether a node returns in every codepath.
	         * @param {Node} node The node to be checked
	         * @returns {boolean} `true` if it returns on every codepath.
	         */
	        function alwaysReturns(node) {
	            if (node.type === "BlockStatement") {
	
	                // If we have a BlockStatement, check each consequent body node.
	                return node.body.some(checkForReturnOrIf);
	            }
	
	            /*
	             * If not a block statement, make sure the consequent isn't a
	             * ReturnStatement or an IfStatement with returns on both paths.
	             */
	            return checkForReturnOrIf(node);
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	
	            IfStatement(node) {
	                const parent = context.getAncestors().pop();
	                let consequents,
	                    alternate;
	
	                // Only "top-level" if statements are checked, meaning the first `if`
	                // in a `if-else-if-...` chain.
	                if (parent.type === "IfStatement" && parent.alternate === node) {
	                    return;
	                }
	
	                for (consequents = []; node.type === "IfStatement"; node = node.alternate) {
	                    if (!node.alternate) {
	                        return;
	                    }
	                    consequents.push(node.consequent);
	                    alternate = node.alternate;
	                }
	
	                if (consequents.every(alwaysReturns)) {
	                    displayReport(alternate);
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 207 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag the use of empty character classes in regular expressions
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/*
	plain-English description of the following regexp:
	0. `^` fix the match at the beginning of the string
	1. `\/`: the `/` that begins the regexp
	2. `([^\\[]|\\.|\[([^\\\]]|\\.)+\])*`: regexp contents; 0 or more of the following
	  2.0. `[^\\[]`: any character that's not a `\` or a `[` (anything but escape sequences and character classes)
	  2.1. `\\.`: an escape sequence
	  2.2. `\[([^\\\]]|\\.)+\]`: a character class that isn't empty
	3. `\/` the `/` that ends the regexp
	4. `[gimuy]*`: optional regexp flags
	5. `$`: fix the match at the end of the string
	*/
	const regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+])*\/[gimuy]*$/;
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow empty character classes in regular expressions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	
	            Literal(node) {
	                const token = sourceCode.getFirstToken(node);
	
	                if (token.type === "RegularExpression" && !regex.test(token.value)) {
	                    context.report(node, "Empty class.");
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 208 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow empty functions.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const ALLOW_OPTIONS = Object.freeze([
	    "functions",
	    "arrowFunctions",
	    "generatorFunctions",
	    "methods",
	    "generatorMethods",
	    "getters",
	    "setters",
	    "constructors"
	]);
	const SHOW_KIND = Object.freeze({
	    functions: "function",
	    arrowFunctions: "arrow function",
	    generatorFunctions: "generator function",
	    asyncFunctions: "async function",
	    methods: "method",
	    generatorMethods: "generator method",
	    asyncMethods: "async method",
	    getters: "getter",
	    setters: "setter",
	    constructors: "constructor"
	});
	
	/**
	 * Gets the kind of a given function node.
	 *
	 * @param {ASTNode} node - A function node to get. This is one of
	 *      an ArrowFunctionExpression, a FunctionDeclaration, or a
	 *      FunctionExpression.
	 * @returns {string} The kind of the function. This is one of "functions",
	 *      "arrowFunctions", "generatorFunctions", "asyncFunctions", "methods",
	 *      "generatorMethods", "asyncMethods", "getters", "setters", and
	 *      "constructors".
	 */
	function getKind(node) {
	    const parent = node.parent;
	    let kind = "";
	
	    if (node.type === "ArrowFunctionExpression") {
	        return "arrowFunctions";
	    }
	
	    // Detects main kind.
	    if (parent.type === "Property") {
	        if (parent.kind === "get") {
	            return "getters";
	        }
	        if (parent.kind === "set") {
	            return "setters";
	        }
	        kind = parent.method ? "methods" : "functions";
	
	    } else if (parent.type === "MethodDefinition") {
	        if (parent.kind === "get") {
	            return "getters";
	        }
	        if (parent.kind === "set") {
	            return "setters";
	        }
	        if (parent.kind === "constructor") {
	            return "constructors";
	        }
	        kind = "methods";
	
	    } else {
	        kind = "functions";
	    }
	
	    // Detects prefix.
	    let prefix = "";
	
	    if (node.generator) {
	        prefix = "generator";
	    } else if (node.async) {
	        prefix = "async";
	    } else {
	        return kind;
	    }
	    return prefix + kind[0].toUpperCase() + kind.slice(1);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow empty functions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allow: {
	                        type: "array",
	                        items: {enum: ALLOW_OPTIONS},
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const allowed = options.allow || [];
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Reports a given function node if the node matches the following patterns.
	         *
	         * - Not allowed by options.
	         * - The body is empty.
	         * - The body doesn't have any comments.
	         *
	         * @param {ASTNode} node - A function node to report. This is one of
	         *      an ArrowFunctionExpression, a FunctionDeclaration, or a
	         *      FunctionExpression.
	         * @returns {void}
	         */
	        function reportIfEmpty(node) {
	            const kind = getKind(node);
	
	            if (allowed.indexOf(kind) === -1 &&
	                node.body.type === "BlockStatement" &&
	                node.body.body.length === 0 &&
	                sourceCode.getComments(node.body).trailing.length === 0
	            ) {
	                context.report({
	                    node,
	                    loc: node.body.loc.start,
	                    message: "Unexpected empty {{kind}}.",
	                    data: {
	                        kind: SHOW_KIND[kind]
	                    }
	                });
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: reportIfEmpty,
	            FunctionDeclaration: reportIfEmpty,
	            FunctionExpression: reportIfEmpty
	        };
	    }
	};


/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow an empty pattern
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow empty destructuring patterns",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        return {
	            ObjectPattern(node) {
	                if (node.properties.length === 0) {
	                    context.report(node, "Unexpected empty object pattern.");
	                }
	            },
	            ArrayPattern(node) {
	                if (node.elements.length === 0) {
	                    context.report(node, "Unexpected empty array pattern.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of an empty block statement
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow empty block statements",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowEmptyCatch: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {},
	            allowEmptyCatch = options.allowEmptyCatch || false;
	
	        const sourceCode = context.getSourceCode();
	
	        return {
	            BlockStatement(node) {
	
	                // if the body is not empty, we can just return immediately
	                if (node.body.length !== 0) {
	                    return;
	                }
	
	                // a function is generally allowed to be empty
	                if (astUtils.isFunction(node.parent)) {
	                    return;
	                }
	
	                if (allowEmptyCatch && node.parent.type === "CatchClause") {
	                    return;
	                }
	
	                // any other block is only allowed to be empty, if it contains a comment
	                if (sourceCode.getComments(node).trailing.length > 0) {
	                    return;
	                }
	
	                context.report(node, "Empty block statement.");
	            },
	
	            SwitchStatement(node) {
	
	                if (typeof node.cases === "undefined" || node.cases.length === 0) {
	                    context.report(node, "Empty switch statement.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 211 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparisons to null without a type-checking
	 * operator.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `null` comparisons without type-checking operators",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            BinaryExpression(node) {
	                const badOperator = node.operator === "==" || node.operator === "!=";
	
	                if (node.right.type === "Literal" && node.right.raw === "null" && badOperator ||
	                        node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
	                    context.report(node, "Use === to compare with null.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of eval() statement
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const candidatesOfGlobalObject = Object.freeze([
	    "global",
	    "window"
	]);
	
	/**
	 * Checks a given node is a Identifier node of the specified name.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - A name to check.
	 * @returns {boolean} `true` if the node is a Identifier node of the name.
	 */
	function isIdentifier(node, name) {
	    return node.type === "Identifier" && node.name === name;
	}
	
	/**
	 * Checks a given node is a Literal node of the specified string value.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - A name to check.
	 * @returns {boolean} `true` if the node is a Literal node of the name.
	 */
	function isConstant(node, name) {
	    switch (node.type) {
	        case "Literal":
	            return node.value === name;
	
	        case "TemplateLiteral":
	            return (
	                node.expressions.length === 0 &&
	                node.quasis[0].value.cooked === name
	            );
	
	        default:
	            return false;
	    }
	}
	
	/**
	 * Checks a given node is a MemberExpression node which has the specified name's
	 * property.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @param {string} name - A name to check.
	 * @returns {boolean} `true` if the node is a MemberExpression node which has
	 *      the specified name's property
	 */
	function isMember(node, name) {
	    return (
	        node.type === "MemberExpression" &&
	        (node.computed ? isConstant : isIdentifier)(node.property, name)
	    );
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `eval()`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowIndirect: {type: "boolean"}
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const allowIndirect = Boolean(
	            context.options[0] &&
	            context.options[0].allowIndirect
	        );
	        const sourceCode = context.getSourceCode();
	        let funcInfo = null;
	
	        /**
	         * Pushs a variable scope (Program or Function) information to the stack.
	         *
	         * This is used in order to check whether or not `this` binding is a
	         * reference to the global object.
	         *
	         * @param {ASTNode} node - A node of the scope. This is one of Program,
	         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.
	         * @returns {void}
	         */
	        function enterVarScope(node) {
	            const strict = context.getScope().isStrict;
	
	            funcInfo = {
	                upper: funcInfo,
	                node,
	                strict,
	                defaultThis: false,
	                initialized: strict
	            };
	        }
	
	        /**
	         * Pops a variable scope from the stack.
	         *
	         * @returns {void}
	         */
	        function exitVarScope() {
	            funcInfo = funcInfo.upper;
	        }
	
	        /**
	         * Reports a given node.
	         *
	         * `node` is `Identifier` or `MemberExpression`.
	         * The parent of `node` might be `CallExpression`.
	         *
	         * The location of the report is always `eval` `Identifier` (or possibly
	         * `Literal`). The type of the report is `CallExpression` if the parent is
	         * `CallExpression`. Otherwise, it's the given node type.
	         *
	         * @param {ASTNode} node - A node to report.
	         * @returns {void}
	         */
	        function report(node) {
	            let locationNode = node;
	            const parent = node.parent;
	
	            if (node.type === "MemberExpression") {
	                locationNode = node.property;
	            }
	            if (parent.type === "CallExpression" && parent.callee === node) {
	                node = parent;
	            }
	
	            context.report({
	                node,
	                loc: locationNode.loc.start,
	                message: "eval can be harmful."
	            });
	        }
	
	        /**
	         * Reports accesses of `eval` via the global object.
	         *
	         * @param {escope.Scope} globalScope - The global scope.
	         * @returns {void}
	         */
	        function reportAccessingEvalViaGlobalObject(globalScope) {
	            for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
	                const name = candidatesOfGlobalObject[i];
	                const variable = astUtils.getVariableByName(globalScope, name);
	
	                if (!variable) {
	                    continue;
	                }
	
	                const references = variable.references;
	
	                for (let j = 0; j < references.length; ++j) {
	                    const identifier = references[j].identifier;
	                    let node = identifier.parent;
	
	                    // To detect code like `window.window.eval`.
	                    while (isMember(node, name)) {
	                        node = node.parent;
	                    }
	
	                    // Reports.
	                    if (isMember(node, "eval")) {
	                        report(node);
	                    }
	                }
	            }
	        }
	
	        /**
	         * Reports all accesses of `eval` (excludes direct calls to eval).
	         *
	         * @param {escope.Scope} globalScope - The global scope.
	         * @returns {void}
	         */
	        function reportAccessingEval(globalScope) {
	            const variable = astUtils.getVariableByName(globalScope, "eval");
	
	            if (!variable) {
	                return;
	            }
	
	            const references = variable.references;
	
	            for (let i = 0; i < references.length; ++i) {
	                const reference = references[i];
	                const id = reference.identifier;
	
	                if (id.name === "eval" && !astUtils.isCallee(id)) {
	
	                    // Is accessing to eval (excludes direct calls to eval)
	                    report(id);
	                }
	            }
	        }
	
	        if (allowIndirect) {
	
	            // Checks only direct calls to eval. It's simple!
	            return {
	                "CallExpression:exit"(node) {
	                    const callee = node.callee;
	
	                    if (isIdentifier(callee, "eval")) {
	                        report(callee);
	                    }
	                }
	            };
	        }
	
	        return {
	            "CallExpression:exit"(node) {
	                const callee = node.callee;
	
	                if (isIdentifier(callee, "eval")) {
	                    report(callee);
	                }
	            },
	
	            Program(node) {
	                const scope = context.getScope(),
	                    features = context.parserOptions.ecmaFeatures || {},
	                    strict =
	                        scope.isStrict ||
	                        node.sourceType === "module" ||
	                        (features.globalReturn && scope.childScopes[0].isStrict);
	
	                funcInfo = {
	                    upper: null,
	                    node,
	                    strict,
	                    defaultThis: true,
	                    initialized: true
	                };
	            },
	
	            "Program:exit"() {
	                const globalScope = context.getScope();
	
	                exitVarScope();
	                reportAccessingEval(globalScope);
	                reportAccessingEvalViaGlobalObject(globalScope);
	            },
	
	            FunctionDeclaration: enterVarScope,
	            "FunctionDeclaration:exit": exitVarScope,
	            FunctionExpression: enterVarScope,
	            "FunctionExpression:exit": exitVarScope,
	            ArrowFunctionExpression: enterVarScope,
	            "ArrowFunctionExpression:exit": exitVarScope,
	
	            ThisExpression(node) {
	                if (!isMember(node.parent, "eval")) {
	                    return;
	                }
	
	                /*
	                 * `this.eval` is found.
	                 * Checks whether or not the value of `this` is the global object.
	                 */
	                if (!funcInfo.initialized) {
	                    funcInfo.initialized = true;
	                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(
	                        funcInfo.node,
	                        sourceCode
	                    );
	                }
	
	                if (!funcInfo.strict && funcInfo.defaultThis) {
	
	                    // `this.eval` is possible built-in `eval`.
	                    report(node.parent);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag assignment of the exception parameter
	 * @author Stephen Murray <spmurrayzzz>
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow reassigning exceptions in `catch` clauses",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            astUtils.getModifyingReferences(variable.references).forEach(function(reference) {
	                context.report(
	                    reference.identifier,
	                    "Do not assign to the exception parameter.");
	            });
	        }
	
	        return {
	            CatchClause(node) {
	                context.getDeclaredVariables(node).forEach(checkVariable);
	            }
	        };
	
	    }
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag adding properties to native object's prototypes.
	 * @author David Nelson
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const globals = __webpack_require__(117);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow extending native types",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        },
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const config = context.options[0] || {};
	        const exceptions = config.exceptions || [];
	        let modifiedBuiltins = Object.keys(globals.builtin).filter(function(builtin) {
	            return builtin[0].toUpperCase() === builtin[0];
	        });
	
	        if (exceptions.length) {
	            modifiedBuiltins = modifiedBuiltins.filter(function(builtIn) {
	                return exceptions.indexOf(builtIn) === -1;
	            });
	        }
	
	        return {
	
	            // handle the Array.prototype.extra style case
	            AssignmentExpression(node) {
	                const lhs = node.left;
	
	                if (lhs.type !== "MemberExpression" || lhs.object.type !== "MemberExpression") {
	                    return;
	                }
	
	                const affectsProto = lhs.object.computed ?
	                    lhs.object.property.type === "Literal" && lhs.object.property.value === "prototype" :
	                    lhs.object.property.name === "prototype";
	
	                if (!affectsProto) {
	                    return;
	                }
	
	                modifiedBuiltins.forEach(function(builtin) {
	                    if (lhs.object.object.name === builtin) {
	                        context.report({
	                            node,
	                            message: "{{builtin}} prototype is read only, properties should not be added.",
	                            data: {
	                                builtin
	                            }
	                        });
	                    }
	                });
	            },
	
	            // handle the Object.definePropert[y|ies](Array.prototype) case
	            CallExpression(node) {
	
	                const callee = node.callee;
	
	                // only worry about Object.definePropert[y|ies]
	                if (callee.type === "MemberExpression" &&
	                    callee.object.name === "Object" &&
	                    (callee.property.name === "defineProperty" || callee.property.name === "defineProperties")) {
	
	                    // verify the object being added to is a native prototype
	                    const subject = node.arguments[0];
	                    const object = subject && subject.object;
	
	                    if (object &&
	                        object.type === "Identifier" &&
	                        (modifiedBuiltins.indexOf(object.name) > -1) &&
	                        subject.property.name === "prototype") {
	
	                        context.report({
	                            node,
	                            message: "{{objectName}} prototype is read only, properties should not be added.",
	                            data: {
	                                objectName: object.name
	                            }
	                        });
	                    }
	                }
	
	            }
	        };
	
	    }
	};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag unnecessary bind calls
	 * @author Bence Dnyi <bence@danyi.me>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const getPropertyName = __webpack_require__(109).getStaticPropertyName;
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary calls to `.bind()`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        let scopeInfo = null;
	
	        /**
	         * Reports a given function node.
	         *
	         * @param {ASTNode} node - A node to report. This is a FunctionExpression or
	         *      an ArrowFunctionExpression.
	         * @returns {void}
	         */
	        function report(node) {
	            context.report({
	                node: node.parent.parent,
	                message: "The function binding is unnecessary.",
	                loc: node.parent.property.loc.start,
	                fix(fixer) {
	                    const firstTokenToRemove = context.getSourceCode()
	                        .getTokensBetween(node.parent.object, node.parent.property)
	                        .find(token => token.value !== ")");
	
	                    return fixer.removeRange([firstTokenToRemove.range[0], node.parent.parent.range[1]]);
	                }
	            });
	        }
	
	        /**
	         * Checks whether or not a given function node is the callee of `.bind()`
	         * method.
	         *
	         * e.g. `(function() {}.bind(foo))`
	         *
	         * @param {ASTNode} node - A node to report. This is a FunctionExpression or
	         *      an ArrowFunctionExpression.
	         * @returns {boolean} `true` if the node is the callee of `.bind()` method.
	         */
	        function isCalleeOfBindMethod(node) {
	            const parent = node.parent;
	            const grandparent = parent.parent;
	
	            return (
	                grandparent &&
	                grandparent.type === "CallExpression" &&
	                grandparent.callee === parent &&
	                grandparent.arguments.length === 1 &&
	                parent.type === "MemberExpression" &&
	                parent.object === node &&
	                getPropertyName(parent) === "bind"
	            );
	        }
	
	        /**
	         * Adds a scope information object to the stack.
	         *
	         * @param {ASTNode} node - A node to add. This node is a FunctionExpression
	         *      or a FunctionDeclaration node.
	         * @returns {void}
	         */
	        function enterFunction(node) {
	            scopeInfo = {
	                isBound: isCalleeOfBindMethod(node),
	                thisFound: false,
	                upper: scopeInfo
	            };
	        }
	
	        /**
	         * Removes the scope information object from the top of the stack.
	         * At the same time, this reports the function node if the function has
	         * `.bind()` and the `this` keywords found.
	         *
	         * @param {ASTNode} node - A node to remove. This node is a
	         *      FunctionExpression or a FunctionDeclaration node.
	         * @returns {void}
	         */
	        function exitFunction(node) {
	            if (scopeInfo.isBound && !scopeInfo.thisFound) {
	                report(node);
	            }
	
	            scopeInfo = scopeInfo.upper;
	        }
	
	        /**
	         * Reports a given arrow function if the function is callee of `.bind()`
	         * method.
	         *
	         * @param {ASTNode} node - A node to report. This node is an
	         *      ArrowFunctionExpression.
	         * @returns {void}
	         */
	        function exitArrowFunction(node) {
	            if (isCalleeOfBindMethod(node)) {
	                report(node);
	            }
	        }
	
	        /**
	         * Set the mark as the `this` keyword was found in this scope.
	         *
	         * @returns {void}
	         */
	        function markAsThisFound() {
	            if (scopeInfo) {
	                scopeInfo.thisFound = true;
	            }
	        }
	
	        return {
	            "ArrowFunctionExpression:exit": exitArrowFunction,
	            FunctionDeclaration: enterFunction,
	            "FunctionDeclaration:exit": exitFunction,
	            FunctionExpression: enterFunction,
	            "FunctionExpression:exit": exitFunction,
	            ThisExpression: markAsThisFound
	        };
	    }
	};


/***/ },
/* 216 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag unnecessary double negation in Boolean contexts
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary boolean casts",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        // Node types which have a test which will coerce values to booleans.
	        const BOOLEAN_NODE_TYPES = [
	            "IfStatement",
	            "DoWhileStatement",
	            "WhileStatement",
	            "ConditionalExpression",
	            "ForStatement"
	        ];
	
	        /**
	         * Check if a node is in a context where its value would be coerced to a boolean at runtime.
	         *
	         * @param {Object} node The node
	         * @param {Object} parent Its parent
	         * @returns {boolean} If it is in a boolean context
	         */
	        function isInBooleanContext(node, parent) {
	            return (
	                (BOOLEAN_NODE_TYPES.indexOf(parent.type) !== -1 &&
	                    node === parent.test) ||
	
	                // !<bool>
	                (parent.type === "UnaryExpression" &&
	                    parent.operator === "!")
	            );
	        }
	
	
	        return {
	            UnaryExpression(node) {
	                const ancestors = context.getAncestors(),
	                    parent = ancestors.pop(),
	                    grandparent = ancestors.pop();
	
	                // Exit early if it's guaranteed not to match
	                if (node.operator !== "!" ||
	                        parent.type !== "UnaryExpression" ||
	                        parent.operator !== "!") {
	                    return;
	                }
	
	                if (isInBooleanContext(parent, grandparent) ||
	
	                    // Boolean(<bool>) and new Boolean(<bool>)
	                    ((grandparent.type === "CallExpression" || grandparent.type === "NewExpression") &&
	                        grandparent.callee.type === "Identifier" &&
	                        grandparent.callee.name === "Boolean")
	                ) {
	                    context.report(node, "Redundant double negation.");
	                }
	            },
	            CallExpression(node) {
	                const parent = node.parent;
	
	                if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
	                    return;
	                }
	
	                if (isInBooleanContext(node, parent)) {
	                    context.report(node, "Redundant Boolean call.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow unnecessary labels
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary labels",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let scopeInfo = null;
	
	        /**
	         * Creates a new scope with a breakable statement.
	         *
	         * @param {ASTNode} node - A node to create. This is a BreakableStatement.
	         * @returns {void}
	         */
	        function enterBreakableStatement(node) {
	            scopeInfo = {
	                label: astUtils.getLabel(node),
	                breakable: true,
	                upper: scopeInfo
	            };
	        }
	
	        /**
	         * Removes the top scope of the stack.
	         *
	         * @returns {void}
	         */
	        function exitBreakableStatement() {
	            scopeInfo = scopeInfo.upper;
	        }
	
	        /**
	         * Creates a new scope with a labeled statement.
	         *
	         * This ignores it if the body is a breakable statement.
	         * In this case it's handled in the `enterBreakableStatement` function.
	         *
	         * @param {ASTNode} node - A node to create. This is a LabeledStatement.
	         * @returns {void}
	         */
	        function enterLabeledStatement(node) {
	            if (!astUtils.isBreakableStatement(node.body)) {
	                scopeInfo = {
	                    label: node.label.name,
	                    breakable: false,
	                    upper: scopeInfo
	                };
	            }
	        }
	
	        /**
	         * Removes the top scope of the stack.
	         *
	         * This ignores it if the body is a breakable statement.
	         * In this case it's handled in the `exitBreakableStatement` function.
	         *
	         * @param {ASTNode} node - A node. This is a LabeledStatement.
	         * @returns {void}
	         */
	        function exitLabeledStatement(node) {
	            if (!astUtils.isBreakableStatement(node.body)) {
	                scopeInfo = scopeInfo.upper;
	            }
	        }
	
	        /**
	         * Reports a given control node if it's unnecessary.
	         *
	         * @param {ASTNode} node - A node. This is a BreakStatement or a
	         *      ContinueStatement.
	         * @returns {void}
	         */
	        function reportIfUnnecessary(node) {
	            if (!node.label) {
	                return;
	            }
	
	            const labelNode = node.label;
	            const label = labelNode.name;
	            let info = scopeInfo;
	
	            while (info) {
	                if (info.breakable || info.label === label) {
	                    if (info.breakable && info.label === label) {
	                        context.report({
	                            node: labelNode,
	                            message: "This label '{{name}}' is unnecessary.",
	                            data: labelNode
	                        });
	                    }
	                    return;
	                }
	
	                info = info.upper;
	            }
	        }
	
	        return {
	            WhileStatement: enterBreakableStatement,
	            "WhileStatement:exit": exitBreakableStatement,
	            DoWhileStatement: enterBreakableStatement,
	            "DoWhileStatement:exit": exitBreakableStatement,
	            ForStatement: enterBreakableStatement,
	            "ForStatement:exit": exitBreakableStatement,
	            ForInStatement: enterBreakableStatement,
	            "ForInStatement:exit": exitBreakableStatement,
	            ForOfStatement: enterBreakableStatement,
	            "ForOfStatement:exit": exitBreakableStatement,
	            SwitchStatement: enterBreakableStatement,
	            "SwitchStatement:exit": exitBreakableStatement,
	            LabeledStatement: enterLabeledStatement,
	            "LabeledStatement:exit": exitLabeledStatement,
	            BreakStatement: reportIfUnnecessary,
	            ContinueStatement: reportIfUnnecessary
	        };
	    }
	};


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallow parenthesising higher precedence subexpressions.
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	const esUtils = __webpack_require__(110);
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary parentheses",
	            category: "Possible Errors",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["functions"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["all"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                conditionalAssign: {type: "boolean"},
	                                nestedBinaryExpressions: {type: "boolean"},
	                                returnAssign: {type: "boolean"}
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        }
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        const isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);
	        const precedence = astUtils.getPrecedence;
	        const ALL_NODES = context.options[0] !== "functions";
	        const EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;
	        const NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;
	        const EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;
	
	        /**
	         * Determines if this rule should be enforced for a node given the current configuration.
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the rule should be enforced for this node.
	         * @private
	         */
	        function ruleApplies(node) {
	            return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
	        }
	
	        /**
	         * Determines if a node is surrounded by parentheses twice.
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is doubly parenthesised.
	         * @private
	         */
	        function isParenthesisedTwice(node) {
	            const previousToken = sourceCode.getTokenBefore(node, 1),
	                nextToken = sourceCode.getTokenAfter(node, 1);
	
	            return isParenthesised(node) && previousToken && nextToken &&
	                previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	                nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	        }
	
	        /**
	         * Determines if a node is surrounded by (potentially) invalid parentheses.
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is incorrectly parenthesised.
	         * @private
	         */
	        function hasExcessParens(node) {
	            return ruleApplies(node) && isParenthesised(node);
	        }
	
	        /**
	         * Determines if a node that is expected to be parenthesised is surrounded by
	         * (potentially) invalid extra parentheses.
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.
	         * @private
	         */
	        function hasDoubleExcessParens(node) {
	            return ruleApplies(node) && isParenthesisedTwice(node);
	        }
	
	        /**
	         * Determines if a node test expression is allowed to have a parenthesised assignment
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the assignment can be parenthesised.
	         * @private
	         */
	        function isCondAssignException(node) {
	            return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
	        }
	
	        /**
	         * Determines if a node is in a return statement
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is in a return statement.
	         * @private
	         */
	        function isInReturnStatement(node) {
	            while (node) {
	                if (node.type === "ReturnStatement" ||
	                        (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement")) {
	                    return true;
	                }
	                node = node.parent;
	            }
	
	            return false;
	        }
	
	        /**
	         * Determines if a node is or contains an assignment expression
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is or contains an assignment expression.
	         * @private
	         */
	        function containsAssignment(node) {
	            if (node.type === "AssignmentExpression") {
	                return true;
	            } else if (node.type === "ConditionalExpression" &&
	                    (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
	                return true;
	            } else if ((node.left && node.left.type === "AssignmentExpression") ||
	                    (node.right && node.right.type === "AssignmentExpression")) {
	                return true;
	            }
	
	            return false;
	        }
	
	        /**
	         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the assignment can be parenthesised.
	         * @private
	         */
	        function isReturnAssignException(node) {
	            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
	                return false;
	            }
	
	            if (node.type === "ReturnStatement") {
	                return node.argument && containsAssignment(node.argument);
	            } else if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
	                return containsAssignment(node.body);
	            } else {
	                return containsAssignment(node);
	            }
	        }
	
	        /**
	         * Determines if a node following a [no LineTerminator here] restriction is
	         * surrounded by (potentially) invalid extra parentheses.
	         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.
	         * @param {ASTNode} node - The node to be checked.
	         * @returns {boolean} True if the node is incorrectly parenthesised.
	         * @private
	         */
	        function hasExcessParensNoLineTerminator(token, node) {
	            if (token.loc.end.line === node.loc.start.line) {
	                return hasExcessParens(node);
	            }
	
	            return hasDoubleExcessParens(node);
	        }
	
	        /**
	         * Checks whether or not a given node is located at the head of ExpressionStatement.
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} `true` if the node is located at the head of ExpressionStatement.
	         */
	        function isHeadOfExpressionStatement(node) {
	            let parent = node.parent;
	
	            while (parent) {
	                switch (parent.type) {
	                    case "SequenceExpression":
	                        if (parent.expressions[0] !== node || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "UnaryExpression":
	                    case "UpdateExpression":
	                        if (parent.prefix || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "BinaryExpression":
	                    case "LogicalExpression":
	                        if (parent.left !== node || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "ConditionalExpression":
	                        if (parent.test !== node || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "CallExpression":
	                        if (parent.callee !== node || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "MemberExpression":
	                        if (parent.object !== node || isParenthesised(node)) {
	                            return false;
	                        }
	                        break;
	
	                    case "ExpressionStatement":
	                        return true;
	
	                    default:
	                        return false;
	                }
	
	                node = parent;
	                parent = parent.parent;
	            }
	
	            /* istanbul ignore next */
	            throw new Error("unreachable");
	        }
	
	        /**
	         * Determines whether a node should be preceded by an additional space when removing parens
	         * @param {ASTNode} node node to evaluate; must be surrounded by parentheses
	         * @returns {boolean} `true` if a space should be inserted before the node
	         * @private
	         */
	        function requiresLeadingSpace(node) {
	            const leftParenToken = sourceCode.getTokenBefore(node);
	            const tokenBeforeLeftParen = sourceCode.getTokenBefore(node, 1);
	            const firstToken = sourceCode.getFirstToken(node);
	
	            // If there is already whitespace before the previous token, don't add more.
	            if (!tokenBeforeLeftParen || tokenBeforeLeftParen.end !== leftParenToken.start) {
	                return false;
	            }
	
	            // If the parens are preceded by a keyword (e.g. `typeof(0)`), a space should be inserted (`typeof 0`)
	            const precededByKeyword = tokenBeforeLeftParen.type === "Keyword";
	
	            // However, a space should not be inserted unless the first character of the token is an identifier part
	            // e.g. `typeof([])` should be fixed to `typeof[]`
	            const startsWithIdentifierPart = esUtils.code.isIdentifierPartES6(firstToken.value.charCodeAt(0));
	
	            // If the parens are preceded by and start with a unary plus/minus (e.g. `+(+foo)`), a space should be inserted (`+ +foo`)
	            const precededByUnaryPlus = tokenBeforeLeftParen.type === "Punctuator" && tokenBeforeLeftParen.value === "+";
	            const precededByUnaryMinus = tokenBeforeLeftParen.type === "Punctuator" && tokenBeforeLeftParen.value === "-";
	
	            const startsWithUnaryPlus = firstToken.type === "Punctuator" && firstToken.value === "+";
	            const startsWithUnaryMinus = firstToken.type === "Punctuator" && firstToken.value === "-";
	
	            return (precededByKeyword && startsWithIdentifierPart) ||
	                (precededByUnaryPlus && startsWithUnaryPlus) ||
	                (precededByUnaryMinus && startsWithUnaryMinus);
	        }
	
	        /**
	         * Report the node
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function report(node) {
	            const leftParenToken = sourceCode.getTokenBefore(node);
	            const rightParenToken = sourceCode.getTokenAfter(node);
	
	            context.report({
	                node,
	                loc: leftParenToken.loc.start,
	                message: "Gratuitous parentheses around expression.",
	                fix(fixer) {
	                    const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
	
	                    return fixer.replaceTextRange([
	                        leftParenToken.range[0],
	                        rightParenToken.range[1]
	                    ], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource);
	                }
	            });
	        }
	
	        /**
	         * Evaluate Unary update
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function dryUnaryUpdate(node) {
	            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {
	                report(node.argument);
	            }
	        }
	
	        /**
	         * Evaluate a new call
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function dryCallNew(node) {
	            if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(
	                node.type === "CallExpression" &&
	                node.callee.type === "FunctionExpression" &&
	
	                // One set of parentheses are allowed for a function expression
	                !hasDoubleExcessParens(node.callee)
	            )) {
	                report(node.callee);
	            }
	            if (node.arguments.length === 1) {
	                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: "AssignmentExpression"})) {
	                    report(node.arguments[0]);
	                }
	            } else {
	                [].forEach.call(node.arguments, function(arg) {
	                    if (hasExcessParens(arg) && precedence(arg) >= precedence({type: "AssignmentExpression"})) {
	                        report(arg);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Evaluate binary logicals
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function dryBinaryLogical(node) {
	            const prec = precedence(node);
	            const shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression");
	            const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");
	
	            if (!shouldSkipLeft && hasExcessParens(node.left) && precedence(node.left) >= prec) {
	                report(node.left);
	            }
	            if (!shouldSkipRight && hasExcessParens(node.right) && precedence(node.right) > prec) {
	                report(node.right);
	            }
	        }
	
	        return {
	            ArrayExpression(node) {
	                [].forEach.call(node.elements, function(e) {
	                    if (e && hasExcessParens(e) && precedence(e) >= precedence({type: "AssignmentExpression"})) {
	                        report(e);
	                    }
	                });
	            },
	
	            ArrowFunctionExpression(node) {
	                if (isReturnAssignException(node)) {
	                    return;
	                }
	
	                if (node.body.type !== "BlockStatement") {
	                    if (sourceCode.getFirstToken(node.body).value !== "{" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: "AssignmentExpression"})) {
	                        report(node.body);
	                        return;
	                    }
	
	                    // Object literals *must* be parenthesised
	                    if (node.body.type === "ObjectExpression" && hasDoubleExcessParens(node.body)) {
	                        report(node.body);
	                    }
	                }
	            },
	
	            AssignmentExpression(node) {
	                if (isReturnAssignException(node)) {
	                    return;
	                }
	
	                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {
	                    report(node.right);
	                }
	            },
	
	            BinaryExpression: dryBinaryLogical,
	            CallExpression: dryCallNew,
	
	            ConditionalExpression(node) {
	                if (isReturnAssignException(node)) {
	                    return;
	                }
	
	                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: "LogicalExpression", operator: "||"})) {
	                    report(node.test);
	                }
	
	                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: "AssignmentExpression"})) {
	                    report(node.consequent);
	                }
	
	                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: "AssignmentExpression"})) {
	                    report(node.alternate);
	                }
	            },
	
	            DoWhileStatement(node) {
	                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
	                    report(node.test);
	                }
	            },
	
	            ExpressionStatement(node) {
	                if (hasExcessParens(node.expression)) {
	                    const firstTokens = sourceCode.getFirstTokens(node.expression, 2);
	                    const firstToken = firstTokens[0];
	                    const secondToken = firstTokens[1];
	
	                    if (
	                        !firstToken ||
	                        firstToken.value !== "{" &&
	                        firstToken.value !== "function" &&
	                        firstToken.value !== "class" &&
	                        (
	                            firstToken.value !== "let" ||
	                            !secondToken ||
	                            secondToken.value !== "["
	                        )
	                    ) {
	                        report(node.expression);
	                    }
	                }
	            },
	
	            ForInStatement(node) {
	                if (hasExcessParens(node.right)) {
	                    report(node.right);
	                }
	            },
	
	            ForOfStatement(node) {
	                if (hasExcessParens(node.right)) {
	                    report(node.right);
	                }
	            },
	
	            ForStatement(node) {
	                if (node.init && hasExcessParens(node.init)) {
	                    report(node.init);
	                }
	
	                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
	                    report(node.test);
	                }
	
	                if (node.update && hasExcessParens(node.update)) {
	                    report(node.update);
	                }
	            },
	
	            IfStatement(node) {
	                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
	                    report(node.test);
	                }
	            },
	
	            LogicalExpression: dryBinaryLogical,
	
	            MemberExpression(node) {
	                if (
	                    hasExcessParens(node.object) &&
	                    precedence(node.object) >= precedence(node) &&
	                    (
	                        node.computed ||
	                        !(
	                            (node.object.type === "Literal" &&
	                            typeof node.object.value === "number" &&
	                            astUtils.isDecimalInteger(node.object))
	                            ||
	
	                            // RegExp literal is allowed to have parens (#1589)
	                            (node.object.type === "Literal" && node.object.regex)
	                        )
	                    ) &&
	                    !(
	                        (node.object.type === "FunctionExpression" || node.object.type === "ClassExpression") &&
	                        isHeadOfExpressionStatement(node) &&
	                        !hasDoubleExcessParens(node.object)
	                    )
	                ) {
	                    report(node.object);
	                }
	                if (node.computed && hasExcessParens(node.property)) {
	                    report(node.property);
	                }
	            },
	
	            NewExpression: dryCallNew,
	
	            ObjectExpression(node) {
	                [].forEach.call(node.properties, function(e) {
	                    const v = e.value;
	
	                    if (v && hasExcessParens(v) && precedence(v) >= precedence({type: "AssignmentExpression"})) {
	                        report(v);
	                    }
	                });
	            },
	
	            ReturnStatement(node) {
	                const returnToken = sourceCode.getFirstToken(node);
	
	                if (isReturnAssignException(node)) {
	                    return;
	                }
	
	                if (node.argument &&
	                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&
	
	                        // RegExp literal is allowed to have parens (#1589)
	                        !(node.argument.type === "Literal" && node.argument.regex)) {
	                    report(node.argument);
	                }
	            },
	
	            SequenceExpression(node) {
	                [].forEach.call(node.expressions, function(e) {
	                    if (hasExcessParens(e) && precedence(e) >= precedence(node)) {
	                        report(e);
	                    }
	                });
	            },
	
	            SwitchCase(node) {
	                if (node.test && hasExcessParens(node.test)) {
	                    report(node.test);
	                }
	            },
	
	            SwitchStatement(node) {
	                if (hasDoubleExcessParens(node.discriminant)) {
	                    report(node.discriminant);
	                }
	            },
	
	            ThrowStatement(node) {
	                const throwToken = sourceCode.getFirstToken(node);
	
	                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
	                    report(node.argument);
	                }
	            },
	
	            UnaryExpression: dryUnaryUpdate,
	            UpdateExpression: dryUnaryUpdate,
	            AwaitExpression: dryUnaryUpdate,
	
	            VariableDeclarator(node) {
	                if (node.init && hasExcessParens(node.init) &&
	                        precedence(node.init) >= precedence({type: "AssignmentExpression"}) &&
	
	                        // RegExp literal is allowed to have parens (#1589)
	                        !(node.init.type === "Literal" && node.init.regex)) {
	                    report(node.init);
	                }
	            },
	
	            WhileStatement(node) {
	                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {
	                    report(node.test);
	                }
	            },
	
	            WithStatement(node) {
	                if (hasDoubleExcessParens(node.object)) {
	                    report(node.object);
	                }
	            },
	
	            YieldExpression(node) {
	                if (node.argument) {
	                    const yieldToken = sourceCode.getFirstToken(node);
	
	                    if ((precedence(node.argument) >= precedence(node) &&
	                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||
	                            hasDoubleExcessParens(node.argument)) {
	                        report(node.argument);
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 219 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of unnecessary semicolons
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary semicolons",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        fixable: "code",
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Reports an unnecessary semicolon error.
	         * @param {Node|Token} nodeOrToken - A node or a token to be reported.
	         * @returns {void}
	         */
	        function report(nodeOrToken) {
	            context.report({
	                node: nodeOrToken,
	                message: "Unnecessary semicolon.",
	                fix(fixer) {
	                    return fixer.remove(nodeOrToken);
	                }
	            });
	        }
	
	        /**
	         * Checks for a part of a class body.
	         * This checks tokens from a specified token to a next MethodDefinition or the end of class body.
	         *
	         * @param {Token} firstToken - The first token to check.
	         * @returns {void}
	         */
	        function checkForPartOfClassBody(firstToken) {
	            for (let token = firstToken;
	                token.type === "Punctuator" && token.value !== "}";
	                token = sourceCode.getTokenAfter(token)
	            ) {
	                if (token.value === ";") {
	                    report(token);
	                }
	            }
	        }
	
	        return {
	
	            /**
	             * Reports this empty statement, except if the parent node is a loop.
	             * @param {Node} node - A EmptyStatement node to be reported.
	             * @returns {void}
	             */
	            EmptyStatement(node) {
	                const parent = node.parent,
	                    allowedParentTypes = [
	                        "ForStatement",
	                        "ForInStatement",
	                        "ForOfStatement",
	                        "WhileStatement",
	                        "DoWhileStatement",
	                        "IfStatement",
	                        "LabeledStatement",
	                        "WithStatement"
	                    ];
	
	                if (allowedParentTypes.indexOf(parent.type) === -1) {
	                    report(node);
	                }
	            },
	
	            /**
	             * Checks tokens from the head of this class body to the first MethodDefinition or the end of this class body.
	             * @param {Node} node - A ClassBody node to check.
	             * @returns {void}
	             */
	            ClassBody(node) {
	                checkForPartOfClassBody(sourceCode.getFirstToken(node, 1)); // 0 is `{`.
	            },
	
	            /**
	             * Checks tokens from this MethodDefinition to the next MethodDefinition or the end of this class body.
	             * @param {Node} node - A MethodDefinition node of the start point.
	             * @returns {void}
	             */
	            MethodDefinition(node) {
	                checkForPartOfClassBody(sourceCode.getTokenAfter(node));
	            }
	        };
	
	    }
	};


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag fall-through cases in switch statements.
	 * @author Matt DuVall <http://mattduvall.com/>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/i;
	
	/**
	 * Checks whether or not a given node has a fallthrough comment.
	 * @param {ASTNode} node - A SwitchCase node to get comments.
	 * @param {RuleContext} context - A rule context which stores comments.
	 * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.
	 * @returns {boolean} `true` if the node has a valid fallthrough comment.
	 */
	function hasFallthroughComment(node, context, fallthroughCommentPattern) {
	    const sourceCode = context.getSourceCode();
	    const comment = lodash.last(sourceCode.getComments(node).leading);
	
	    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
	}
	
	/**
	 * Checks whether or not a given code path segment is reachable.
	 * @param {CodePathSegment} segment - A CodePathSegment to check.
	 * @returns {boolean} `true` if the segment is reachable.
	 */
	function isReachable(segment) {
	    return segment.reachable;
	}
	
	/**
	 * Checks whether a node and a token are separated by blank lines
	 * @param {ASTNode} node - The node to check
	 * @param {Token} token - The token to compare against
	 * @returns {boolean} `true` if there are blank lines between node and token
	 */
	function hasBlankLinesBetween(node, token) {
	    return token.loc.start.line > node.loc.end.line + 1;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow fallthrough of `case` statements",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    commentPattern: {
	                        type: "string"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        let currentCodePath = null;
	        const sourceCode = context.getSourceCode();
	
	        /*
	         * We need to use leading comments of the next SwitchCase node because
	         * trailing comments is wrong if semicolons are omitted.
	         */
	        let fallthroughCase = null;
	        let fallthroughCommentPattern = null;
	
	        if (options.commentPattern) {
	            fallthroughCommentPattern = new RegExp(options.commentPattern);
	        } else {
	            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
	        }
	
	        return {
	            onCodePathStart(codePath) {
	                currentCodePath = codePath;
	            },
	            onCodePathEnd() {
	                currentCodePath = currentCodePath.upper;
	            },
	
	            SwitchCase(node) {
	
	                /*
	                 * Checks whether or not there is a fallthrough comment.
	                 * And reports the previous fallthrough node if that does not exist.
	                 */
	                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {
	                    context.report({
	                        message: "Expected a 'break' statement before '{{type}}'.",
	                        data: {type: node.test ? "case" : "default"},
	                        node
	                    });
	                }
	                fallthroughCase = null;
	            },
	
	            "SwitchCase:exit"(node) {
	                const nextToken = sourceCode.getTokenAfter(node);
	
	                /*
	                 * `reachable` meant fall through because statements preceded by
	                 * `break`, `return`, or `throw` are unreachable.
	                 * And allows empty cases and the last case.
	                 */
	                if (currentCodePath.currentSegments.some(isReachable) &&
	                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&
	                    lodash.last(node.parent.cases) !== node) {
	                    fallthroughCase = node;
	                }
	            }
	        };
	    }
	};


/***/ },
/* 221 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of a leading/trailing decimal point in a numeric literal
	 * @author James Allardice
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow leading or trailing decimal points in numeric literals",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        return {
	            Literal(node) {
	
	                if (typeof node.value === "number") {
	                    if (node.raw.indexOf(".") === 0) {
	                        context.report({
	                            node,
	                            message: "A leading decimal point can be confused with a dot.",
	                            fix: fixer => fixer.insertTextBefore(node, "0")
	                        });
	                    }
	                    if (node.raw.indexOf(".") === node.raw.length - 1) {
	                        context.report({
	                            node,
	                            message: "A trailing decimal point can be confused with a dot.",
	                            fix: fixer => fixer.insertTextAfter(node, "0")
	                        });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of function declaration identifiers as variables.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow reassigning `function` declarations",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Reports a reference if is non initializer and writable.
	         * @param {References} references - Collection of reference to check.
	         * @returns {void}
	         */
	        function checkReference(references) {
	            astUtils.getModifyingReferences(references).forEach(function(reference) {
	                context.report(
	                    reference.identifier,
	                    "'{{name}}' is a function.",
	                    {name: reference.identifier.name});
	            });
	        }
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            if (variable.defs[0].type === "FunctionName") {
	                checkReference(variable.references);
	            }
	        }
	
	        /**
	         * Checks parameters of a given function node.
	         * @param {ASTNode} node - A function node to check.
	         * @returns {void}
	         */
	        function checkForFunction(node) {
	            context.getDeclaredVariables(node).forEach(checkVariable);
	        }
	
	        return {
	            FunctionDeclaration: checkForFunction,
	            FunctionExpression: checkForFunction
	        };
	    }
	};


/***/ },
/* 223 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow assignments to native objects or read-only global variables",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {type: "string"},
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const config = context.options[0];
	        const exceptions = (config && config.exceptions) || [];
	
	        /**
	         * Reports write references.
	         * @param {Reference} reference - A reference to check.
	         * @param {int} index - The index of the reference in the references.
	         * @param {Reference[]} references - The array that the reference belongs to.
	         * @returns {void}
	         */
	        function checkReference(reference, index, references) {
	            const identifier = reference.identifier;
	
	            if (reference.init === false &&
	                reference.isWrite() &&
	
	                // Destructuring assignments can have multiple default value,
	                // so possibly there are multiple writeable references for the same identifier.
	                (index === 0 || references[index - 1].identifier !== identifier)
	            ) {
	                context.report({
	                    node: identifier,
	                    message: "Read-only global '{{name}}' should not be modified.",
	                    data: identifier
	                });
	            }
	        }
	
	        /**
	         * Reports write references if a given variable is read-only builtin.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
	                variable.references.forEach(checkReference);
	            }
	        }
	
	        return {
	            Program() {
	                const globalScope = context.getScope();
	
	                globalScope.variables.forEach(checkVariable);
	            }
	        };
	    }
	};


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow the type conversions with shorter notations.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;
	const ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
	
	/**
	 * Parses and normalizes an option object.
	 * @param {Object} options - An option object to parse.
	 * @returns {Object} The parsed and normalized option object.
	 */
	function parseOptions(options) {
	    options = options || {};
	    return {
	        boolean: "boolean" in options ? Boolean(options.boolean) : true,
	        number: "number" in options ? Boolean(options.number) : true,
	        string: "string" in options ? Boolean(options.string) : true,
	        allow: options.allow || []
	    };
	}
	
	/**
	 * Checks whether or not a node is a double logical nigating.
	 * @param {ASTNode} node - An UnaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a double logical nigating.
	 */
	function isDoubleLogicalNegating(node) {
	    return (
	        node.operator === "!" &&
	        node.argument.type === "UnaryExpression" &&
	        node.argument.operator === "!"
	    );
	}
	
	/**
	 * Checks whether or not a node is a binary negating of `.indexOf()` method calling.
	 * @param {ASTNode} node - An UnaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.
	 */
	function isBinaryNegatingOfIndexOf(node) {
	    return (
	        node.operator === "~" &&
	        node.argument.type === "CallExpression" &&
	        node.argument.callee.type === "MemberExpression" &&
	        node.argument.callee.property.type === "Identifier" &&
	        INDEX_OF_PATTERN.test(node.argument.callee.property.name)
	    );
	}
	
	/**
	 * Checks whether or not a node is a multiplying by one.
	 * @param {BinaryExpression} node - A BinaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a multiplying by one.
	 */
	function isMultiplyByOne(node) {
	    return node.operator === "*" && (
	        node.left.type === "Literal" && node.left.value === 1 ||
	        node.right.type === "Literal" && node.right.value === 1
	    );
	}
	
	/**
	 * Checks whether the result of a node is numeric or not
	 * @param {ASTNode} node The node to test
	 * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call
	 */
	function isNumeric(node) {
	    return (
	        node.type === "Literal" && typeof node.value === "number" ||
	        node.type === "CallExpression" && (
	            node.callee.name === "Number" ||
	            node.callee.name === "parseInt" ||
	            node.callee.name === "parseFloat"
	        )
	    );
	}
	
	/**
	 * Returns the first non-numeric operand in a BinaryExpression. Designed to be
	 * used from bottom to up since it walks up the BinaryExpression trees using
	 * node.parent to find the result.
	 * @param {BinaryExpression} node The BinaryExpression node to be walked up on
	 * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null
	 */
	function getNonNumericOperand(node) {
	    const left = node.left,
	        right = node.right;
	
	    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
	        return right;
	    }
	
	    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
	        return left;
	    }
	
	    return null;
	}
	
	/**
	 * Checks whether a node is an empty string literal or not.
	 * @param {ASTNode} node The node to check.
	 * @returns {boolean} Whether or not the passed in node is an
	 * empty string literal or not.
	 */
	function isEmptyString(node) {
	    return astUtils.isStringLiteral(node) && (node.value === "" || (node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === ""));
	}
	
	/**
	 * Checks whether or not a node is a concatenating with an empty string.
	 * @param {ASTNode} node - A BinaryExpression node to check.
	 * @returns {boolean} Whether or not the node is a concatenating with an empty string.
	 */
	function isConcatWithEmptyString(node) {
	    return node.operator === "+" && (
	        (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right)) ||
	        (isEmptyString(node.right) && !astUtils.isStringLiteral(node.left))
	    );
	}
	
	/**
	 * Checks whether or not a node is appended with an empty string.
	 * @param {ASTNode} node - An AssignmentExpression node to check.
	 * @returns {boolean} Whether or not the node is appended with an empty string.
	 */
	function isAppendEmptyString(node) {
	    return node.operator === "+=" && isEmptyString(node.right);
	}
	
	/**
	 * Returns the operand that is not an empty string from a flagged BinaryExpression.
	 * @param {ASTNode} node - The flagged BinaryExpression node to check.
	 * @returns {ASTNode} The operand that is not an empty string from a flagged BinaryExpression.
	 */
	function getNonEmptyOperand(node) {
	    return isEmptyString(node.left) ? node.right : node.left;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow shorthand type conversions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        fixable: "code",
	        schema: [{
	            type: "object",
	            properties: {
	                boolean: {
	                    type: "boolean"
	                },
	                number: {
	                    type: "boolean"
	                },
	                string: {
	                    type: "boolean"
	                },
	                allow: {
	                    type: "array",
	                    items: {
	                        enum: ALLOWABLE_OPERATORS
	                    },
	                    uniqueItems: true
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const options = parseOptions(context.options[0]);
	        const sourceCode = context.getSourceCode();
	
	        /**
	        * Reports an error and autofixes the node
	        * @param {ASTNode} node - An ast node to report the error on.
	        * @param {string} recommendation - The recommended code for the issue
	        * @param {bool} shouldFix - Whether this report should fix the node
	        * @returns {void}
	        */
	        function report(node, recommendation, shouldFix) {
	            shouldFix = typeof shouldFix === "undefined" ? true : shouldFix;
	            const reportObj = {
	                node,
	                message: "use `{{recommendation}}` instead.",
	                data: {
	                    recommendation
	                }
	            };
	
	            if (shouldFix) {
	                reportObj.fix = fixer => fixer.replaceText(node, recommendation);
	            }
	
	            context.report(reportObj);
	        }
	
	        return {
	            UnaryExpression(node) {
	                let operatorAllowed;
	
	                // !!foo
	                operatorAllowed = options.allow.indexOf("!!") >= 0;
	                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
	                    const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
	
	                    report(node, recommendation);
	                }
	
	                // ~foo.indexOf(bar)
	                operatorAllowed = options.allow.indexOf("~") >= 0;
	                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
	                    const recommendation = `${sourceCode.getText(node.argument)} !== -1`;
	
	                    report(node, recommendation, false);
	                }
	
	                // +foo
	                operatorAllowed = options.allow.indexOf("+") >= 0;
	                if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
	                    const recommendation = `Number(${sourceCode.getText(node.argument)})`;
	
	                    report(node, recommendation);
	                }
	            },
	
	            // Use `:exit` to prevent double reporting
	            "BinaryExpression:exit"(node) {
	                let operatorAllowed;
	
	                // 1 * foo
	                operatorAllowed = options.allow.indexOf("*") >= 0;
	                const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
	
	                if (nonNumericOperand) {
	                    const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
	
	                    report(node, recommendation);
	                }
	
	                // "" + foo
	                operatorAllowed = options.allow.indexOf("+") >= 0;
	                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
	                    const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
	
	                    report(node, recommendation);
	                }
	            },
	
	            AssignmentExpression(node) {
	
	                // foo += ""
	                const operatorAllowed = options.allow.indexOf("+") >= 0;
	
	                if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
	                    const code = sourceCode.getText(getNonEmptyOperand(node));
	                    const recommendation = `${code} = String(${code})`;
	
	                    report(node, recommendation);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 225 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for implicit global variables and functions.
	 * @author Joshua Peek
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow variable and `function` declarations in the global scope",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        return {
	            Program() {
	                const scope = context.getScope();
	
	                scope.variables.forEach(function(variable) {
	                    if (variable.writeable) {
	                        return;
	                    }
	
	                    variable.defs.forEach(function(def) {
	                        if (def.type === "FunctionName" || (def.type === "Variable" && def.parent.kind === "var")) {
	                            context.report(def.node, "Implicit global variable, assign as global property instead.");
	                        }
	                    });
	                });
	
	                scope.implicit.variables.forEach(function(variable) {
	                    const scopeVariable = scope.set.get(variable.name);
	
	                    if (scopeVariable && scopeVariable.writeable) {
	                        return;
	                    }
	
	                    variable.defs.forEach(function(def) {
	                        context.report(def.node, "Implicit global variable, assign as global property instead.");
	                    });
	                });
	            }
	        };
	
	    }
	};


/***/ },
/* 226 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
	 * @author James Allardice
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `eval()`-like methods",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const CALLEE_RE = /set(?:Timeout|Interval)|execScript/;
	
	        /*
	         * Figures out if we should inspect a given binary expression. Is a stack
	         * of stacks, where the first element in each substack is a CallExpression.
	         */
	        const impliedEvalAncestorsStack = [];
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.
	         * @param {array} arr What to inspect
	         * @returns {*} The last element of arr
	         * @private
	         */
	        function last(arr) {
	            return arr ? arr[arr.length - 1] : null;
	        }
	
	        /**
	         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.
	         * @param {ASTNode} node The MemberExpression node to check.
	         * @returns {boolean} Whether or not the given node is potentially an implied eval.
	         * @private
	         */
	        function isImpliedEvalMemberExpression(node) {
	            const object = node.object,
	                property = node.property,
	                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);
	
	            return object.name === "window" && hasImpliedEvalName;
	        }
	
	        /**
	         * Determines if a node represents a call to a potentially implied eval.
	         *
	         * This checks the callee name and that there's an argument, but not the type of the argument.
	         *
	         * @param {ASTNode} node The CallExpression to check.
	         * @returns {boolean} True if the node matches, false if not.
	         * @private
	         */
	        function isImpliedEvalCallExpression(node) {
	            const isMemberExpression = (node.callee.type === "MemberExpression"),
	                isIdentifier = (node.callee.type === "Identifier"),
	                isImpliedEvalCallee =
	                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||
	                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));
	
	            return isImpliedEvalCallee && node.arguments.length;
	        }
	
	        /**
	         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.
	         * @param {ASTNode} node The node to inspect the parent of.
	         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?
	         * @private
	         */
	        function hasImpliedEvalParent(node) {
	
	            // make sure our parent is marked
	            return node.parent === last(last(impliedEvalAncestorsStack)) &&
	
	                // if our parent is a CallExpression, make sure we're the first argument
	                (node.parent.type !== "CallExpression" || node === node.parent.arguments[0]);
	        }
	
	        /**
	         * Checks if our parent is marked as part of an implied eval argument. If
	         * so, collapses the top of impliedEvalAncestorsStack and reports on the
	         * original CallExpression.
	         * @param {ASTNode} node The CallExpression to check.
	         * @returns {boolean} True if the node matches, false if not.
	         * @private
	         */
	        function checkString(node) {
	            if (hasImpliedEvalParent(node)) {
	
	                // remove the entire substack, to avoid duplicate reports
	                const substack = impliedEvalAncestorsStack.pop();
	
	                context.report(substack[0], "Implied eval. Consider passing a function instead of a string.");
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            CallExpression(node) {
	                if (isImpliedEvalCallExpression(node)) {
	
	                    // call expressions create a new substack
	                    impliedEvalAncestorsStack.push([node]);
	                }
	            },
	
	            "CallExpression:exit"(node) {
	                if (node === last(last(impliedEvalAncestorsStack))) {
	
	                    /* Destroys the entire sub-stack, rather than just using
	                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is
	                     * always the bottom of a impliedEvalAncestorsStack substack.
	                     */
	                    impliedEvalAncestorsStack.pop();
	                }
	            },
	
	            BinaryExpression(node) {
	                if (node.operator === "+" && hasImpliedEvalParent(node)) {
	                    last(impliedEvalAncestorsStack).push(node);
	                }
	            },
	
	            "BinaryExpression:exit"(node) {
	                if (node === last(last(impliedEvalAncestorsStack))) {
	                    last(impliedEvalAncestorsStack).pop();
	                }
	            },
	
	            Literal(node) {
	                if (typeof node.value === "string") {
	                    checkString(node);
	                }
	            },
	
	            TemplateLiteral(node) {
	                checkString(node);
	            }
	        };
	
	    }
	};


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Enforces or disallows inline comments.
	 * @author Greg Cochard
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow inline comments after code",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Will check that comments are not on lines starting with or ending with code
	         * @param {ASTNode} node The comment node to check
	         * @private
	         * @returns {void}
	         */
	        function testCodeAroundComment(node) {
	
	            // Get the whole line and cut it off at the start of the comment
	            const startLine = String(sourceCode.lines[node.loc.start.line - 1]);
	            const endLine = String(sourceCode.lines[node.loc.end.line - 1]);
	
	            const preamble = startLine.slice(0, node.loc.start.column).trim();
	
	            // Also check after the comment
	            const postamble = endLine.slice(node.loc.end.column).trim();
	
	            // Check that this comment isn't an ESLint directive
	            const isDirective = astUtils.isDirectiveComment(node);
	
	            // Should be empty if there was only whitespace around the comment
	            if (!isDirective && (preamble || postamble)) {
	                context.report(node, "Unexpected comment inline with code.");
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            LineComment: testCodeAroundComment,
	            BlockComment: testCodeAroundComment
	
	        };
	    }
	};


/***/ },
/* 228 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce declarations in program or function body root.
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow variable or `function` declarations in nested blocks",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                enum: ["functions", "both"]
	            }
	        ]
	    },
	
	    create(context) {
	
	        /**
	         * Find the nearest Program or Function ancestor node.
	         * @returns {Object} Ancestor's type and distance from node.
	         */
	        function nearestBody() {
	            const ancestors = context.getAncestors();
	            let ancestor = ancestors.pop(),
	                generation = 1;
	
	            while (ancestor && ["Program", "FunctionDeclaration",
	                "FunctionExpression", "ArrowFunctionExpression"
	            ].indexOf(ancestor.type) < 0) {
	                generation += 1;
	                ancestor = ancestors.pop();
	            }
	
	            return {
	
	                // Type of containing ancestor
	                type: ancestor.type,
	
	                // Separation between ancestor and node
	                distance: generation
	            };
	        }
	
	        /**
	         * Ensure that a given node is at a program or function body's root.
	         * @param {ASTNode} node Declaration node to check.
	         * @returns {void}
	         */
	        function check(node) {
	            const body = nearestBody(node),
	                valid = ((body.type === "Program" && body.distance === 1) ||
	                    body.distance === 2);
	
	            if (!valid) {
	                context.report(node, "Move {{type}} declaration to {{body}} root.",
	                    {
	                        type: (node.type === "FunctionDeclaration" ?
	                            "function" : "variable"),
	                        body: (body.type === "Program" ?
	                            "program" : "function body")
	                    }
	                );
	            }
	        }
	
	        return {
	
	            FunctionDeclaration: check,
	            VariableDeclaration(node) {
	                if (context.options[0] === "both" && node.kind === "var") {
	                    check(node);
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validate strings passed to the RegExp constructor
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const espree = __webpack_require__(230);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow invalid regular expression strings in `RegExp` constructors",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                allowConstructorFlags: {
	                    type: "array",
	                    items: {
	                        type: "string"
	                    }
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	
	        const options = context.options[0];
	        let allowedFlags = "";
	
	        if (options && options.allowConstructorFlags) {
	            allowedFlags = options.allowConstructorFlags.join("");
	        }
	
	        /**
	         * Check if node is a string
	         * @param {ASTNode} node node to evaluate
	         * @returns {boolean} True if its a string
	         * @private
	         */
	        function isString(node) {
	            return node && node.type === "Literal" && typeof node.value === "string";
	        }
	
	        /**
	         * Validate strings passed to the RegExp constructor
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function check(node) {
	            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0])) {
	                let flags = isString(node.arguments[1]) ? node.arguments[1].value : "";
	
	                if (allowedFlags) {
	                    flags = flags.replace(new RegExp(`[${allowedFlags}]`, "gi"), "");
	                }
	
	                try {
	                    void new RegExp(node.arguments[0].value);
	                } catch (e) {
	                    context.report({
	                        node,
	                        message: `${e.message}.`
	                    });
	                }
	
	                if (flags) {
	
	                    try {
	                        espree.parse(`/./${flags}`, context.parserOptions);
	                    } catch (ex) {
	                        context.report({
	                            node,
	                            message: "Invalid flags supplied to RegExp constructor '{{flags}}'.",
	                            data: {
	                                flags
	                            }
	                        });
	                    }
	                }
	
	            }
	        }
	
	        return {
	            CallExpression: check,
	            NewExpression: check
	        };
	
	    }
	};


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Main Espree file that converts Acorn into Esprima output.
	 *
	 * This file contains code from the following MIT-licensed projects:
	 * 1. Acorn
	 * 2. Babylon
	 * 3. Babel-ESLint
	 *
	 * This file also contains code from Esprima, which is BSD licensed.
	 *
	 * Acorn is Copyright 2012-2015 Acorn Contributors (https://github.com/marijnh/acorn/blob/master/AUTHORS)
	 * Babylon is Copyright 2014-2015 various contributors (https://github.com/babel/babel/blob/master/packages/babylon/AUTHORS)
	 * Babel-ESLint is Copyright 2014-2015 Sebastian McKenzie <sebmck@gmail.com>
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 * * Redistributions of source code must retain the above copyright
	 *   notice, this list of conditions and the following disclaimer.
	 * * Redistributions in binary form must reproduce the above copyright
	 *   notice, this list of conditions and the following disclaimer in the
	 *   documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 *
	 * Esprima is Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.
	 *
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are met:
	 *
	 *   * Redistributions of source code must retain the above copyright
	 *     notice, this list of conditions and the following disclaimer.
	 *   * Redistributions in binary form must reproduce the above copyright
	 *     notice, this list of conditions and the following disclaimer in the
	 *     documentation and/or other materials provided with the distribution.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */
	/* eslint no-undefined:0, no-use-before-define: 0 */
	
	"use strict";
	
	var astNodeTypes = __webpack_require__(231),
	    commentAttachment = __webpack_require__(232),
	    TokenTranslator = __webpack_require__(233),
	    acornJSX = __webpack_require__(234),
	    rawAcorn = __webpack_require__(236);
	
	
	var acorn = acornJSX(rawAcorn);
	
	var lookahead,
	    extra,
	    lastToken;
	
	/**
	 * Resets the extra object to its default.
	 * @returns {void}
	 * @private
	 */
	function resetExtra() {
	    extra = {
	        tokens: null,
	        range: false,
	        loc: false,
	        comment: false,
	        comments: [],
	        tolerant: false,
	        errors: [],
	        strict: false,
	        ecmaFeatures: {},
	        ecmaVersion: 5,
	        isModule: false
	    };
	}
	
	
	
	var tt = acorn.tokTypes,
	    getLineInfo = acorn.getLineInfo;
	
	// custom type for JSX attribute values
	tt.jsxAttrValueToken = {};
	
	/**
	 * Determines if a node is valid given the set of ecmaFeatures.
	 * @param {ASTNode} node The node to check.
	 * @returns {boolean} True if the node is allowed, false if not.
	 * @private
	 */
	function isValidNode(node) {
	    var ecma = extra.ecmaFeatures;
	
	    switch (node.type) {
	        case "ExperimentalSpreadProperty":
	        case "ExperimentalRestProperty":
	            return ecma.experimentalObjectRestSpread;
	
	        case "ImportDeclaration":
	        case "ExportNamedDeclaration":
	        case "ExportDefaultDeclaration":
	        case "ExportAllDeclaration":
	            return extra.isModule;
	
	        default:
	            return true;
	    }
	}
	
	/**
	 * Performs last-minute Esprima-specific compatibility checks and fixes.
	 * @param {ASTNode} result The node to check.
	 * @returns {ASTNode} The finished node.
	 * @private
	 * @this acorn.Parser
	 */
	function esprimaFinishNode(result) {
	    // ensure that parsed node was allowed through ecmaFeatures
	    if (!isValidNode(result)) {
	        this.unexpected(result.start);
	    }
	
	    // https://github.com/marijnh/acorn/issues/323
	    if (result.type === "TryStatement") {
	        delete result.guardedHandlers;
	    } else if (result.type === "CatchClause") {
	        delete result.guard;
	    }
	
	    // Acorn doesn't count the opening and closing backticks as part of templates
	    // so we have to adjust ranges/locations appropriately.
	    if (result.type === "TemplateElement") {
	
	        // additional adjustment needed if ${ is the last token
	        var terminalDollarBraceL = this.input.slice(result.end, result.end + 2) === "${";
	
	        if (result.range) {
	            result.range[0]--;
	            result.range[1] += (terminalDollarBraceL ? 2 : 1);
	        }
	
	        if (result.loc) {
	            result.loc.start.column--;
	            result.loc.end.column += (terminalDollarBraceL ? 2 : 1);
	        }
	    }
	
	    // Acorn currently uses expressions instead of declarations in default exports
	    if (result.type === "ExportDefaultDeclaration") {
	        if (/^(Class|Function)Expression$/.test(result.declaration.type)) {
	            result.declaration.type = result.declaration.type.replace("Expression", "Declaration");
	        }
	    }
	
	    // Acorn uses undefined instead of null, which affects serialization
	    if (result.type === "Literal" && result.value === undefined) {
	        result.value = null;
	    }
	
	    if (extra.attachComment) {
	        commentAttachment.processComment(result);
	    }
	
	    if (result.type.indexOf("Function") > -1 && !result.generator) {
	        result.generator = false;
	    }
	
	    return result;
	}
	
	/**
	 * Determines if a token is valid given the set of ecmaFeatures.
	 * @param {acorn.Parser} parser The parser to check.
	 * @returns {boolean} True if the token is allowed, false if not.
	 * @private
	 */
	function isValidToken(parser) {
	    var ecma = extra.ecmaFeatures;
	    var type = parser.type;
	
	    switch (type) {
	        case tt.jsxName:
	        case tt.jsxText:
	        case tt.jsxTagStart:
	        case tt.jsxTagEnd:
	            return ecma.jsx;
	
	        // https://github.com/ternjs/acorn/issues/363
	        case tt.regexp:
	            if (extra.ecmaVersion < 6 && parser.value.flags && parser.value.flags.indexOf("y") > -1) {
	                return false;
	            }
	
	            return true;
	
	        default:
	            return true;
	    }
	}
	
	/**
	 * Injects esprimaFinishNode into the finishNode process.
	 * @param {Function} finishNode Original finishNode function.
	 * @returns {ASTNode} The finished node.
	 * @private
	 */
	function wrapFinishNode(finishNode) {
	    return /** @this acorn.Parser */ function(node, type, pos, loc) {
	        var result = finishNode.call(this, node, type, pos, loc);
	        return esprimaFinishNode.call(this, result);
	    };
	}
	
	acorn.plugins.espree = function(instance) {
	
	    instance.extend("finishNode", wrapFinishNode);
	
	    instance.extend("finishNodeAt", wrapFinishNode);
	
	    instance.extend("next", function(next) {
	        return /** @this acorn.Parser */ function() {
	            if (!isValidToken(this)) {
	                this.unexpected();
	            }
	            return next.call(this);
	        };
	    });
	
	    // needed for experimental object rest/spread
	    instance.extend("checkLVal", function(checkLVal) {
	
	        return /** @this acorn.Parser */ function(expr, isBinding, checkClashes) {
	
	            if (extra.ecmaFeatures.experimentalObjectRestSpread && expr.type === "ObjectPattern") {
	                for (var i = 0; i < expr.properties.length; i++) {
	                    if (expr.properties[i].type.indexOf("Experimental") === -1) {
	                        this.checkLVal(expr.properties[i].value, isBinding, checkClashes);
	                    }
	                }
	                return undefined;
	            }
	
	            return checkLVal.call(this, expr, isBinding, checkClashes);
	        };
	    });
	
	    instance.extend("parseTopLevel", function(parseTopLevel) {
	        return /** @this acorn.Parser */ function(node) {
	            if (extra.ecmaFeatures.impliedStrict && this.options.ecmaVersion >= 5) {
	                this.strict = true;
	            }
	            return parseTopLevel.call(this, node);
	        };
	    });
	
	    instance.extend("toAssignable", function(toAssignable) {
	
	        return /** @this acorn.Parser */ function(node, isBinding) {
	
	            if (extra.ecmaFeatures.experimentalObjectRestSpread &&
	                    node.type === "ObjectExpression"
	            ) {
	                node.type = "ObjectPattern";
	
	                for (var i = 0; i < node.properties.length; i++) {
	                    var prop = node.properties[i];
	
	                    if (prop.type === "ExperimentalSpreadProperty") {
	                        prop.type = "ExperimentalRestProperty";
	                    } else if (prop.kind !== "init") {
	                        this.raise(prop.key.start, "Object pattern can't contain getter or setter");
	                    } else {
	                        this.toAssignable(prop.value, isBinding);
	                    }
	                }
	
	                return node;
	            } else {
	                return toAssignable.call(this, node, isBinding);
	            }
	        };
	
	    });
	
	    /**
	     * Method to parse an object rest or object spread.
	     * @returns {ASTNode} The node representing object rest or object spread.
	     * @this acorn.Parser
	     */
	    instance.parseObjectRest = function() {
	        var node = this.startNode();
	        this.next();
	        node.argument = this.parseIdent();
	        return this.finishNode(node, "ExperimentalRestProperty");
	    };
	
	    /**
	     * Method to parse an object with object rest or object spread.
	     * @param {boolean} isPattern True if the object is a destructuring pattern.
	     * @param {Object} refShorthandDefaultPos ?
	     * @returns {ASTNode} The node representing object rest or object spread.
	     * @this acorn.Parser
	     */
	    instance.parseObj = function(isPattern, refShorthandDefaultPos) {
	        var node = this.startNode(),
	            first = true,
	            propHash = {};
	        node.properties = [];
	        this.next();
	        while (!this.eat(tt.braceR)) {
	
	            if (!first) {
	                this.expect(tt.comma);
	
	                if (this.afterTrailingComma(tt.braceR)) {
	                    break;
	                }
	
	            } else {
	                first = false;
	            }
	
	            var prop = this.startNode(),
	                isGenerator,
	                isAsync,
	                startPos,
	                startLoc;
	
	            if (extra.ecmaFeatures.experimentalObjectRestSpread && this.type === tt.ellipsis) {
	                if (isPattern) {
	                    prop = this.parseObjectRest();
	                } else {
	                    prop = this.parseSpread();
	                    prop.type = "ExperimentalSpreadProperty";
	                }
	
	                node.properties.push(prop);
	                continue;
	            }
	
	            if (this.options.ecmaVersion >= 6) {
	                prop.method = false;
	                prop.shorthand = false;
	
	                if (isPattern || refShorthandDefaultPos) {
	                    startPos = this.start;
	                    startLoc = this.startLoc;
	                }
	
	                if (!isPattern) {
	                    isGenerator = this.eat(tt.star);
	                }
	            }
	
	            // grab the property name or "async"
	            this.parsePropertyName(prop, refShorthandDefaultPos);
	            if (this.options.ecmaVersion >= 8 &&
	                !isPattern &&
	                !isGenerator &&
	                !prop.computed &&
	                prop.key.type === "Identifier" &&
	                prop.key.name === "async" &&
	                this.type !== tt.parenL &&
	                this.type !== tt.colon &&
	                !this.canInsertSemicolon()
	            ) {
	                this.parsePropertyName(prop, refShorthandDefaultPos);
	                isAsync = true;
	            } else {
	                isAsync = false;
	            }
	
	            this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refShorthandDefaultPos);
	            this.checkPropClash(prop, propHash);
	            node.properties.push(this.finishNode(prop, "Property"));
	        }
	
	        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
	    };
	
	    /**
	     * Overwrites the default raise method to throw Esprima-style errors.
	     * @param {int} pos The position of the error.
	     * @param {string} message The error message.
	     * @throws {SyntaxError} A syntax error.
	     * @returns {void}
	     */
	    instance.raise = instance.raiseRecoverable = function(pos, message) {
	        var loc = getLineInfo(this.input, pos);
	        var err = new SyntaxError(message);
	        err.index = pos;
	        err.lineNumber = loc.line;
	        err.column = loc.column + 1; // acorn uses 0-based columns
	        throw err;
	    };
	
	    /**
	     * Overwrites the default unexpected method to throw Esprima-style errors.
	     * @param {int} pos The position of the error.
	     * @throws {SyntaxError} A syntax error.
	     * @returns {void}
	     */
	    instance.unexpected = function(pos) {
	        var message = "Unexpected token";
	
	        if (pos !== null && pos !== undefined) {
	            this.pos = pos;
	
	            if (this.options.locations) {
	                while (this.pos < this.lineStart) {
	                    this.lineStart = this.input.lastIndexOf("\n", this.lineStart - 2) + 1;
	                    --this.curLine;
	                }
	            }
	
	            this.nextToken();
	        }
	
	        if (this.end > this.start) {
	            message += " " + this.input.slice(this.start, this.end);
	        }
	
	        this.raise(this.start, message);
	    };
	
	    /*
	    * Esprima-FB represents JSX strings as tokens called "JSXText", but Acorn-JSX
	    * uses regular tt.string without any distinction between this and regular JS
	    * strings. As such, we intercept an attempt to read a JSX string and set a flag
	    * on extra so that when tokens are converted, the next token will be switched
	    * to JSXText via onToken.
	    */
	    instance.extend("jsx_readString", function(jsxReadString) {
	        return /** @this acorn.Parser */ function(quote) {
	            var result = jsxReadString.call(this, quote);
	            if (this.type === tt.string) {
	                extra.jsxAttrValueToken = true;
	            }
	
	            return result;
	        };
	    });
	};
	
	//------------------------------------------------------------------------------
	// Tokenizer
	//------------------------------------------------------------------------------
	
	/**
	 * Tokenizes the given code.
	 * @param {string} code The code to tokenize.
	 * @param {Object} options Options defining how to tokenize.
	 * @returns {Token[]} An array of tokens.
	 * @throws {SyntaxError} If the input code is invalid.
	 * @private
	 */
	function tokenize(code, options) {
	    var toString,
	        tokens,
	        impliedStrict,
	        translator = new TokenTranslator(tt, code);
	
	    toString = String;
	    if (typeof code !== "string" && !(code instanceof String)) {
	        code = toString(code);
	    }
	
	    lookahead = null;
	
	    // Options matching.
	    options = options || {};
	
	    var acornOptions = {
	        ecmaVersion: 5,
	        plugins: {
	            espree: true
	        }
	    };
	
	    resetExtra();
	
	    // Of course we collect tokens here.
	    options.tokens = true;
	    extra.tokens = [];
	
	    extra.range = (typeof options.range === "boolean") && options.range;
	    acornOptions.ranges = extra.range;
	
	    extra.loc = (typeof options.loc === "boolean") && options.loc;
	    acornOptions.locations = extra.loc;
	
	    extra.comment = typeof options.comment === "boolean" && options.comment;
	
	    if (extra.comment) {
	        acornOptions.onComment = function() {
	            var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
	            extra.comments.push(comment);
	        };
	    }
	
	    extra.tolerant = typeof options.tolerant === "boolean" && options.tolerant;
	
	    if (typeof options.ecmaVersion === "number") {
	        switch (options.ecmaVersion) {
	            case 3:
	            case 5:
	            case 6:
	            case 7:
	            case 8:
	                acornOptions.ecmaVersion = options.ecmaVersion;
	                extra.ecmaVersion = options.ecmaVersion;
	                break;
	
	            default:
	                throw new Error("ecmaVersion must be 3, 5, 6, 7, or 8.");
	        }
	    }
	
	    // apply parsing flags
	    if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
	        extra.ecmaFeatures = options.ecmaFeatures;
	        impliedStrict = extra.ecmaFeatures.impliedStrict;
	        extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
	    }
	
	    try {
	        var tokenizer = acorn.tokenizer(code, acornOptions);
	        while ((lookahead = tokenizer.getToken()).type !== tt.eof) {
	            translator.onToken(lookahead, extra);
	        }
	
	        // filterTokenLocation();
	        tokens = extra.tokens;
	
	        if (extra.comment) {
	            tokens.comments = extra.comments;
	        }
	        if (extra.tolerant) {
	            tokens.errors = extra.errors;
	        }
	    } catch (e) {
	        throw e;
	    }
	    return tokens;
	}
	
	//------------------------------------------------------------------------------
	// Parser
	//------------------------------------------------------------------------------
	
	
	
	/**
	 * Converts an Acorn comment to a Esprima comment.
	 * @param {boolean} block True if it's a block comment, false if not.
	 * @param {string} text The text of the comment.
	 * @param {int} start The index at which the comment starts.
	 * @param {int} end The index at which the comment ends.
	 * @param {Location} startLoc The location at which the comment starts.
	 * @param {Location} endLoc The location at which the comment ends.
	 * @returns {Object} The comment object.
	 * @private
	 */
	function convertAcornCommentToEsprimaComment(block, text, start, end, startLoc, endLoc) {
	    var comment = {
	        type: block ? "Block" : "Line",
	        value: text
	    };
	
	    if (typeof start === "number") {
	        comment.start = start;
	        comment.end = end;
	        comment.range = [start, end];
	    }
	
	    if (typeof startLoc === "object") {
	        comment.loc = {
	            start: startLoc,
	            end: endLoc
	        };
	    }
	
	    return comment;
	}
	
	/**
	 * Parses the given code.
	 * @param {string} code The code to tokenize.
	 * @param {Object} options Options defining how to tokenize.
	 * @returns {ASTNode} The "Program" AST node.
	 * @throws {SyntaxError} If the input code is invalid.
	 * @private
	 */
	function parse(code, options) {
	    var program,
	        toString = String,
	        translator,
	        impliedStrict,
	        acornOptions = {
	            ecmaVersion: 5,
	            plugins: {
	                espree: true
	            }
	        };
	
	    lastToken = null;
	
	    if (typeof code !== "string" && !(code instanceof String)) {
	        code = toString(code);
	    }
	
	    resetExtra();
	    commentAttachment.reset();
	
	    if (typeof options !== "undefined") {
	        extra.range = (typeof options.range === "boolean") && options.range;
	        extra.loc = (typeof options.loc === "boolean") && options.loc;
	        extra.attachComment = (typeof options.attachComment === "boolean") && options.attachComment;
	
	        if (extra.loc && options.source !== null && options.source !== undefined) {
	            extra.source = toString(options.source);
	        }
	
	        if (typeof options.tokens === "boolean" && options.tokens) {
	            extra.tokens = [];
	            translator = new TokenTranslator(tt, code);
	        }
	        if (typeof options.comment === "boolean" && options.comment) {
	            extra.comment = true;
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === "boolean" && options.tolerant) {
	            extra.errors = [];
	        }
	        if (extra.attachComment) {
	            extra.range = true;
	            extra.comments = [];
	            commentAttachment.reset();
	        }
	
	        if (typeof options.ecmaVersion === "number") {
	            switch (options.ecmaVersion) {
	                case 3:
	                case 5:
	                case 6:
	                case 7:
	                case 8:
	                    acornOptions.ecmaVersion = options.ecmaVersion;
	                    extra.ecmaVersion = options.ecmaVersion;
	                    break;
	
	                default:
	                    throw new Error("ecmaVersion must be 3, 5, 6, 7, or 8.");
	            }
	        }
	
	        if (options.sourceType === "module") {
	            extra.isModule = true;
	
	            // modules must be in 6 at least
	            if (acornOptions.ecmaVersion < 6) {
	                acornOptions.ecmaVersion = 6;
	                extra.ecmaVersion = 6;
	            }
	
	            acornOptions.sourceType = "module";
	        }
	
	        // apply parsing flags after sourceType to allow overriding
	        if (options.ecmaFeatures && typeof options.ecmaFeatures === "object") {
	            extra.ecmaFeatures = options.ecmaFeatures;
	            impliedStrict = extra.ecmaFeatures.impliedStrict;
	            extra.ecmaFeatures.impliedStrict = typeof impliedStrict === "boolean" && impliedStrict;
	            if (options.ecmaFeatures.globalReturn) {
	                acornOptions.allowReturnOutsideFunction = true;
	            }
	        }
	
	
	        acornOptions.onToken = function(token) {
	            if (extra.tokens) {
	                translator.onToken(token, extra);
	            }
	            if (token.type !== tt.eof) {
	                lastToken = token;
	            }
	        };
	
	        if (extra.attachComment || extra.comment) {
	            acornOptions.onComment = function() {
	                var comment = convertAcornCommentToEsprimaComment.apply(this, arguments);
	                extra.comments.push(comment);
	
	                if (extra.attachComment) {
	                    commentAttachment.addComment(comment);
	                }
	            };
	        }
	
	        if (extra.range) {
	            acornOptions.ranges = true;
	        }
	
	        if (extra.loc) {
	            acornOptions.locations = true;
	        }
	
	        if (extra.ecmaFeatures.jsx) {
	            // Should process jsx plugin before espree plugin.
	            acornOptions.plugins = {
	                jsx: true,
	                espree: true
	            };
	        }
	    }
	
	    program = acorn.parse(code, acornOptions);
	    program.sourceType = extra.isModule ? "module" : "script";
	
	    if (extra.comment || extra.attachComment) {
	        program.comments = extra.comments;
	    }
	
	    if (extra.tokens) {
	        program.tokens = extra.tokens;
	    }
	
	    /*
	     * Adjust opening and closing position of program to match Esprima.
	     * Acorn always starts programs at range 0 whereas Esprima starts at the
	     * first AST node's start (the only real difference is when there's leading
	     * whitespace or leading comments). Acorn also counts trailing whitespace
	     * as part of the program whereas Esprima only counts up to the last token.
	     */
	    if (program.range) {
	        program.range[0] = program.body.length ? program.body[0].range[0] : program.range[0];
	        program.range[1] = lastToken ? lastToken.range[1] : program.range[1];
	    }
	
	    if (program.loc) {
	        program.loc.start = program.body.length ? program.body[0].loc.start : program.loc.start;
	        program.loc.end = lastToken ? lastToken.loc.end : program.loc.end;
	    }
	
	    return program;
	}
	
	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------
	
	exports.version = __webpack_require__(237).version;
	
	exports.tokenize = tokenize;
	
	exports.parse = parse;
	
	// Deep copy.
	/* istanbul ignore next */
	exports.Syntax = (function() {
	    var name, types = {};
	
	    if (typeof Object.create === "function") {
	        types = Object.create(null);
	    }
	
	    for (name in astNodeTypes) {
	        if (astNodeTypes.hasOwnProperty(name)) {
	            types[name] = astNodeTypes[name];
	        }
	    }
	
	    if (typeof Object.freeze === "function") {
	        Object.freeze(types);
	    }
	
	    return types;
	}());
	
	/* istanbul ignore next */
	exports.VisitorKeys = (function() {
	    var visitorKeys = __webpack_require__(238);
	    var name,
	        keys = {};
	
	    if (typeof Object.create === "function") {
	        keys = Object.create(null);
	    }
	
	    for (name in visitorKeys) {
	        if (visitorKeys.hasOwnProperty(name)) {
	            keys[name] = visitorKeys[name];
	        }
	    }
	
	    if (typeof Object.freeze === "function") {
	        Object.freeze(keys);
	    }
	
	    return keys;
	}());


/***/ },
/* 231 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The AST node types produced by the parser.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	// None!
	
	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------
	
	module.exports = {
	    AssignmentExpression: "AssignmentExpression",
	    AssignmentPattern: "AssignmentPattern",
	    ArrayExpression: "ArrayExpression",
	    ArrayPattern: "ArrayPattern",
	    ArrowFunctionExpression: "ArrowFunctionExpression",
	    BlockStatement: "BlockStatement",
	    BinaryExpression: "BinaryExpression",
	    BreakStatement: "BreakStatement",
	    CallExpression: "CallExpression",
	    CatchClause: "CatchClause",
	    ClassBody: "ClassBody",
	    ClassDeclaration: "ClassDeclaration",
	    ClassExpression: "ClassExpression",
	    ConditionalExpression: "ConditionalExpression",
	    ContinueStatement: "ContinueStatement",
	    DoWhileStatement: "DoWhileStatement",
	    DebuggerStatement: "DebuggerStatement",
	    EmptyStatement: "EmptyStatement",
	    ExperimentalRestProperty: "ExperimentalRestProperty",
	    ExperimentalSpreadProperty: "ExperimentalSpreadProperty",
	    ExpressionStatement: "ExpressionStatement",
	    ForStatement: "ForStatement",
	    ForInStatement: "ForInStatement",
	    ForOfStatement: "ForOfStatement",
	    FunctionDeclaration: "FunctionDeclaration",
	    FunctionExpression: "FunctionExpression",
	    Identifier: "Identifier",
	    IfStatement: "IfStatement",
	    Literal: "Literal",
	    LabeledStatement: "LabeledStatement",
	    LogicalExpression: "LogicalExpression",
	    MemberExpression: "MemberExpression",
	    MetaProperty: "MetaProperty",
	    MethodDefinition: "MethodDefinition",
	    NewExpression: "NewExpression",
	    ObjectExpression: "ObjectExpression",
	    ObjectPattern: "ObjectPattern",
	    Program: "Program",
	    Property: "Property",
	    RestElement: "RestElement",
	    ReturnStatement: "ReturnStatement",
	    SequenceExpression: "SequenceExpression",
	    SpreadElement: "SpreadElement",
	    Super: "Super",
	    SwitchCase: "SwitchCase",
	    SwitchStatement: "SwitchStatement",
	    TaggedTemplateExpression: "TaggedTemplateExpression",
	    TemplateElement: "TemplateElement",
	    TemplateLiteral: "TemplateLiteral",
	    ThisExpression: "ThisExpression",
	    ThrowStatement: "ThrowStatement",
	    TryStatement: "TryStatement",
	    UnaryExpression: "UnaryExpression",
	    UpdateExpression: "UpdateExpression",
	    VariableDeclaration: "VariableDeclaration",
	    VariableDeclarator: "VariableDeclarator",
	    WhileStatement: "WhileStatement",
	    WithStatement: "WithStatement",
	    YieldExpression: "YieldExpression",
	    JSXIdentifier: "JSXIdentifier",
	    JSXNamespacedName: "JSXNamespacedName",
	    JSXMemberExpression: "JSXMemberExpression",
	    JSXEmptyExpression: "JSXEmptyExpression",
	    JSXExpressionContainer: "JSXExpressionContainer",
	    JSXElement: "JSXElement",
	    JSXClosingElement: "JSXClosingElement",
	    JSXOpeningElement: "JSXOpeningElement",
	    JSXAttribute: "JSXAttribute",
	    JSXSpreadAttribute: "JSXSpreadAttribute",
	    JSXText: "JSXText",
	    ExportDefaultDeclaration: "ExportDefaultDeclaration",
	    ExportNamedDeclaration: "ExportNamedDeclaration",
	    ExportAllDeclaration: "ExportAllDeclaration",
	    ExportSpecifier: "ExportSpecifier",
	    ImportDeclaration: "ImportDeclaration",
	    ImportSpecifier: "ImportSpecifier",
	    ImportDefaultSpecifier: "ImportDefaultSpecifier",
	    ImportNamespaceSpecifier: "ImportNamespaceSpecifier"
	};


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Attaches comments to the AST.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	var astNodeTypes = __webpack_require__(231);
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	var extra = {
	    trailingComments: [],
	    leadingComments: [],
	    bottomRightStack: [],
	    previousNode: null
	};
	
	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    reset: function() {
	        extra.trailingComments = [];
	        extra.leadingComments = [];
	        extra.bottomRightStack = [];
	        extra.previousNode = null;
	    },
	
	    addComment: function(comment) {
	        extra.trailingComments.push(comment);
	        extra.leadingComments.push(comment);
	    },
	
	    processComment: function(node) {
	        var lastChild,
	            trailingComments,
	            i,
	            j;
	
	        if (node.type === astNodeTypes.Program) {
	            if (node.body.length > 0) {
	                return;
	            }
	        }
	
	        if (extra.trailingComments.length > 0) {
	
	            /*
	             * If the first comment in trailingComments comes after the
	             * current node, then we're good - all comments in the array will
	             * come after the node and so it's safe to add then as official
	             * trailingComments.
	             */
	            if (extra.trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = extra.trailingComments;
	                extra.trailingComments = [];
	            } else {
	
	                /*
	                 * Otherwise, if the first comment doesn't come after the
	                 * current node, that means we have a mix of leading and trailing
	                 * comments in the array and that leadingComments contains the
	                 * same items as trailingComments. Reset trailingComments to
	                 * zero items and we'll handle this by evaluating leadingComments
	                 * later.
	                 */
	                extra.trailingComments.length = 0;
	            }
	        } else {
	            if (extra.bottomRightStack.length > 0 &&
	                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&
	                    extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {
	                trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	                delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;
	            }
	        }
	
	        // Eating the stack.
	        while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {
	            lastChild = extra.bottomRightStack.pop();
	        }
	
	        if (lastChild) {
	            if (lastChild.leadingComments) {
	                if (lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {
	                    node.leadingComments = lastChild.leadingComments;
	                    delete lastChild.leadingComments;
	                } else {
	                    // A leading comment for an anonymous class had been stolen by its first MethodDefinition,
	                    // so this takes back the leading comment.
	                    // See Also: https://github.com/eslint/espree/issues/158
	                    for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
	                        if (lastChild.leadingComments[i].range[1] <= node.range[0]) {
	                            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
	                            break;
	                        }
	                    }
	                }
	            }
	        } else if (extra.leadingComments.length > 0) {
	            if (extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {
	                if (extra.previousNode) {
	                    for (j = 0; j < extra.leadingComments.length; j++) {
	                        if (extra.leadingComments[j].end < extra.previousNode.end) {
	                            extra.leadingComments.splice(j, 1);
	                            j--;
	                        }
	                    }
	                }
	                if (extra.leadingComments.length > 0) {
	                    node.leadingComments = extra.leadingComments;
	                    extra.leadingComments = [];
	                }
	            } else {
	
	                // https://github.com/eslint/espree/issues/2
	
	                /*
	                 * In special cases, such as return (without a value) and
	                 * debugger, all comments will end up as leadingComments and
	                 * will otherwise be eliminated. This extra step runs when the
	                 * bottomRightStack is empty and there are comments left
	                 * in leadingComments.
	                 *
	                 * This loop figures out the stopping point between the actual
	                 * leading and trailing comments by finding the location of the
	                 * first comment that comes after the given node.
	                 */
	                for (i = 0; i < extra.leadingComments.length; i++) {
	                    if (extra.leadingComments[i].range[1] > node.range[0]) {
	                        break;
	                    }
	                }
	
	                /*
	                 * Split the array based on the location of the first comment
	                 * that comes after the node. Keep in mind that this could
	                 * result in an empty array, and if so, the array must be
	                 * deleted.
	                 */
	                node.leadingComments = extra.leadingComments.slice(0, i);
	                if (node.leadingComments.length === 0) {
	                    delete node.leadingComments;
	                }
	
	                /*
	                 * Similarly, trailing comments are attached later. The variable
	                 * must be reset to null if there are no trailing comments.
	                 */
	                trailingComments = extra.leadingComments.slice(i);
	                if (trailingComments.length === 0) {
	                    trailingComments = null;
	                }
	            }
	        }
	
	        extra.previousNode = node;
	
	        if (trailingComments) {
	            node.trailingComments = trailingComments;
	        }
	
	        extra.bottomRightStack.push(node);
	    }
	
	};


/***/ },
/* 233 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Translates tokens between Acorn format and Esprima format.
	 * @author Nicholas C. Zakas
	 */
	/* eslint no-underscore-dangle: 0 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	// none!
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	
	// Esprima Token Types
	var Token = {
	    Boolean: "Boolean",
	    EOF: "<end>",
	    Identifier: "Identifier",
	    Keyword: "Keyword",
	    Null: "Null",
	    Numeric: "Numeric",
	    Punctuator: "Punctuator",
	    String: "String",
	    RegularExpression: "RegularExpression",
	    Template: "Template",
	    JSXIdentifier: "JSXIdentifier",
	    JSXText: "JSXText"
	};
	
	/**
	 * Converts part of a template into an Esprima token.
	 * @param {AcornToken[]} tokens The Acorn tokens representing the template.
	 * @param {string} code The source code.
	 * @returns {EsprimaToken} The Esprima equivalent of the template token.
	 * @private
	 */
	function convertTemplatePart(tokens, code) {
	    var firstToken = tokens[0],
	        lastTemplateToken = tokens[tokens.length - 1];
	
	    var token = {
	        type: Token.Template,
	        value: code.slice(firstToken.start, lastTemplateToken.end)
	    };
	
	    if (firstToken.loc) {
	        token.loc = {
	            start: firstToken.loc.start,
	            end: lastTemplateToken.loc.end
	        };
	    }
	
	    if (firstToken.range) {
	        token.range = [firstToken.range[0], lastTemplateToken.range[1]];
	    }
	
	    return token;
	}
	
	/**
	 * Contains logic to translate Acorn tokens into Esprima tokens.
	 * @param {Object} acornTokTypes The Acorn token types.
	 * @param {string} code The source code Acorn is parsing. This is necessary
	 *      to correct the "value" property of some tokens.
	 * @constructor
	 */
	function TokenTranslator(acornTokTypes, code) {
	
	    // token types
	    this._acornTokTypes = acornTokTypes;
	
	    // token buffer for templates
	    this._tokens = [];
	
	    // track the last curly brace
	    this._curlyBrace = null;
	
	    // the source code
	    this._code = code;
	
	}
	
	TokenTranslator.prototype = {
	    constructor: TokenTranslator,
	
	    /**
	     * Translates a single Esprima token to a single Acorn token. This may be
	     * inaccurate due to how templates are handled differently in Esprima and
	     * Acorn, but should be accurate for all other tokens.
	     * @param {AcornToken} token The Acorn token to translate.
	     * @param {Object} extra Espree extra object.
	     * @returns {EsprimaToken} The Esprima version of the token.
	     */
	    translate: function(token, extra) {
	
	        var type = token.type,
	            tt = this._acornTokTypes;
	
	        if (type === tt.name) {
	            token.type = Token.Identifier;
	
	            // TODO: See if this is an Acorn bug
	            if (token.value === "static") {
	                token.type = Token.Keyword;
	            }
	
	            if (extra.ecmaVersion > 5 && (token.value === "yield" || token.value === "let")) {
	                token.type = Token.Keyword;
	            }
	
	        } else if (type === tt.semi || type === tt.comma ||
	                 type === tt.parenL || type === tt.parenR ||
	                 type === tt.braceL || type === tt.braceR ||
	                 type === tt.dot || type === tt.bracketL ||
	                 type === tt.colon || type === tt.question ||
	                 type === tt.bracketR || type === tt.ellipsis ||
	                 type === tt.arrow || type === tt.jsxTagStart ||
	                 type === tt.incDec || type === tt.starstar ||
	                 type === tt.jsxTagEnd || type === tt.prefix ||
	                 (type.binop && !type.keyword) ||
	                 type.isAssign) {
	
	            token.type = Token.Punctuator;
	            token.value = this._code.slice(token.start, token.end);
	        } else if (type === tt.jsxName) {
	            token.type = Token.JSXIdentifier;
	        } else if (type.label === "jsxText" || type === tt.jsxAttrValueToken) {
	            token.type = Token.JSXText;
	        } else if (type.keyword) {
	            if (type.keyword === "true" || type.keyword === "false") {
	                token.type = Token.Boolean;
	            } else if (type.keyword === "null") {
	                token.type = Token.Null;
	            } else {
	                token.type = Token.Keyword;
	            }
	        } else if (type === tt.num) {
	            token.type = Token.Numeric;
	            token.value = this._code.slice(token.start, token.end);
	        } else if (type === tt.string) {
	
	            if (extra.jsxAttrValueToken) {
	                extra.jsxAttrValueToken = false;
	                token.type = Token.JSXText;
	            } else {
	                token.type = Token.String;
	            }
	
	            token.value = this._code.slice(token.start, token.end);
	        } else if (type === tt.regexp) {
	            token.type = Token.RegularExpression;
	            var value = token.value;
	            token.regex = {
	                flags: value.flags,
	                pattern: value.pattern
	            };
	            token.value = "/" + value.pattern + "/" + value.flags;
	        }
	
	        return token;
	    },
	
	    /**
	     * Function to call during Acorn's onToken handler.
	     * @param {AcornToken} token The Acorn token.
	     * @param {Object} extra The Espree extra object.
	     * @returns {void}
	     */
	    onToken: function(token, extra) {
	
	        var that = this,
	            tt = this._acornTokTypes,
	            tokens = extra.tokens,
	            templateTokens = this._tokens;
	
	        /**
	         * Flushes the buffered template tokens and resets the template
	         * tracking.
	         * @returns {void}
	         * @private
	         */
	        function translateTemplateTokens() {
	            tokens.push(convertTemplatePart(that._tokens, that._code));
	            that._tokens = [];
	        }
	
	        if (token.type === tt.eof) {
	
	            // might be one last curlyBrace
	            if (this._curlyBrace) {
	                tokens.push(this.translate(this._curlyBrace, extra));
	            }
	
	            return;
	        }
	
	        if (token.type === tt.backQuote) {
	
	            // if there's already a curly, it's not part of the template
	            if (this._curlyBrace) {
	                tokens.push(this.translate(this._curlyBrace, extra));
	                this._curlyBrace = null;
	            }
	
	            templateTokens.push(token);
	
	            // it's the end
	            if (templateTokens.length > 1) {
	                translateTemplateTokens();
	            }
	
	            return;
	        } else if (token.type === tt.dollarBraceL) {
	            templateTokens.push(token);
	            translateTemplateTokens();
	            return;
	        } else if (token.type === tt.braceR) {
	
	            // if there's already a curly, it's not part of the template
	            if (this._curlyBrace) {
	                tokens.push(this.translate(this._curlyBrace, extra));
	            }
	
	            // store new curly for later
	            this._curlyBrace = token;
	            return;
	        } else if (token.type === tt.template) {
	            if (this._curlyBrace) {
	                templateTokens.push(this._curlyBrace);
	                this._curlyBrace = null;
	            }
	
	            templateTokens.push(token);
	            return;
	        }
	
	        if (this._curlyBrace) {
	            tokens.push(this.translate(this._curlyBrace, extra));
	            this._curlyBrace = null;
	        }
	
	        tokens.push(this.translate(token, extra));
	    }
	};
	
	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------
	
	module.exports = TokenTranslator;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var XHTMLEntities = __webpack_require__(235);
	
	var hexNumber = /^[\da-fA-F]+$/;
	var decimalNumber = /^\d+$/;
	
	module.exports = function(acorn) {
	  var tt = acorn.tokTypes;
	  var tc = acorn.tokContexts;
	
	  tc.j_oTag = new acorn.TokContext('<tag', false);
	  tc.j_cTag = new acorn.TokContext('</tag', false);
	  tc.j_expr = new acorn.TokContext('<tag>...</tag>', true, true);
	
	  tt.jsxName = new acorn.TokenType('jsxName');
	  tt.jsxText = new acorn.TokenType('jsxText', {beforeExpr: true});
	  tt.jsxTagStart = new acorn.TokenType('jsxTagStart');
	  tt.jsxTagEnd = new acorn.TokenType('jsxTagEnd');
	
	  tt.jsxTagStart.updateContext = function() {
	    this.context.push(tc.j_expr); // treat as beginning of JSX expression
	    this.context.push(tc.j_oTag); // start opening tag context
	    this.exprAllowed = false;
	  };
	  tt.jsxTagEnd.updateContext = function(prevType) {
	    var out = this.context.pop();
	    if (out === tc.j_oTag && prevType === tt.slash || out === tc.j_cTag) {
	      this.context.pop();
	      this.exprAllowed = this.curContext() === tc.j_expr;
	    } else {
	      this.exprAllowed = true;
	    }
	  };
	
	  var pp = acorn.Parser.prototype;
	
	  // Reads inline JSX contents token.
	
	  pp.jsx_readToken = function() {
	    var out = '', chunkStart = this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated JSX contents');
	      var ch = this.input.charCodeAt(this.pos);
	
	      switch (ch) {
	      case 60: // '<'
	      case 123: // '{'
	        if (this.pos === this.start) {
	          if (ch === 60 && this.exprAllowed) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagStart);
	          }
	          return this.getTokenFromCode(ch);
	        }
	        out += this.input.slice(chunkStart, this.pos);
	        return this.finishToken(tt.jsxText, out);
	
	      case 38: // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	        break;
	
	      default:
	        if (acorn.isNewLine(ch)) {
	          out += this.input.slice(chunkStart, this.pos);
	          out += this.jsx_readNewLine(true);
	          chunkStart = this.pos;
	        } else {
	          ++this.pos;
	        }
	      }
	    }
	  };
	
	  pp.jsx_readNewLine = function(normalizeCRLF) {
	    var ch = this.input.charCodeAt(this.pos);
	    var out;
	    ++this.pos;
	    if (ch === 13 && this.input.charCodeAt(this.pos) === 10) {
	      ++this.pos;
	      out = normalizeCRLF ? '\n' : '\r\n';
	    } else {
	      out = String.fromCharCode(ch);
	    }
	    if (this.options.locations) {
	      ++this.curLine;
	      this.lineStart = this.pos;
	    }
	
	    return out;
	  };
	
	  pp.jsx_readString = function(quote) {
	    var out = '', chunkStart = ++this.pos;
	    for (;;) {
	      if (this.pos >= this.input.length)
	        this.raise(this.start, 'Unterminated string constant');
	      var ch = this.input.charCodeAt(this.pos);
	      if (ch === quote) break;
	      if (ch === 38) { // '&'
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readEntity();
	        chunkStart = this.pos;
	      } else if (acorn.isNewLine(ch)) {
	        out += this.input.slice(chunkStart, this.pos);
	        out += this.jsx_readNewLine(false);
	        chunkStart = this.pos;
	      } else {
	        ++this.pos;
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++);
	    return this.finishToken(tt.string, out);
	  };
	
	  pp.jsx_readEntity = function() {
	    var str = '', count = 0, entity;
	    var ch = this.input[this.pos];
	    if (ch !== '&')
	      this.raise(this.pos, 'Entity must start with an ampersand');
	    var startPos = ++this.pos;
	    while (this.pos < this.input.length && count++ < 10) {
	      ch = this.input[this.pos++];
	      if (ch === ';') {
	        if (str[0] === '#') {
	          if (str[1] === 'x') {
	            str = str.substr(2);
	            if (hexNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 16));
	          } else {
	            str = str.substr(1);
	            if (decimalNumber.test(str))
	              entity = String.fromCharCode(parseInt(str, 10));
	          }
	        } else {
	          entity = XHTMLEntities[str];
	        }
	        break;
	      }
	      str += ch;
	    }
	    if (!entity) {
	      this.pos = startPos;
	      return '&';
	    }
	    return entity;
	  };
	
	
	  // Read a JSX identifier (valid tag or attribute name).
	  //
	  // Optimized version since JSX identifiers can't contain
	  // escape characters and so can be read as single slice.
	  // Also assumes that first character was already checked
	  // by isIdentifierStart in readToken.
	
	  pp.jsx_readWord = function() {
	    var ch, start = this.pos;
	    do {
	      ch = this.input.charCodeAt(++this.pos);
	    } while (acorn.isIdentifierChar(ch) || ch === 45); // '-'
	    return this.finishToken(tt.jsxName, this.input.slice(start, this.pos));
	  };
	
	  // Transforms JSX element name to string.
	
	  function getQualifiedJSXName(object) {
	    if (object.type === 'JSXIdentifier')
	      return object.name;
	
	    if (object.type === 'JSXNamespacedName')
	      return object.namespace.name + ':' + object.name.name;
	
	    if (object.type === 'JSXMemberExpression')
	      return getQualifiedJSXName(object.object) + '.' +
	      getQualifiedJSXName(object.property);
	  }
	
	  // Parse next token as JSX identifier
	
	  pp.jsx_parseIdentifier = function() {
	    var node = this.startNode();
	    if (this.type === tt.jsxName)
	      node.name = this.value;
	    else if (this.type.keyword)
	      node.name = this.type.keyword;
	    else
	      this.unexpected();
	    this.next();
	    return this.finishNode(node, 'JSXIdentifier');
	  };
	
	  // Parse namespaced identifier.
	
	  pp.jsx_parseNamespacedName = function() {
	    var startPos = this.start, startLoc = this.startLoc;
	    var name = this.jsx_parseIdentifier();
	    if (!this.options.plugins.jsx.allowNamespaces || !this.eat(tt.colon)) return name;
	    var node = this.startNodeAt(startPos, startLoc);
	    node.namespace = name;
	    node.name = this.jsx_parseIdentifier();
	    return this.finishNode(node, 'JSXNamespacedName');
	  };
	
	  // Parses element name in any form - namespaced, member
	  // or single identifier.
	
	  pp.jsx_parseElementName = function() {
	    var startPos = this.start, startLoc = this.startLoc;
	    var node = this.jsx_parseNamespacedName();
	    if (this.type === tt.dot && node.type === 'JSXNamespacedName' && !this.options.plugins.jsx.allowNamespacedObjects) {
	      this.unexpected();
	    }
	    while (this.eat(tt.dot)) {
	      var newNode = this.startNodeAt(startPos, startLoc);
	      newNode.object = node;
	      newNode.property = this.jsx_parseIdentifier();
	      node = this.finishNode(newNode, 'JSXMemberExpression');
	    }
	    return node;
	  };
	
	  // Parses any type of JSX attribute value.
	
	  pp.jsx_parseAttributeValue = function() {
	    switch (this.type) {
	    case tt.braceL:
	      var node = this.jsx_parseExpressionContainer();
	      if (node.expression.type === 'JSXEmptyExpression')
	        this.raise(node.start, 'JSX attributes must only be assigned a non-empty expression');
	      return node;
	
	    case tt.jsxTagStart:
	    case tt.string:
	      return this.parseExprAtom();
	
	    default:
	      this.raise(this.start, 'JSX value should be either an expression or a quoted JSX text');
	    }
	  };
	
	  // JSXEmptyExpression is unique type since it doesn't actually parse anything,
	  // and so it should start at the end of last read token (left brace) and finish
	  // at the beginning of the next one (right brace).
	
	  pp.jsx_parseEmptyExpression = function() {
	    var node = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
	    return this.finishNodeAt(node, 'JSXEmptyExpression', this.start, this.startLoc);
	  };
	
	  // Parses JSX expression enclosed into curly brackets.
	
	
	  pp.jsx_parseExpressionContainer = function() {
	    var node = this.startNode();
	    this.next();
	    node.expression = this.type === tt.braceR
	      ? this.jsx_parseEmptyExpression()
	      : this.parseExpression();
	    this.expect(tt.braceR);
	    return this.finishNode(node, 'JSXExpressionContainer');
	  };
	
	  // Parses following JSX attribute name-value pair.
	
	  pp.jsx_parseAttribute = function() {
	    var node = this.startNode();
	    if (this.eat(tt.braceL)) {
	      this.expect(tt.ellipsis);
	      node.argument = this.parseMaybeAssign();
	      this.expect(tt.braceR);
	      return this.finishNode(node, 'JSXSpreadAttribute');
	    }
	    node.name = this.jsx_parseNamespacedName();
	    node.value = this.eat(tt.eq) ? this.jsx_parseAttributeValue() : null;
	    return this.finishNode(node, 'JSXAttribute');
	  };
	
	  // Parses JSX opening tag starting after '<'.
	
	  pp.jsx_parseOpeningElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.attributes = [];
	    node.name = this.jsx_parseElementName();
	    while (this.type !== tt.slash && this.type !== tt.jsxTagEnd)
	      node.attributes.push(this.jsx_parseAttribute());
	    node.selfClosing = this.eat(tt.slash);
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, 'JSXOpeningElement');
	  };
	
	  // Parses JSX closing tag starting after '</'.
	
	  pp.jsx_parseClosingElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    node.name = this.jsx_parseElementName();
	    this.expect(tt.jsxTagEnd);
	    return this.finishNode(node, 'JSXClosingElement');
	  };
	
	  // Parses entire JSX element, including it's opening tag
	  // (starting after '<'), attributes, contents and closing tag.
	
	  pp.jsx_parseElementAt = function(startPos, startLoc) {
	    var node = this.startNodeAt(startPos, startLoc);
	    var children = [];
	    var openingElement = this.jsx_parseOpeningElementAt(startPos, startLoc);
	    var closingElement = null;
	
	    if (!openingElement.selfClosing) {
	      contents: for (;;) {
	        switch (this.type) {
	        case tt.jsxTagStart:
	          startPos = this.start; startLoc = this.startLoc;
	          this.next();
	          if (this.eat(tt.slash)) {
	            closingElement = this.jsx_parseClosingElementAt(startPos, startLoc);
	            break contents;
	          }
	          children.push(this.jsx_parseElementAt(startPos, startLoc));
	          break;
	
	        case tt.jsxText:
	          children.push(this.parseExprAtom());
	          break;
	
	        case tt.braceL:
	          children.push(this.jsx_parseExpressionContainer());
	          break;
	
	        default:
	          this.unexpected();
	        }
	      }
	      if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
	        this.raise(
	          closingElement.start,
	          'Expected corresponding JSX closing tag for <' + getQualifiedJSXName(openingElement.name) + '>');
	      }
	    }
	
	    node.openingElement = openingElement;
	    node.closingElement = closingElement;
	    node.children = children;
	    if (this.type === tt.relational && this.value === "<") {
	      this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
	    }
	    return this.finishNode(node, 'JSXElement');
	  };
	
	  // Parses entire JSX element from current position.
	
	  pp.jsx_parseElement = function() {
	    var startPos = this.start, startLoc = this.startLoc;
	    this.next();
	    return this.jsx_parseElementAt(startPos, startLoc);
	  };
	
	  acorn.plugins.jsx = function(instance, opts) {
	    if (!opts) {
	      return;
	    }
	
	    if (typeof opts !== 'object') {
	      opts = {};
	    }
	
	    instance.options.plugins.jsx = {
	      allowNamespaces: opts.allowNamespaces !== false,
	      allowNamespacedObjects: !!opts.allowNamespacedObjects
	    };
	
	    instance.extend('parseExprAtom', function(inner) {
	      return function(refShortHandDefaultPos) {
	        if (this.type === tt.jsxText)
	          return this.parseLiteral(this.value);
	        else if (this.type === tt.jsxTagStart)
	          return this.jsx_parseElement();
	        else
	          return inner.call(this, refShortHandDefaultPos);
	      };
	    });
	
	    instance.extend('readToken', function(inner) {
	      return function(code) {
	        var context = this.curContext();
	
	        if (context === tc.j_expr) return this.jsx_readToken();
	
	        if (context === tc.j_oTag || context === tc.j_cTag) {
	          if (acorn.isIdentifierStart(code)) return this.jsx_readWord();
	
	          if (code == 62) {
	            ++this.pos;
	            return this.finishToken(tt.jsxTagEnd);
	          }
	
	          if ((code === 34 || code === 39) && context == tc.j_oTag)
	            return this.jsx_readString(code);
	        }
	
	        if (code === 60 && this.exprAllowed) {
	          ++this.pos;
	          return this.finishToken(tt.jsxTagStart);
	        }
	        return inner.call(this, code);
	      };
	    });
	
	    instance.extend('updateContext', function(inner) {
	      return function(prevType) {
	        if (this.type == tt.braceL) {
	          var curContext = this.curContext();
	          if (curContext == tc.j_oTag) this.context.push(tc.b_expr);
	          else if (curContext == tc.j_expr) this.context.push(tc.b_tmpl);
	          else inner.call(this, prevType);
	          this.exprAllowed = true;
	        } else if (this.type === tt.slash && prevType === tt.jsxTagStart) {
	          this.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
	          this.context.push(tc.j_cTag); // reconsider as closing tag context
	          this.exprAllowed = false;
	        } else {
	          return inner.call(this, prevType);
	        }
	      };
	    });
	  };
	
	  return acorn;
	};


/***/ },
/* 235 */
/***/ function(module, exports) {

	module.exports = {
	  quot: '\u0022',
	  amp: '&',
	  apos: '\u0027',
	  lt: '<',
	  gt: '>',
	  nbsp: '\u00A0',
	  iexcl: '\u00A1',
	  cent: '\u00A2',
	  pound: '\u00A3',
	  curren: '\u00A4',
	  yen: '\u00A5',
	  brvbar: '\u00A6',
	  sect: '\u00A7',
	  uml: '\u00A8',
	  copy: '\u00A9',
	  ordf: '\u00AA',
	  laquo: '\u00AB',
	  not: '\u00AC',
	  shy: '\u00AD',
	  reg: '\u00AE',
	  macr: '\u00AF',
	  deg: '\u00B0',
	  plusmn: '\u00B1',
	  sup2: '\u00B2',
	  sup3: '\u00B3',
	  acute: '\u00B4',
	  micro: '\u00B5',
	  para: '\u00B6',
	  middot: '\u00B7',
	  cedil: '\u00B8',
	  sup1: '\u00B9',
	  ordm: '\u00BA',
	  raquo: '\u00BB',
	  frac14: '\u00BC',
	  frac12: '\u00BD',
	  frac34: '\u00BE',
	  iquest: '\u00BF',
	  Agrave: '\u00C0',
	  Aacute: '\u00C1',
	  Acirc: '\u00C2',
	  Atilde: '\u00C3',
	  Auml: '\u00C4',
	  Aring: '\u00C5',
	  AElig: '\u00C6',
	  Ccedil: '\u00C7',
	  Egrave: '\u00C8',
	  Eacute: '\u00C9',
	  Ecirc: '\u00CA',
	  Euml: '\u00CB',
	  Igrave: '\u00CC',
	  Iacute: '\u00CD',
	  Icirc: '\u00CE',
	  Iuml: '\u00CF',
	  ETH: '\u00D0',
	  Ntilde: '\u00D1',
	  Ograve: '\u00D2',
	  Oacute: '\u00D3',
	  Ocirc: '\u00D4',
	  Otilde: '\u00D5',
	  Ouml: '\u00D6',
	  times: '\u00D7',
	  Oslash: '\u00D8',
	  Ugrave: '\u00D9',
	  Uacute: '\u00DA',
	  Ucirc: '\u00DB',
	  Uuml: '\u00DC',
	  Yacute: '\u00DD',
	  THORN: '\u00DE',
	  szlig: '\u00DF',
	  agrave: '\u00E0',
	  aacute: '\u00E1',
	  acirc: '\u00E2',
	  atilde: '\u00E3',
	  auml: '\u00E4',
	  aring: '\u00E5',
	  aelig: '\u00E6',
	  ccedil: '\u00E7',
	  egrave: '\u00E8',
	  eacute: '\u00E9',
	  ecirc: '\u00EA',
	  euml: '\u00EB',
	  igrave: '\u00EC',
	  iacute: '\u00ED',
	  icirc: '\u00EE',
	  iuml: '\u00EF',
	  eth: '\u00F0',
	  ntilde: '\u00F1',
	  ograve: '\u00F2',
	  oacute: '\u00F3',
	  ocirc: '\u00F4',
	  otilde: '\u00F5',
	  ouml: '\u00F6',
	  divide: '\u00F7',
	  oslash: '\u00F8',
	  ugrave: '\u00F9',
	  uacute: '\u00FA',
	  ucirc: '\u00FB',
	  uuml: '\u00FC',
	  yacute: '\u00FD',
	  thorn: '\u00FE',
	  yuml: '\u00FF',
	  OElig: '\u0152',
	  oelig: '\u0153',
	  Scaron: '\u0160',
	  scaron: '\u0161',
	  Yuml: '\u0178',
	  fnof: '\u0192',
	  circ: '\u02C6',
	  tilde: '\u02DC',
	  Alpha: '\u0391',
	  Beta: '\u0392',
	  Gamma: '\u0393',
	  Delta: '\u0394',
	  Epsilon: '\u0395',
	  Zeta: '\u0396',
	  Eta: '\u0397',
	  Theta: '\u0398',
	  Iota: '\u0399',
	  Kappa: '\u039A',
	  Lambda: '\u039B',
	  Mu: '\u039C',
	  Nu: '\u039D',
	  Xi: '\u039E',
	  Omicron: '\u039F',
	  Pi: '\u03A0',
	  Rho: '\u03A1',
	  Sigma: '\u03A3',
	  Tau: '\u03A4',
	  Upsilon: '\u03A5',
	  Phi: '\u03A6',
	  Chi: '\u03A7',
	  Psi: '\u03A8',
	  Omega: '\u03A9',
	  alpha: '\u03B1',
	  beta: '\u03B2',
	  gamma: '\u03B3',
	  delta: '\u03B4',
	  epsilon: '\u03B5',
	  zeta: '\u03B6',
	  eta: '\u03B7',
	  theta: '\u03B8',
	  iota: '\u03B9',
	  kappa: '\u03BA',
	  lambda: '\u03BB',
	  mu: '\u03BC',
	  nu: '\u03BD',
	  xi: '\u03BE',
	  omicron: '\u03BF',
	  pi: '\u03C0',
	  rho: '\u03C1',
	  sigmaf: '\u03C2',
	  sigma: '\u03C3',
	  tau: '\u03C4',
	  upsilon: '\u03C5',
	  phi: '\u03C6',
	  chi: '\u03C7',
	  psi: '\u03C8',
	  omega: '\u03C9',
	  thetasym: '\u03D1',
	  upsih: '\u03D2',
	  piv: '\u03D6',
	  ensp: '\u2002',
	  emsp: '\u2003',
	  thinsp: '\u2009',
	  zwnj: '\u200C',
	  zwj: '\u200D',
	  lrm: '\u200E',
	  rlm: '\u200F',
	  ndash: '\u2013',
	  mdash: '\u2014',
	  lsquo: '\u2018',
	  rsquo: '\u2019',
	  sbquo: '\u201A',
	  ldquo: '\u201C',
	  rdquo: '\u201D',
	  bdquo: '\u201E',
	  dagger: '\u2020',
	  Dagger: '\u2021',
	  bull: '\u2022',
	  hellip: '\u2026',
	  permil: '\u2030',
	  prime: '\u2032',
	  Prime: '\u2033',
	  lsaquo: '\u2039',
	  rsaquo: '\u203A',
	  oline: '\u203E',
	  frasl: '\u2044',
	  euro: '\u20AC',
	  image: '\u2111',
	  weierp: '\u2118',
	  real: '\u211C',
	  trade: '\u2122',
	  alefsym: '\u2135',
	  larr: '\u2190',
	  uarr: '\u2191',
	  rarr: '\u2192',
	  darr: '\u2193',
	  harr: '\u2194',
	  crarr: '\u21B5',
	  lArr: '\u21D0',
	  uArr: '\u21D1',
	  rArr: '\u21D2',
	  dArr: '\u21D3',
	  hArr: '\u21D4',
	  forall: '\u2200',
	  part: '\u2202',
	  exist: '\u2203',
	  empty: '\u2205',
	  nabla: '\u2207',
	  isin: '\u2208',
	  notin: '\u2209',
	  ni: '\u220B',
	  prod: '\u220F',
	  sum: '\u2211',
	  minus: '\u2212',
	  lowast: '\u2217',
	  radic: '\u221A',
	  prop: '\u221D',
	  infin: '\u221E',
	  ang: '\u2220',
	  and: '\u2227',
	  or: '\u2228',
	  cap: '\u2229',
	  cup: '\u222A',
	  'int': '\u222B',
	  there4: '\u2234',
	  sim: '\u223C',
	  cong: '\u2245',
	  asymp: '\u2248',
	  ne: '\u2260',
	  equiv: '\u2261',
	  le: '\u2264',
	  ge: '\u2265',
	  sub: '\u2282',
	  sup: '\u2283',
	  nsub: '\u2284',
	  sube: '\u2286',
	  supe: '\u2287',
	  oplus: '\u2295',
	  otimes: '\u2297',
	  perp: '\u22A5',
	  sdot: '\u22C5',
	  lceil: '\u2308',
	  rceil: '\u2309',
	  lfloor: '\u230A',
	  rfloor: '\u230B',
	  lang: '\u2329',
	  rang: '\u232A',
	  loz: '\u25CA',
	  spades: '\u2660',
	  clubs: '\u2663',
	  hearts: '\u2665',
	  diams: '\u2666'
	};


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
	   true ? factory(exports) :
	  typeof define === 'function' && define.amd ? define(['exports'], factory) :
	  (factory((global.acorn = global.acorn || {})));
	}(this, function (exports) { 'use strict';
	
	  // Reserved word lists for various dialects of the language
	
	  var reservedWords = {
	    3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
	    5: "class enum extends super const export import",
	    6: "enum",
	    strict: "implements interface let package private protected public static yield",
	    strictBind: "eval arguments"
	  }
	
	  // And the keywords
	
	  var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"
	
	  var keywords = {
	    5: ecma5AndLessKeywords,
	    6: ecma5AndLessKeywords + " const class extends export import super"
	  }
	
	  // ## Character categories
	
	  // Big ugly regular expressions that match characters in the
	  // whitespace, identifier, and identifier-start categories. These
	  // are only applied when a character is found to actually have a
	  // code point above 128.
	  // Generated by `bin/generate-identifier-regex.js`.
	
	  var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc"
	  var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f"
	
	  var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]")
	  var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]")
	
	  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null
	
	  // These are a run-length and offset encoded representation of the
	  // >0xffff code points that are a valid part of identifiers. The
	  // offset starts at 0x10000, and each pair of numbers represents an
	  // offset to the next range, and then a size of the range. They were
	  // generated by bin/generate-identifier-regex.js
	  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]
	  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]
	
	  // This has a complexity linear to the value of the code. The
	  // assumption is that looking up astral identifier characters is
	  // rare.
	  function isInAstralSet(code, set) {
	    var pos = 0x10000
	    for (var i = 0; i < set.length; i += 2) {
	      pos += set[i]
	      if (pos > code) return false
	      pos += set[i + 1]
	      if (pos >= code) return true
	    }
	  }
	
	  // Test whether a given character code starts an identifier.
	
	  function isIdentifierStart(code, astral) {
	    if (code < 65) return code === 36
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes)
	  }
	
	  // Test whether a given character is part of an identifier.
	
	  function isIdentifierChar(code, astral) {
	    if (code < 48) return code === 36
	    if (code < 58) return true
	    if (code < 65) return false
	    if (code < 91) return true
	    if (code < 97) return code === 95
	    if (code < 123) return true
	    if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))
	    if (astral === false) return false
	    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
	  }
	
	  // ## Token types
	
	  // The assignment of fine-grained, information-carrying type objects
	  // allows the tokenizer to store the information it has about a
	  // token in a way that is very cheap for the parser to look up.
	
	  // All token type variables start with an underscore, to make them
	  // easy to recognize.
	
	  // The `beforeExpr` property is used to disambiguate between regular
	  // expressions and divisions. It is set on all token types that can
	  // be followed by an expression (thus, a slash after them would be a
	  // regular expression).
	  //
	  // The `startsExpr` property is used to check if the token ends a
	  // `yield` expression. It is set on all token types that either can
	  // directly start an expression (like a quotation mark) or can
	  // continue an expression (like the body of a string).
	  //
	  // `isLoop` marks a keyword as starting a loop, which is important
	  // to know when parsing a label, in order to allow or disallow
	  // continue jumps to that label.
	
	  var TokenType = function TokenType(label, conf) {
	    if ( conf === void 0 ) conf = {};
	
	    this.label = label
	    this.keyword = conf.keyword
	    this.beforeExpr = !!conf.beforeExpr
	    this.startsExpr = !!conf.startsExpr
	    this.isLoop = !!conf.isLoop
	    this.isAssign = !!conf.isAssign
	    this.prefix = !!conf.prefix
	    this.postfix = !!conf.postfix
	    this.binop = conf.binop || null
	    this.updateContext = null
	  };
	
	  function binop(name, prec) {
	    return new TokenType(name, {beforeExpr: true, binop: prec})
	  }
	  var beforeExpr = {beforeExpr: true};
	  var startsExpr = {startsExpr: true};
	  // Map keyword names to token types.
	
	  var keywordTypes = {}
	
	  // Succinct definitions of keyword token types
	  function kw(name, options) {
	    if ( options === void 0 ) options = {};
	
	    options.keyword = name
	    return keywordTypes[name] = new TokenType(name, options)
	  }
	
	  var tt = {
	    num: new TokenType("num", startsExpr),
	    regexp: new TokenType("regexp", startsExpr),
	    string: new TokenType("string", startsExpr),
	    name: new TokenType("name", startsExpr),
	    eof: new TokenType("eof"),
	
	    // Punctuation token types.
	    bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
	    bracketR: new TokenType("]"),
	    braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
	    braceR: new TokenType("}"),
	    parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
	    parenR: new TokenType(")"),
	    comma: new TokenType(",", beforeExpr),
	    semi: new TokenType(";", beforeExpr),
	    colon: new TokenType(":", beforeExpr),
	    dot: new TokenType("."),
	    question: new TokenType("?", beforeExpr),
	    arrow: new TokenType("=>", beforeExpr),
	    template: new TokenType("template"),
	    ellipsis: new TokenType("...", beforeExpr),
	    backQuote: new TokenType("`", startsExpr),
	    dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
	
	    // Operators. These carry several kinds of properties to help the
	    // parser use them properly (the presence of these properties is
	    // what categorizes them as operators).
	    //
	    // `binop`, when present, specifies that this operator is a binary
	    // operator, and will refer to its precedence.
	    //
	    // `prefix` and `postfix` mark the operator as a prefix or postfix
	    // unary operator.
	    //
	    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
	    // binary operators with a very low precedence, that should result
	    // in AssignmentExpression nodes.
	
	    eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
	    assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
	    incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
	    prefix: new TokenType("prefix", {beforeExpr: true, prefix: true, startsExpr: true}),
	    logicalOR: binop("||", 1),
	    logicalAND: binop("&&", 2),
	    bitwiseOR: binop("|", 3),
	    bitwiseXOR: binop("^", 4),
	    bitwiseAND: binop("&", 5),
	    equality: binop("==/!=", 6),
	    relational: binop("</>", 7),
	    bitShift: binop("<</>>", 8),
	    plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
	    modulo: binop("%", 10),
	    star: binop("*", 10),
	    slash: binop("/", 10),
	    starstar: new TokenType("**", {beforeExpr: true}),
	
	    // Keyword token types.
	    _break: kw("break"),
	    _case: kw("case", beforeExpr),
	    _catch: kw("catch"),
	    _continue: kw("continue"),
	    _debugger: kw("debugger"),
	    _default: kw("default", beforeExpr),
	    _do: kw("do", {isLoop: true, beforeExpr: true}),
	    _else: kw("else", beforeExpr),
	    _finally: kw("finally"),
	    _for: kw("for", {isLoop: true}),
	    _function: kw("function", startsExpr),
	    _if: kw("if"),
	    _return: kw("return", beforeExpr),
	    _switch: kw("switch"),
	    _throw: kw("throw", beforeExpr),
	    _try: kw("try"),
	    _var: kw("var"),
	    _const: kw("const"),
	    _while: kw("while", {isLoop: true}),
	    _with: kw("with"),
	    _new: kw("new", {beforeExpr: true, startsExpr: true}),
	    _this: kw("this", startsExpr),
	    _super: kw("super", startsExpr),
	    _class: kw("class"),
	    _extends: kw("extends", beforeExpr),
	    _export: kw("export"),
	    _import: kw("import"),
	    _null: kw("null", startsExpr),
	    _true: kw("true", startsExpr),
	    _false: kw("false", startsExpr),
	    _in: kw("in", {beforeExpr: true, binop: 7}),
	    _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
	    _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
	    _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
	  }
	
	  // Matches a whole line break (where CRLF is considered a single
	  // line break). Used to count lines.
	
	  var lineBreak = /\r\n?|\n|\u2028|\u2029/
	  var lineBreakG = new RegExp(lineBreak.source, "g")
	
	  function isNewLine(code) {
	    return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
	  }
	
	  var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/
	
	  var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g
	
	  function isArray(obj) {
	    return Object.prototype.toString.call(obj) === "[object Array]"
	  }
	
	  // Checks if an object has a property.
	
	  function has(obj, propName) {
	    return Object.prototype.hasOwnProperty.call(obj, propName)
	  }
	
	  // These are used when `options.locations` is on, for the
	  // `startLoc` and `endLoc` properties.
	
	  var Position = function Position(line, col) {
	    this.line = line
	    this.column = col
	  };
	
	  Position.prototype.offset = function offset (n) {
	    return new Position(this.line, this.column + n)
	  };
	
	  var SourceLocation = function SourceLocation(p, start, end) {
	    this.start = start
	    this.end = end
	    if (p.sourceFile !== null) this.source = p.sourceFile
	  };
	
	  // The `getLineInfo` function is mostly useful when the
	  // `locations` option is off (for performance reasons) and you
	  // want to find the line/column position for a given character
	  // offset. `input` should be the code string that the offset refers
	  // into.
	
	  function getLineInfo(input, offset) {
	    for (var line = 1, cur = 0;;) {
	      lineBreakG.lastIndex = cur
	      var match = lineBreakG.exec(input)
	      if (match && match.index < offset) {
	        ++line
	        cur = match.index + match[0].length
	      } else {
	        return new Position(line, offset - cur)
	      }
	    }
	  }
	
	  // A second optional argument can be given to further configure
	  // the parser process. These options are recognized:
	
	  var defaultOptions = {
	    // `ecmaVersion` indicates the ECMAScript version to parse. Must
	    // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
	    // for strict mode, the set of reserved words, and support for
	    // new syntax features. The default is 7.
	    ecmaVersion: 7,
	    // `sourceType` indicates the mode the code should be parsed in.
	    // Can be either `"script"` or `"module"`. This influences global
	    // strict mode and parsing of `import` and `export` declarations.
	    sourceType: "script",
	    // `onInsertedSemicolon` can be a callback that will be called
	    // when a semicolon is automatically inserted. It will be passed
	    // th position of the comma as an offset, and if `locations` is
	    // enabled, it is given the location as a `{line, column}` object
	    // as second argument.
	    onInsertedSemicolon: null,
	    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
	    // trailing commas.
	    onTrailingComma: null,
	    // By default, reserved words are only enforced if ecmaVersion >= 5.
	    // Set `allowReserved` to a boolean value to explicitly turn this on
	    // an off. When this option has the value "never", reserved words
	    // and keywords can also not be used as property names.
	    allowReserved: null,
	    // When enabled, a return at the top level is not considered an
	    // error.
	    allowReturnOutsideFunction: false,
	    // When enabled, import/export statements are not constrained to
	    // appearing at the top of the program.
	    allowImportExportEverywhere: false,
	    // When enabled, hashbang directive in the beginning of file
	    // is allowed and treated as a line comment.
	    allowHashBang: false,
	    // When `locations` is on, `loc` properties holding objects with
	    // `start` and `end` properties in `{line, column}` form (with
	    // line being 1-based and column 0-based) will be attached to the
	    // nodes.
	    locations: false,
	    // A function can be passed as `onToken` option, which will
	    // cause Acorn to call that function with object in the same
	    // format as tokens returned from `tokenizer().getToken()`. Note
	    // that you are not allowed to call the parser from the
	    // callbackthat will corrupt its internal state.
	    onToken: null,
	    // A function can be passed as `onComment` option, which will
	    // cause Acorn to call that function with `(block, text, start,
	    // end)` parameters whenever a comment is skipped. `block` is a
	    // boolean indicating whether this is a block (`/* */`) comment,
	    // `text` is the content of the comment, and `start` and `end` are
	    // character offsets that denote the start and end of the comment.
	    // When the `locations` option is on, two more parameters are
	    // passed, the full `{line, column}` locations of the start and
	    // end of the comments. Note that you are not allowed to call the
	    // parser from the callbackthat will corrupt its internal state.
	    onComment: null,
	    // Nodes have their start and end characters offsets recorded in
	    // `start` and `end` properties (directly on the node, rather than
	    // the `loc` object, which holds line/column data. To also add a
	    // [semi-standardized][range] `range` property holding a `[start,
	    // end]` array with the same numbers, set the `ranges` option to
	    // `true`.
	    //
	    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
	    ranges: false,
	    // It is possible to parse multiple files into a single AST by
	    // passing the tree produced by parsing the first file as
	    // `program` option in subsequent parses. This will add the
	    // toplevel forms of the parsed file to the `Program` (top) node
	    // of an existing parse tree.
	    program: null,
	    // When `locations` is on, you can pass this to record the source
	    // file in every node's `loc` object.
	    sourceFile: null,
	    // This value, if given, is stored in every node, whether
	    // `locations` is on or off.
	    directSourceFile: null,
	    // When enabled, parenthesized expressions are represented by
	    // (non-standard) ParenthesizedExpression nodes
	    preserveParens: false,
	    plugins: {}
	  }
	
	  // Interpret and default an options object
	
	  function getOptions(opts) {
	    var options = {}
	
	    for (var opt in defaultOptions)
	      options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]
	
	    if (options.ecmaVersion >= 2015)
	      options.ecmaVersion -= 2009
	
	    if (options.allowReserved == null)
	      options.allowReserved = options.ecmaVersion < 5
	
	    if (isArray(options.onToken)) {
	      var tokens = options.onToken
	      options.onToken = function (token) { return tokens.push(token); }
	    }
	    if (isArray(options.onComment))
	      options.onComment = pushComment(options, options.onComment)
	
	    return options
	  }
	
	  function pushComment(options, array) {
	    return function (block, text, start, end, startLoc, endLoc) {
	      var comment = {
	        type: block ? 'Block' : 'Line',
	        value: text,
	        start: start,
	        end: end
	      }
	      if (options.locations)
	        comment.loc = new SourceLocation(this, startLoc, endLoc)
	      if (options.ranges)
	        comment.range = [start, end]
	      array.push(comment)
	    }
	  }
	
	  // Registered plugins
	  var plugins = {}
	
	  function keywordRegexp(words) {
	    return new RegExp("^(" + words.replace(/ /g, "|") + ")$")
	  }
	
	  var Parser = function Parser(options, input, startPos) {
	    this.options = options = getOptions(options)
	    this.sourceFile = options.sourceFile
	    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])
	    var reserved = ""
	    if (!options.allowReserved) {
	      for (var v = options.ecmaVersion;; v--)
	        if (reserved = reservedWords[v]) break
	      if (options.sourceType == "module") reserved += " await"
	    }
	    this.reservedWords = keywordRegexp(reserved)
	    var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict
	    this.reservedWordsStrict = keywordRegexp(reservedStrict)
	    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind)
	    this.input = String(input)
	
	    // Used to signal to callers of `readWord1` whether the word
	    // contained any escape sequences. This is needed because words with
	    // escape sequences must not be interpreted as keywords.
	    this.containsEsc = false
	
	    // Load plugins
	    this.loadPlugins(options.plugins)
	
	    // Set up token state
	
	    // The current position of the tokenizer in the input.
	    if (startPos) {
	      this.pos = startPos
	      this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1
	      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length
	    } else {
	      this.pos = this.lineStart = 0
	      this.curLine = 1
	    }
	
	    // Properties of the current token:
	    // Its type
	    this.type = tt.eof
	    // For tokens that include more information than their type, the value
	    this.value = null
	    // Its start and end offset
	    this.start = this.end = this.pos
	    // And, if locations are used, the {line, column} object
	    // corresponding to those offsets
	    this.startLoc = this.endLoc = this.curPosition()
	
	    // Position information for the previous token
	    this.lastTokEndLoc = this.lastTokStartLoc = null
	    this.lastTokStart = this.lastTokEnd = this.pos
	
	    // The context stack is used to superficially track syntactic
	    // context to predict whether a regular expression is allowed in a
	    // given position.
	    this.context = this.initialContext()
	    this.exprAllowed = true
	
	    // Figure out if it's a module code.
	    this.strict = this.inModule = options.sourceType === "module"
	
	    // Used to signify the start of a potential arrow function
	    this.potentialArrowAt = -1
	
	    // Flags to track whether we are in a function, a generator, an async function.
	    this.inFunction = this.inGenerator = this.inAsync = false
	    // Positions to delayed-check that yield/await does not exist in default parameters.
	    this.yieldPos = this.awaitPos = 0
	    // Labels in scope.
	    this.labels = []
	
	    // If enabled, skip leading hashbang line.
	    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')
	      this.skipLineComment(2)
	  };
	
	  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
	  Parser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
	  Parser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };
	
	  Parser.prototype.extend = function extend (name, f) {
	    this[name] = f(this[name])
	  };
	
	  Parser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
	      var this$1 = this;
	
	    for (var name in pluginConfigs) {
	      var plugin = plugins[name]
	      if (!plugin) throw new Error("Plugin '" + name + "' not found")
	      plugin(this$1, pluginConfigs[name])
	    }
	  };
	
	  Parser.prototype.parse = function parse () {
	    var node = this.options.program || this.startNode()
	    this.nextToken()
	    return this.parseTopLevel(node)
	  };
	
	  var pp = Parser.prototype
	
	  // ## Parser utilities
	
	  // Test whether a statement node is the string literal `"use strict"`.
	
	  pp.isUseStrict = function(stmt) {
	    return this.options.ecmaVersion >= 5 && stmt.type === "ExpressionStatement" &&
	      stmt.expression.type === "Literal" &&
	      stmt.expression.raw.slice(1, -1) === "use strict"
	  }
	
	  // Predicate that tests whether the next token is of the given
	  // type, and if yes, consumes it as a side effect.
	
	  pp.eat = function(type) {
	    if (this.type === type) {
	      this.next()
	      return true
	    } else {
	      return false
	    }
	  }
	
	  // Tests whether parsed token is a contextual keyword.
	
	  pp.isContextual = function(name) {
	    return this.type === tt.name && this.value === name
	  }
	
	  // Consumes contextual keyword if possible.
	
	  pp.eatContextual = function(name) {
	    return this.value === name && this.eat(tt.name)
	  }
	
	  // Asserts that following token is given contextual keyword.
	
	  pp.expectContextual = function(name) {
	    if (!this.eatContextual(name)) this.unexpected()
	  }
	
	  // Test whether a semicolon can be inserted at the current position.
	
	  pp.canInsertSemicolon = function() {
	    return this.type === tt.eof ||
	      this.type === tt.braceR ||
	      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	  }
	
	  pp.insertSemicolon = function() {
	    if (this.canInsertSemicolon()) {
	      if (this.options.onInsertedSemicolon)
	        this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)
	      return true
	    }
	  }
	
	  // Consume a semicolon, or, failing that, see if we are allowed to
	  // pretend that there is a semicolon at this position.
	
	  pp.semicolon = function() {
	    if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()
	  }
	
	  pp.afterTrailingComma = function(tokType, notNext) {
	    if (this.type == tokType) {
	      if (this.options.onTrailingComma)
	        this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)
	      if (!notNext)
	        this.next()
	      return true
	    }
	  }
	
	  // Expect a token of a given type. If found, consume it, otherwise,
	  // raise an unexpected token error.
	
	  pp.expect = function(type) {
	    this.eat(type) || this.unexpected()
	  }
	
	  // Raise an unexpected token error.
	
	  pp.unexpected = function(pos) {
	    this.raise(pos != null ? pos : this.start, "Unexpected token")
	  }
	
	  var DestructuringErrors = function DestructuringErrors() {
	    this.shorthandAssign = 0
	    this.trailingComma = 0
	  };
	
	  pp.checkPatternErrors = function(refDestructuringErrors, andThrow) {
	    var trailing = refDestructuringErrors && refDestructuringErrors.trailingComma
	    if (!andThrow) return !!trailing
	    if (trailing) this.raise(trailing, "Comma is not permitted after the rest element")
	  }
	
	  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
	    var pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign
	    if (!andThrow) return !!pos
	    if (pos) this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns")
	  }
	
	  pp.checkYieldAwaitInDefaultParams = function() {
	    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
	      this.raise(this.yieldPos, "Yield expression cannot be a default value")
	    if (this.awaitPos)
	      this.raise(this.awaitPos, "Await expression cannot be a default value")
	  }
	
	  var pp$1 = Parser.prototype
	
	  // ### Statement parsing
	
	  // Parse a program. Initializes the parser, reads any number of
	  // statements, and wraps them in a Program node.  Optionally takes a
	  // `program` argument.  If present, the statements will be appended
	  // to its body instead of creating a new node.
	
	  pp$1.parseTopLevel = function(node) {
	    var this$1 = this;
	
	    var first = true, exports = {}
	    if (!node.body) node.body = []
	    while (this.type !== tt.eof) {
	      var stmt = this$1.parseStatement(true, true, exports)
	      node.body.push(stmt)
	      if (first) {
	        if (this$1.isUseStrict(stmt)) this$1.setStrict(true)
	        first = false
	      }
	    }
	    this.next()
	    if (this.options.ecmaVersion >= 6) {
	      node.sourceType = this.options.sourceType
	    }
	    return this.finishNode(node, "Program")
	  }
	
	  var loopLabel = {kind: "loop"};
	  var switchLabel = {kind: "switch"};
	  pp$1.isLet = function() {
	    if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != "let") return false
	    skipWhiteSpace.lastIndex = this.pos
	    var skip = skipWhiteSpace.exec(this.input)
	    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)
	    if (nextCh === 91 || nextCh == 123) return true // '{' and '['
	    if (isIdentifierStart(nextCh, true)) {
	      for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}
	      var ident = this.input.slice(next, pos)
	      if (!this.isKeyword(ident)) return true
	    }
	    return false
	  }
	
	  // check 'async [no LineTerminator here] function'
	  // - 'async /*foo*/ function' is OK.
	  // - 'async /*\n*/ function' is invalid.
	  pp$1.isAsyncFunction = function() {
	    if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != "async")
	      return false
	
	    skipWhiteSpace.lastIndex = this.pos
	    var skip = skipWhiteSpace.exec(this.input)
	    var next = this.pos + skip[0].length
	    return !lineBreak.test(this.input.slice(this.pos, next)) &&
	      this.input.slice(next, next + 8) === "function" &&
	      (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
	  }
	
	  // Parse a single statement.
	  //
	  // If expecting a statement and finding a slash operator, parse a
	  // regular expression literal. This is to handle cases like
	  // `if (foo) /blah/.exec(foo)`, where looking at the previous token
	  // does not help.
	
	  pp$1.parseStatement = function(declaration, topLevel, exports) {
	    var starttype = this.type, node = this.startNode(), kind
	
	    if (this.isLet()) {
	      starttype = tt._var
	      kind = "let"
	    }
	
	    // Most types of statements are recognized by the keyword they
	    // start with. Many are trivial to parse, some require a bit of
	    // complexity.
	
	    switch (starttype) {
	    case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
	    case tt._debugger: return this.parseDebuggerStatement(node)
	    case tt._do: return this.parseDoStatement(node)
	    case tt._for: return this.parseForStatement(node)
	    case tt._function:
	      if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()
	      return this.parseFunctionStatement(node, false)
	    case tt._class:
	      if (!declaration) this.unexpected()
	      return this.parseClass(node, true)
	    case tt._if: return this.parseIfStatement(node)
	    case tt._return: return this.parseReturnStatement(node)
	    case tt._switch: return this.parseSwitchStatement(node)
	    case tt._throw: return this.parseThrowStatement(node)
	    case tt._try: return this.parseTryStatement(node)
	    case tt._const: case tt._var:
	      kind = kind || this.value
	      if (!declaration && kind != "var") this.unexpected()
	      return this.parseVarStatement(node, kind)
	    case tt._while: return this.parseWhileStatement(node)
	    case tt._with: return this.parseWithStatement(node)
	    case tt.braceL: return this.parseBlock()
	    case tt.semi: return this.parseEmptyStatement(node)
	    case tt._export:
	    case tt._import:
	      if (!this.options.allowImportExportEverywhere) {
	        if (!topLevel)
	          this.raise(this.start, "'import' and 'export' may only appear at the top level")
	        if (!this.inModule)
	          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")
	      }
	      return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)
	
	      // If the statement does not start with a statement keyword or a
	      // brace, it's an ExpressionStatement or LabeledStatement. We
	      // simply start parsing an expression, and afterwards, if the
	      // next token is a colon and the expression was a simple
	      // Identifier node, we switch to interpreting it as a label.
	    default:
	      if (this.isAsyncFunction() && declaration) {
	        this.next()
	        return this.parseFunctionStatement(node, true)
	      }
	
	      var maybeName = this.value, expr = this.parseExpression()
	      if (starttype === tt.name && expr.type === "Identifier" && this.eat(tt.colon))
	        return this.parseLabeledStatement(node, maybeName, expr)
	      else return this.parseExpressionStatement(node, expr)
	    }
	  }
	
	  pp$1.parseBreakContinueStatement = function(node, keyword) {
	    var this$1 = this;
	
	    var isBreak = keyword == "break"
	    this.next()
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null
	    else if (this.type !== tt.name) this.unexpected()
	    else {
	      node.label = this.parseIdent()
	      this.semicolon()
	    }
	
	    // Verify that there is an actual destination to break or
	    // continue to.
	    for (var i = 0; i < this.labels.length; ++i) {
	      var lab = this$1.labels[i]
	      if (node.label == null || lab.name === node.label.name) {
	        if (lab.kind != null && (isBreak || lab.kind === "loop")) break
	        if (node.label && isBreak) break
	      }
	    }
	    if (i === this.labels.length) this.raise(node.start, "Unsyntactic " + keyword)
	    return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
	  }
	
	  pp$1.parseDebuggerStatement = function(node) {
	    this.next()
	    this.semicolon()
	    return this.finishNode(node, "DebuggerStatement")
	  }
	
	  pp$1.parseDoStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    this.expect(tt._while)
	    node.test = this.parseParenExpression()
	    if (this.options.ecmaVersion >= 6)
	      this.eat(tt.semi)
	    else
	      this.semicolon()
	    return this.finishNode(node, "DoWhileStatement")
	  }
	
	  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`
	  // loop is non-trivial. Basically, we have to parse the init `var`
	  // statement or expression, disallowing the `in` operator (see
	  // the second parameter to `parseExpression`), and then check
	  // whether the next token is `in` or `of`. When there is no init
	  // part (semicolon immediately after the opening parenthesis), it
	  // is a regular `for` loop.
	
	  pp$1.parseForStatement = function(node) {
	    this.next()
	    this.labels.push(loopLabel)
	    this.expect(tt.parenL)
	    if (this.type === tt.semi) return this.parseFor(node, null)
	    var isLet = this.isLet()
	    if (this.type === tt._var || this.type === tt._const || isLet) {
	      var init$1 = this.startNode(), kind = isLet ? "let" : this.value
	      this.next()
	      this.parseVar(init$1, true, kind)
	      this.finishNode(init$1, "VariableDeclaration")
	      if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
	          !(kind !== "var" && init$1.declarations[0].init))
	        return this.parseForIn(node, init$1)
	      return this.parseFor(node, init$1)
	    }
	    var refDestructuringErrors = new DestructuringErrors
	    var init = this.parseExpression(true, refDestructuringErrors)
	    if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      this.toAssignable(init)
	      this.checkLVal(init)
	      return this.parseForIn(node, init)
	    } else {
	      this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return this.parseFor(node, init)
	  }
	
	  pp$1.parseFunctionStatement = function(node, isAsync) {
	    this.next()
	    return this.parseFunction(node, true, false, isAsync)
	  }
	
	  pp$1.isFunction = function() {
	    return this.type === tt._function || this.isAsyncFunction()
	  }
	
	  pp$1.parseIfStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    // allow function declarations in branches, but only in non-strict mode
	    node.consequent = this.parseStatement(!this.strict && this.isFunction())
	    node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null
	    return this.finishNode(node, "IfStatement")
	  }
	
	  pp$1.parseReturnStatement = function(node) {
	    if (!this.inFunction && !this.options.allowReturnOutsideFunction)
	      this.raise(this.start, "'return' outside of function")
	    this.next()
	
	    // In `return` (and `break`/`continue`), the keywords with
	    // optional arguments, we eagerly look for a semicolon or the
	    // possibility to insert one.
	
	    if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null
	    else { node.argument = this.parseExpression(); this.semicolon() }
	    return this.finishNode(node, "ReturnStatement")
	  }
	
	  pp$1.parseSwitchStatement = function(node) {
	    var this$1 = this;
	
	    this.next()
	    node.discriminant = this.parseParenExpression()
	    node.cases = []
	    this.expect(tt.braceL)
	    this.labels.push(switchLabel)
	
	    // Statements under must be grouped (by label) in SwitchCase
	    // nodes. `cur` is used to keep the node that we are currently
	    // adding statements to.
	
	    for (var cur, sawDefault = false; this.type != tt.braceR;) {
	      if (this$1.type === tt._case || this$1.type === tt._default) {
	        var isCase = this$1.type === tt._case
	        if (cur) this$1.finishNode(cur, "SwitchCase")
	        node.cases.push(cur = this$1.startNode())
	        cur.consequent = []
	        this$1.next()
	        if (isCase) {
	          cur.test = this$1.parseExpression()
	        } else {
	          if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses")
	          sawDefault = true
	          cur.test = null
	        }
	        this$1.expect(tt.colon)
	      } else {
	        if (!cur) this$1.unexpected()
	        cur.consequent.push(this$1.parseStatement(true))
	      }
	    }
	    if (cur) this.finishNode(cur, "SwitchCase")
	    this.next() // Closing brace
	    this.labels.pop()
	    return this.finishNode(node, "SwitchStatement")
	  }
	
	  pp$1.parseThrowStatement = function(node) {
	    this.next()
	    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
	      this.raise(this.lastTokEnd, "Illegal newline after throw")
	    node.argument = this.parseExpression()
	    this.semicolon()
	    return this.finishNode(node, "ThrowStatement")
	  }
	
	  // Reused empty array added for node fields that are always empty.
	
	  var empty = []
	
	  pp$1.parseTryStatement = function(node) {
	    this.next()
	    node.block = this.parseBlock()
	    node.handler = null
	    if (this.type === tt._catch) {
	      var clause = this.startNode()
	      this.next()
	      this.expect(tt.parenL)
	      clause.param = this.parseBindingAtom()
	      this.checkLVal(clause.param, true)
	      this.expect(tt.parenR)
	      clause.body = this.parseBlock()
	      node.handler = this.finishNode(clause, "CatchClause")
	    }
	    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null
	    if (!node.handler && !node.finalizer)
	      this.raise(node.start, "Missing catch or finally clause")
	    return this.finishNode(node, "TryStatement")
	  }
	
	  pp$1.parseVarStatement = function(node, kind) {
	    this.next()
	    this.parseVar(node, false, kind)
	    this.semicolon()
	    return this.finishNode(node, "VariableDeclaration")
	  }
	
	  pp$1.parseWhileStatement = function(node) {
	    this.next()
	    node.test = this.parseParenExpression()
	    this.labels.push(loopLabel)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "WhileStatement")
	  }
	
	  pp$1.parseWithStatement = function(node) {
	    if (this.strict) this.raise(this.start, "'with' in strict mode")
	    this.next()
	    node.object = this.parseParenExpression()
	    node.body = this.parseStatement(false)
	    return this.finishNode(node, "WithStatement")
	  }
	
	  pp$1.parseEmptyStatement = function(node) {
	    this.next()
	    return this.finishNode(node, "EmptyStatement")
	  }
	
	  pp$1.parseLabeledStatement = function(node, maybeName, expr) {
	    var this$1 = this;
	
	    for (var i = 0; i < this.labels.length; ++i)
	      if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, "Label '" + maybeName + "' is already declared")
	    var kind = this.type.isLoop ? "loop" : this.type === tt._switch ? "switch" : null
	    for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {
	      var label = this$1.labels[i$1]
	      if (label.statementStart == node.start) {
	        label.statementStart = this$1.start
	        label.kind = kind
	      } else break
	    }
	    this.labels.push({name: maybeName, kind: kind, statementStart: this.start})
	    node.body = this.parseStatement(true)
	    this.labels.pop()
	    node.label = expr
	    return this.finishNode(node, "LabeledStatement")
	  }
	
	  pp$1.parseExpressionStatement = function(node, expr) {
	    node.expression = expr
	    this.semicolon()
	    return this.finishNode(node, "ExpressionStatement")
	  }
	
	  // Parse a semicolon-enclosed block of statements, handling `"use
	  // strict"` declarations when `allowStrict` is true (used for
	  // function bodies).
	
	  pp$1.parseBlock = function(allowStrict) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, oldStrict
	    node.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      var stmt = this$1.parseStatement(true)
	      node.body.push(stmt)
	      if (first && allowStrict && this$1.isUseStrict(stmt)) {
	        oldStrict = this$1.strict
	        this$1.setStrict(this$1.strict = true)
	      }
	      first = false
	    }
	    if (oldStrict === false) this.setStrict(false)
	    return this.finishNode(node, "BlockStatement")
	  }
	
	  // Parse a regular `for` loop. The disambiguation code in
	  // `parseStatement` will already have parsed the init statement or
	  // expression.
	
	  pp$1.parseFor = function(node, init) {
	    node.init = init
	    this.expect(tt.semi)
	    node.test = this.type === tt.semi ? null : this.parseExpression()
	    this.expect(tt.semi)
	    node.update = this.type === tt.parenR ? null : this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, "ForStatement")
	  }
	
	  // Parse a `for`/`in` and `for`/`of` loop, which are almost
	  // same from parser's perspective.
	
	  pp$1.parseForIn = function(node, init) {
	    var type = this.type === tt._in ? "ForInStatement" : "ForOfStatement"
	    this.next()
	    node.left = init
	    node.right = this.parseExpression()
	    this.expect(tt.parenR)
	    node.body = this.parseStatement(false)
	    this.labels.pop()
	    return this.finishNode(node, type)
	  }
	
	  // Parse a list of variable declarations.
	
	  pp$1.parseVar = function(node, isFor, kind) {
	    var this$1 = this;
	
	    node.declarations = []
	    node.kind = kind
	    for (;;) {
	      var decl = this$1.startNode()
	      this$1.parseVarId(decl)
	      if (this$1.eat(tt.eq)) {
	        decl.init = this$1.parseMaybeAssign(isFor)
	      } else if (kind === "const" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
	        this$1.unexpected()
	      } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === tt._in || this$1.isContextual("of")))) {
	        this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value")
	      } else {
	        decl.init = null
	      }
	      node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"))
	      if (!this$1.eat(tt.comma)) break
	    }
	    return node
	  }
	
	  pp$1.parseVarId = function(decl) {
	    decl.id = this.parseBindingAtom()
	    this.checkLVal(decl.id, true)
	  }
	
	  // Parse a function declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
	    this.initFunction(node)
	    if (this.options.ecmaVersion >= 6 && !isAsync)
	      node.generator = this.eat(tt.star)
	    if (this.options.ecmaVersion >= 8)
	      node.async = !!isAsync
	
	    if (isStatement)
	      node.id = this.parseIdent()
	
	    var oldInGen = this.inGenerator, oldInAsync = this.inAsync, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos
	    this.inGenerator = node.generator
	    this.inAsync = node.async
	    this.yieldPos = 0
	    this.awaitPos = 0
	
	    if (!isStatement && this.type === tt.name)
	      node.id = this.parseIdent()
	    this.parseFunctionParams(node)
	    this.parseFunctionBody(node, allowExpressionBody)
	
	    this.inGenerator = oldInGen
	    this.inAsync = oldInAsync
	    this.yieldPos = oldYieldPos
	    this.awaitPos = oldAwaitPos
	    return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
	  }
	
	  pp$1.parseFunctionParams = function(node) {
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)
	    this.checkYieldAwaitInDefaultParams()
	  }
	
	  // Parse a class declaration or literal (depending on the
	  // `isStatement` parameter).
	
	  pp$1.parseClass = function(node, isStatement) {
	    var this$1 = this;
	
	    this.next()
	    this.parseClassId(node, isStatement)
	    this.parseClassSuper(node)
	    var classBody = this.startNode()
	    var hadConstructor = false
	    classBody.body = []
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (this$1.eat(tt.semi)) continue
	      var method = this$1.startNode()
	      var isGenerator = this$1.eat(tt.star)
	      var isAsync = false
	      var isMaybeStatic = this$1.type === tt.name && this$1.value === "static"
	      this$1.parsePropertyName(method)
	      method.static = isMaybeStatic && this$1.type !== tt.parenL
	      if (method.static) {
	        if (isGenerator) this$1.unexpected()
	        isGenerator = this$1.eat(tt.star)
	        this$1.parsePropertyName(method)
	      }
	      if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&
	          method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== tt.parenL &&
	          !this$1.canInsertSemicolon()) {
	        isAsync = true
	        this$1.parsePropertyName(method)
	      }
	      method.kind = "method"
	      var isGetSet = false
	      if (!method.computed) {
	        var key = method.key;
	        if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== tt.parenL && (key.name === "get" || key.name === "set")) {
	          isGetSet = true
	          method.kind = key.name
	          key = this$1.parsePropertyName(method)
	        }
	        if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
	            key.type === "Literal" && key.value === "constructor")) {
	          if (hadConstructor) this$1.raise(key.start, "Duplicate constructor in the same class")
	          if (isGetSet) this$1.raise(key.start, "Constructor can't have get/set modifier")
	          if (isGenerator) this$1.raise(key.start, "Constructor can't be a generator")
	          if (isAsync) this$1.raise(key.start, "Constructor can't be an async method")
	          method.kind = "constructor"
	          hadConstructor = true
	        }
	      }
	      this$1.parseClassMethod(classBody, method, isGenerator, isAsync)
	      if (isGetSet) {
	        var paramCount = method.kind === "get" ? 0 : 1
	        if (method.value.params.length !== paramCount) {
	          var start = method.value.start
	          if (method.kind === "get")
	            this$1.raiseRecoverable(start, "getter should have no params")
	          else
	            this$1.raiseRecoverable(start, "setter should have exactly one param")
	        } else {
	          if (method.kind === "set" && method.value.params[0].type === "RestElement")
	            this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params")
	        }
	      }
	    }
	    node.body = this.finishNode(classBody, "ClassBody")
	    return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
	  }
	
	  pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
	    method.value = this.parseMethod(isGenerator, isAsync)
	    classBody.body.push(this.finishNode(method, "MethodDefinition"))
	  }
	
	  pp$1.parseClassId = function(node, isStatement) {
	    node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null
	  }
	
	  pp$1.parseClassSuper = function(node) {
	    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null
	  }
	
	  // Parses module export declaration.
	
	  pp$1.parseExport = function(node, exports) {
	    var this$1 = this;
	
	    this.next()
	    // export * from '...'
	    if (this.eat(tt.star)) {
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      this.semicolon()
	      return this.finishNode(node, "ExportAllDeclaration")
	    }
	    if (this.eat(tt._default)) { // export default ...
	      this.checkExport(exports, "default", this.lastTokStart)
	      var parens = this.type == tt.parenL
	      var expr = this.parseMaybeAssign()
	      var needsSemi = true
	      if (!parens && (expr.type == "FunctionExpression" ||
	                      expr.type == "ClassExpression")) {
	        needsSemi = false
	        if (expr.id) {
	          expr.type = expr.type == "FunctionExpression"
	            ? "FunctionDeclaration"
	            : "ClassDeclaration"
	        }
	      }
	      node.declaration = expr
	      if (needsSemi) this.semicolon()
	      return this.finishNode(node, "ExportDefaultDeclaration")
	    }
	    // export var|const|let|function|class ...
	    if (this.shouldParseExportStatement()) {
	      node.declaration = this.parseStatement(true)
	      if (node.declaration.type === "VariableDeclaration")
	        this.checkVariableExport(exports, node.declaration.declarations)
	      else
	        this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)
	      node.specifiers = []
	      node.source = null
	    } else { // export { x, y as z } [from '...']
	      node.declaration = null
	      node.specifiers = this.parseExportSpecifiers(exports)
	      if (this.eatContextual("from")) {
	        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	      } else {
	        // check for keywords used as local names
	        for (var i = 0; i < node.specifiers.length; i++) {
	          if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {
	            this$1.unexpected(node.specifiers[i].local.start)
	          }
	        }
	
	        node.source = null
	      }
	      this.semicolon()
	    }
	    return this.finishNode(node, "ExportNamedDeclaration")
	  }
	
	  pp$1.checkExport = function(exports, name, pos) {
	    if (!exports) return
	    if (Object.prototype.hasOwnProperty.call(exports, name))
	      this.raiseRecoverable(pos, "Duplicate export '" + name + "'")
	    exports[name] = true
	  }
	
	  pp$1.checkPatternExport = function(exports, pat) {
	    var this$1 = this;
	
	    var type = pat.type
	    if (type == "Identifier")
	      this.checkExport(exports, pat.name, pat.start)
	    else if (type == "ObjectPattern")
	      for (var i = 0; i < pat.properties.length; ++i)
	        this$1.checkPatternExport(exports, pat.properties[i].value)
	    else if (type == "ArrayPattern")
	      for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {
	        var elt = pat.elements[i$1]
	        if (elt) this$1.checkPatternExport(exports, elt)
	      }
	    else if (type == "AssignmentPattern")
	      this.checkPatternExport(exports, pat.left)
	    else if (type == "ParenthesizedExpression")
	      this.checkPatternExport(exports, pat.expression)
	  }
	
	  pp$1.checkVariableExport = function(exports, decls) {
	    var this$1 = this;
	
	    if (!exports) return
	    for (var i = 0; i < decls.length; i++)
	      this$1.checkPatternExport(exports, decls[i].id)
	  }
	
	  pp$1.shouldParseExportStatement = function() {
	    return this.type.keyword || this.isLet() || this.isAsyncFunction()
	  }
	
	  // Parses a comma-separated list of module exports.
	
	  pp$1.parseExportSpecifiers = function(exports) {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    // export { x, y as z } [from '...']
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node = this$1.startNode()
	      node.local = this$1.parseIdent(this$1.type === tt._default)
	      node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local
	      this$1.checkExport(exports, node.exported.name, node.exported.start)
	      nodes.push(this$1.finishNode(node, "ExportSpecifier"))
	    }
	    return nodes
	  }
	
	  // Parses import declaration.
	
	  pp$1.parseImport = function(node) {
	    this.next()
	    // import '...'
	    if (this.type === tt.string) {
	      node.specifiers = empty
	      node.source = this.parseExprAtom()
	    } else {
	      node.specifiers = this.parseImportSpecifiers()
	      this.expectContextual("from")
	      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()
	    }
	    this.semicolon()
	    return this.finishNode(node, "ImportDeclaration")
	  }
	
	  // Parses a comma-separated list of module imports.
	
	  pp$1.parseImportSpecifiers = function() {
	    var this$1 = this;
	
	    var nodes = [], first = true
	    if (this.type === tt.name) {
	      // import defaultObj, { x, y as z } from '...'
	      var node = this.startNode()
	      node.local = this.parseIdent()
	      this.checkLVal(node.local, true)
	      nodes.push(this.finishNode(node, "ImportDefaultSpecifier"))
	      if (!this.eat(tt.comma)) return nodes
	    }
	    if (this.type === tt.star) {
	      var node$1 = this.startNode()
	      this.next()
	      this.expectContextual("as")
	      node$1.local = this.parseIdent()
	      this.checkLVal(node$1.local, true)
	      nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"))
	      return nodes
	    }
	    this.expect(tt.braceL)
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var node$2 = this$1.startNode()
	      node$2.imported = this$1.parseIdent(true)
	      if (this$1.eatContextual("as")) {
	        node$2.local = this$1.parseIdent()
	      } else {
	        node$2.local = node$2.imported
	        if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)
	        if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, "The keyword '" + node$2.local.name + "' is reserved")
	      }
	      this$1.checkLVal(node$2.local, true)
	      nodes.push(this$1.finishNode(node$2, "ImportSpecifier"))
	    }
	    return nodes
	  }
	
	  var pp$2 = Parser.prototype
	
	  // Convert existing expression atom to assignable pattern
	  // if possible.
	
	  pp$2.toAssignable = function(node, isBinding) {
	    var this$1 = this;
	
	    if (this.options.ecmaVersion >= 6 && node) {
	      switch (node.type) {
	        case "Identifier":
	        if (this.inAsync && node.name === "await")
	          this.raise(node.start, "Can not use 'await' as identifier inside an async function")
	        break
	
	      case "ObjectPattern":
	      case "ArrayPattern":
	        break
	
	      case "ObjectExpression":
	        node.type = "ObjectPattern"
	        for (var i = 0; i < node.properties.length; i++) {
	          var prop = node.properties[i]
	          if (prop.kind !== "init") this$1.raise(prop.key.start, "Object pattern can't contain getter or setter")
	          this$1.toAssignable(prop.value, isBinding)
	        }
	        break
	
	      case "ArrayExpression":
	        node.type = "ArrayPattern"
	        this.toAssignableList(node.elements, isBinding)
	        break
	
	      case "AssignmentExpression":
	        if (node.operator === "=") {
	          node.type = "AssignmentPattern"
	          delete node.operator
	          this.toAssignable(node.left, isBinding)
	          // falls through to AssignmentPattern
	        } else {
	          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.")
	          break
	        }
	
	      case "AssignmentPattern":
	        break
	
	      case "ParenthesizedExpression":
	        node.expression = this.toAssignable(node.expression, isBinding)
	        break
	
	      case "MemberExpression":
	        if (!isBinding) break
	
	      default:
	        this.raise(node.start, "Assigning to rvalue")
	      }
	    }
	    return node
	  }
	
	  // Convert list of expression atoms to binding list.
	
	  pp$2.toAssignableList = function(exprList, isBinding) {
	    var this$1 = this;
	
	    var end = exprList.length
	    if (end) {
	      var last = exprList[end - 1]
	      if (last && last.type == "RestElement") {
	        --end
	      } else if (last && last.type == "SpreadElement") {
	        last.type = "RestElement"
	        var arg = last.argument
	        this.toAssignable(arg, isBinding)
	        if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern")
	          this.unexpected(arg.start)
	        --end
	      }
	
	      if (isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
	        this.unexpected(last.argument.start)
	    }
	    for (var i = 0; i < end; i++) {
	      var elt = exprList[i]
	      if (elt) this$1.toAssignable(elt, isBinding)
	    }
	    return exprList
	  }
	
	  // Parses spread element.
	
	  pp$2.parseSpread = function(refDestructuringErrors) {
	    var node = this.startNode()
	    this.next()
	    node.argument = this.parseMaybeAssign(false, refDestructuringErrors)
	    return this.finishNode(node, "SpreadElement")
	  }
	
	  pp$2.parseRest = function(allowNonIdent) {
	    var node = this.startNode()
	    this.next()
	
	    // RestElement inside of a function parameter must be an identifier
	    if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()
	    else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()
	
	    return this.finishNode(node, "RestElement")
	  }
	
	  // Parses lvalue (assignable) atom.
	
	  pp$2.parseBindingAtom = function() {
	    if (this.options.ecmaVersion < 6) return this.parseIdent()
	    switch (this.type) {
	    case tt.name:
	      return this.parseIdent()
	
	    case tt.bracketL:
	      var node = this.startNode()
	      this.next()
	      node.elements = this.parseBindingList(tt.bracketR, true, true)
	      return this.finishNode(node, "ArrayPattern")
	
	    case tt.braceL:
	      return this.parseObj(true)
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (first) first = false
	      else this$1.expect(tt.comma)
	      if (allowEmpty && this$1.type === tt.comma) {
	        elts.push(null)
	      } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
	        break
	      } else if (this$1.type === tt.ellipsis) {
	        var rest = this$1.parseRest(allowNonIdent)
	        this$1.parseBindingListItem(rest)
	        elts.push(rest)
	        if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
	        this$1.expect(close)
	        break
	      } else {
	        var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)
	        this$1.parseBindingListItem(elem)
	        elts.push(elem)
	      }
	    }
	    return elts
	  }
	
	  pp$2.parseBindingListItem = function(param) {
	    return param
	  }
	
	  // Parses assignment pattern around given atom if possible.
	
	  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
	    left = left || this.parseBindingAtom()
	    if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.right = this.parseMaybeAssign()
	    return this.finishNode(node, "AssignmentPattern")
	  }
	
	  // Verify that a node is an lval  something that can be assigned
	  // to.
	
	  pp$2.checkLVal = function(expr, isBinding, checkClashes) {
	    var this$1 = this;
	
	    switch (expr.type) {
	    case "Identifier":
	      if (this.strict && this.reservedWordsStrictBind.test(expr.name))
	        this.raiseRecoverable(expr.start, (isBinding ? "Binding " : "Assigning to ") + expr.name + " in strict mode")
	      if (checkClashes) {
	        if (has(checkClashes, expr.name))
	          this.raiseRecoverable(expr.start, "Argument name clash")
	        checkClashes[expr.name] = true
	      }
	      break
	
	    case "MemberExpression":
	      if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression")
	      break
	
	    case "ObjectPattern":
	      for (var i = 0; i < expr.properties.length; i++)
	        this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)
	      break
	
	    case "ArrayPattern":
	      for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {
	        var elem = expr.elements[i$1]
	        if (elem) this$1.checkLVal(elem, isBinding, checkClashes)
	      }
	      break
	
	    case "AssignmentPattern":
	      this.checkLVal(expr.left, isBinding, checkClashes)
	      break
	
	    case "RestElement":
	      this.checkLVal(expr.argument, isBinding, checkClashes)
	      break
	
	    case "ParenthesizedExpression":
	      this.checkLVal(expr.expression, isBinding, checkClashes)
	      break
	
	    default:
	      this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " rvalue")
	    }
	  }
	
	  var pp$3 = Parser.prototype
	
	  // Check if property name clashes with already added.
	  // Object/class getters and setters are not allowed to clash 
	  // either with each other or with an init property  and in
	  // strict mode, init properties are also not allowed to be repeated.
	
	  pp$3.checkPropClash = function(prop, propHash) {
	    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
	      return
	    var key = prop.key;
	    var name
	    switch (key.type) {
	    case "Identifier": name = key.name; break
	    case "Literal": name = String(key.value); break
	    default: return
	    }
	    var kind = prop.kind;
	    if (this.options.ecmaVersion >= 6) {
	      if (name === "__proto__" && kind === "init") {
	        if (propHash.proto) this.raiseRecoverable(key.start, "Redefinition of __proto__ property")
	        propHash.proto = true
	      }
	      return
	    }
	    name = "$" + name
	    var other = propHash[name]
	    if (other) {
	      var isGetSet = kind !== "init"
	      if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))
	        this.raiseRecoverable(key.start, "Redefinition of property")
	    } else {
	      other = propHash[name] = {
	        init: false,
	        get: false,
	        set: false
	      }
	    }
	    other[kind] = true
	  }
	
	  // ### Expression parsing
	
	  // These nest, from the most general expression type at the top to
	  // 'atomic', nondivisible expression types at the bottom. Most of
	  // the functions will simply let the function(s) below them parse,
	  // and, *if* the syntactic construct they handle is present, wrap
	  // the AST node that the inner parser gave them in another node.
	
	  // Parse a full expression. The optional arguments are used to
	  // forbid the `in` operator (in for loops initalization expressions)
	  // and provide reference for storing '=' operator inside shorthand
	  // property assignment in contexts where both object expression
	  // and object pattern might appear (so it's possible to raise
	  // delayed syntax error at correct position).
	
	  pp$3.parseExpression = function(noIn, refDestructuringErrors) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)
	    if (this.type === tt.comma) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.expressions = [expr]
	      while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))
	      return this.finishNode(node, "SequenceExpression")
	    }
	    return expr
	  }
	
	  // Parse an assignment expression. This includes applications of
	  // operators like `+=`.
	
	  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
	    if (this.inGenerator && this.isContextual("yield")) return this.parseYield()
	
	    var ownDestructuringErrors = false
	    if (!refDestructuringErrors) {
	      refDestructuringErrors = new DestructuringErrors
	      ownDestructuringErrors = true
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    if (this.type == tt.parenL || this.type == tt.name)
	      this.potentialArrowAt = this.start
	    var left = this.parseMaybeConditional(noIn, refDestructuringErrors)
	    if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)
	    if (this.type.isAssign) {
	      this.checkPatternErrors(refDestructuringErrors, true)
	      if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)
	      var node = this.startNodeAt(startPos, startLoc)
	      node.operator = this.value
	      node.left = this.type === tt.eq ? this.toAssignable(left) : left
	      refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly
	      this.checkLVal(left)
	      this.next()
	      node.right = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "AssignmentExpression")
	    } else {
	      if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)
	    }
	    return left
	  }
	
	  // Parse a ternary conditional (`?:`) operator.
	
	  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprOps(noIn, refDestructuringErrors)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    if (this.eat(tt.question)) {
	      var node = this.startNodeAt(startPos, startLoc)
	      node.test = expr
	      node.consequent = this.parseMaybeAssign()
	      this.expect(tt.colon)
	      node.alternate = this.parseMaybeAssign(noIn)
	      return this.finishNode(node, "ConditionalExpression")
	    }
	    return expr
	  }
	
	  // Start the precedence parser.
	
	  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseMaybeUnary(refDestructuringErrors, false)
	    if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	    return this.parseExprOp(expr, startPos, startLoc, -1, noIn)
	  }
	
	  // Parse binary operators with the operator precedence parsing
	  // algorithm. `left` is the left-hand side of the operator.
	  // `minPrec` provides context that allows the function to stop and
	  // defer further parser to one of its callers when it encounters an
	  // operator that has a lower precedence than the set it is parsing.
	
	  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
	    var prec = this.type.binop
	    if (prec != null && (!noIn || this.type !== tt._in)) {
	      if (prec > minPrec) {
	        var logical = this.type === tt.logicalOR || this.type === tt.logicalAND
	        var op = this.value
	        this.next()
	        var startPos = this.start, startLoc = this.startLoc
	        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)
	        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)
	        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
	      }
	    }
	    return left
	  }
	
	  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
	    var node = this.startNodeAt(startPos, startLoc)
	    node.left = left
	    node.operator = op
	    node.right = right
	    return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
	  }
	
	  // Parse unary operators, both prefix and postfix.
	
	  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, expr
	    if (this.inAsync && this.isContextual("await")) {
	      expr = this.parseAwait(refDestructuringErrors)
	      sawUnary = true
	    } else if (this.type.prefix) {
	      var node = this.startNode(), update = this.type === tt.incDec
	      node.operator = this.value
	      node.prefix = true
	      this.next()
	      node.argument = this.parseMaybeUnary(null, true)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	      if (update) this.checkLVal(node.argument)
	      else if (this.strict && node.operator === "delete" &&
	               node.argument.type === "Identifier")
	        this.raiseRecoverable(node.start, "Deleting local variable in strict mode")
	      else sawUnary = true
	      expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression")
	    } else {
	      expr = this.parseExprSubscripts(refDestructuringErrors)
	      if (this.checkExpressionErrors(refDestructuringErrors)) return expr
	      while (this.type.postfix && !this.canInsertSemicolon()) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.operator = this$1.value
	        node$1.prefix = false
	        node$1.argument = expr
	        this$1.checkLVal(expr)
	        this$1.next()
	        expr = this$1.finishNode(node$1, "UpdateExpression")
	      }
	    }
	
	    if (!sawUnary && this.eat(tt.starstar))
	      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false)
	    else
	      return expr
	  }
	
	  // Parse call, dot, and `[]`-subscript expressions.
	
	  pp$3.parseExprSubscripts = function(refDestructuringErrors) {
	    var startPos = this.start, startLoc = this.startLoc
	    var expr = this.parseExprAtom(refDestructuringErrors)
	    var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
	    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr
	    return this.parseSubscripts(expr, startPos, startLoc)
	  }
	
	  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
	    var this$1 = this;
	
	    for (;;) {
	      var maybeAsyncArrow = this$1.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" && !this$1.canInsertSemicolon()
	      if (this$1.eat(tt.dot)) {
	        var node = this$1.startNodeAt(startPos, startLoc)
	        node.object = base
	        node.property = this$1.parseIdent(true)
	        node.computed = false
	        base = this$1.finishNode(node, "MemberExpression")
	      } else if (this$1.eat(tt.bracketL)) {
	        var node$1 = this$1.startNodeAt(startPos, startLoc)
	        node$1.object = base
	        node$1.property = this$1.parseExpression()
	        node$1.computed = true
	        this$1.expect(tt.bracketR)
	        base = this$1.finishNode(node$1, "MemberExpression")
	      } else if (!noCalls && this$1.eat(tt.parenL)) {
	        var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos
	        this$1.yieldPos = 0
	        this$1.awaitPos = 0
	        var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)
	        if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {
	          this$1.checkPatternErrors(refDestructuringErrors, true)
	          this$1.checkYieldAwaitInDefaultParams()
	          this$1.yieldPos = oldYieldPos
	          this$1.awaitPos = oldAwaitPos
	          return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
	        }
	        this$1.checkExpressionErrors(refDestructuringErrors, true)
	        this$1.yieldPos = oldYieldPos || this$1.yieldPos
	        this$1.awaitPos = oldAwaitPos || this$1.awaitPos
	        var node$2 = this$1.startNodeAt(startPos, startLoc)
	        node$2.callee = base
	        node$2.arguments = exprList
	        base = this$1.finishNode(node$2, "CallExpression")
	      } else if (this$1.type === tt.backQuote) {
	        var node$3 = this$1.startNodeAt(startPos, startLoc)
	        node$3.tag = base
	        node$3.quasi = this$1.parseTemplate()
	        base = this$1.finishNode(node$3, "TaggedTemplateExpression")
	      } else {
	        return base
	      }
	    }
	  }
	
	  // Parse an atomic expression  either a single token that is an
	  // expression, an expression started by a keyword like `function` or
	  // `new`, or an expression wrapped in punctuation like `()`, `[]`,
	  // or `{}`.
	
	  pp$3.parseExprAtom = function(refDestructuringErrors) {
	    var node, canBeArrow = this.potentialArrowAt == this.start
	    switch (this.type) {
	    case tt._super:
	      if (!this.inFunction)
	        this.raise(this.start, "'super' outside of function or class")
	
	    case tt._this:
	      var type = this.type === tt._this ? "ThisExpression" : "Super"
	      node = this.startNode()
	      this.next()
	      return this.finishNode(node, type)
	
	    case tt.name:
	      var startPos = this.start, startLoc = this.startLoc
	      var id = this.parseIdent(this.type !== tt.name)
	      if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(tt._function))
	        return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)
	      if (canBeArrow && !this.canInsertSemicolon()) {
	        if (this.eat(tt.arrow))
	          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)
	        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === tt.name) {
	          id = this.parseIdent()
	          if (this.canInsertSemicolon() || !this.eat(tt.arrow))
	            this.unexpected()
	          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
	        }
	      }
	      return id
	
	    case tt.regexp:
	      var value = this.value
	      node = this.parseLiteral(value.value)
	      node.regex = {pattern: value.pattern, flags: value.flags}
	      return node
	
	    case tt.num: case tt.string:
	      return this.parseLiteral(this.value)
	
	    case tt._null: case tt._true: case tt._false:
	      node = this.startNode()
	      node.value = this.type === tt._null ? null : this.type === tt._true
	      node.raw = this.type.keyword
	      this.next()
	      return this.finishNode(node, "Literal")
	
	    case tt.parenL:
	      return this.parseParenAndDistinguishExpression(canBeArrow)
	
	    case tt.bracketL:
	      node = this.startNode()
	      this.next()
	      node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)
	      return this.finishNode(node, "ArrayExpression")
	
	    case tt.braceL:
	      return this.parseObj(false, refDestructuringErrors)
	
	    case tt._function:
	      node = this.startNode()
	      this.next()
	      return this.parseFunction(node, false)
	
	    case tt._class:
	      return this.parseClass(this.startNode(), false)
	
	    case tt._new:
	      return this.parseNew()
	
	    case tt.backQuote:
	      return this.parseTemplate()
	
	    default:
	      this.unexpected()
	    }
	  }
	
	  pp$3.parseLiteral = function(value) {
	    var node = this.startNode()
	    node.value = value
	    node.raw = this.input.slice(this.start, this.end)
	    this.next()
	    return this.finishNode(node, "Literal")
	  }
	
	  pp$3.parseParenExpression = function() {
	    this.expect(tt.parenL)
	    var val = this.parseExpression()
	    this.expect(tt.parenR)
	    return val
	  }
	
	  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
	    var this$1 = this;
	
	    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8
	    if (this.options.ecmaVersion >= 6) {
	      this.next()
	
	      var innerStartPos = this.start, innerStartLoc = this.startLoc
	      var exprList = [], first = true, lastIsComma = false
	      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart
	      this.yieldPos = 0
	      this.awaitPos = 0
	      while (this.type !== tt.parenR) {
	        first ? first = false : this$1.expect(tt.comma)
	        if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {
	          lastIsComma = true
	          break
	        } else if (this$1.type === tt.ellipsis) {
	          spreadStart = this$1.start
	          exprList.push(this$1.parseParenItem(this$1.parseRest()))
	          if (this$1.type === tt.comma) this$1.raise(this$1.start, "Comma is not permitted after the rest element")
	          break
	        } else {
	          if (this$1.type === tt.parenL && !innerParenStart) {
	            innerParenStart = this$1.start
	          }
	          exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))
	        }
	      }
	      var innerEndPos = this.start, innerEndLoc = this.startLoc
	      this.expect(tt.parenR)
	
	      if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {
	        this.checkPatternErrors(refDestructuringErrors, true)
	        this.checkYieldAwaitInDefaultParams()
	        if (innerParenStart) this.unexpected(innerParenStart)
	        this.yieldPos = oldYieldPos
	        this.awaitPos = oldAwaitPos
	        return this.parseParenArrowList(startPos, startLoc, exprList)
	      }
	
	      if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)
	      if (spreadStart) this.unexpected(spreadStart)
	      this.checkExpressionErrors(refDestructuringErrors, true)
	      this.yieldPos = oldYieldPos || this.yieldPos
	      this.awaitPos = oldAwaitPos || this.awaitPos
	
	      if (exprList.length > 1) {
	        val = this.startNodeAt(innerStartPos, innerStartLoc)
	        val.expressions = exprList
	        this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc)
	      } else {
	        val = exprList[0]
	      }
	    } else {
	      val = this.parseParenExpression()
	    }
	
	    if (this.options.preserveParens) {
	      var par = this.startNodeAt(startPos, startLoc)
	      par.expression = val
	      return this.finishNode(par, "ParenthesizedExpression")
	    } else {
	      return val
	    }
	  }
	
	  pp$3.parseParenItem = function(item) {
	    return item
	  }
	
	  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
	    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
	  }
	
	  // New's precedence is slightly tricky. It must allow its argument to
	  // be a `[]` or dot subscript expression, but not a call  at least,
	  // not without wrapping it in parentheses. Thus, it uses the noCalls
	  // argument to parseSubscripts to prevent it from consuming the
	  // argument list.
	
	  var empty$1 = []
	
	  pp$3.parseNew = function() {
	    var node = this.startNode()
	    var meta = this.parseIdent(true)
	    if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {
	      node.meta = meta
	      node.property = this.parseIdent(true)
	      if (node.property.name !== "target")
	        this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target")
	      if (!this.inFunction)
	        this.raiseRecoverable(node.start, "new.target can only be used in functions")
	      return this.finishNode(node, "MetaProperty")
	    }
	    var startPos = this.start, startLoc = this.startLoc
	    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)
	    if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)
	    else node.arguments = empty$1
	    return this.finishNode(node, "NewExpression")
	  }
	
	  // Parse template expression.
	
	  pp$3.parseTemplateElement = function() {
	    var elem = this.startNode()
	    elem.value = {
	      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, '\n'),
	      cooked: this.value
	    }
	    this.next()
	    elem.tail = this.type === tt.backQuote
	    return this.finishNode(elem, "TemplateElement")
	  }
	
	  pp$3.parseTemplate = function() {
	    var this$1 = this;
	
	    var node = this.startNode()
	    this.next()
	    node.expressions = []
	    var curElt = this.parseTemplateElement()
	    node.quasis = [curElt]
	    while (!curElt.tail) {
	      this$1.expect(tt.dollarBraceL)
	      node.expressions.push(this$1.parseExpression())
	      this$1.expect(tt.braceR)
	      node.quasis.push(curElt = this$1.parseTemplateElement())
	    }
	    this.next()
	    return this.finishNode(node, "TemplateLiteral")
	  }
	
	  // Parse an object literal or binding pattern.
	
	  pp$3.parseObj = function(isPattern, refDestructuringErrors) {
	    var this$1 = this;
	
	    var node = this.startNode(), first = true, propHash = {}
	    node.properties = []
	    this.next()
	    while (!this.eat(tt.braceR)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (this$1.afterTrailingComma(tt.braceR)) break
	      } else first = false
	
	      var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc
	      if (this$1.options.ecmaVersion >= 6) {
	        prop.method = false
	        prop.shorthand = false
	        if (isPattern || refDestructuringErrors) {
	          startPos = this$1.start
	          startLoc = this$1.startLoc
	        }
	        if (!isPattern)
	          isGenerator = this$1.eat(tt.star)
	      }
	      this$1.parsePropertyName(prop)
	      if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&
	          prop.key.type === "Identifier" && prop.key.name === "async" && this$1.type !== tt.parenL &&
	          this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {
	        isAsync = true
	        this$1.parsePropertyName(prop, refDestructuringErrors)
	      } else {
	        isAsync = false
	      }
	      this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)
	      this$1.checkPropClash(prop, propHash)
	      node.properties.push(this$1.finishNode(prop, "Property"))
	    }
	    return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
	  }
	
	  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
	    if ((isGenerator || isAsync) && this.type === tt.colon)
	      this.unexpected()
	
	    if (this.eat(tt.colon)) {
	      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)
	      prop.kind = "init"
	    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {
	      if (isPattern) this.unexpected()
	      prop.kind = "init"
	      prop.method = true
	      prop.value = this.parseMethod(isGenerator, isAsync)
	    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
	               (prop.key.name === "get" || prop.key.name === "set") &&
	               (this.type != tt.comma && this.type != tt.braceR)) {
	      if (isGenerator || isAsync || isPattern) this.unexpected()
	      prop.kind = prop.key.name
	      this.parsePropertyName(prop)
	      prop.value = this.parseMethod(false)
	      var paramCount = prop.kind === "get" ? 0 : 1
	      if (prop.value.params.length !== paramCount) {
	        var start = prop.value.start
	        if (prop.kind === "get")
	          this.raiseRecoverable(start, "getter should have no params")
	        else
	          this.raiseRecoverable(start, "setter should have exactly one param")
	      } else {
	        if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
	          this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params")
	      }
	    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
	      if (this.keywords.test(prop.key.name) ||
	          (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||
	          (this.inGenerator && prop.key.name == "yield") ||
	          (this.inAsync && prop.key.name == "await"))
	        this.raiseRecoverable(prop.key.start, "'" + prop.key.name + "' can not be used as shorthand property")
	      prop.kind = "init"
	      if (isPattern) {
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else if (this.type === tt.eq && refDestructuringErrors) {
	        if (!refDestructuringErrors.shorthandAssign)
	          refDestructuringErrors.shorthandAssign = this.start
	        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)
	      } else {
	        prop.value = prop.key
	      }
	      prop.shorthand = true
	    } else this.unexpected()
	  }
	
	  pp$3.parsePropertyName = function(prop) {
	    if (this.options.ecmaVersion >= 6) {
	      if (this.eat(tt.bracketL)) {
	        prop.computed = true
	        prop.key = this.parseMaybeAssign()
	        this.expect(tt.bracketR)
	        return prop.key
	      } else {
	        prop.computed = false
	      }
	    }
	    return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)
	  }
	
	  // Initialize empty function node.
	
	  pp$3.initFunction = function(node) {
	    node.id = null
	    if (this.options.ecmaVersion >= 6) {
	      node.generator = false
	      node.expression = false
	    }
	    if (this.options.ecmaVersion >= 8)
	      node.async = false
	  }
	
	  // Parse object or class method.
	
	  pp$3.parseMethod = function(isGenerator, isAsync) {
	    var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos
	
	    this.initFunction(node)
	    if (this.options.ecmaVersion >= 6)
	      node.generator = isGenerator
	    if (this.options.ecmaVersion >= 8)
	      node.async = !!isAsync
	
	    this.inGenerator = node.generator
	    this.inAsync = node.async
	    this.yieldPos = 0
	    this.awaitPos = 0
	
	    this.expect(tt.parenL)
	    node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)
	    this.checkYieldAwaitInDefaultParams()
	    this.parseFunctionBody(node, false)
	
	    this.inGenerator = oldInGen
	    this.inAsync = oldInAsync
	    this.yieldPos = oldYieldPos
	    this.awaitPos = oldAwaitPos
	    return this.finishNode(node, "FunctionExpression")
	  }
	
	  // Parse arrow function expression with given parameters.
	
	  pp$3.parseArrowExpression = function(node, params, isAsync) {
	    var oldInGen = this.inGenerator, oldInAsync = this.inAsync, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos
	
	    this.initFunction(node)
	    if (this.options.ecmaVersion >= 8)
	      node.async = !!isAsync
	
	    this.inGenerator = false
	    this.inAsync = node.async
	    this.yieldPos = 0
	    this.awaitPos = 0
	
	    node.params = this.toAssignableList(params, true)
	    this.parseFunctionBody(node, true)
	
	    this.inGenerator = oldInGen
	    this.inAsync = oldInAsync
	    this.yieldPos = oldYieldPos
	    this.awaitPos = oldAwaitPos
	    return this.finishNode(node, "ArrowFunctionExpression")
	  }
	
	  // Parse function body and check parameters.
	
	  pp$3.parseFunctionBody = function(node, isArrowFunction) {
	    var isExpression = isArrowFunction && this.type !== tt.braceL
	
	    if (isExpression) {
	      node.body = this.parseMaybeAssign()
	      node.expression = true
	    } else {
	      // Start a new scope with regard to labels and the `inFunction`
	      // flag (restore them to their old value afterwards).
	      var oldInFunc = this.inFunction, oldLabels = this.labels
	      this.inFunction = true; this.labels = []
	      node.body = this.parseBlock(true)
	      node.expression = false
	      this.inFunction = oldInFunc; this.labels = oldLabels
	    }
	
	    // If this is a strict mode function, verify that argument names
	    // are not repeated, and it does not try to bind the words `eval`
	    // or `arguments`.
	    var useStrict = (!isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) ? node.body.body[0] : null
	    if (useStrict && this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params))
	      this.raiseRecoverable(useStrict.start, "Illegal 'use strict' directive in function with non-simple parameter list")
	
	    if (this.strict || useStrict) {
	      var oldStrict = this.strict
	      this.strict = true
	      if (node.id)
	        this.checkLVal(node.id, true)
	      this.checkParams(node)
	      this.strict = oldStrict
	    } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {
	      this.checkParams(node)
	    }
	  }
	
	  pp$3.isSimpleParamList = function(params) {
	    for (var i = 0; i < params.length; i++)
	      if (params[i].type !== "Identifier") return false
	    return true
	  }
	
	  // Checks function params for various disallowed patterns such as using "eval"
	  // or "arguments" and duplicate parameters.
	
	  pp$3.checkParams = function(node) {
	    var this$1 = this;
	
	    var nameHash = {}
	    for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash)
	  }
	
	  // Parses a comma-separated list of expressions, and returns them as
	  // an array. `close` is the token type that ends the list, and
	  // `allowEmpty` can be turned on to allow subsequent commas with
	  // nothing in between them to be parsed as `null` (which is needed
	  // for array literals).
	
	  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
	    var this$1 = this;
	
	    var elts = [], first = true
	    while (!this.eat(close)) {
	      if (!first) {
	        this$1.expect(tt.comma)
	        if (allowTrailingComma && this$1.afterTrailingComma(close)) break
	      } else first = false
	
	      var elt
	      if (allowEmpty && this$1.type === tt.comma)
	        elt = null
	      else if (this$1.type === tt.ellipsis) {
	        elt = this$1.parseSpread(refDestructuringErrors)
	        if (this$1.type === tt.comma && refDestructuringErrors && !refDestructuringErrors.trailingComma) {
	          refDestructuringErrors.trailingComma = this$1.start
	        }
	      } else
	        elt = this$1.parseMaybeAssign(false, refDestructuringErrors)
	      elts.push(elt)
	    }
	    return elts
	  }
	
	  // Parse the next token as an identifier. If `liberal` is true (used
	  // when parsing properties), it will also convert keywords into
	  // identifiers.
	
	  pp$3.parseIdent = function(liberal) {
	    var node = this.startNode()
	    if (liberal && this.options.allowReserved == "never") liberal = false
	    if (this.type === tt.name) {
	      if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&
	          (this.options.ecmaVersion >= 6 ||
	           this.input.slice(this.start, this.end).indexOf("\\") == -1))
	        this.raiseRecoverable(this.start, "The keyword '" + this.value + "' is reserved")
	      if (this.inGenerator && this.value === "yield")
	        this.raiseRecoverable(this.start, "Can not use 'yield' as identifier inside a generator")
	      if (this.inAsync && this.value === "await")
	        this.raiseRecoverable(this.start, "Can not use 'await' as identifier inside an async function")
	      node.name = this.value
	    } else if (liberal && this.type.keyword) {
	      node.name = this.type.keyword
	    } else {
	      this.unexpected()
	    }
	    this.next()
	    return this.finishNode(node, "Identifier")
	  }
	
	  // Parses yield expression inside generator.
	
	  pp$3.parseYield = function() {
	    if (!this.yieldPos) this.yieldPos = this.start
	
	    var node = this.startNode()
	    this.next()
	    if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {
	      node.delegate = false
	      node.argument = null
	    } else {
	      node.delegate = this.eat(tt.star)
	      node.argument = this.parseMaybeAssign()
	    }
	    return this.finishNode(node, "YieldExpression")
	  }
	
	  pp$3.parseAwait = function() {
	    if (!this.awaitPos) this.awaitPos = this.start
	
	    var node = this.startNode()
	    this.next()
	    node.argument = this.parseMaybeUnary(null, true)
	    return this.finishNode(node, "AwaitExpression")
	  }
	
	  var pp$4 = Parser.prototype
	
	  // This function is used to raise exceptions on parse errors. It
	  // takes an offset integer (into the current `input`) to indicate
	  // the location of the error, attaches the position to the end
	  // of the error message, and then raises a `SyntaxError` with that
	  // message.
	
	  pp$4.raise = function(pos, message) {
	    var loc = getLineInfo(this.input, pos)
	    message += " (" + loc.line + ":" + loc.column + ")"
	    var err = new SyntaxError(message)
	    err.pos = pos; err.loc = loc; err.raisedAt = this.pos
	    throw err
	  }
	
	  pp$4.raiseRecoverable = pp$4.raise
	
	  pp$4.curPosition = function() {
	    if (this.options.locations) {
	      return new Position(this.curLine, this.pos - this.lineStart)
	    }
	  }
	
	  var Node = function Node(parser, pos, loc) {
	    this.type = ""
	    this.start = pos
	    this.end = 0
	    if (parser.options.locations)
	      this.loc = new SourceLocation(parser, loc)
	    if (parser.options.directSourceFile)
	      this.sourceFile = parser.options.directSourceFile
	    if (parser.options.ranges)
	      this.range = [pos, 0]
	  };
	
	  // Start an AST node, attaching a start offset.
	
	  var pp$5 = Parser.prototype
	
	  pp$5.startNode = function() {
	    return new Node(this, this.start, this.startLoc)
	  }
	
	  pp$5.startNodeAt = function(pos, loc) {
	    return new Node(this, pos, loc)
	  }
	
	  // Finish an AST node, adding `type` and `end` properties.
	
	  function finishNodeAt(node, type, pos, loc) {
	    node.type = type
	    node.end = pos
	    if (this.options.locations)
	      node.loc.end = loc
	    if (this.options.ranges)
	      node.range[1] = pos
	    return node
	  }
	
	  pp$5.finishNode = function(node, type) {
	    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
	  }
	
	  // Finish node at given position
	
	  pp$5.finishNodeAt = function(node, type, pos, loc) {
	    return finishNodeAt.call(this, node, type, pos, loc)
	  }
	
	  var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
	    this.token = token
	    this.isExpr = !!isExpr
	    this.preserveSpace = !!preserveSpace
	    this.override = override
	  };
	
	  var types = {
	    b_stat: new TokContext("{", false),
	    b_expr: new TokContext("{", true),
	    b_tmpl: new TokContext("${", true),
	    p_stat: new TokContext("(", false),
	    p_expr: new TokContext("(", true),
	    q_tmpl: new TokContext("`", true, true, function (p) { return p.readTmplToken(); }),
	    f_expr: new TokContext("function", true)
	  }
	
	  var pp$6 = Parser.prototype
	
	  pp$6.initialContext = function() {
	    return [types.b_stat]
	  }
	
	  pp$6.braceIsBlock = function(prevType) {
	    if (prevType === tt.colon) {
	      var parent = this.curContext()
	      if (parent === types.b_stat || parent === types.b_expr)
	        return !parent.isExpr
	    }
	    if (prevType === tt._return)
	      return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
	    if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)
	      return true
	    if (prevType == tt.braceL)
	      return this.curContext() === types.b_stat
	    return !this.exprAllowed
	  }
	
	  pp$6.updateContext = function(prevType) {
	    var update, type = this.type
	    if (type.keyword && prevType == tt.dot)
	      this.exprAllowed = false
	    else if (update = type.updateContext)
	      update.call(this, prevType)
	    else
	      this.exprAllowed = type.beforeExpr
	  }
	
	  // Token-specific context update code
	
	  tt.parenR.updateContext = tt.braceR.updateContext = function() {
	    if (this.context.length == 1) {
	      this.exprAllowed = true
	      return
	    }
	    var out = this.context.pop()
	    if (out === types.b_stat && this.curContext() === types.f_expr) {
	      this.context.pop()
	      this.exprAllowed = false
	    } else if (out === types.b_tmpl) {
	      this.exprAllowed = true
	    } else {
	      this.exprAllowed = !out.isExpr
	    }
	  }
	
	  tt.braceL.updateContext = function(prevType) {
	    this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)
	    this.exprAllowed = true
	  }
	
	  tt.dollarBraceL.updateContext = function() {
	    this.context.push(types.b_tmpl)
	    this.exprAllowed = true
	  }
	
	  tt.parenL.updateContext = function(prevType) {
	    var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while
	    this.context.push(statementParens ? types.p_stat : types.p_expr)
	    this.exprAllowed = true
	  }
	
	  tt.incDec.updateContext = function() {
	    // tokExprAllowed stays unchanged
	  }
	
	  tt._function.updateContext = function(prevType) {
	    if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&
	        !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))
	      this.context.push(types.f_expr)
	    this.exprAllowed = false
	  }
	
	  tt.backQuote.updateContext = function() {
	    if (this.curContext() === types.q_tmpl)
	      this.context.pop()
	    else
	      this.context.push(types.q_tmpl)
	    this.exprAllowed = false
	  }
	
	  // Object type used to represent tokens. Note that normally, tokens
	  // simply exist as properties on the parser object. This is only
	  // used for the onToken callback and the external tokenizer.
	
	  var Token = function Token(p) {
	    this.type = p.type
	    this.value = p.value
	    this.start = p.start
	    this.end = p.end
	    if (p.options.locations)
	      this.loc = new SourceLocation(p, p.startLoc, p.endLoc)
	    if (p.options.ranges)
	      this.range = [p.start, p.end]
	  };
	
	  // ## Tokenizer
	
	  var pp$7 = Parser.prototype
	
	  // Are we running under Rhino?
	  var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]"
	
	  // Move to the next token
	
	  pp$7.next = function() {
	    if (this.options.onToken)
	      this.options.onToken(new Token(this))
	
	    this.lastTokEnd = this.end
	    this.lastTokStart = this.start
	    this.lastTokEndLoc = this.endLoc
	    this.lastTokStartLoc = this.startLoc
	    this.nextToken()
	  }
	
	  pp$7.getToken = function() {
	    this.next()
	    return new Token(this)
	  }
	
	  // If we're in an ES6 environment, make parsers iterable
	  if (typeof Symbol !== "undefined")
	    pp$7[Symbol.iterator] = function () {
	      var self = this
	      return {next: function () {
	        var token = self.getToken()
	        return {
	          done: token.type === tt.eof,
	          value: token
	        }
	      }}
	    }
	
	  // Toggle strict mode. Re-reads the next number or string to please
	  // pedantic tests (`"use strict"; 010;` should fail).
	
	  pp$7.setStrict = function(strict) {
	    var this$1 = this;
	
	    this.strict = strict
	    if (this.type !== tt.num && this.type !== tt.string) return
	    this.pos = this.start
	    if (this.options.locations) {
	      while (this.pos < this.lineStart) {
	        this$1.lineStart = this$1.input.lastIndexOf("\n", this$1.lineStart - 2) + 1
	        --this$1.curLine
	      }
	    }
	    this.nextToken()
	  }
	
	  pp$7.curContext = function() {
	    return this.context[this.context.length - 1]
	  }
	
	  // Read a single token, updating the parser object's token-related
	  // properties.
	
	  pp$7.nextToken = function() {
	    var curContext = this.curContext()
	    if (!curContext || !curContext.preserveSpace) this.skipSpace()
	
	    this.start = this.pos
	    if (this.options.locations) this.startLoc = this.curPosition()
	    if (this.pos >= this.input.length) return this.finishToken(tt.eof)
	
	    if (curContext.override) return curContext.override(this)
	    else this.readToken(this.fullCharCodeAtPos())
	  }
	
	  pp$7.readToken = function(code) {
	    // Identifier or keyword. '\uXXXX' sequences are allowed in
	    // identifiers, so '\' also dispatches to that.
	    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
	      return this.readWord()
	
	    return this.getTokenFromCode(code)
	  }
	
	  pp$7.fullCharCodeAtPos = function() {
	    var code = this.input.charCodeAt(this.pos)
	    if (code <= 0xd7ff || code >= 0xe000) return code
	    var next = this.input.charCodeAt(this.pos + 1)
	    return (code << 10) + next - 0x35fdc00
	  }
	
	  pp$7.skipBlockComment = function() {
	    var this$1 = this;
	
	    var startLoc = this.options.onComment && this.curPosition()
	    var start = this.pos, end = this.input.indexOf("*/", this.pos += 2)
	    if (end === -1) this.raise(this.pos - 2, "Unterminated comment")
	    this.pos = end + 2
	    if (this.options.locations) {
	      lineBreakG.lastIndex = start
	      var match
	      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
	        ++this$1.curLine
	        this$1.lineStart = match.index + match[0].length
	      }
	    }
	    if (this.options.onComment)
	      this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  pp$7.skipLineComment = function(startSkip) {
	    var this$1 = this;
	
	    var start = this.pos
	    var startLoc = this.options.onComment && this.curPosition()
	    var ch = this.input.charCodeAt(this.pos+=startSkip)
	    while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
	      ++this$1.pos
	      ch = this$1.input.charCodeAt(this$1.pos)
	    }
	    if (this.options.onComment)
	      this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
	                             startLoc, this.curPosition())
	  }
	
	  // Called at the start of the parse and after every token. Skips
	  // whitespace and comments, and.
	
	  pp$7.skipSpace = function() {
	    var this$1 = this;
	
	    loop: while (this.pos < this.input.length) {
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      switch (ch) {
	        case 32: case 160: // ' '
	          ++this$1.pos
	          break
	        case 13:
	          if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
	            ++this$1.pos
	          }
	        case 10: case 8232: case 8233:
	          ++this$1.pos
	          if (this$1.options.locations) {
	            ++this$1.curLine
	            this$1.lineStart = this$1.pos
	          }
	          break
	        case 47: // '/'
	          switch (this$1.input.charCodeAt(this$1.pos + 1)) {
	            case 42: // '*'
	              this$1.skipBlockComment()
	              break
	            case 47:
	              this$1.skipLineComment(2)
	              break
	            default:
	              break loop
	          }
	          break
	        default:
	          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
	            ++this$1.pos
	          } else {
	            break loop
	          }
	      }
	    }
	  }
	
	  // Called at the end of every token. Sets `end`, `val`, and
	  // maintains `context` and `exprAllowed`, and skips the space after
	  // the token, so that the next one's `start` will point at the
	  // right position.
	
	  pp$7.finishToken = function(type, val) {
	    this.end = this.pos
	    if (this.options.locations) this.endLoc = this.curPosition()
	    var prevType = this.type
	    this.type = type
	    this.value = val
	
	    this.updateContext(prevType)
	  }
	
	  // ### Token reading
	
	  // This is the function that is called to fetch the next token. It
	  // is somewhat obscure, because it works in character codes rather
	  // than characters, and because operator parsing has been inlined
	  // into it.
	  //
	  // All in the name of speed.
	  //
	  pp$7.readToken_dot = function() {
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next >= 48 && next <= 57) return this.readNumber(true)
	    var next2 = this.input.charCodeAt(this.pos + 2)
	    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
	      this.pos += 3
	      return this.finishToken(tt.ellipsis)
	    } else {
	      ++this.pos
	      return this.finishToken(tt.dot)
	    }
	  }
	
	  pp$7.readToken_slash = function() { // '/'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (this.exprAllowed) {++this.pos; return this.readRegexp()}
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.slash, 1)
	  }
	
	  pp$7.readToken_mult_modulo_exp = function(code) { // '%*'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    var tokentype = code === 42 ? tt.star : tt.modulo
	
	    // exponentiation operator ** and **=
	    if (this.options.ecmaVersion >= 7 && next === 42) {
	      ++size
	      tokentype = tt.starstar
	      next = this.input.charCodeAt(this.pos + 2)
	    }
	
	    if (next === 61) return this.finishOp(tt.assign, size + 1)
	    return this.finishOp(tokentype, size)
	  }
	
	  pp$7.readToken_pipe_amp = function(code) { // '|&'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)
	  }
	
	  pp$7.readToken_caret = function() { // '^'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.bitwiseXOR, 1)
	  }
	
	  pp$7.readToken_plus_min = function(code) { // '+-'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === code) {
	      if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&
	          lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {
	        // A `-->` line comment
	        this.skipLineComment(3)
	        this.skipSpace()
	        return this.nextToken()
	      }
	      return this.finishOp(tt.incDec, 2)
	    }
	    if (next === 61) return this.finishOp(tt.assign, 2)
	    return this.finishOp(tt.plusMin, 1)
	  }
	
	  pp$7.readToken_lt_gt = function(code) { // '<>'
	    var next = this.input.charCodeAt(this.pos + 1)
	    var size = 1
	    if (next === code) {
	      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2
	      if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)
	      return this.finishOp(tt.bitShift, size)
	    }
	    if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&
	        this.input.charCodeAt(this.pos + 3) == 45) {
	      if (this.inModule) this.unexpected()
	      // `<!--`, an XML-style comment that should be interpreted as a line comment
	      this.skipLineComment(4)
	      this.skipSpace()
	      return this.nextToken()
	    }
	    if (next === 61) size = 2
	    return this.finishOp(tt.relational, size)
	  }
	
	  pp$7.readToken_eq_excl = function(code) { // '=!'
	    var next = this.input.charCodeAt(this.pos + 1)
	    if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)
	    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
	      this.pos += 2
	      return this.finishToken(tt.arrow)
	    }
	    return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)
	  }
	
	  pp$7.getTokenFromCode = function(code) {
	    switch (code) {
	      // The interpretation of a dot depends on whether it is followed
	      // by a digit or another two dots.
	    case 46: // '.'
	      return this.readToken_dot()
	
	      // Punctuation tokens.
	    case 40: ++this.pos; return this.finishToken(tt.parenL)
	    case 41: ++this.pos; return this.finishToken(tt.parenR)
	    case 59: ++this.pos; return this.finishToken(tt.semi)
	    case 44: ++this.pos; return this.finishToken(tt.comma)
	    case 91: ++this.pos; return this.finishToken(tt.bracketL)
	    case 93: ++this.pos; return this.finishToken(tt.bracketR)
	    case 123: ++this.pos; return this.finishToken(tt.braceL)
	    case 125: ++this.pos; return this.finishToken(tt.braceR)
	    case 58: ++this.pos; return this.finishToken(tt.colon)
	    case 63: ++this.pos; return this.finishToken(tt.question)
	
	    case 96: // '`'
	      if (this.options.ecmaVersion < 6) break
	      ++this.pos
	      return this.finishToken(tt.backQuote)
	
	    case 48: // '0'
	      var next = this.input.charCodeAt(this.pos + 1)
	      if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number
	      if (this.options.ecmaVersion >= 6) {
	        if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number
	        if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number
	      }
	      // Anything else beginning with a digit is an integer, octal
	      // number, or float.
	    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
	      return this.readNumber(false)
	
	      // Quotes produce strings.
	    case 34: case 39: // '"', "'"
	      return this.readString(code)
	
	      // Operators are parsed inline in tiny state machines. '=' (61) is
	      // often referred to. `finishOp` simply skips the amount of
	      // characters it is given as second argument, and returns a token
	      // of the type given by its first argument.
	
	    case 47: // '/'
	      return this.readToken_slash()
	
	    case 37: case 42: // '%*'
	      return this.readToken_mult_modulo_exp(code)
	
	    case 124: case 38: // '|&'
	      return this.readToken_pipe_amp(code)
	
	    case 94: // '^'
	      return this.readToken_caret()
	
	    case 43: case 45: // '+-'
	      return this.readToken_plus_min(code)
	
	    case 60: case 62: // '<>'
	      return this.readToken_lt_gt(code)
	
	    case 61: case 33: // '=!'
	      return this.readToken_eq_excl(code)
	
	    case 126: // '~'
	      return this.finishOp(tt.prefix, 1)
	    }
	
	    this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'")
	  }
	
	  pp$7.finishOp = function(type, size) {
	    var str = this.input.slice(this.pos, this.pos + size)
	    this.pos += size
	    return this.finishToken(type, str)
	  }
	
	  // Parse a regular expression. Some context-awareness is necessary,
	  // since a '/' inside a '[]' set does not end the expression.
	
	  function tryCreateRegexp(src, flags, throwErrorAt, parser) {
	    try {
	      return new RegExp(src, flags)
	    } catch (e) {
	      if (throwErrorAt !== undefined) {
	        if (e instanceof SyntaxError) parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message)
	        throw e
	      }
	    }
	  }
	
	  var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u")
	
	  pp$7.readRegexp = function() {
	    var this$1 = this;
	
	    var escaped, inClass, start = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(start, "Unterminated regular expression")
	      var ch = this$1.input.charAt(this$1.pos)
	      if (lineBreak.test(ch)) this$1.raise(start, "Unterminated regular expression")
	      if (!escaped) {
	        if (ch === "[") inClass = true
	        else if (ch === "]" && inClass) inClass = false
	        else if (ch === "/" && !inClass) break
	        escaped = ch === "\\"
	      } else escaped = false
	      ++this$1.pos
	    }
	    var content = this.input.slice(start, this.pos)
	    ++this.pos
	    // Need to use `readWord1` because '\uXXXX' sequences are allowed
	    // here (don't ask).
	    var mods = this.readWord1()
	    var tmp = content, tmpFlags = ""
	    if (mods) {
	      var validFlags = /^[gim]*$/
	      if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/
	      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag")
	      if (mods.indexOf("u") >= 0) {
	        if (regexpUnicodeSupport) {
	          tmpFlags = "u"
	        } else {
	          // Replace each astral symbol and every Unicode escape sequence that
	          // possibly represents an astral symbol or a paired surrogate with a
	          // single ASCII symbol to avoid throwing on regular expressions that
	          // are only valid in combination with the `/u` flag.
	          // Note: replacing with the ASCII symbol `x` might cause false
	          // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
	          // perfectly valid pattern that is equivalent to `[a-b]`, but it would
	          // be replaced by `[x-b]` which throws an error.
	          tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
	            code = Number("0x" + code)
	            if (code > 0x10FFFF) this$1.raise(start + offset + 3, "Code point out of bounds")
	            return "x"
	          })
	          tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x")
	          tmpFlags = tmpFlags.replace("u", "")
	        }
	      }
	    }
	    // Detect invalid regular expressions.
	    var value = null
	    // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
	    // so don't do detection if we are running under Rhino
	    if (!isRhino) {
	      tryCreateRegexp(tmp, tmpFlags, start, this)
	      // Get a regular expression object for this pattern-flag pair, or `null` in
	      // case the current environment doesn't support the flags it uses.
	      value = tryCreateRegexp(content, mods)
	    }
	    return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})
	  }
	
	  // Read an integer in the given radix. Return null if zero digits
	  // were read, the integer value otherwise. When `len` is given, this
	  // will return `null` unless the integer has exactly `len` digits.
	
	  pp$7.readInt = function(radix, len) {
	    var this$1 = this;
	
	    var start = this.pos, total = 0
	    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
	      var code = this$1.input.charCodeAt(this$1.pos), val
	      if (code >= 97) val = code - 97 + 10 // a
	      else if (code >= 65) val = code - 65 + 10 // A
	      else if (code >= 48 && code <= 57) val = code - 48 // 0-9
	      else val = Infinity
	      if (val >= radix) break
	      ++this$1.pos
	      total = total * radix + val
	    }
	    if (this.pos === start || len != null && this.pos - start !== len) return null
	
	    return total
	  }
	
	  pp$7.readRadixNumber = function(radix) {
	    this.pos += 2 // 0x
	    var val = this.readInt(radix)
	    if (val == null) this.raise(this.start + 2, "Expected number in radix " + radix)
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read an integer, octal integer, or floating-point number.
	
	  pp$7.readNumber = function(startsWithDot) {
	    var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48
	    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number")
	    if (octal && this.pos == start + 1) octal = false
	    var next = this.input.charCodeAt(this.pos)
	    if (next === 46 && !octal) { // '.'
	      ++this.pos
	      this.readInt(10)
	      isFloat = true
	      next = this.input.charCodeAt(this.pos)
	    }
	    if ((next === 69 || next === 101) && !octal) { // 'eE'
	      next = this.input.charCodeAt(++this.pos)
	      if (next === 43 || next === 45) ++this.pos // '+-'
	      if (this.readInt(10) === null) this.raise(start, "Invalid number")
	      isFloat = true
	    }
	    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, "Identifier directly after number")
	
	    var str = this.input.slice(start, this.pos), val
	    if (isFloat) val = parseFloat(str)
	    else if (!octal || str.length === 1) val = parseInt(str, 10)
	    else if (/[89]/.test(str) || this.strict) this.raise(start, "Invalid number")
	    else val = parseInt(str, 8)
	    return this.finishToken(tt.num, val)
	  }
	
	  // Read a string value, interpreting backslash-escapes.
	
	  pp$7.readCodePoint = function() {
	    var ch = this.input.charCodeAt(this.pos), code
	
	    if (ch === 123) {
	      if (this.options.ecmaVersion < 6) this.unexpected()
	      var codePos = ++this.pos
	      code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)
	      ++this.pos
	      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds")
	    } else {
	      code = this.readHexChar(4)
	    }
	    return code
	  }
	
	  function codePointToString(code) {
	    // UTF-16 Decoding
	    if (code <= 0xFFFF) return String.fromCharCode(code)
	    code -= 0x10000
	    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
	  }
	
	  pp$7.readString = function(quote) {
	    var this$1 = this;
	
	    var out = "", chunkStart = ++this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated string constant")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === quote) break
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(false)
	        chunkStart = this$1.pos
	      } else {
	        if (isNewLine(ch)) this$1.raise(this$1.start, "Unterminated string constant")
	        ++this$1.pos
	      }
	    }
	    out += this.input.slice(chunkStart, this.pos++)
	    return this.finishToken(tt.string, out)
	  }
	
	  // Reads template string tokens.
	
	  pp$7.readTmplToken = function() {
	    var this$1 = this;
	
	    var out = "", chunkStart = this.pos
	    for (;;) {
	      if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, "Unterminated template")
	      var ch = this$1.input.charCodeAt(this$1.pos)
	      if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
	        if (this$1.pos === this$1.start && this$1.type === tt.template) {
	          if (ch === 36) {
	            this$1.pos += 2
	            return this$1.finishToken(tt.dollarBraceL)
	          } else {
	            ++this$1.pos
	            return this$1.finishToken(tt.backQuote)
	          }
	        }
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        return this$1.finishToken(tt.template, out)
	      }
	      if (ch === 92) { // '\'
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        out += this$1.readEscapedChar(true)
	        chunkStart = this$1.pos
	      } else if (isNewLine(ch)) {
	        out += this$1.input.slice(chunkStart, this$1.pos)
	        ++this$1.pos
	        switch (ch) {
	          case 13:
	            if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos
	          case 10:
	            out += "\n"
	            break
	          default:
	            out += String.fromCharCode(ch)
	            break
	        }
	        if (this$1.options.locations) {
	          ++this$1.curLine
	          this$1.lineStart = this$1.pos
	        }
	        chunkStart = this$1.pos
	      } else {
	        ++this$1.pos
	      }
	    }
	  }
	
	  // Used to read escaped characters
	
	  pp$7.readEscapedChar = function(inTemplate) {
	    var ch = this.input.charCodeAt(++this.pos)
	    ++this.pos
	    switch (ch) {
	    case 110: return "\n" // 'n' -> '\n'
	    case 114: return "\r" // 'r' -> '\r'
	    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
	    case 117: return codePointToString(this.readCodePoint()) // 'u'
	    case 116: return "\t" // 't' -> '\t'
	    case 98: return "\b" // 'b' -> '\b'
	    case 118: return "\u000b" // 'v' -> '\u000b'
	    case 102: return "\f" // 'f' -> '\f'
	    case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\r\n'
	    case 10: // ' \n'
	      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }
	      return ""
	    default:
	      if (ch >= 48 && ch <= 55) {
	        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]
	        var octal = parseInt(octalStr, 8)
	        if (octal > 255) {
	          octalStr = octalStr.slice(0, -1)
	          octal = parseInt(octalStr, 8)
	        }
	        if (octalStr !== "0" && (this.strict || inTemplate)) {
	          this.raise(this.pos - 2, "Octal literal in strict mode")
	        }
	        this.pos += octalStr.length - 1
	        return String.fromCharCode(octal)
	      }
	      return String.fromCharCode(ch)
	    }
	  }
	
	  // Used to read character escape sequences ('\x', '\u', '\U').
	
	  pp$7.readHexChar = function(len) {
	    var codePos = this.pos
	    var n = this.readInt(16, len)
	    if (n === null) this.raise(codePos, "Bad character escape sequence")
	    return n
	  }
	
	  // Read an identifier, and return it as a string. Sets `this.containsEsc`
	  // to whether the word contained a '\u' escape.
	  //
	  // Incrementally adds only escaped chars, adding other chunks as-is
	  // as a micro-optimization.
	
	  pp$7.readWord1 = function() {
	    var this$1 = this;
	
	    this.containsEsc = false
	    var word = "", first = true, chunkStart = this.pos
	    var astral = this.options.ecmaVersion >= 6
	    while (this.pos < this.input.length) {
	      var ch = this$1.fullCharCodeAtPos()
	      if (isIdentifierChar(ch, astral)) {
	        this$1.pos += ch <= 0xffff ? 1 : 2
	      } else if (ch === 92) { // "\"
	        this$1.containsEsc = true
	        word += this$1.input.slice(chunkStart, this$1.pos)
	        var escStart = this$1.pos
	        if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
	          this$1.raise(this$1.pos, "Expecting Unicode escape sequence \\uXXXX")
	        ++this$1.pos
	        var esc = this$1.readCodePoint()
	        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
	          this$1.raise(escStart, "Invalid Unicode escape")
	        word += codePointToString(esc)
	        chunkStart = this$1.pos
	      } else {
	        break
	      }
	      first = false
	    }
	    return word + this.input.slice(chunkStart, this.pos)
	  }
	
	  // Read an identifier or keyword token. Will check for reserved
	  // words when necessary.
	
	  pp$7.readWord = function() {
	    var word = this.readWord1()
	    var type = tt.name
	    if ((this.options.ecmaVersion >= 6 || !this.containsEsc) && this.keywords.test(word))
	      type = keywordTypes[word]
	    return this.finishToken(type, word)
	  }
	
	  var version = "4.0.3"
	
	  // The main exported interface (under `self.acorn` when in the
	  // browser) is a `parse` function that takes a code string and
	  // returns an abstract syntax tree as specified by [Mozilla parser
	  // API][api].
	  //
	  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API
	
	  function parse(input, options) {
	    return new Parser(options, input).parse()
	  }
	
	  // This function tries to parse a single expression at a given
	  // offset in a string. Useful for parsing mixed-language formats
	  // that embed JavaScript expressions.
	
	  function parseExpressionAt(input, pos, options) {
	    var p = new Parser(options, input, pos)
	    p.nextToken()
	    return p.parseExpression()
	  }
	
	  // Acorn is organized as a tokenizer and a recursive-descent parser.
	  // The `tokenizer` export provides an interface to the tokenizer.
	
	  function tokenizer(input, options) {
	    return new Parser(options, input)
	  }
	
	  // This is a terrible kludge to support the existing, pre-ES6
	  // interface where the loose parser module retroactively adds exports
	  // to this module.
	  function addLooseExports(parse, Parser, plugins) {
	    exports.parse_dammit = parse
	    exports.LooseParser = Parser
	    exports.pluginsLoose = plugins
	  }
	
	  exports.version = version;
	  exports.parse = parse;
	  exports.parseExpressionAt = parseExpressionAt;
	  exports.tokenizer = tokenizer;
	  exports.addLooseExports = addLooseExports;
	  exports.Parser = Parser;
	  exports.plugins = plugins;
	  exports.defaultOptions = defaultOptions;
	  exports.Position = Position;
	  exports.SourceLocation = SourceLocation;
	  exports.getLineInfo = getLineInfo;
	  exports.Node = Node;
	  exports.TokenType = TokenType;
	  exports.tokTypes = tt;
	  exports.TokContext = TokContext;
	  exports.tokContexts = types;
	  exports.isIdentifierChar = isIdentifierChar;
	  exports.isIdentifierStart = isIdentifierStart;
	  exports.Token = Token;
	  exports.isNewLine = isNewLine;
	  exports.lineBreak = lineBreak;
	  exports.lineBreakG = lineBreakG;
	
	  Object.defineProperty(exports, '__esModule', { value: true });
	
	}));

/***/ },
/* 237 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "espree",
					"scope": null,
					"escapedName": "espree",
					"name": "espree",
					"rawSpec": "",
					"spec": "latest",
					"type": "tag"
				},
				"/home/joe/prog/googlejs-site"
			]
		],
		"_from": "espree@latest",
		"_id": "espree@3.3.2",
		"_inCache": true,
		"_location": "/espree",
		"_nodeVersion": "4.4.7",
		"_npmOperationalInternal": {
			"host": "packages-16-east.internal.npmjs.com",
			"tmp": "tmp/espree-3.3.2.tgz_1475184001667_0.6324210215825588"
		},
		"_npmUser": {
			"name": "eslint",
			"email": "nicholas+eslint@nczconsulting.com"
		},
		"_npmVersion": "2.15.8",
		"_phantomChildren": {},
		"_requested": {
			"raw": "espree",
			"scope": null,
			"escapedName": "espree",
			"name": "espree",
			"rawSpec": "",
			"spec": "latest",
			"type": "tag"
		},
		"_requiredBy": [
			"#USER",
			"/",
			"/eslint"
		],
		"_resolved": "https://registry.npmjs.org/espree/-/espree-3.3.2.tgz",
		"_shasum": "dbf3fadeb4ecb4d4778303e50103b3d36c88b89c",
		"_shrinkwrap": null,
		"_spec": "espree",
		"_where": "/home/joe/prog/googlejs-site",
		"author": {
			"name": "Nicholas C. Zakas",
			"email": "nicholas+npm@nczconsulting.com"
		},
		"bugs": {
			"url": "http://github.com/eslint/espree.git"
		},
		"dependencies": {
			"acorn": "^4.0.1",
			"acorn-jsx": "^3.0.0"
		},
		"description": "An Esprima-compatible JavaScript parser built on Acorn",
		"devDependencies": {
			"browserify": "^7.0.0",
			"chai": "^1.10.0",
			"eslint": "^2.0.0-beta.1",
			"eslint-config-eslint": "^3.0.0",
			"eslint-release": "^0.10.0",
			"esprima": "latest",
			"esprima-fb": "^8001.2001.0-dev-harmony-fb",
			"istanbul": "~0.2.6",
			"json-diff": "~0.3.1",
			"leche": "^1.0.1",
			"mocha": "^2.0.1",
			"regenerate": "~0.5.4",
			"shelljs": "^0.3.0",
			"shelljs-nodecli": "^0.1.1",
			"unicode-6.3.0": "~0.1.0"
		},
		"directories": {},
		"dist": {
			"shasum": "dbf3fadeb4ecb4d4778303e50103b3d36c88b89c",
			"tarball": "https://registry.npmjs.org/espree/-/espree-3.3.2.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"files": [
			"lib",
			"espree.js"
		],
		"gitHead": "c8ca13a205ecd3572045872cd0471e174a060281",
		"homepage": "https://github.com/eslint/espree",
		"keywords": [
			"ast",
			"ecmascript",
			"javascript",
			"parser",
			"syntax",
			"acorn"
		],
		"license": "BSD-2-Clause",
		"main": "espree.js",
		"maintainers": [
			{
				"name": "eslint",
				"email": "nicholas+eslint@nczconsulting.com"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "espree",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/eslint/espree.git"
		},
		"scripts": {
			"alpharelease": "eslint-prelease alpha",
			"betarelease": "eslint-prelease beta",
			"browserify": "node Makefile.js browserify",
			"ci-release": "eslint-ci-release",
			"generate-regex": "node tools/generate-identifier-regex.js",
			"gh-release": "eslint-gh-release",
			"lint": "node Makefile.js lint",
			"release": "eslint-release",
			"test": "npm run-script lint && node Makefile.js test"
		},
		"version": "3.3.2"
	};

/***/ },
/* 238 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The visitor keys for the node types Espree supports
	 * @author Nicholas C. Zakas
	 *
	 * This file contains code from estraverse-fb.
	 *
	 * The MIT license. Copyright (c) 2014 Ingvar Stepanyan
	 *
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 *
	 * The above copyright notice and this permission notice shall be included in all
	 * copies or substantial portions of the Software.
	 *
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	 * SOFTWARE.
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	// None!
	
	//------------------------------------------------------------------------------
	// Public
	//------------------------------------------------------------------------------
	
	module.exports = {
	
	    // ECMAScript
	    AssignmentExpression: ["left", "right"],
	    AssignmentPattern: ["left", "right"],
	    ArrayExpression: ["elements"],
	    ArrayPattern: ["elements"],
	    ArrowFunctionExpression: ["params", "body"],
	    BlockStatement: ["body"],
	    BinaryExpression: ["left", "right"],
	    BreakStatement: ["label"],
	    CallExpression: ["callee", "arguments"],
	    CatchClause: ["param", "body"],
	    ClassBody: ["body"],
	    ClassDeclaration: ["id", "superClass", "body"],
	    ClassExpression: ["id", "superClass", "body"],
	    ConditionalExpression: ["test", "consequent", "alternate"],
	    ContinueStatement: ["label"],
	    DebuggerStatement: [],
	    DirectiveStatement: [],
	    DoWhileStatement: ["body", "test"],
	    EmptyStatement: [],
	    ExportAllDeclaration: ["source"],
	    ExportDefaultDeclaration: ["declaration"],
	    ExportNamedDeclaration: ["declaration", "specifiers", "source"],
	    ExportSpecifier: ["exported", "local"],
	    ExpressionStatement: ["expression"],
	    ForStatement: ["init", "test", "update", "body"],
	    ForInStatement: ["left", "right", "body"],
	    ForOfStatement: ["left", "right", "body"],
	    FunctionDeclaration: ["id", "params", "body"],
	    FunctionExpression: ["id", "params", "body"],
	    Identifier: [],
	    IfStatement: ["test", "consequent", "alternate"],
	    ImportDeclaration: ["specifiers", "source"],
	    ImportDefaultSpecifier: ["local"],
	    ImportNamespaceSpecifier: ["local"],
	    ImportSpecifier: ["imported", "local"],
	    Literal: [],
	    LabeledStatement: ["label", "body"],
	    LogicalExpression: ["left", "right"],
	    MemberExpression: ["object", "property"],
	    MetaProperty: ["meta", "property"],
	    MethodDefinition: ["key", "value"],
	    ModuleSpecifier: [],
	    NewExpression: ["callee", "arguments"],
	    ObjectExpression: ["properties"],
	    ObjectPattern: ["properties"],
	    Program: ["body"],
	    Property: ["key", "value"],
	    RestElement: [ "argument" ],
	    ReturnStatement: ["argument"],
	    SequenceExpression: ["expressions"],
	    SpreadElement: ["argument"],
	    Super: [],
	    SwitchStatement: ["discriminant", "cases"],
	    SwitchCase: ["test", "consequent"],
	    TaggedTemplateExpression: ["tag", "quasi"],
	    TemplateElement: [],
	    TemplateLiteral: ["quasis", "expressions"],
	    ThisExpression: [],
	    ThrowStatement: ["argument"],
	    TryStatement: ["block", "handler", "finalizer"],
	    UnaryExpression: ["argument"],
	    UpdateExpression: ["argument"],
	    VariableDeclaration: ["declarations"],
	    VariableDeclarator: ["id", "init"],
	    WhileStatement: ["test", "body"],
	    WithStatement: ["object", "body"],
	    YieldExpression: ["argument"],
	
	    // JSX
	    JSXIdentifier: [],
	    JSXNamespacedName: ["namespace", "name"],
	    JSXMemberExpression: ["object", "property"],
	    JSXEmptyExpression: [],
	    JSXExpressionContainer: ["expression"],
	    JSXElement: ["openingElement", "closingElement", "children"],
	    JSXClosingElement: ["name"],
	    JSXOpeningElement: ["name", "attributes"],
	    JSXAttribute: ["name", "value"],
	    JSXText: null,
	    JSXSpreadAttribute: ["argument"],
	
	    // Experimental features
	    ExperimentalRestProperty: ["argument"],
	    ExperimentalSpreadProperty: ["argument"]
	};


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow `this` keywords outside of classes or class-like objects.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `this` keywords outside of classes or class-like objects",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const stack = [],
	            sourceCode = context.getSourceCode();
	
	        /**
	         * Gets the current checking context.
	         *
	         * The return value has a flag that whether or not `this` keyword is valid.
	         * The flag is initialized when got at the first time.
	         *
	         * @returns {{valid: boolean}}
	         *   an object which has a flag that whether or not `this` keyword is valid.
	         */
	        stack.getCurrent = function() {
	            const current = this[this.length - 1];
	
	            if (!current.init) {
	                current.init = true;
	                current.valid = !astUtils.isDefaultThisBinding(
	                    current.node,
	                    sourceCode);
	            }
	            return current;
	        };
	
	        /**
	         * Pushs new checking context into the stack.
	         *
	         * The checking context is not initialized yet.
	         * Because most functions don't have `this` keyword.
	         * When `this` keyword was found, the checking context is initialized.
	         *
	         * @param {ASTNode} node - A function node that was entered.
	         * @returns {void}
	         */
	        function enterFunction(node) {
	
	            // `this` can be invalid only under strict mode.
	            stack.push({
	                init: !context.getScope().isStrict,
	                node,
	                valid: true
	            });
	        }
	
	        /**
	         * Pops the current checking context from the stack.
	         * @returns {void}
	         */
	        function exitFunction() {
	            stack.pop();
	        }
	
	        return {
	
	            /*
	             * `this` is invalid only under strict mode.
	             * Modules is always strict mode.
	             */
	            Program(node) {
	                const scope = context.getScope(),
	                    features = context.parserOptions.ecmaFeatures || {};
	
	                stack.push({
	                    init: true,
	                    node,
	                    valid: !(
	                        scope.isStrict ||
	                        node.sourceType === "module" ||
	                        (features.globalReturn && scope.childScopes[0].isStrict)
	                    )
	                });
	            },
	
	            "Program:exit"() {
	                stack.pop();
	            },
	
	            FunctionDeclaration: enterFunction,
	            "FunctionDeclaration:exit": exitFunction,
	            FunctionExpression: enterFunction,
	            "FunctionExpression:exit": exitFunction,
	
	            // Reports if `this` of the current context is invalid.
	            ThisExpression(node) {
	                const current = stack.getCurrent();
	
	                if (current && !current.valid) {
	                    context.report(node, "Unexpected 'this'.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 240 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed
	 * @author Jonathan Kingston
	 * @author Christophe Porteneuve
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const ALL_IRREGULARS = /[\f\v\u0085\u00A0\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/;
	const IRREGULAR_WHITESPACE = /[\f\v\u0085\u00A0\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mg;
	const IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mg;
	const LINE_BREAK = /\r\n|\r|\n|\u2028|\u2029/g;
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow irregular whitespace outside of strings and comments",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    skipComments: {
	                        type: "boolean"
	                    },
	                    skipStrings: {
	                        type: "boolean"
	                    },
	                    skipTemplates: {
	                        type: "boolean"
	                    },
	                    skipRegExps: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // Module store of errors that we have found
	        let errors = [];
	
	        // Comment nodes.  We accumulate these as we go, so we can be sure to trigger them after the whole `Program` entity is parsed, even for top-of-file comments.
	        const commentNodes = [];
	
	        // Lookup the `skipComments` option, which defaults to `false`.
	        const options = context.options[0] || {};
	        const skipComments = !!options.skipComments;
	        const skipStrings = options.skipStrings !== false;
	        const skipRegExps = !!options.skipRegExps;
	        const skipTemplates = !!options.skipTemplates;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Removes errors that occur inside a string node
	         * @param {ASTNode} node to check for matching errors.
	         * @returns {void}
	         * @private
	         */
	        function removeWhitespaceError(node) {
	            const locStart = node.loc.start;
	            const locEnd = node.loc.end;
	
	            errors = errors.filter(function(error) {
	                const errorLoc = error[1];
	
	                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {
	                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {
	                        return false;
	                    }
	                }
	                return true;
	            });
	        }
	
	        /**
	         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
	         * @param {ASTNode} node to check for matching errors.
	         * @returns {void}
	         * @private
	         */
	        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
	            const shouldCheckStrings = skipStrings && (typeof node.value === "string");
	            const shouldCheckRegExps = skipRegExps && (node.value instanceof RegExp);
	
	            if (shouldCheckStrings || shouldCheckRegExps) {
	
	                // If we have irregular characters remove them from the errors list
	                if (ALL_IRREGULARS.test(node.raw)) {
	                    removeWhitespaceError(node);
	                }
	            }
	        }
	
	        /**
	         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
	         * @param {ASTNode} node to check for matching errors.
	         * @returns {void}
	         * @private
	         */
	        function removeInvalidNodeErrorsInTemplateLiteral(node) {
	            if (typeof node.value.raw === "string") {
	                if (ALL_IRREGULARS.test(node.value.raw)) {
	                    removeWhitespaceError(node);
	                }
	            }
	        }
	
	        /**
	         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors
	         * @param {ASTNode} node to check for matching errors.
	         * @returns {void}
	         * @private
	         */
	        function removeInvalidNodeErrorsInComment(node) {
	            if (ALL_IRREGULARS.test(node.value)) {
	                removeWhitespaceError(node);
	            }
	        }
	
	        /**
	         * Checks the program source for irregular whitespace
	         * @param {ASTNode} node The program node
	         * @returns {void}
	         * @private
	         */
	        function checkForIrregularWhitespace(node) {
	            const sourceLines = sourceCode.lines;
	
	            sourceLines.forEach(function(sourceLine, lineIndex) {
	                const lineNumber = lineIndex + 1;
	                let match;
	
	                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
	                    const location = {
	                        line: lineNumber,
	                        column: match.index
	                    };
	
	                    errors.push([node, location, "Irregular whitespace not allowed."]);
	                }
	            });
	        }
	
	        /**
	         * Checks the program source for irregular line terminators
	         * @param {ASTNode} node The program node
	         * @returns {void}
	         * @private
	         */
	        function checkForIrregularLineTerminators(node) {
	            const source = sourceCode.getText(),
	                sourceLines = sourceCode.lines,
	                linebreaks = source.match(LINE_BREAK);
	            let lastLineIndex = -1,
	                match;
	
	            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
	                const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
	                const location = {
	                    line: lineIndex + 1,
	                    column: sourceLines[lineIndex].length
	                };
	
	                errors.push([node, location, "Irregular whitespace not allowed."]);
	                lastLineIndex = lineIndex;
	            }
	        }
	
	        /**
	         * Stores a comment node (`LineComment` or `BlockComment`) for later stripping of errors within; a necessary deferring of processing to deal with top-of-file comments.
	         * @param {ASTNode} node The comment node
	         * @returns {void}
	         * @private
	         */
	        function rememberCommentNode(node) {
	            commentNodes.push(node);
	        }
	
	        /**
	         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.
	         * @returns {void}
	         * @private
	         */
	        function noop() {}
	
	        const nodes = {};
	
	        if (ALL_IRREGULARS.test(sourceCode.getText())) {
	            nodes.Program = function(node) {
	
	                /*
	                 * As we can easily fire warnings for all white space issues with
	                 * all the source its simpler to fire them here.
	                 * This means we can check all the application code without having
	                 * to worry about issues caused in the parser tokens.
	                 * When writing this code also evaluating per node was missing out
	                 * connecting tokens in some cases.
	                 * We can later filter the errors when they are found to be not an
	                 * issue in nodes we don't care about.
	                 */
	
	                checkForIrregularWhitespace(node);
	                checkForIrregularLineTerminators(node);
	            };
	
	            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
	            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
	            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
	            nodes.LineComment = skipComments ? rememberCommentNode : noop;
	            nodes.BlockComment = skipComments ? rememberCommentNode : noop;
	            nodes["Program:exit"] = function() {
	
	                if (skipComments) {
	
	                    // First strip errors occurring in comment nodes.  We have to do this post-`Program` to deal with top-of-file comments.
	                    commentNodes.forEach(removeInvalidNodeErrorsInComment);
	                }
	
	                // If we have any errors remaining report on them
	                errors.forEach(function(error) {
	                    context.report.apply(context, error);
	                });
	            };
	        } else {
	            nodes.Program = noop;
	        }
	
	        return nodes;
	    }
	};


/***/ },
/* 241 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag usage of __iterator__ property
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of the `__iterator__` property",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            MemberExpression(node) {
	
	                if (node.property &&
	                        (node.property.type === "Identifier" && node.property.name === "__iterator__" && !node.computed) ||
	                        (node.property.type === "Literal" && node.property.value === "__iterator__")) {
	                    context.report(node, "Reserved name '__iterator__'.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag labels that are the same as an identifier
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow labels that share a name with a variable",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Check if the identifier is present inside current scope
	         * @param {Object} scope current scope
	         * @param {string} name To evaluate
	         * @returns {boolean} True if its present
	         * @private
	         */
	        function findIdentifier(scope, name) {
	            return astUtils.getVariableByName(scope, name) !== null;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	
	            LabeledStatement(node) {
	
	                // Fetch the innermost scope.
	                const scope = context.getScope();
	
	                // Recursively find the identifier walking up the scope, starting
	                // with the innermost scope.
	                if (findIdentifier(scope, node.label.name)) {
	                    context.report(node, "Found identifier with same name as label.");
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallow Labeled Statements
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow labeled statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowLoop: {
	                        type: "boolean"
	                    },
	                    allowSwitch: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0];
	        const allowLoop = Boolean(options && options.allowLoop);
	        const allowSwitch = Boolean(options && options.allowSwitch);
	        let scopeInfo = null;
	
	        /**
	         * Gets the kind of a given node.
	         *
	         * @param {ASTNode} node - A node to get.
	         * @returns {string} The kind of the node.
	         */
	        function getBodyKind(node) {
	            if (astUtils.isLoop(node)) {
	                return "loop";
	            }
	            if (node.type === "SwitchStatement") {
	                return "switch";
	            }
	            return "other";
	        }
	
	        /**
	         * Checks whether the label of a given kind is allowed or not.
	         *
	         * @param {string} kind - A kind to check.
	         * @returns {boolean} `true` if the kind is allowed.
	         */
	        function isAllowed(kind) {
	            switch (kind) {
	                case "loop": return allowLoop;
	                case "switch": return allowSwitch;
	                default: return false;
	            }
	        }
	
	        /**
	         * Checks whether a given name is a label of a loop or not.
	         *
	         * @param {string} label - A name of a label to check.
	         * @returns {boolean} `true` if the name is a label of a loop.
	         */
	        function getKind(label) {
	            let info = scopeInfo;
	
	            while (info) {
	                if (info.label === label) {
	                    return info.kind;
	                }
	                info = info.upper;
	            }
	
	            /* istanbul ignore next: syntax error */
	            return "other";
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            LabeledStatement(node) {
	                scopeInfo = {
	                    label: node.label.name,
	                    kind: getBodyKind(node.body),
	                    upper: scopeInfo
	                };
	            },
	
	            "LabeledStatement:exit"(node) {
	                if (!isAllowed(scopeInfo.kind)) {
	                    context.report({
	                        node,
	                        message: "Unexpected labeled statement."
	                    });
	                }
	
	                scopeInfo = scopeInfo.upper;
	            },
	
	            BreakStatement(node) {
	                if (node.label && !isAllowed(getKind(node.label.name))) {
	                    context.report({
	                        node,
	                        message: "Unexpected label in break statement."
	                    });
	                }
	            },
	
	            ContinueStatement(node) {
	                if (node.label && !isAllowed(getKind(node.label.name))) {
	                    context.report({
	                        node,
	                        message: "Unexpected label in continue statement."
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 244 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag blocks with no reason to exist
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary nested blocks",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        // A stack of lone blocks to be checked for block-level bindings
	        const loneBlocks = [];
	        let ruleDef;
	
	        /**
	         * Reports a node as invalid.
	         * @param {ASTNode} node - The node to be reported.
	         * @returns {void}
	        */
	        function report(node) {
	            const parent = context.getAncestors().pop();
	
	            context.report(node, parent.type === "Program" ?
	                "Block is redundant." :
	                "Nested block is redundant."
	            );
	        }
	
	        /**
	         * Checks for any ocurrence of BlockStatement > BlockStatement or Program > BlockStatement
	         * @returns {boolean} True if the current node is a lone block.
	        */
	        function isLoneBlock() {
	            const parent = context.getAncestors().pop();
	
	            return parent.type === "BlockStatement" || parent.type === "Program";
	        }
	
	        /**
	         * Checks the enclosing block of the current node for block-level bindings,
	         * and "marks it" as valid if any.
	         * @returns {void}
	        */
	        function markLoneBlock() {
	            if (loneBlocks.length === 0) {
	                return;
	            }
	
	            const block = context.getAncestors().pop();
	
	            if (loneBlocks[loneBlocks.length - 1] === block) {
	                loneBlocks.pop();
	            }
	        }
	
	        // Default rule definition: report all lone blocks
	        ruleDef = {
	            BlockStatement(node) {
	                if (isLoneBlock(node)) {
	                    report(node);
	                }
	            }
	        };
	
	        // ES6: report blocks without block-level bindings
	        if (context.parserOptions.ecmaVersion >= 6) {
	            ruleDef = {
	                BlockStatement(node) {
	                    if (isLoneBlock(node)) {
	                        loneBlocks.push(node);
	                    }
	                },
	                "BlockStatement:exit"(node) {
	                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
	                        loneBlocks.pop();
	                        report(node);
	                    }
	                }
	            };
	
	            ruleDef.VariableDeclaration = function(node) {
	                if (node.kind === "let" || node.kind === "const") {
	                    markLoneBlock(node);
	                }
	            };
	
	            ruleDef.FunctionDeclaration = function(node) {
	                if (context.getScope().isStrict) {
	                    markLoneBlock(node);
	                }
	            };
	
	            ruleDef.ClassDeclaration = markLoneBlock;
	        }
	
	        return ruleDef;
	    }
	};


/***/ },
/* 245 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow if as the only statmenet in an else block
	 * @author Brandon Mills
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `if` statements as the only statement in `else` blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            IfStatement(node) {
	                const ancestors = context.getAncestors(),
	                    parent = ancestors.pop(),
	                    grandparent = ancestors.pop();
	
	                if (parent && parent.type === "BlockStatement" &&
	                        parent.body.length === 1 && grandparent &&
	                        grandparent.type === "IfStatement" &&
	                        parent === grandparent.alternate) {
	                    context.report({
	                        node,
	                        message: "Unexpected if as the only statement in an else block.",
	                        fix(fixer) {
	                            const openingElseCurly = sourceCode.getFirstToken(parent);
	                            const closingElseCurly = sourceCode.getLastToken(parent);
	                            const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
	                            const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
	                            const lastIfToken = sourceCode.getLastToken(node.consequent);
	                            const sourceText = sourceCode.getText();
	
	                            if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
	
	                                // Don't fix if there are any non-whitespace characters interfering (e.g. comments)
	                                return null;
	                            }
	
	                            if (
	                                node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock &&
	                                (
	                                    node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line ||
	                                    /^[([/+`-]/.test(tokenAfterElseBlock.value) ||
	                                    lastIfToken.value === "++" ||
	                                    lastIfToken.value === "--"
	                                )
	                            ) {
	
	                                /*
	                                 * If the `if` statement has no block, and is not followed by a semicolon, make sure that fixing
	                                 * the issue would not change semantics due to ASI. If this would happen, don't do a fix.
	                                 */
	                                return null;
	                            }
	
	                            return fixer.replaceTextRange(
	                                [openingElseCurly.range[0], closingElseCurly.range[1]],
	                                (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node)
	                            );
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 246 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag creation of function inside a loop
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Gets the containing loop node of a specified node.
	 *
	 * We don't need to check nested functions, so this ignores those.
	 * `Scope.through` contains references of nested functions.
	 *
	 * @param {ASTNode} node - An AST node to get.
	 * @returns {ASTNode|null} The containing loop node of the specified node, or
	 *      `null`.
	 */
	function getContainingLoopNode(node) {
	    let parent = node.parent;
	
	    while (parent) {
	        switch (parent.type) {
	            case "WhileStatement":
	            case "DoWhileStatement":
	                return parent;
	
	            case "ForStatement":
	
	                // `init` is outside of the loop.
	                if (parent.init !== node) {
	                    return parent;
	                }
	                break;
	
	            case "ForInStatement":
	            case "ForOfStatement":
	
	                // `right` is outside of the loop.
	                if (parent.right !== node) {
	                    return parent;
	                }
	                break;
	
	            case "ArrowFunctionExpression":
	            case "FunctionExpression":
	            case "FunctionDeclaration":
	
	                // We don't need to check nested functions.
	                return null;
	
	            default:
	                break;
	        }
	
	        node = parent;
	        parent = node.parent;
	    }
	
	    return null;
	}
	
	/**
	 * Gets the containing loop node of a given node.
	 * If the loop was nested, this returns the most outer loop.
	 *
	 * @param {ASTNode} node - A node to get. This is a loop node.
	 * @param {ASTNode|null} excludedNode - A node that the result node should not
	 *      include.
	 * @returns {ASTNode} The most outer loop node.
	 */
	function getTopLoopNode(node, excludedNode) {
	    let retv = node;
	    const border = excludedNode ? excludedNode.range[1] : 0;
	
	    while (node && node.range[0] >= border) {
	        retv = node;
	        node = getContainingLoopNode(node);
	    }
	
	    return retv;
	}
	
	/**
	 * Checks whether a given reference which refers to an upper scope's variable is
	 * safe or not.
	 *
	 * @param {ASTNode} funcNode - A target function node.
	 * @param {ASTNode} loopNode - A containing loop node.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the reference is safe or not.
	 */
	function isSafe(funcNode, loopNode, reference) {
	    const variable = reference.resolved;
	    const definition = variable && variable.defs[0];
	    const declaration = definition && definition.parent;
	    const kind = (declaration && declaration.type === "VariableDeclaration")
	        ? declaration.kind
	        : "";
	
	    // Variables which are declared by `const` is safe.
	    if (kind === "const") {
	        return true;
	    }
	
	    // Variables which are declared by `let` in the loop is safe.
	    // It's a different instance from the next loop step's.
	    if (kind === "let" &&
	        declaration.range[0] > loopNode.range[0] &&
	        declaration.range[1] < loopNode.range[1]
	    ) {
	        return true;
	    }
	
	    // WriteReferences which exist after this border are unsafe because those
	    // can modify the variable.
	    const border = getTopLoopNode(
	        loopNode,
	        (kind === "let") ? declaration : null
	    ).range[0];
	
	    /**
	     * Checks whether a given reference is safe or not.
	     * The reference is every reference of the upper scope's variable we are
	     * looking now.
	     *
	     * It's safeafe if the reference matches one of the following condition.
	     * - is readonly.
	     * - doesn't exist inside a local function and after the border.
	     *
	     * @param {escope.Reference} upperRef - A reference to check.
	     * @returns {boolean} `true` if the reference is safe.
	     */
	    function isSafeReference(upperRef) {
	        const id = upperRef.identifier;
	
	        return (
	            !upperRef.isWrite() ||
	            variable.scope.variableScope === upperRef.from.variableScope &&
	            id.range[0] < border
	        );
	    }
	
	    return Boolean(variable) && variable.references.every(isSafeReference);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `function` declarations and expressions inside loop statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Reports functions which match the following condition:
	         *
	         * - has a loop node in ancestors.
	         * - has any references which refers to an unsafe variable.
	         *
	         * @param {ASTNode} node The AST node to check.
	         * @returns {boolean} Whether or not the node is within a loop.
	         */
	        function checkForLoops(node) {
	            const loopNode = getContainingLoopNode(node);
	
	            if (!loopNode) {
	                return;
	            }
	
	            const references = context.getScope().through;
	
	            if (references.length > 0 &&
	                !references.every(isSafe.bind(null, node, loopNode))
	            ) {
	                context.report(node, "Don't make functions within a loop.");
	            }
	        }
	
	        return {
	            ArrowFunctionExpression: checkForLoops,
	            FunctionExpression: checkForLoops,
	            FunctionDeclaration: checkForLoops
	        };
	    }
	};


/***/ },
/* 247 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements that use magic numbers (adapted from https://github.com/danielstjules/buddy.js)
	 * @author Vincent Lemeunier
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow magic numbers",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [{
	            type: "object",
	            properties: {
	                detectObjects: {
	                    type: "boolean"
	                },
	                enforceConst: {
	                    type: "boolean"
	                },
	                ignore: {
	                    type: "array",
	                    items: {
	                        type: "number"
	                    },
	                    uniqueItems: true
	                },
	                ignoreArrayIndexes: {
	                    type: "boolean"
	                }
	            },
	            additionalProperties: false
	        }]
	    },
	
	    create(context) {
	        const config = context.options[0] || {},
	            detectObjects = !!config.detectObjects,
	            enforceConst = !!config.enforceConst,
	            ignore = config.ignore || [],
	            ignoreArrayIndexes = !!config.ignoreArrayIndexes;
	
	        /**
	         * Returns whether the node is number literal
	         * @param {Node} node - the node literal being evaluated
	         * @returns {boolean} true if the node is a number literal
	         */
	        function isNumber(node) {
	            return typeof node.value === "number";
	        }
	
	        /**
	         * Returns whether the number should be ignored
	         * @param {number} num - the number
	         * @returns {boolean} true if the number should be ignored
	         */
	        function shouldIgnoreNumber(num) {
	            return ignore.indexOf(num) !== -1;
	        }
	
	        /**
	         * Returns whether the number should be ignored when used as a radix within parseInt() or Number.parseInt()
	         * @param {ASTNode} parent - the non-"UnaryExpression" parent
	         * @param {ASTNode} node - the node literal being evaluated
	         * @returns {boolean} true if the number should be ignored
	         */
	        function shouldIgnoreParseInt(parent, node) {
	            return parent.type === "CallExpression" && node === parent.arguments[1] &&
	                (parent.callee.name === "parseInt" ||
	                parent.callee.type === "MemberExpression" &&
	                parent.callee.object.name === "Number" &&
	                parent.callee.property.name === "parseInt");
	        }
	
	        /**
	         * Returns whether the number should be ignored when used to define a JSX prop
	         * @param {ASTNode} parent - the non-"UnaryExpression" parent
	         * @returns {boolean} true if the number should be ignored
	         */
	        function shouldIgnoreJSXNumbers(parent) {
	            return parent.type.indexOf("JSX") === 0;
	        }
	
	        /**
	         * Returns whether the number should be ignored when used as an array index with enabled 'ignoreArrayIndexes' option.
	         * @param {ASTNode} parent - the non-"UnaryExpression" parent.
	         * @returns {boolean} true if the number should be ignored
	         */
	        function shouldIgnoreArrayIndexes(parent) {
	            return parent.type === "MemberExpression" && ignoreArrayIndexes;
	        }
	
	        return {
	            Literal(node) {
	                let parent = node.parent,
	                    value = node.value,
	                    raw = node.raw;
	                const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
	
	                if (!isNumber(node)) {
	                    return;
	                }
	
	                // For negative magic numbers: update the value and parent node
	                if (parent.type === "UnaryExpression" && parent.operator === "-") {
	                    node = parent;
	                    parent = node.parent;
	                    value = -value;
	                    raw = `-${raw}`;
	                }
	
	                if (shouldIgnoreNumber(value) ||
	                    shouldIgnoreParseInt(parent, node) ||
	                    shouldIgnoreArrayIndexes(parent) ||
	                    shouldIgnoreJSXNumbers(parent)) {
	                    return;
	                }
	
	                if (parent.type === "VariableDeclarator") {
	                    if (enforceConst && parent.parent.kind !== "const") {
	                        context.report({
	                            node,
	                            message: "Number constants declarations must use 'const'."
	                        });
	                    }
	                } else if (
	                    okTypes.indexOf(parent.type) === -1 ||
	                    (parent.type === "AssignmentExpression" && parent.left.type === "Identifier")
	                ) {
	                    context.report({
	                        node,
	                        message: "No magic number: {{raw}}.",
	                        data: {
	                            raw
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow mixed binary operators.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
	const BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
	const COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
	const LOGICAL_OPERATORS = ["&&", "||"];
	const RELATIONAL_OPERATORS = ["in", "instanceof"];
	const ALL_OPERATORS = [].concat(
	    ARITHMETIC_OPERATORS,
	    BITWISE_OPERATORS,
	    COMPARISON_OPERATORS,
	    LOGICAL_OPERATORS,
	    RELATIONAL_OPERATORS
	);
	const DEFAULT_GROUPS = [
	    ARITHMETIC_OPERATORS,
	    BITWISE_OPERATORS,
	    COMPARISON_OPERATORS,
	    LOGICAL_OPERATORS,
	    RELATIONAL_OPERATORS
	];
	const TARGET_NODE_TYPE = /^(?:Binary|Logical)Expression$/;
	
	/**
	 * Normalizes options.
	 *
	 * @param {Object|undefined} options - A options object to normalize.
	 * @returns {Object} Normalized option object.
	 */
	function normalizeOptions(options) {
	    const hasGroups = (options && options.groups && options.groups.length > 0);
	    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
	    const allowSamePrecedence = (options && options.allowSamePrecedence) !== false;
	
	    return {
	        groups,
	        allowSamePrecedence
	    };
	}
	
	/**
	 * Checks whether any group which includes both given operator exists or not.
	 *
	 * @param {Array.<string[]>} groups - A list of groups to check.
	 * @param {string} left - An operator.
	 * @param {string} right - Another operator.
	 * @returns {boolean} `true` if such group existed.
	 */
	function includesBothInAGroup(groups, left, right) {
	    return groups.some(function(group) {
	        return group.indexOf(left) !== -1 && group.indexOf(right) !== -1;
	    });
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow mixed binary operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    groups: {
	                        type: "array",
	                        items: {
	                            type: "array",
	                            items: {enum: ALL_OPERATORS},
	                            minItems: 2,
	                            uniqueItems: true
	                        },
	                        uniqueItems: true
	                    },
	                    allowSamePrecedence: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const options = normalizeOptions(context.options[0]);
	
	        /**
	         * Checks whether a given node should be ignored by options or not.
	         *
	         * @param {ASTNode} node - A node to check. This is a BinaryExpression
	         *      node or a LogicalExpression node. This parent node is one of
	         *      them, too.
	         * @returns {boolean} `true` if the node should be ignored.
	         */
	        function shouldIgnore(node) {
	            const a = node;
	            const b = node.parent;
	
	            return (
	                !includesBothInAGroup(options.groups, a.operator, b.operator) ||
	                (
	                    options.allowSamePrecedence &&
	                    astUtils.getPrecedence(a) === astUtils.getPrecedence(b)
	                )
	            );
	        }
	
	        /**
	         * Checks whether the operator of a given node is mixed with parent
	         * node's operator or not.
	         *
	         * @param {ASTNode} node - A node to check. This is a BinaryExpression
	         *      node or a LogicalExpression node. This parent node is one of
	         *      them, too.
	         * @returns {boolean} `true` if the node was mixed.
	         */
	        function isMixedWithParent(node) {
	            return (
	                node.operator !== node.parent.operator &&
	                !astUtils.isParenthesised(sourceCode, node)
	            );
	        }
	
	        /**
	         * Gets the operator token of a given node.
	         *
	         * @param {ASTNode} node - A node to check. This is a BinaryExpression
	         *      node or a LogicalExpression node.
	         * @returns {Token} The operator token of the node.
	         */
	        function getOperatorToken(node) {
	            let token = sourceCode.getTokenAfter(node.left);
	
	            while (token.value === ")") {
	                token = sourceCode.getTokenAfter(token);
	            }
	
	            return token;
	        }
	
	        /**
	         * Reports both the operator of a given node and the operator of the
	         * parent node.
	         *
	         * @param {ASTNode} node - A node to check. This is a BinaryExpression
	         *      node or a LogicalExpression node. This parent node is one of
	         *      them, too.
	         * @returns {void}
	         */
	        function reportBothOperators(node) {
	            const parent = node.parent;
	            const left = (parent.left === node) ? node : parent;
	            const right = (parent.left !== node) ? node : parent;
	            const message =
	                "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'.";
	            const data = {
	                leftOperator: left.operator,
	                rightOperator: right.operator
	            };
	
	            context.report({
	                node: left,
	                loc: getOperatorToken(left).loc.start,
	                message,
	                data
	            });
	            context.report({
	                node: right,
	                loc: getOperatorToken(right).loc.start,
	                message,
	                data
	            });
	        }
	
	        /**
	         * Checks between the operator of this node and the operator of the
	         * parent node.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {void}
	         */
	        function check(node) {
	            if (TARGET_NODE_TYPE.test(node.parent.type) &&
	                isMixedWithParent(node) &&
	                !shouldIgnore(node)
	            ) {
	                reportBothOperators(node);
	            }
	        }
	
	        return {
	            BinaryExpression: check,
	            LogicalExpression: check
	        };
	    }
	};


/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce grouped require statements for Node.JS
	 * @author Raphael Pigulla
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `require` calls to be mixed with regular variable declarations",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        type: "boolean"
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            grouping: {
	                                type: "boolean"
	                            },
	                            allowCall: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const options = context.options[0];
	        let grouping = false,
	            allowCall = false;
	
	        if (typeof options === "object") {
	            grouping = options.grouping;
	            allowCall = options.allowCall;
	        } else {
	            grouping = !!options;
	        }
	
	        /**
	         * Returns the list of built-in modules.
	         *
	         * @returns {string[]} An array of built-in Node.js modules.
	         */
	        function getBuiltinModules() {
	
	            /*
	             * This list is generated using:
	             * `require("repl")._builtinLibs.concat('repl').sort()`
	             * This particular list is as per nodejs v0.12.2 and iojs v0.7.1
	             */
	            return [
	                "assert", "buffer", "child_process", "cluster", "crypto",
	                "dgram", "dns", "domain", "events", "fs", "http", "https",
	                "net", "os", "path", "punycode", "querystring", "readline",
	                "repl", "smalloc", "stream", "string_decoder", "tls", "tty",
	                "url", "util", "v8", "vm", "zlib"
	            ];
	        }
	
	        const BUILTIN_MODULES = getBuiltinModules();
	
	        const DECL_REQUIRE = "require",
	            DECL_UNINITIALIZED = "uninitialized",
	            DECL_OTHER = "other";
	
	        const REQ_CORE = "core",
	            REQ_FILE = "file",
	            REQ_MODULE = "module",
	            REQ_COMPUTED = "computed";
	
	        /**
	         * Determines the type of a declaration statement.
	         * @param {ASTNode} initExpression The init node of the VariableDeclarator.
	         * @returns {string} The type of declaration represented by the expression.
	         */
	        function getDeclarationType(initExpression) {
	            if (!initExpression) {
	
	                // "var x;"
	                return DECL_UNINITIALIZED;
	            }
	
	            if (initExpression.type === "CallExpression" &&
	                initExpression.callee.type === "Identifier" &&
	                initExpression.callee.name === "require"
	            ) {
	
	                // "var x = require('util');"
	                return DECL_REQUIRE;
	            } else if (allowCall &&
	                initExpression.type === "CallExpression" &&
	                initExpression.callee.type === "CallExpression"
	            ) {
	
	                // "var x = require('diagnose')('sub-module');"
	                return getDeclarationType(initExpression.callee);
	            } else if (initExpression.type === "MemberExpression") {
	
	                // "var x = require('glob').Glob;"
	                return getDeclarationType(initExpression.object);
	            }
	
	            // "var x = 42;"
	            return DECL_OTHER;
	        }
	
	        /**
	         * Determines the type of module that is loaded via require.
	         * @param {ASTNode} initExpression The init node of the VariableDeclarator.
	         * @returns {string} The module type.
	         */
	        function inferModuleType(initExpression) {
	            if (initExpression.type === "MemberExpression") {
	
	                // "var x = require('glob').Glob;"
	                return inferModuleType(initExpression.object);
	            } else if (initExpression.arguments.length === 0) {
	
	                // "var x = require();"
	                return REQ_COMPUTED;
	            }
	
	            const arg = initExpression.arguments[0];
	
	            if (arg.type !== "Literal" || typeof arg.value !== "string") {
	
	                // "var x = require(42);"
	                return REQ_COMPUTED;
	            }
	
	            if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
	
	                // "var fs = require('fs');"
	                return REQ_CORE;
	            } else if (/^\.{0,2}\//.test(arg.value)) {
	
	                // "var utils = require('./utils');"
	                return REQ_FILE;
	            } else {
	
	                // "var async = require('async');"
	                return REQ_MODULE;
	            }
	        }
	
	        /**
	         * Check if the list of variable declarations is mixed, i.e. whether it
	         * contains both require and other declarations.
	         * @param {ASTNode} declarations The list of VariableDeclarators.
	         * @returns {boolean} True if the declarations are mixed, false if not.
	         */
	        function isMixed(declarations) {
	            const contains = {};
	
	            declarations.forEach(function(declaration) {
	                const type = getDeclarationType(declaration.init);
	
	                contains[type] = true;
	            });
	
	            return !!(
	                contains[DECL_REQUIRE] &&
	                (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER])
	            );
	        }
	
	        /**
	         * Check if all require declarations in the given list are of the same
	         * type.
	         * @param {ASTNode} declarations The list of VariableDeclarators.
	         * @returns {boolean} True if the declarations are grouped, false if not.
	         */
	        function isGrouped(declarations) {
	            const found = {};
	
	            declarations.forEach(function(declaration) {
	                if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
	                    found[inferModuleType(declaration.init)] = true;
	                }
	            });
	
	            return Object.keys(found).length <= 1;
	        }
	
	
	        return {
	
	            VariableDeclaration(node) {
	
	                if (isMixed(node.declarations)) {
	                    context.report(
	                        node,
	                        "Do not mix 'require' and other declarations."
	                    );
	                } else if (grouping && !isGrouped(node.declarations)) {
	                    context.report(
	                        node,
	                        "Do not mix core, module, file and computed requires."
	                    );
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 250 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow mixed spaces and tabs for indentation
	 * @author Jary Niebur
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow mixed spaces and tabs for indentation",
	            category: "Stylistic Issues",
	            recommended: true
	        },
	
	        schema: [
	            {
	                enum: ["smart-tabs", true, false]
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        let smartTabs;
	        const ignoredLocs = [];
	
	        switch (context.options[0]) {
	            case true: // Support old syntax, maybe add deprecation warning here
	            case "smart-tabs":
	                smartTabs = true;
	                break;
	            default:
	                smartTabs = false;
	        }
	
	        /**
	         * Determines if a given line and column are before a location.
	         * @param {Location} loc The location object from an AST node.
	         * @param {int} line The line to check.
	         * @param {int} column The column to check.
	         * @returns {boolean} True if the line and column are before the location, false if not.
	         * @private
	         */
	        function beforeLoc(loc, line, column) {
	            if (line < loc.start.line) {
	                return true;
	            }
	            return line === loc.start.line && column < loc.start.column;
	        }
	
	        /**
	         * Determines if a given line and column are after a location.
	         * @param {Location} loc The location object from an AST node.
	         * @param {int} line The line to check.
	         * @param {int} column The column to check.
	         * @returns {boolean} True if the line and column are after the location, false if not.
	         * @private
	         */
	        function afterLoc(loc, line, column) {
	            if (line > loc.end.line) {
	                return true;
	            }
	            return line === loc.end.line && column > loc.end.column;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            TemplateElement(node) {
	                ignoredLocs.push(node.loc);
	            },
	
	            "Program:exit"(node) {
	
	                /*
	                 * At least one space followed by a tab
	                 * or the reverse before non-tab/-space
	                 * characters begin.
	                 */
	                let regex = /^(?=[\t ]*(\t | \t))/;
	                const lines = sourceCode.lines,
	                    comments = sourceCode.getAllComments();
	
	                comments.forEach(function(comment) {
	                    ignoredLocs.push(comment.loc);
	                });
	
	                ignoredLocs.sort(function(first, second) {
	                    if (beforeLoc(first, second.start.line, second.start.column)) {
	                        return 1;
	                    }
	
	                    if (beforeLoc(second, first.start.line, second.start.column)) {
	                        return -1;
	                    }
	
	                    return 0;
	                });
	
	                if (smartTabs) {
	
	                    /*
	                     * At least one space followed by a tab
	                     * before non-tab/-space characters begin.
	                     */
	                    regex = /^(?=[\t ]* \t)/;
	                }
	
	                lines.forEach(function(line, i) {
	                    const match = regex.exec(line);
	
	                    if (match) {
	                        const lineNumber = i + 1,
	                            column = match.index + 1;
	
	                        for (let j = 0; j < ignoredLocs.length; j++) {
	                            if (beforeLoc(ignoredLocs[j], lineNumber, column)) {
	                                continue;
	                            }
	                            if (afterLoc(ignoredLocs[j], lineNumber, column)) {
	                                continue;
	                            }
	
	                            return;
	                        }
	
	                        context.report(node, { line: lineNumber, column }, "Mixed spaces and tabs.");
	                    }
	                });
	            }
	
	        };
	
	    }
	};


/***/ },
/* 251 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow use of multiple spaces.
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow multiple spaces",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "object",
	                        patternProperties: {
	                            "^([A-Z][a-z]*)+$": {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // the index of the last comment that was checked
	        const exceptions = { Property: true },
	            options = context.options[0];
	        let hasExceptions = true,
	            lastCommentIndex = 0;
	
	        if (options && options.exceptions) {
	            Object.keys(options.exceptions).forEach(function(key) {
	                if (options.exceptions[key]) {
	                    exceptions[key] = true;
	                } else {
	                    delete exceptions[key];
	                }
	            });
	            hasExceptions = Object.keys(exceptions).length > 0;
	        }
	
	        /**
	         * Determines if a given source index is in a comment or not by checking
	         * the index against the comment range. Since the check goes straight
	         * through the file, once an index is passed a certain comment, we can
	         * go to the next comment to check that.
	         * @param {int} index The source index to check.
	         * @param {ASTNode[]} comments An array of comment nodes.
	         * @returns {boolean} True if the index is within a comment, false if not.
	         * @private
	         */
	        function isIndexInComment(index, comments) {
	            while (lastCommentIndex < comments.length) {
	                const comment = comments[lastCommentIndex];
	
	                if (comment.range[0] <= index && index < comment.range[1]) {
	                    return true;
	                } else if (index > comment.range[1]) {
	                    lastCommentIndex++;
	                } else {
	                    break;
	                }
	            }
	
	            return false;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Program() {
	
	                const sourceCode = context.getSourceCode(),
	                    source = sourceCode.getText(),
	                    allComments = sourceCode.getAllComments(),
	                    pattern = /[^\n\r\u2028\u2029\t ].? {2,}/g;  // note: repeating space
	                let parent;
	
	
	                /**
	                 * Creates a fix function that removes the multiple spaces between the two tokens
	                 * @param {RuleFixer} leftToken left token
	                 * @param {RuleFixer} rightToken right token
	                 * @returns {Function} fix function
	                 * @private
	                 */
	                function createFix(leftToken, rightToken) {
	                    return function(fixer) {
	                        return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ");
	                    };
	                }
	
	                while (pattern.test(source)) {
	
	                    // do not flag anything inside of comments
	                    if (!isIndexInComment(pattern.lastIndex, allComments)) {
	
	                        const token = sourceCode.getTokenByRangeStart(pattern.lastIndex);
	
	                        if (token) {
	                            const previousToken = sourceCode.getTokenBefore(token);
	
	                            if (hasExceptions) {
	                                parent = sourceCode.getNodeByRangeIndex(pattern.lastIndex - 1);
	                            }
	
	                            if (!parent || !exceptions[parent.type]) {
	                                context.report({
	                                    node: token,
	                                    loc: token.loc.start,
	                                    message: "Multiple spaces found before '{{value}}'.",
	                                    data: { value: token.value },
	                                    fix: createFix(previousToken, token)
	                                });
	                            }
	                        }
	
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 252 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using multiline strings
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow multiline strings",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Determines if a given node is part of JSX syntax.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node is a JSX node, false if not.
	         * @private
	         */
	        function isJSXElement(node) {
	            return node.type.indexOf("JSX") === 0;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	
	            Literal(node) {
	                const lineBreak = /\n/;
	
	                if (lineBreak.test(node.raw) && !isJSXElement(node.parent)) {
	                    context.report(node, "Multiline support is limited to browsers supporting ES5 only.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 253 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallows multiple blank lines.
	 * implementation adapted from the no-trailing-spaces rule.
	 * @author Greg Cochard
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow multiple empty lines",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    max: {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    maxEOF: {
	                        type: "integer",
	                        minimum: 0
	                    },
	                    maxBOF: {
	                        type: "integer",
	                        minimum: 0
	                    }
	                },
	                required: ["max"],
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // Use options.max or 2 as default
	        let max = 2,
	            maxEOF = max,
	            maxBOF = max;
	
	        if (context.options.length) {
	            max = context.options[0].max;
	            maxEOF = typeof context.options[0].maxEOF !== "undefined" ? context.options[0].maxEOF : max;
	            maxBOF = typeof context.options[0].maxBOF !== "undefined" ? context.options[0].maxBOF : max;
	        }
	
	        const sourceCode = context.getSourceCode();
	        const fullLines = sourceCode.text.match(/.*(\r\n|\r|\n|\u2028|\u2029)/g) || [];
	        const lineStartLocations = fullLines.reduce((startIndices, nextLine) => startIndices.concat(startIndices[startIndices.length - 1] + nextLine.length), [0]);
	
	        // Swallow the final newline, as some editors add it automatically and we don't want it to cause an issue
	        const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
	        const templateLiteralLines = new Set();
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            TemplateLiteral(node) {
	                node.quasis.forEach(literalPart => {
	
	                    // Empty lines have a semantic meaning if they're inside template literals. Don't count these as empty lines.
	                    for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
	                        templateLiteralLines.add(ignoredLine);
	                    }
	                });
	            },
	            "Program:exit"(node) {
	                return allLines
	
	                    // Given a list of lines, first get a list of line numbers that are non-empty.
	                    .reduce((nonEmptyLineNumbers, line, index) => nonEmptyLineNumbers.concat(line.trim() || templateLiteralLines.has(index + 1) ? [index + 1] : []), [])
	
	                    // Add a value at the end to allow trailing empty lines to be checked.
	                    .concat(allLines.length + 1)
	
	                    // Given two line numbers of non-empty lines, report the lines between if the difference is too large.
	                    .reduce((lastLineNumber, lineNumber) => {
	                        let message, maxAllowed;
	
	                        if (lastLineNumber === 0) {
	                            message = "Too many blank lines at the beginning of file. Max of {{max}} allowed.";
	                            maxAllowed = maxBOF;
	                        } else if (lineNumber === allLines.length + 1) {
	                            message = "Too many blank lines at the end of file. Max of {{max}} allowed.";
	                            maxAllowed = maxEOF;
	                        } else {
	                            message = "More than {{max}} blank {{pluralizedLines}} not allowed.";
	                            maxAllowed = max;
	                        }
	
	                        if (lineNumber - lastLineNumber - 1 > maxAllowed) {
	                            context.report({
	                                node,
	                                loc: {start: {line: lastLineNumber + 1, column: 0}, end: {line: lineNumber, column: 0}},
	                                message,
	                                data: {max: maxAllowed, pluralizedLines: maxAllowed === 1 ? "line" : "lines"},
	                                fix: fixer => fixer.removeRange([lineStartLocations[lastLineNumber], lineStartLocations[lineNumber - maxAllowed - 1]])
	                            });
	                        }
	
	                        return lineNumber;
	                    }, 0);
	            }
	        };
	    }
	};


/***/ },
/* 254 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
	 * @author Ilya Volodin
	 * @deprecated in ESLint v3.3.0
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow assignments to native objects or read-only global variables",
	            category: "Best Practices",
	            recommended: true,
	            replacedBy: ["no-global-assign"]
	        },
	
	        deprecated: true,
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {type: "string"},
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const config = context.options[0];
	        const exceptions = (config && config.exceptions) || [];
	
	        /**
	         * Reports write references.
	         * @param {Reference} reference - A reference to check.
	         * @param {int} index - The index of the reference in the references.
	         * @param {Reference[]} references - The array that the reference belongs to.
	         * @returns {void}
	         */
	        function checkReference(reference, index, references) {
	            const identifier = reference.identifier;
	
	            if (reference.init === false &&
	                reference.isWrite() &&
	
	                // Destructuring assignments can have multiple default value,
	                // so possibly there are multiple writeable references for the same identifier.
	                (index === 0 || references[index - 1].identifier !== identifier)
	            ) {
	                context.report({
	                    node: identifier,
	                    message: "Read-only global '{{name}}' should not be modified.",
	                    data: identifier
	                });
	            }
	        }
	
	        /**
	         * Reports write references if a given variable is read-only builtin.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
	                variable.references.forEach(checkReference);
	            }
	        }
	
	        return {
	            Program() {
	                const globalScope = context.getScope();
	
	                globalScope.variables.forEach(checkVariable);
	            }
	        };
	    }
	};


/***/ },
/* 255 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow a negated condition
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow negated conditions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Determines if a given node is an if-else without a condition on the else
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node has an else without an if.
	         * @private
	         */
	        function hasElseWithoutCondition(node) {
	            return node.alternate && node.alternate.type !== "IfStatement";
	        }
	
	        /**
	         * Determines if a given node is a negated unary expression
	         * @param {Object} test The test object to check.
	         * @returns {boolean} True if the node is a negated unary expression.
	         * @private
	         */
	        function isNegatedUnaryExpression(test) {
	            return test.type === "UnaryExpression" && test.operator === "!";
	        }
	
	        /**
	         * Determines if a given node is a negated binary expression
	         * @param {Test} test The test to check.
	         * @returns {boolean} True if the node is a negated binary expression.
	         * @private
	         */
	        function isNegatedBinaryExpression(test) {
	            return test.type === "BinaryExpression" &&
	                (test.operator === "!=" || test.operator === "!==");
	        }
	
	        /**
	         * Determines if a given node has a negated if expression
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} True if the node has a negated if expression.
	         * @private
	         */
	        function isNegatedIf(node) {
	            return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
	        }
	
	        return {
	            IfStatement(node) {
	                if (!hasElseWithoutCondition(node)) {
	                    return;
	                }
	
	                if (isNegatedIf(node)) {
	                    context.report(node, "Unexpected negated condition.");
	                }
	            },
	            ConditionalExpression(node) {
	                if (isNegatedIf(node)) {
	                    context.report(node, "Unexpected negated condition.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 256 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow negated left operands of the `in` operator
	 * @author Michael Ficarra
	 * @deprecated in ESLint v3.3.0
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow negating the left operand in `in` expressions",
	            category: "Possible Errors",
	            recommended: true,
	            replacedBy: ["no-unsafe-negation"]
	        },
	        deprecated: true,
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            BinaryExpression(node) {
	                if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
	                    context.report(node, "The 'in' expression's left operand is negated.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 257 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag nested ternary expressions
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow nested ternary expressions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            ConditionalExpression(node) {
	                if (node.alternate.type === "ConditionalExpression" ||
	                        node.consequent.type === "ConditionalExpression") {
	                    context.report(node, "Do not nest ternary expressions.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 258 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using new Function
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `new` operators with the `Function` object",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Checks if the callee is the Function constructor, and if so, reports an issue.
	         * @param {ASTNode} node The node to check and report on
	         * @returns {void}
	         * @private
	         */
	        function validateCallee(node) {
	            if (node.callee.name === "Function") {
	                context.report(node, "The Function constructor is eval.");
	            }
	        }
	
	        return {
	            NewExpression: validateCallee,
	            CallExpression: validateCallee
	        };
	
	    }
	};


/***/ },
/* 259 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to disallow calls to the Object constructor
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `Object` constructors",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            NewExpression(node) {
	                if (node.callee.name === "Object") {
	                    context.report(node, "The object literal notation {} is preferrable.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 260 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of new operator with the `require` function
	 * @author Wil Moore III
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `new` operators with calls to `require`",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            NewExpression(node) {
	                if (node.callee.type === "Identifier" && node.callee.name === "require") {
	                    context.report(node, "Unexpected use of new with require.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 261 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of the new operator with the `Symbol` object
	 * @author Alberto Rodrguez
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `new` operators with the `Symbol` object",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            "Program:exit"() {
	                const globalScope = context.getScope();
	                const variable = globalScope.set.get("Symbol");
	
	                if (variable && variable.defs.length === 0) {
	                    variable.references.forEach(function(ref) {
	                        const node = ref.identifier;
	
	                        if (node.parent && node.parent.type === "NewExpression") {
	                            context.report(node, "`Symbol` cannot be called as a constructor.");
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 262 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using constructor for wrapper objects
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            NewExpression(node) {
	                const wrapperObjects = ["String", "Number", "Boolean", "Math", "JSON"];
	
	                if (wrapperObjects.indexOf(node.callee.name) > -1) {
	                    context.report(node, "Do not use {{fn}} as a constructor.", { fn: node.callee.name });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 263 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag statements with function invocation preceded by
	 * "new" and not part of assignment
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `new` operators outside of assignments or comparisons",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            ExpressionStatement(node) {
	
	                if (node.expression.type === "NewExpression") {
	                    context.report(node, "Do not use 'new' for side effects.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 264 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function
	 * @author James Allardice
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow calling global object properties as functions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            CallExpression(node) {
	
	                if (node.callee.type === "Identifier") {
	                    const name = node.callee.name;
	
	                    if (name === "Math" || name === "JSON") {
	                        context.report(node, "'{{name}}' is not a function.", { name });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 265 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag octal escape sequences in string literals.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow octal escape sequences in string literals",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            Literal(node) {
	                if (typeof node.value !== "string") {
	                    return;
	                }
	
	                const match = node.raw.match(/^([^\\]|\\[^0-7])*\\([0-3][0-7]{1,2}|[4-7][0-7]|[0-7])/);
	
	                if (match) {
	                    const octalDigit = match[2];
	
	                    // \0 is actually not considered an octal
	                    if (match[2] !== "0" || typeof match[3] !== "undefined") {
	                        context.report(node, "Don't use octal: '\\{{octalDigit}}'. Use '\\u....' instead.",
	                                { octalDigit });
	                    }
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 266 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when initializing octal literal
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow octal literals",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            Literal(node) {
	                if (typeof node.value === "number" && /^0[0-7]/.test(node.raw)) {
	                    context.report(node, "Octal literals should not be used.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 267 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow reassignment of function parameters.
	 * @author Nat Burns
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow reassigning `function` parameters",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    props: {type: "boolean"}
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const props = context.options[0] && Boolean(context.options[0].props);
	
	        /**
	         * Checks whether or not the reference modifies properties of its variable.
	         * @param {Reference} reference - A reference to check.
	         * @returns {boolean} Whether or not the reference modifies properties of its variable.
	         */
	        function isModifyingProp(reference) {
	            let node = reference.identifier;
	            let parent = node.parent;
	
	            while (parent && !stopNodePattern.test(parent.type)) {
	                switch (parent.type) {
	
	                    // e.g. foo.a = 0;
	                    case "AssignmentExpression":
	                        return parent.left === node;
	
	                    // e.g. ++foo.a;
	                    case "UpdateExpression":
	                        return true;
	
	                    // e.g. delete foo.a;
	                    case "UnaryExpression":
	                        if (parent.operator === "delete") {
	                            return true;
	                        }
	                        break;
	
	                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;
	                    case "CallExpression":
	                        if (parent.callee !== node) {
	                            return false;
	                        }
	                        break;
	
	                    // EXCLUDES: e.g. cache[foo.a] = 0;
	                    case "MemberExpression":
	                        if (parent.property === node) {
	                            return false;
	                        }
	                        break;
	
	                    default:
	                        break;
	                }
	
	                node = parent;
	                parent = node.parent;
	            }
	
	            return false;
	        }
	
	        /**
	         * Reports a reference if is non initializer and writable.
	         * @param {Reference} reference - A reference to check.
	         * @param {int} index - The index of the reference in the references.
	         * @param {Reference[]} references - The array that the reference belongs to.
	         * @returns {void}
	         */
	        function checkReference(reference, index, references) {
	            const identifier = reference.identifier;
	
	            if (identifier &&
	                !reference.init &&
	
	                // Destructuring assignments can have multiple default value,
	                // so possibly there are multiple writeable references for the same identifier.
	                (index === 0 || references[index - 1].identifier !== identifier)
	            ) {
	                if (reference.isWrite()) {
	                    context.report(
	                        identifier,
	                        "Assignment to function parameter '{{name}}'.",
	                        {name: identifier.name});
	                } else if (props && isModifyingProp(reference)) {
	                    context.report(
	                        identifier,
	                        "Assignment to property of function parameter '{{name}}'.",
	                        {name: identifier.name});
	                }
	            }
	        }
	
	        /**
	         * Finds and reports references that are non initializer and writable.
	         * @param {Variable} variable - A variable to check.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            if (variable.defs[0].type === "Parameter") {
	                variable.references.forEach(checkReference);
	            }
	        }
	
	        /**
	         * Checks parameters of a given function node.
	         * @param {ASTNode} node - A function node to check.
	         * @returns {void}
	         */
	        function checkForFunction(node) {
	            context.getDeclaredVariables(node).forEach(checkVariable);
	        }
	
	        return {
	
	            // `:exit` is needed for the `node.parent` property of identifier nodes.
	            "FunctionDeclaration:exit": checkForFunction,
	            "FunctionExpression:exit": checkForFunction,
	            "ArrowFunctionExpression:exit": checkForFunction
	        };
	
	    }
	};


/***/ },
/* 268 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow string concatenation when using __dirname and __filename
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow string concatenation with `__dirname` and `__filename`",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        const MATCHER = /^__(?:dir|file)name$/;
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            BinaryExpression(node) {
	
	                const left = node.left,
	                    right = node.right;
	
	                if (node.operator === "+" &&
	                        ((left.type === "Identifier" && MATCHER.test(left.name)) ||
	                        (right.type === "Identifier" && MATCHER.test(right.name)))
	                ) {
	
	                    context.report(node, "Use path.join() or path.resolve() instead of + to create paths.");
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 269 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of unary increment and decrement operators.
	 * @author Ian Christian Myers
	 * @author Brody McKee (github.com/mrmckeb)
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the unary operators `++` and `--`",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowForLoopAfterthoughts: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const config = context.options[0];
	        let allowInForAfterthought = false;
	
	        if (typeof config === "object") {
	            allowInForAfterthought = config.allowForLoopAfterthoughts === true;
	        }
	
	        return {
	
	            UpdateExpression(node) {
	                if (allowInForAfterthought && node.parent.type === "ForStatement") {
	                    return;
	                }
	                context.report({
	                    node,
	                    message: "Unary operator '{{operator}}' used.",
	                    data: {
	                        operator: node.operator
	                    }
	                });
	            }
	
	        };
	
	    }
	};


/***/ },
/* 270 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow the use of process.env()
	 * @author Vignesh Anand
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `process.env`",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            MemberExpression(node) {
	                const objectName = node.object.name,
	                    propertyName = node.property.name;
	
	                if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
	                    context.report(node, "Unexpected use of process.env.");
	                }
	
	            }
	
	        };
	
	    }
	};


/***/ },
/* 271 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow the use of process.exit()
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `process.exit()`",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            CallExpression(node) {
	                const callee = node.callee;
	
	                if (callee.type === "MemberExpression" && callee.object.name === "process" &&
	                    callee.property.name === "exit"
	                ) {
	                    context.report(node, "Don't use process.exit(); throw an error instead.");
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 272 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag usage of __proto__ property
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of the `__proto__` property",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            MemberExpression(node) {
	
	                if (node.property &&
	                        (node.property.type === "Identifier" && node.property.name === "__proto__" && !node.computed) ||
	                        (node.property.type === "Literal" && node.property.value === "__proto__")) {
	                    context.report(node, "The '__proto__' property is deprecated.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 273 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of Object.prototype builtins on objects
	 * @author Andrew Levine
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow calling some `Object.prototype` methods directly on objects",
	            category: "Possible Errors",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const DISALLOWED_PROPS = [
	            "hasOwnProperty",
	            "isPrototypeOf",
	            "propertyIsEnumerable"
	        ];
	
	        /**
	         * Reports if a disallowed property is used in a CallExpression
	         * @param {ASTNode} node The CallExpression node.
	         * @returns {void}
	         */
	        function disallowBuiltIns(node) {
	            if (node.callee.type !== "MemberExpression" || node.callee.computed) {
	                return;
	            }
	            const propName = node.callee.property.name;
	
	            if (DISALLOWED_PROPS.indexOf(propName) > -1) {
	                context.report({
	                    message: "Do not access Object.prototype method '{{prop}}' from target object.",
	                    loc: node.callee.property.loc.start,
	                    data: {prop: propName},
	                    node
	                });
	            }
	        }
	
	        return {
	            CallExpression: disallowBuiltIns
	        };
	    }
	};


/***/ },
/* 274 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when the same variable is declared more then once.
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow variable redeclaration",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    builtinGlobals: {type: "boolean"}
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = {
	            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals)
	        };
	
	        /**
	         * Find variables in a given scope and flag redeclared ones.
	         * @param {Scope} scope - An escope scope object.
	         * @returns {void}
	         * @private
	         */
	        function findVariablesInScope(scope) {
	            scope.variables.forEach(function(variable) {
	                const hasBuiltin = options.builtinGlobals && "writeable" in variable;
	                const count = (hasBuiltin ? 1 : 0) + variable.identifiers.length;
	
	                if (count >= 2) {
	                    variable.identifiers.sort(function(a, b) {
	                        return a.range[1] - b.range[1];
	                    });
	
	                    for (let i = (hasBuiltin ? 0 : 1), l = variable.identifiers.length; i < l; i++) {
	                        context.report(
	                            variable.identifiers[i],
	                            "'{{a}}' is already defined.",
	                            {a: variable.name});
	                    }
	                }
	            });
	
	        }
	
	        /**
	         * Find variables in the current scope.
	         * @param {ASTNode} node - The Program node.
	         * @returns {void}
	         * @private
	         */
	        function checkForGlobal(node) {
	            const scope = context.getScope(),
	                parserOptions = context.parserOptions,
	                ecmaFeatures = parserOptions.ecmaFeatures || {};
	
	            // Nodejs env or modules has a special scope.
	            if (ecmaFeatures.globalReturn || node.sourceType === "module") {
	                findVariablesInScope(scope.childScopes[0]);
	            } else {
	                findVariablesInScope(scope);
	            }
	        }
	
	        /**
	         * Find variables in the current scope.
	         * @returns {void}
	         * @private
	         */
	        function checkForBlock() {
	            findVariablesInScope(context.getScope());
	        }
	
	        if (context.parserOptions.ecmaVersion >= 6) {
	            return {
	                Program: checkForGlobal,
	                BlockStatement: checkForBlock,
	                SwitchStatement: checkForBlock
	            };
	        } else {
	            return {
	                Program: checkForGlobal,
	                FunctionDeclaration: checkForBlock,
	                FunctionExpression: checkForBlock,
	                ArrowFunctionExpression: checkForBlock
	            };
	        }
	    }
	};


/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to count multiple spaces in regular expressions
	 * @author Matt DuVall <http://www.mattduvall.com/>
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow multiple spaces in regular expressions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Validate regular expressions
	         * @param {ASTNode} node node to validate
	         * @param {string} value regular expression to validate
	         * @param {number} valueStart The start location of the regex/string literal. It will always be the case that
	         `sourceCode.getText().slice(valueStart, valueStart + value.length) === value`
	         * @returns {void}
	         * @private
	         */
	        function checkRegex(node, value, valueStart) {
	            const multipleSpacesRegex = /( {2,})+?/,
	                regexResults = multipleSpacesRegex.exec(value);
	
	            if (regexResults !== null) {
	                const count = regexResults[0].length;
	
	                context.report({
	                    node,
	                    message: "Spaces are hard to count. Use {{{count}}}.",
	                    data: {count},
	                    fix(fixer) {
	                        return fixer.replaceTextRange(
	                            [valueStart + regexResults.index, valueStart + regexResults.index + count],
	                            ` {${count}}`
	                        );
	                    }
	                });
	
	                /*
	                 * TODO: (platinumazure) Fix message to use rule message
	                 * substitution when api.report is fixed in lib/eslint.js.
	                 */
	            }
	        }
	
	        /**
	         * Validate regular expression literals
	         * @param {ASTNode} node node to validate
	         * @returns {void}
	         * @private
	         */
	        function checkLiteral(node) {
	            const token = sourceCode.getFirstToken(node),
	                nodeType = token.type,
	                nodeValue = token.value;
	
	            if (nodeType === "RegularExpression") {
	                checkRegex(node, nodeValue, token.start);
	            }
	        }
	
	        /**
	         * Check if node is a string
	         * @param {ASTNode} node node to evaluate
	         * @returns {boolean} True if its a string
	         * @private
	         */
	        function isString(node) {
	            return node && node.type === "Literal" && typeof node.value === "string";
	        }
	
	        /**
	         * Validate strings passed to the RegExp constructor
	         * @param {ASTNode} node node to validate
	         * @returns {void}
	         * @private
	         */
	        function checkFunction(node) {
	            const scope = context.getScope();
	            const regExpVar = astUtils.getVariableByName(scope, "RegExp");
	            const shadowed = regExpVar && regExpVar.defs.length > 0;
	
	            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(node.arguments[0]) && !shadowed) {
	                checkRegex(node, node.arguments[0].value, node.arguments[0].start + 1);
	            }
	        }
	
	        return {
	            Literal: checkLiteral,
	            CallExpression: checkFunction,
	            NewExpression: checkFunction
	        };
	
	    }
	};


/***/ },
/* 276 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Restrict usage of specified globals.
	 * @author Benot Zugmeyer
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified global variables",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                type: "string"
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	        const restrictedGlobals = context.options;
	
	        // if no globals are restricted we don't need to check
	        if (restrictedGlobals.length === 0) {
	            return {};
	        }
	
	        /**
	         * Report a variable to be used as a restricted global.
	         * @param {Reference} reference the variable reference
	         * @returns {void}
	         * @private
	         */
	        function reportReference(reference) {
	            context.report(reference.identifier, "Unexpected use of '{{name}}'.", {
	                name: reference.identifier.name
	            });
	        }
	
	        /**
	         * Check if the given name is a restricted global name.
	         * @param {string} name name of a variable
	         * @returns {boolean} whether the variable is a restricted global or not
	         * @private
	         */
	        function isRestricted(name) {
	            return restrictedGlobals.indexOf(name) >= 0;
	        }
	
	        return {
	            Program() {
	                const scope = context.getScope();
	
	                // Report variables declared elsewhere (ex: variables defined as "global" by eslint)
	                scope.variables.forEach(function(variable) {
	                    if (!variable.defs.length && isRestricted(variable.name)) {
	                        variable.references.forEach(reportReference);
	                    }
	                });
	
	                // Report variables not declared at all
	                scope.through.forEach(function(reference) {
	                    if (isRestricted(reference.identifier.name)) {
	                        reportReference(reference);
	                    }
	                });
	
	            }
	        };
	    }
	};


/***/ },
/* 277 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Restrict usage of specified node imports.
	 * @author Guy Ellis
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified modules when loaded by `import`",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                type: "string"
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	        const restrictedImports = context.options;
	
	        // if no imports are restricted we don"t need to check
	        if (restrictedImports.length === 0) {
	            return {};
	        }
	
	        return {
	            ImportDeclaration(node) {
	                if (node && node.source && node.source.value) {
	
	                    const value = node.source.value.trim();
	
	                    if (restrictedImports.indexOf(value) !== -1) {
	                        context.report(node, "'{{importName}}' import is restricted from being used.", {
	                            importName: value
	                        });
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 278 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Restrict usage of specified node modules.
	 * @author Christian Schulz
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified modules when loaded by `require`",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                type: "string"
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	
	        // trim restricted module names
	        const restrictedModules = context.options;
	
	        // if no modules are restricted we don't need to check the CallExpressions
	        if (restrictedModules.length === 0) {
	            return {};
	        }
	
	        /**
	         * Function to check if a node is a string literal.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} If the node is a string literal.
	         */
	        function isString(node) {
	            return node && node.type === "Literal" && typeof node.value === "string";
	        }
	
	        /**
	         * Function to check if a node is a require call.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} If the node is a require call.
	         */
	        function isRequireCall(node) {
	            return node.callee.type === "Identifier" && node.callee.name === "require";
	        }
	
	        /**
	         * Function to check if a node has an argument that is an restricted module and return its name.
	         * @param {ASTNode} node The node to check
	         * @returns {undefined|string} restricted module name or undefined if node argument isn't restricted.
	         */
	        function getRestrictedModuleName(node) {
	            let moduleName;
	
	            // node has arguments and first argument is string
	            if (node.arguments.length && isString(node.arguments[0])) {
	                const argumentValue = node.arguments[0].value.trim();
	
	                // check if argument value is in restricted modules array
	                if (restrictedModules.indexOf(argumentValue) !== -1) {
	                    moduleName = argumentValue;
	                }
	            }
	
	            return moduleName;
	        }
	
	        return {
	            CallExpression(node) {
	                if (isRequireCall(node)) {
	                    const restrictedModuleName = getRestrictedModuleName(node);
	
	                    if (restrictedModuleName) {
	                        context.report(node, "'{{moduleName}}' module is restricted from being used.", {
	                            moduleName: restrictedModuleName
	                        });
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow certain object properties
	 * @author Will Klein & Eli White
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow certain properties on certain objects",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: {
	                anyOf: [ // `object` and `property` are both optional, but at least one of them must be provided.
	                    {
	                        type: "object",
	                        properties: {
	                            object: {
	                                type: "string"
	                            },
	                            property: {
	                                type: "string"
	                            },
	                            message: {
	                                type: "string"
	                            }
	                        },
	                        additionalProperties: false,
	                        required: ["object"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            object: {
	                                type: "string"
	                            },
	                            property: {
	                                type: "string"
	                            },
	                            message: {
	                                type: "string"
	                            }
	                        },
	                        additionalProperties: false,
	                        required: ["property"]
	                    }
	                ]
	            },
	            uniqueItems: true
	        }
	    },
	
	    create(context) {
	        const restrictedCalls = context.options;
	
	        if (restrictedCalls.length === 0) {
	            return {};
	        }
	
	        const restrictedProperties = new Map();
	        const globallyRestrictedObjects = new Map();
	        const globallyRestrictedProperties = new Map();
	
	        restrictedCalls.forEach(option => {
	            const objectName = option.object;
	            const propertyName = option.property;
	
	            if (typeof objectName === "undefined") {
	                globallyRestrictedProperties.set(propertyName, {message: option.message});
	            } else if (typeof propertyName === "undefined") {
	                globallyRestrictedObjects.set(objectName, {message: option.message});
	            } else {
	                if (!restrictedProperties.has(objectName)) {
	                    restrictedProperties.set(objectName, new Map());
	                }
	
	                restrictedProperties.get(objectName).set(propertyName, {
	                    message: option.message
	                });
	            }
	        });
	
	        /**
	        * Checks to see whether a property access is restricted, and reports it if so.
	        * @param {ASTNode} node The node to report
	        * @param {string} objectName The name of the object
	        * @param {string} propertyName The name of the property
	        * @returns {undefined}
	        */
	        function checkPropertyAccess(node, objectName, propertyName) {
	            if (propertyName === null) {
	                return;
	            }
	            const matchedObject = restrictedProperties.get(objectName);
	            const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
	            const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);
	
	            if (matchedObjectProperty) {
	                const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
	
	                context.report(node, "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}", {
	                    objectName,
	                    propertyName,
	                    message
	                });
	            } else if (globalMatchedProperty) {
	                const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
	
	                context.report(node, "'{{propertyName}}' is restricted from being used.{{message}}", {
	                    propertyName,
	                    message
	                });
	            }
	        }
	
	        /**
	        * Checks property accesses in a destructuring assignment expression, e.g. `var foo; ({foo} = bar);`
	        * @param {ASTNode} node An AssignmentExpression or AssignmentPattern node
	        * @returns {undefined}
	        */
	        function checkDestructuringAssignment(node) {
	            if (node.right.type === "Identifier") {
	                const objectName = node.right.name;
	
	                if (node.left.type === "ObjectPattern") {
	                    node.left.properties.forEach(property => {
	                        checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
	                    });
	                }
	            }
	        }
	
	        return {
	            MemberExpression(node) {
	                checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
	            },
	            VariableDeclarator(node) {
	                if (node.init && node.init.type === "Identifier") {
	                    const objectName = node.init.name;
	
	                    if (node.id.type === "ObjectPattern") {
	                        node.id.properties.forEach(property => {
	                            checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
	                        });
	                    }
	                }
	            },
	            AssignmentExpression: checkDestructuringAssignment,
	            AssignmentPattern: checkDestructuringAssignment
	        };
	    }
	};


/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of certain node types
	 * @author Burak Yigit Kaya
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const nodeTypes = __webpack_require__(230).Syntax;
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified syntax",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: {
	            type: "array",
	            items: [
	                {
	                    enum: Object.keys(nodeTypes).map(function(k) {
	                        return nodeTypes[k];
	                    })
	                }
	            ],
	            uniqueItems: true,
	            minItems: 0
	        }
	    },
	
	    create(context) {
	
	        /**
	         * Generates a warning from the provided node, saying that node type is not allowed.
	         * @param {ASTNode} node The node to warn on
	         * @returns {void}
	         */
	        function warn(node) {
	            context.report(node, "Using '{{type}}' is not allowed.", node);
	        }
	
	        return context.options.reduce(function(result, nodeType) {
	            result[nodeType] = warn;
	
	            return result;
	        }, {});
	
	    }
	};


/***/ },
/* 281 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when return statement contains assignment
	 * @author Ilya Volodin
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;
	
	/**
	 * Checks whether or not a node is enclosed in parentheses.
	 * @param {Node|null} node - A node to check.
	 * @param {sourceCode} sourceCode - The ESLint SourceCode object.
	 * @returns {boolean} Whether or not the node is enclosed in parentheses.
	 */
	function isEnclosedInParens(node, sourceCode) {
	    const prevToken = sourceCode.getTokenBefore(node);
	    const nextToken = sourceCode.getTokenAfter(node);
	
	    return prevToken && prevToken.value === "(" && nextToken && nextToken.value === ")";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow assignment operators in `return` statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["except-parens", "always"]
	            }
	        ]
	    },
	
	    create(context) {
	        const always = (context.options[0] || "except-parens") !== "except-parens";
	        const sourceCode = context.getSourceCode();
	
	        return {
	            AssignmentExpression(node) {
	                if (!always && isEnclosedInParens(node, sourceCode)) {
	                    return;
	                }
	
	                let parent = node.parent;
	
	                // Find ReturnStatement or ArrowFunctionExpression in ancestors.
	                while (parent && !SENTINEL_TYPE.test(parent.type)) {
	                    node = parent;
	                    parent = parent.parent;
	                }
	
	                // Reports.
	                if (parent && parent.type === "ReturnStatement") {
	                    context.report({
	                        node: parent,
	                        message: "Return statement should not contain assignment."
	                    });
	                } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === node) {
	                    context.report({
	                        node: parent,
	                        message: "Arrow function should not return assignment."
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 282 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when using javascript: urls
	 * @author Ilya Volodin
	 */
	/* jshint scripturl: true */
	/* eslint no-script-url: 0 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `javascript:` urls",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            Literal(node) {
	                if (node.value && typeof node.value === "string") {
	                    const value = node.value.toLowerCase();
	
	                    if (value.indexOf("javascript:") === 0) {
	                        context.report(node, "Script URL is a form of eval.");
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow assignments where both sides are exactly the same
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const SPACES = /\s+/g;
	
	/**
	 * Checks whether the property of 2 given member expression nodes are the same
	 * property or not.
	 *
	 * @param {ASTNode} left - A member expression node to check.
	 * @param {ASTNode} right - Another member expression node to check.
	 * @returns {boolean} `true` if the member expressions have the same property.
	 */
	function isSameProperty(left, right) {
	    if (left.property.type === "Identifier" &&
	        left.property.type === right.property.type &&
	        left.property.name === right.property.name &&
	        left.computed === right.computed
	    ) {
	        return true;
	    }
	
	    const lname = astUtils.getStaticPropertyName(left);
	    const rname = astUtils.getStaticPropertyName(right);
	
	    return lname !== null && lname === rname;
	}
	
	/**
	 * Checks whether 2 given member expression nodes are the reference to the same
	 * property or not.
	 *
	 * @param {ASTNode} left - A member expression node to check.
	 * @param {ASTNode} right - Another member expression node to check.
	 * @returns {boolean} `true` if the member expressions are the reference to the
	 *  same property or not.
	 */
	function isSameMember(left, right) {
	    if (!isSameProperty(left, right)) {
	        return false;
	    }
	
	    const lobj = left.object;
	    const robj = right.object;
	
	    if (lobj.type !== robj.type) {
	        return false;
	    }
	    if (lobj.type === "MemberExpression") {
	        return isSameMember(lobj, robj);
	    }
	    return lobj.type === "Identifier" && lobj.name === robj.name;
	}
	
	/**
	 * Traverses 2 Pattern nodes in parallel, then reports self-assignments.
	 *
	 * @param {ASTNode|null} left - A left node to traverse. This is a Pattern or
	 *      a Property.
	 * @param {ASTNode|null} right - A right node to traverse. This is a Pattern or
	 *      a Property.
	 * @param {boolean} props - The flag to check member expressions as well.
	 * @param {Function} report - A callback function to report.
	 * @returns {void}
	 */
	function eachSelfAssignment(left, right, props, report) {
	    if (!left || !right) {
	
	        // do nothing
	    } else if (
	        left.type === "Identifier" &&
	        right.type === "Identifier" &&
	        left.name === right.name
	    ) {
	        report(right);
	    } else if (
	        left.type === "ArrayPattern" &&
	        right.type === "ArrayExpression"
	    ) {
	        const end = Math.min(left.elements.length, right.elements.length);
	
	        for (let i = 0; i < end; ++i) {
	            const rightElement = right.elements[i];
	
	            eachSelfAssignment(left.elements[i], rightElement, props, report);
	
	            // After a spread element, those indices are unknown.
	            if (rightElement && rightElement.type === "SpreadElement") {
	                break;
	            }
	        }
	    } else if (
	        left.type === "RestElement" &&
	        right.type === "SpreadElement"
	    ) {
	        eachSelfAssignment(left.argument, right.argument, props, report);
	    } else if (
	        left.type === "ObjectPattern" &&
	        right.type === "ObjectExpression" &&
	        right.properties.length >= 1
	    ) {
	
	        // Gets the index of the last spread property.
	        // It's possible to overwrite properties followed by it.
	        let startJ = 0;
	
	        for (let i = right.properties.length - 1; i >= 0; --i) {
	            if (right.properties[i].type === "ExperimentalSpreadProperty") {
	                startJ = i + 1;
	                break;
	            }
	        }
	
	        for (let i = 0; i < left.properties.length; ++i) {
	            for (let j = startJ; j < right.properties.length; ++j) {
	                eachSelfAssignment(
	                    left.properties[i],
	                    right.properties[j],
	                    props,
	                    report
	                );
	            }
	        }
	    } else if (
	        left.type === "Property" &&
	        right.type === "Property" &&
	        !left.computed &&
	        !right.computed &&
	        right.kind === "init" &&
	        !right.method &&
	        left.key.name === right.key.name
	    ) {
	        eachSelfAssignment(left.value, right.value, props, report);
	    } else if (
	        props &&
	        left.type === "MemberExpression" &&
	        right.type === "MemberExpression" &&
	        isSameMember(left, right)
	    ) {
	        report(right);
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow assignments where both sides are exactly the same",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    props: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const options = context.options[0];
	        const props = Boolean(options && options.props);
	
	        /**
	         * Reports a given node as self assignments.
	         *
	         * @param {ASTNode} node - A node to report. This is an Identifier node.
	         * @returns {void}
	         */
	        function report(node) {
	            context.report({
	                node,
	                message: "'{{name}}' is assigned to itself.",
	                data: {
	                    name: sourceCode.getText(node).replace(SPACES, "")
	                }
	            });
	        }
	
	        return {
	            AssignmentExpression(node) {
	                if (node.operator === "=") {
	                    eachSelfAssignment(node.left, node.right, props, report);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 284 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparison where left part is the same as the right
	 * part.
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow comparisons where both sides are exactly the same",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            BinaryExpression(node) {
	                const operators = ["===", "==", "!==", "!=", ">", "<", ">=", "<="];
	
	                if (operators.indexOf(node.operator) > -1 &&
	                    (node.left.type === "Identifier" && node.right.type === "Identifier" && node.left.name === node.right.name ||
	                    node.left.type === "Literal" && node.right.type === "Literal" && node.left.value === node.right.value)) {
	                    context.report(node, "Comparing to itself is potentially pointless.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 285 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of comma operator
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow comma operators",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Parts of the grammar that are required to have parens.
	         */
	        const parenthesized = {
	            DoWhileStatement: "test",
	            IfStatement: "test",
	            SwitchStatement: "discriminant",
	            WhileStatement: "test",
	            WithStatement: "object",
	            ArrowFunctionExpression: "body"
	
	            // Omitting CallExpression - commas are parsed as argument separators
	            // Omitting NewExpression - commas are parsed as argument separators
	            // Omitting ForInStatement - parts aren't individually parenthesised
	            // Omitting ForStatement - parts aren't individually parenthesised
	        };
	
	        /**
	         * Determines whether a node is required by the grammar to be wrapped in
	         * parens, e.g. the test of an if statement.
	         * @param {ASTNode} node - The AST node
	         * @returns {boolean} True if parens around node belong to parent node.
	         */
	        function requiresExtraParens(node) {
	            return node.parent && parenthesized[node.parent.type] &&
	                    node === node.parent[parenthesized[node.parent.type]];
	        }
	
	        /**
	         * Check if a node is wrapped in parens.
	         * @param {ASTNode} node - The AST node
	         * @returns {boolean} True if the node has a paren on each side.
	         */
	        function isParenthesised(node) {
	            const previousToken = sourceCode.getTokenBefore(node),
	                nextToken = sourceCode.getTokenAfter(node);
	
	            return previousToken && nextToken &&
	                previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	                nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	        }
	
	        /**
	         * Check if a node is wrapped in two levels of parens.
	         * @param {ASTNode} node - The AST node
	         * @returns {boolean} True if two parens surround the node on each side.
	         */
	        function isParenthesisedTwice(node) {
	            const previousToken = sourceCode.getTokenBefore(node, 1),
	                nextToken = sourceCode.getTokenAfter(node, 1);
	
	            return isParenthesised(node) && previousToken && nextToken &&
	                previousToken.value === "(" && previousToken.range[1] <= node.range[0] &&
	                nextToken.value === ")" && nextToken.range[0] >= node.range[1];
	        }
	
	        return {
	            SequenceExpression(node) {
	
	                // Always allow sequences in for statement update
	                if (node.parent.type === "ForStatement" &&
	                        (node === node.parent.init || node === node.parent.update)) {
	                    return;
	                }
	
	                // Wrapping a sequence in extra parens indicates intent
	                if (requiresExtraParens(node)) {
	                    if (isParenthesisedTwice(node)) {
	                        return;
	                    }
	                } else {
	                    if (isParenthesised(node)) {
	                        return;
	                    }
	                }
	
	                const child = sourceCode.getTokenAfter(node.expressions[0]);
	
	                context.report(node, child.loc.start, "Unexpected use of comma operator.");
	            }
	        };
	
	    }
	};


/***/ },
/* 286 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow shadowing of NaN, undefined, and Infinity (ES5 section 15.1.1)
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow identifiers from shadowing restricted names",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        const RESTRICTED = ["undefined", "NaN", "Infinity", "arguments", "eval"];
	
	        /**
	         * Check if the node name is present inside the restricted list
	         * @param {ASTNode} id id to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkForViolation(id) {
	            if (RESTRICTED.indexOf(id.name) > -1) {
	                context.report({
	                    node: id,
	                    message: "Shadowing of global property '{{idName}}'.",
	                    data: {
	                        idName: id.name
	                    }
	                });
	            }
	        }
	
	        return {
	            VariableDeclarator(node) {
	                checkForViolation(node.id);
	            },
	            ArrowFunctionExpression(node) {
	                [].map.call(node.params, checkForViolation);
	            },
	            FunctionExpression(node) {
	                if (node.id) {
	                    checkForViolation(node.id);
	                }
	                [].map.call(node.params, checkForViolation);
	            },
	            FunctionDeclaration(node) {
	                if (node.id) {
	                    checkForViolation(node.id);
	                    [].map.call(node.params, checkForViolation);
	                }
	            },
	            CatchClause(node) {
	                checkForViolation(node.param);
	            }
	        };
	
	    }
	};


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag on declaring variables already declared in the outer scope
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow variable declarations from shadowing variables declared in the outer scope",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    builtinGlobals: {type: "boolean"},
	                    hoist: {enum: ["all", "functions", "never"]},
	                    allow: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const options = {
	            builtinGlobals: Boolean(context.options[0] && context.options[0].builtinGlobals),
	            hoist: (context.options[0] && context.options[0].hoist) || "functions",
	            allow: (context.options[0] && context.options[0].allow) || []
	        };
	
	        /**
	         * Check if variable name is allowed.
	         *
	         * @param  {ASTNode} variable The variable to check.
	         * @returns {boolean} Whether or not the variable name is allowed.
	         */
	        function isAllowed(variable) {
	            return options.allow.indexOf(variable.name) !== -1;
	        }
	
	        /**
	         * Checks if a variable of the class name in the class scope of ClassDeclaration.
	         *
	         * ClassDeclaration creates two variables of its name into its outer scope and its class scope.
	         * So we should ignore the variable in the class scope.
	         *
	         * @param {Object} variable The variable to check.
	         * @returns {boolean} Whether or not the variable of the class name in the class scope of ClassDeclaration.
	         */
	        function isDuplicatedClassNameVariable(variable) {
	            const block = variable.scope.block;
	
	            return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
	        }
	
	        /**
	         * Checks if a variable is inside the initializer of scopeVar.
	         *
	         * To avoid reporting at declarations such as `var a = function a() {};`.
	         * But it should report `var a = function(a) {};` or `var a = function() { function a() {} };`.
	         *
	         * @param {Object} variable The variable to check.
	         * @param {Object} scopeVar The scope variable to look for.
	         * @returns {boolean} Whether or not the variable is inside initializer of scopeVar.
	         */
	        function isOnInitializer(variable, scopeVar) {
	            const outerScope = scopeVar.scope;
	            const outerDef = scopeVar.defs[0];
	            const outer = outerDef && outerDef.parent && outerDef.parent.range;
	            const innerScope = variable.scope;
	            const innerDef = variable.defs[0];
	            const inner = innerDef && innerDef.name.range;
	
	            return (
	                outer &&
	                inner &&
	                outer[0] < inner[0] &&
	                inner[1] < outer[1] &&
	                ((innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression") || innerDef.node.type === "ClassExpression") &&
	                outerScope === innerScope.upper
	            );
	        }
	
	        /**
	         * Get a range of a variable's identifier node.
	         * @param {Object} variable The variable to get.
	         * @returns {Array|undefined} The range of the variable's identifier node.
	         */
	        function getNameRange(variable) {
	            const def = variable.defs[0];
	
	            return def && def.name.range;
	        }
	
	        /**
	         * Checks if a variable is in TDZ of scopeVar.
	         * @param {Object} variable The variable to check.
	         * @param {Object} scopeVar The variable of TDZ.
	         * @returns {boolean} Whether or not the variable is in TDZ of scopeVar.
	         */
	        function isInTdz(variable, scopeVar) {
	            const outerDef = scopeVar.defs[0];
	            const inner = getNameRange(variable);
	            const outer = getNameRange(scopeVar);
	
	            return (
	                inner &&
	                outer &&
	                inner[1] < outer[0] &&
	
	                // Excepts FunctionDeclaration if is {"hoist":"function"}.
	                (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration")
	            );
	        }
	
	        /**
	         * Checks the current context for shadowed variables.
	         * @param {Scope} scope - Fixme
	         * @returns {void}
	         */
	        function checkForShadows(scope) {
	            const variables = scope.variables;
	
	            for (let i = 0; i < variables.length; ++i) {
	                const variable = variables[i];
	
	                // Skips "arguments" or variables of a class name in the class scope of ClassDeclaration.
	                if (variable.identifiers.length === 0 ||
	                    isDuplicatedClassNameVariable(variable) ||
	                    isAllowed(variable)
	                ) {
	                    continue;
	                }
	
	                // Gets shadowed variable.
	                const shadowed = astUtils.getVariableByName(scope.upper, variable.name);
	
	                if (shadowed &&
	                    (shadowed.identifiers.length > 0 || (options.builtinGlobals && "writeable" in shadowed)) &&
	                    !isOnInitializer(variable, shadowed) &&
	                    !(options.hoist !== "all" && isInTdz(variable, shadowed))
	                ) {
	                    context.report({
	                        node: variable.identifiers[0],
	                        message: "'{{name}}' is already declared in the upper scope.",
	                        data: variable
	                    });
	                }
	            }
	        }
	
	        return {
	            "Program:exit"() {
	                const globalScope = context.getScope();
	                const stack = globalScope.childScopes.slice();
	
	                while (stack.length) {
	                    const scope = stack.pop();
	
	                    stack.push.apply(stack, scope.childScopes);
	                    checkForShadows(scope);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 288 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check that spaced function application
	 * @author Matt DuVall <http://www.mattduvall.com>
	 * @deprecated in ESLint v3.3.0
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow spacing between function identifiers and their applications (deprecated)",
	            category: "Stylistic Issues",
	            recommended: false,
	            replacedBy: ["func-call-spacing"]
	        },
	
	        deprecated: true,
	
	        fixable: "whitespace",
	        schema: []
	    },
	
	    create(context) {
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Check if open space is present in a function name
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function detectOpenSpaces(node) {
	            const lastCalleeToken = sourceCode.getLastToken(node.callee);
	            let prevToken = lastCalleeToken,
	                parenToken = sourceCode.getTokenAfter(lastCalleeToken);
	
	            // advances to an open parenthesis.
	            while (
	                parenToken &&
	                parenToken.range[1] < node.range[1] &&
	                parenToken.value !== "("
	            ) {
	                prevToken = parenToken;
	                parenToken = sourceCode.getTokenAfter(parenToken);
	            }
	
	            // look for a space between the callee and the open paren
	            if (parenToken &&
	                parenToken.range[1] < node.range[1] &&
	                sourceCode.isSpaceBetweenTokens(prevToken, parenToken)
	            ) {
	                context.report({
	                    node,
	                    loc: lastCalleeToken.loc.start,
	                    message: "Unexpected space between function name and paren.",
	                    fix(fixer) {
	                        return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
	                    }
	                });
	            }
	        }
	
	        return {
	            CallExpression: detectOpenSpaces,
	            NewExpression: detectOpenSpaces
	        };
	
	    }
	};


/***/ },
/* 289 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow sparse arrays
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow sparse arrays",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            ArrayExpression(node) {
	
	                const emptySpot = node.elements.indexOf(null) > -1;
	
	                if (emptySpot) {
	                    context.report(node, "Unexpected comma in middle of array.");
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 290 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for properties whose identifier ends with the string Sync
	 * @author Matt DuVall<http://mattduvall.com/>
	 */
	
	/* jshint node:true */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow synchronous methods",
	            category: "Node.js and CommonJS",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            MemberExpression(node) {
	                const propertyName = node.property.name,
	                    syncRegex = /.*Sync$/;
	
	                if (syncRegex.exec(propertyName) !== null) {
	                    context.report({
	                        node,
	                        message: "Unexpected sync method: '{{propertyName}}'.",
	                        data: {
	                            propertyName
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 291 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for tabs inside a file
	 * @author Gyandeep Singh
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	const regex = /\t/;
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow tabs in file",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        schema: []
	    },
	
	    create(context) {
	        return {
	            Program(node) {
	                context.getSourceLines().forEach((line, index) => {
	                    const match = regex.exec(line);
	
	                    if (match) {
	                        context.report(
	                            node,
	                            {
	                                line: index + 1,
	                                column: match.index + 1
	                            },
	                            "Unexpected tab character."
	                        );
	                    }
	                });
	            }
	        };
	    }
	};


/***/ },
/* 292 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Warn when using template string syntax in regular strings
	 * @author Jeroen Engels
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow template literal placeholder syntax in regular strings",
	            category: "Possible Errors",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const regex = /\$\{[^}]+\}/;
	
	        return {
	            Literal(node) {
	                if (typeof node.value === "string" && regex.test(node.value)) {
	                    context.report({
	                        node,
	                        message: "Unexpected template string expression."
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 293 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of ternary operators.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow ternary operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            ConditionalExpression(node) {
	                context.report(node, "Ternary operator used.");
	            }
	
	        };
	
	    }
	};


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow using `this`/`super` before `super()`.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is a constructor.
	 * @param {ASTNode} node - A node to check. This node type is one of
	 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
	 *   `ArrowFunctionExpression`.
	 * @returns {boolean} `true` if the node is a constructor.
	 */
	function isConstructorFunction(node) {
	    return (
	        node.type === "FunctionExpression" &&
	        node.parent.type === "MethodDefinition" &&
	        node.parent.kind === "constructor"
	    );
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `this`/`super` before calling `super()` in constructors",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /*
	         * Information for each constructor.
	         * - upper:      Information of the upper constructor.
	         * - hasExtends: A flag which shows whether the owner class has a valid
	         *   `extends` part.
	         * - scope:      The scope of the owner class.
	         * - codePath:   The code path of this constructor.
	         */
	        let funcInfo = null;
	
	        /*
	         * Information for each code path segment.
	         * Each key is the id of a code path segment.
	         * Each value is an object:
	         * - superCalled:  The flag which shows `super()` called in all code paths.
	         * - invalidNodes: The array of invalid ThisExpression and Super nodes.
	         */
	        let segInfoMap = Object.create(null);
	
	        /**
	         * Gets whether or not `super()` is called in a given code path segment.
	         * @param {CodePathSegment} segment - A code path segment to get.
	         * @returns {boolean} `true` if `super()` is called.
	         */
	        function isCalled(segment) {
	            return !segment.reachable || segInfoMap[segment.id].superCalled;
	        }
	
	        /**
	         * Checks whether or not this is in a constructor.
	         * @returns {boolean} `true` if this is in a constructor.
	         */
	        function isInConstructorOfDerivedClass() {
	            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
	        }
	
	        /**
	         * Checks whether or not this is before `super()` is called.
	         * @returns {boolean} `true` if this is before `super()` is called.
	         */
	        function isBeforeCallOfSuper() {
	            return (
	                isInConstructorOfDerivedClass(funcInfo) &&
	                !funcInfo.codePath.currentSegments.every(isCalled)
	            );
	        }
	
	        /**
	         * Sets a given node as invalid.
	         * @param {ASTNode} node - A node to set as invalid. This is one of
	         *      a ThisExpression and a Super.
	         * @returns {void}
	         */
	        function setInvalid(node) {
	            const segments = funcInfo.codePath.currentSegments;
	
	            for (let i = 0; i < segments.length; ++i) {
	                const segment = segments[i];
	
	                if (segment.reachable) {
	                    segInfoMap[segment.id].invalidNodes.push(node);
	                }
	            }
	        }
	
	        /**
	         * Sets the current segment as `super` was called.
	         * @returns {void}
	         */
	        function setSuperCalled() {
	            const segments = funcInfo.codePath.currentSegments;
	
	            for (let i = 0; i < segments.length; ++i) {
	                const segment = segments[i];
	
	                if (segment.reachable) {
	                    segInfoMap[segment.id].superCalled = true;
	                }
	            }
	        }
	
	        return {
	
	            /**
	             * Adds information of a constructor into the stack.
	             * @param {CodePath} codePath - A code path which was started.
	             * @param {ASTNode} node - The current node.
	             * @returns {void}
	             */
	            onCodePathStart(codePath, node) {
	                if (isConstructorFunction(node)) {
	
	                    // Class > ClassBody > MethodDefinition > FunctionExpression
	                    const classNode = node.parent.parent.parent;
	
	                    funcInfo = {
	                        upper: funcInfo,
	                        isConstructor: true,
	                        hasExtends: Boolean(
	                            classNode.superClass &&
	                            !astUtils.isNullOrUndefined(classNode.superClass)
	                        ),
	                        codePath
	                    };
	                } else {
	                    funcInfo = {
	                        upper: funcInfo,
	                        isConstructor: false,
	                        hasExtends: false,
	                        codePath
	                    };
	                }
	            },
	
	            /**
	             * Removes the top of stack item.
	             *
	             * And this treverses all segments of this code path then reports every
	             * invalid node.
	             *
	             * @param {CodePath} codePath - A code path which was ended.
	             * @param {ASTNode} node - The current node.
	             * @returns {void}
	             */
	            onCodePathEnd(codePath) {
	                const isDerivedClass = funcInfo.hasExtends;
	
	                funcInfo = funcInfo.upper;
	                if (!isDerivedClass) {
	                    return;
	                }
	
	                codePath.traverseSegments(function(segment, controller) {
	                    const info = segInfoMap[segment.id];
	
	                    for (let i = 0; i < info.invalidNodes.length; ++i) {
	                        const invalidNode = info.invalidNodes[i];
	
	                        context.report({
	                            message: "'{{kind}}' is not allowed before 'super()'.",
	                            node: invalidNode,
	                            data: {
	                                kind: invalidNode.type === "Super" ? "super" : "this"
	                            }
	                        });
	                    }
	
	                    if (info.superCalled) {
	                        controller.skip();
	                    }
	                });
	            },
	
	            /**
	             * Initialize information of a given code path segment.
	             * @param {CodePathSegment} segment - A code path segment to initialize.
	             * @returns {void}
	             */
	            onCodePathSegmentStart(segment) {
	                if (!isInConstructorOfDerivedClass(funcInfo)) {
	                    return;
	                }
	
	                // Initialize info.
	                segInfoMap[segment.id] = {
	                    superCalled: (
	                        segment.prevSegments.length > 0 &&
	                        segment.prevSegments.every(isCalled)
	                    ),
	                    invalidNodes: []
	                };
	            },
	
	            /**
	             * Update information of the code path segment when a code path was
	             * looped.
	             * @param {CodePathSegment} fromSegment - The code path segment of the
	             *      end of a loop.
	             * @param {CodePathSegment} toSegment - A code path segment of the head
	             *      of a loop.
	             * @returns {void}
	             */
	            onCodePathSegmentLoop(fromSegment, toSegment) {
	                if (!isInConstructorOfDerivedClass(funcInfo)) {
	                    return;
	                }
	
	                // Update information inside of the loop.
	                funcInfo.codePath.traverseSegments(
	                    {first: toSegment, last: fromSegment},
	                    function(segment, controller) {
	                        const info = segInfoMap[segment.id];
	
	                        if (info.superCalled) {
	                            info.invalidNodes = [];
	                            controller.skip();
	                        } else if (
	                            segment.prevSegments.length > 0 &&
	                            segment.prevSegments.every(isCalled)
	                        ) {
	                            info.superCalled = true;
	                            info.invalidNodes = [];
	                        }
	                    }
	                );
	            },
	
	            /**
	             * Reports if this is before `super()`.
	             * @param {ASTNode} node - A target node.
	             * @returns {void}
	             */
	            ThisExpression(node) {
	                if (isBeforeCallOfSuper()) {
	                    setInvalid(node);
	                }
	            },
	
	            /**
	             * Reports if this is before `super()`.
	             * @param {ASTNode} node - A target node.
	             * @returns {void}
	             */
	            Super(node) {
	                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
	                    setInvalid(node);
	                }
	            },
	
	            /**
	             * Marks `super()` called.
	             * @param {ASTNode} node - A target node.
	             * @returns {void}
	             */
	            "CallExpression:exit"(node) {
	                if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
	                    setSuperCalled();
	                }
	            },
	
	            /**
	             * Resets state.
	             * @returns {void}
	             */
	            "Program:exit"() {
	                segInfoMap = Object.create(null);
	            }
	        };
	    }
	};


/***/ },
/* 295 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to restrict what can be thrown as an exception.
	 * @author Dieter Oberkofler
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Determine if a node has a possiblity to be an Error object
	 * @param  {ASTNode}  node  ASTNode to check
	 * @returns {boolean}       True if there is a chance it contains an Error obj
	 */
	function couldBeError(node) {
	    switch (node.type) {
	        case "Identifier":
	        case "CallExpression":
	        case "NewExpression":
	        case "MemberExpression":
	        case "TaggedTemplateExpression":
	        case "YieldExpression":
	            return true; // possibly an error object.
	
	        case "AssignmentExpression":
	            return couldBeError(node.right);
	
	        case "SequenceExpression": {
	            const exprs = node.expressions;
	
	            return exprs.length !== 0 && couldBeError(exprs[exprs.length - 1]);
	        }
	
	        case "LogicalExpression":
	            return couldBeError(node.left) || couldBeError(node.right);
	
	        case "ConditionalExpression":
	            return couldBeError(node.consequent) || couldBeError(node.alternate);
	
	        default:
	            return false;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow throwing literals as exceptions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            ThrowStatement(node) {
	                if (!couldBeError(node.argument)) {
	                    context.report(node, "Expected an object to be thrown.");
	                } else if (node.argument.type === "Identifier") {
	                    if (node.argument.name === "undefined") {
	                        context.report(node, "Do not throw undefined.");
	                    }
	                }
	
	            }
	
	        };
	
	    }
	};


/***/ },
/* 296 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow trailing spaces at the end of lines.
	 * @author Nodeca Team <https://github.com/nodeca>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow trailing whitespace at the end of lines",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    skipBlankLines: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        const BLANK_CLASS = "[ \t\u00a0\u2000-\u200b\u2028\u2029\u3000]",
	            SKIP_BLANK = `^${BLANK_CLASS}*$`,
	            NONBLANK = `${BLANK_CLASS}+$`;
	
	        const options = context.options[0] || {},
	            skipBlankLines = options.skipBlankLines || false;
	
	        /**
	         * Report the error message
	         * @param {ASTNode} node node to report
	         * @param {int[]} location range information
	         * @param {int[]} fixRange Range based on the whole program
	         * @returns {void}
	         */
	        function report(node, location, fixRange) {
	
	            /*
	             * Passing node is a bit dirty, because message data will contain big
	             * text in `source`. But... who cares :) ?
	             * One more kludge will not make worse the bloody wizardry of this
	             * plugin.
	             */
	            context.report({
	                node,
	                loc: location,
	                message: "Trailing spaces not allowed.",
	                fix(fixer) {
	                    return fixer.removeRange(fixRange);
	                }
	            });
	        }
	
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            Program: function checkTrailingSpaces(node) {
	
	                // Let's hack. Since Espree does not return whitespace nodes,
	                // fetch the source code and do matching via regexps.
	
	                const re = new RegExp(NONBLANK),
	                    skipMatch = new RegExp(SKIP_BLANK),
	                    lines = sourceCode.lines,
	                    linebreaks = sourceCode.getText().match(/\r\n|\r|\n|\u2028|\u2029/g);
	                let totalLength = 0,
	                    fixRange = [];
	
	                for (let i = 0, ii = lines.length; i < ii; i++) {
	                    const matches = re.exec(lines[i]);
	
	                    // Always add linebreak length to line length to accommodate for line break (\n or \r\n)
	                    // Because during the fix time they also reserve one spot in the array.
	                    // Usually linebreak length is 2 for \r\n (CRLF) and 1 for \n (LF)
	                    const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
	                    const lineLength = lines[i].length + linebreakLength;
	
	                    if (matches) {
	                        const location = {
	                            line: i + 1,
	                            column: matches.index
	                        };
	
	                        const rangeStart = totalLength + location.column;
	                        const rangeEnd = totalLength + lineLength - linebreakLength;
	                        const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
	
	                        if (containingNode && containingNode.type === "TemplateElement" &&
	                          rangeStart > containingNode.parent.range[0] &&
	                          rangeEnd < containingNode.parent.range[1]) {
	                            totalLength += lineLength;
	                            continue;
	                        }
	
	                        // If the line has only whitespace, and skipBlankLines
	                        // is true, don't report it
	                        if (skipBlankLines && skipMatch.test(lines[i])) {
	                            totalLength += lineLength;
	                            continue;
	                        }
	
	                        fixRange = [rangeStart, rangeEnd];
	                        report(node, location, fixRange);
	                    }
	
	                    totalLength += lineLength;
	                }
	            }
	
	        };
	    }
	};


/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag when initializing to undefined
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow initializing variables to `undefined`",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const sourceCode = context.getSourceCode();
	
	        return {
	
	            VariableDeclarator(node) {
	                const name = sourceCode.getText(node.id),
	                    init = node.init && node.init.name,
	                    scope = context.getScope(),
	                    undefinedVar = astUtils.getVariableByName(scope, "undefined"),
	                    shadowed = undefinedVar && undefinedVar.defs.length > 0;
	
	                if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
	                    context.report({
	                        node,
	                        message: "It's not necessary to initialize '{{name}}' to undefined.",
	                        data: {name},
	                        fix(fixer) {
	                            if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
	
	                                // Don't fix destructuring assignment to `undefined`.
	                                return null;
	                            }
	                            return fixer.removeRange([node.id.range[1], node.range[1]]);
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 298 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag references to undeclared variables.
	 * @author Mark Macdonald
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks if the given node is the argument of a typeof operator.
	 * @param {ASTNode} node The AST node being checked.
	 * @returns {boolean} Whether or not the node is the argument of a typeof operator.
	 */
	function hasTypeOfOperator(node) {
	    const parent = node.parent;
	
	    return parent.type === "UnaryExpression" && parent.operator === "typeof";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
	            category: "Variables",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    typeof: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0];
	        const considerTypeOf = options && options.typeof === true || false;
	
	        return {
	            "Program:exit"(/* node */) {
	                const globalScope = context.getScope();
	
	                globalScope.through.forEach(function(ref) {
	                    const identifier = ref.identifier;
	
	                    if (!considerTypeOf && hasTypeOfOperator(identifier)) {
	                        return;
	                    }
	
	                    context.report({
	                        node: identifier,
	                        message: "'{{name}}' is not defined.",
	                        data: identifier
	                    });
	                });
	            }
	        };
	    }
	};


/***/ },
/* 299 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag references to the undefined variable.
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of `undefined` as an identifier",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	
	            Identifier(node) {
	                if (node.name === "undefined") {
	                    const parent = context.getAncestors().pop();
	
	                    if (!parent || parent.type !== "MemberExpression" || node !== parent.property || parent.computed) {
	                        context.report(node, "Unexpected use of undefined.");
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 300 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag trailing underscores in variable declarations.
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow dangling underscores in identifiers",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allow: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    allowAfterThis: {
	                        type: "boolean"
	                    },
	                    allowAfterSuper: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const options = context.options[0] || {};
	        const ALLOWED_VARIABLES = options.allow ? options.allow : [];
	        const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
	        const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
	
	        //-------------------------------------------------------------------------
	        // Helpers
	        //-------------------------------------------------------------------------
	
	        /**
	         * Check if identifier is present inside the allowed option
	         * @param {string} identifier name of the node
	         * @returns {boolean} true if its is present
	         * @private
	         */
	        function isAllowed(identifier) {
	            return ALLOWED_VARIABLES.some(function(ident) {
	                return ident === identifier;
	            });
	        }
	
	        /**
	         * Check if identifier has a underscore at the end
	         * @param {ASTNode} identifier node to evaluate
	         * @returns {boolean} true if its is present
	         * @private
	         */
	        function hasTrailingUnderscore(identifier) {
	            const len = identifier.length;
	
	            return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
	        }
	
	        /**
	         * Check if identifier is a special case member expression
	         * @param {ASTNode} identifier node to evaluate
	         * @returns {boolean} true if its is a special case
	         * @private
	         */
	        function isSpecialCaseIdentifierForMemberExpression(identifier) {
	            return identifier === "__proto__";
	        }
	
	        /**
	         * Check if identifier is a special case variable expression
	         * @param {ASTNode} identifier node to evaluate
	         * @returns {boolean} true if its is a special case
	         * @private
	         */
	        function isSpecialCaseIdentifierInVariableExpression(identifier) {
	
	            // Checks for the underscore library usage here
	            return identifier === "_";
	        }
	
	        /**
	         * Check if function has a underscore at the end
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkForTrailingUnderscoreInFunctionDeclaration(node) {
	            if (node.id) {
	                const identifier = node.id.name;
	
	                if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) && !isAllowed(identifier)) {
	                    context.report({
	                        node,
	                        message: "Unexpected dangling '_' in '{{identifier}}'.",
	                        data: {
	                            identifier
	                        }
	                    });
	                }
	            }
	        }
	
	        /**
	         * Check if variable expression has a underscore at the end
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkForTrailingUnderscoreInVariableExpression(node) {
	            const identifier = node.id.name;
	
	            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
	                !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
	                context.report({
	                    node,
	                    message: "Unexpected dangling '_' in '{{identifier}}'.",
	                    data: {
	                        identifier
	                    }
	                });
	            }
	        }
	
	        /**
	         * Check if member expression has a underscore at the end
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkForTrailingUnderscoreInMemberExpression(node) {
	            const identifier = node.property.name,
	                isMemberOfThis = node.object.type === "ThisExpression",
	                isMemberOfSuper = node.object.type === "Super";
	
	            if (typeof identifier !== "undefined" && hasTrailingUnderscore(identifier) &&
	                !(isMemberOfThis && allowAfterThis) &&
	                !(isMemberOfSuper && allowAfterSuper) &&
	                !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
	                context.report({
	                    node,
	                    message: "Unexpected dangling '_' in '{{identifier}}'.",
	                    data: {
	                        identifier
	                    }
	                });
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            FunctionDeclaration: checkForTrailingUnderscoreInFunctionDeclaration,
	            VariableDeclarator: checkForTrailingUnderscoreInVariableExpression,
	            MemberExpression: checkForTrailingUnderscoreInMemberExpression
	        };
	
	    }
	};


/***/ },
/* 301 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to spot scenarios where a newline looks like it is ending a statement, but is not.
	 * @author Glen Mailer
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow confusing multiline expressions",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        const FUNCTION_MESSAGE = "Unexpected newline between function and ( of function call.";
	        const PROPERTY_MESSAGE = "Unexpected newline between object and [ of property access.";
	        const TAGGED_TEMPLATE_MESSAGE = "Unexpected newline between template tag and template literal.";
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Check to see if there is a newline between the node and the following open bracket
	         * line's expression
	         * @param {ASTNode} node The node to check.
	         * @param {string} msg The error message to use.
	         * @returns {void}
	         * @private
	         */
	        function checkForBreakAfter(node, msg) {
	            let nodeExpressionEnd = node;
	            let openParen = sourceCode.getTokenAfter(node);
	
	            // Move along until the end of the wrapped expression
	            while (openParen.value === ")") {
	                nodeExpressionEnd = openParen;
	                openParen = sourceCode.getTokenAfter(nodeExpressionEnd);
	            }
	
	            if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
	                context.report(node, openParen.loc.start, msg, { char: openParen.value });
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	
	            MemberExpression(node) {
	                if (!node.computed) {
	                    return;
	                }
	                checkForBreakAfter(node.object, PROPERTY_MESSAGE);
	            },
	
	            TaggedTemplateExpression(node) {
	                if (node.tag.loc.end.line === node.quasi.loc.start.line) {
	                    return;
	                }
	                context.report(node, node.loc.start, TAGGED_TEMPLATE_MESSAGE);
	            },
	
	            CallExpression(node) {
	                if (node.arguments.length === 0) {
	                    return;
	                }
	                checkForBreakAfter(node.callee, FUNCTION_MESSAGE);
	            }
	        };
	
	    }
	};


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow use of unmodified expressions in loop conditions
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const Traverser = __webpack_require__(303),
	    astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const pushAll = Function.apply.bind(Array.prototype.push);
	const SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;
	const LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/;  // for-in/of statements don't have `test` property.
	const GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;
	const SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;
	const DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;
	
	/**
	 * @typedef {Object} LoopConditionInfo
	 * @property {escope.Reference} reference - The reference.
	 * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes
	 *      that the reference is belonging to.
	 * @property {Function} isInLoop - The predicate which checks a given reference
	 *      is in this loop.
	 * @property {boolean} modified - The flag that the reference is modified in
	 *      this loop.
	 */
	
	/**
	 * Checks whether or not a given reference is a write reference.
	 *
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the reference is a write reference.
	 */
	function isWriteReference(reference) {
	    if (reference.init) {
	        const def = reference.resolved && reference.resolved.defs[0];
	
	        if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
	            return false;
	        }
	    }
	    return reference.isWrite();
	}
	
	/**
	 * Checks whether or not a given loop condition info does not have the modified
	 * flag.
	 *
	 * @param {LoopConditionInfo} condition - A loop condition info to check.
	 * @returns {boolean} `true` if the loop condition info is "unmodified".
	 */
	function isUnmodified(condition) {
	    return !condition.modified;
	}
	
	/**
	 * Checks whether or not a given loop condition info does not have the modified
	 * flag and does not have the group this condition belongs to.
	 *
	 * @param {LoopConditionInfo} condition - A loop condition info to check.
	 * @returns {boolean} `true` if the loop condition info is "unmodified".
	 */
	function isUnmodifiedAndNotBelongToGroup(condition) {
	    return !(condition.modified || condition.group);
	}
	
	/**
	 * Checks whether or not a given reference is inside of a given node.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the reference is inside of the node.
	 */
	function isInRange(node, reference) {
	    const or = node.range;
	    const ir = reference.identifier.range;
	
	    return or[0] <= ir[0] && ir[1] <= or[1];
	}
	
	/**
	 * Checks whether or not a given reference is inside of a loop node's condition.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the reference is inside of the loop node's
	 *      condition.
	 */
	const isInLoop = {
	    WhileStatement: isInRange,
	    DoWhileStatement: isInRange,
	    ForStatement(node, reference) {
	        return (
	            isInRange(node, reference) &&
	            !(node.init && isInRange(node.init, reference))
	        );
	    }
	};
	
	/**
	 * Checks whether or not a given group node has any dynamic elements.
	 *
	 * @param {ASTNode} root - A node to check.
	 *      This node is one of BinaryExpression or ConditionalExpression.
	 * @returns {boolean} `true` if the node is dynamic.
	 */
	function hasDynamicExpressions(root) {
	    let retv = false;
	    const traverser = new Traverser();
	
	    traverser.traverse(root, {
	        enter(node) {
	            if (DYNAMIC_PATTERN.test(node.type)) {
	                retv = true;
	                this.break();
	            } else if (SKIP_PATTERN.test(node.type)) {
	                this.skip();
	            }
	        }
	    });
	
	    return retv;
	}
	
	/**
	 * Creates the loop condition information from a given reference.
	 *
	 * @param {escope.Reference} reference - A reference to create.
	 * @returns {LoopConditionInfo|null} Created loop condition info, or null.
	 */
	function toLoopCondition(reference) {
	    if (reference.init) {
	        return null;
	    }
	
	    let group = null;
	    let child = reference.identifier;
	    let node = child.parent;
	
	    while (node) {
	        if (SENTINEL_PATTERN.test(node.type)) {
	            if (LOOP_PATTERN.test(node.type) && node.test === child) {
	
	                // This reference is inside of a loop condition.
	                return {
	                    reference,
	                    group,
	                    isInLoop: isInLoop[node.type].bind(null, node),
	                    modified: false
	                };
	            }
	
	            // This reference is outside of a loop condition.
	            break;
	        }
	
	        /*
	         * If it's inside of a group, OK if either operand is modified.
	         * So stores the group this reference belongs to.
	         */
	        if (GROUP_PATTERN.test(node.type)) {
	
	            // If this expression is dynamic, no need to check.
	            if (hasDynamicExpressions(node)) {
	                break;
	            } else {
	                group = node;
	            }
	        }
	
	        child = node;
	        node = node.parent;
	    }
	
	    return null;
	}
	
	/**
	 * Gets the function which encloses a given reference.
	 * This supports only FunctionDeclaration.
	 *
	 * @param {escope.Reference} reference - A reference to get.
	 * @returns {ASTNode|null} The function node or null.
	 */
	function getEncloseFunctionDeclaration(reference) {
	    let node = reference.identifier;
	
	    while (node) {
	        if (node.type === "FunctionDeclaration") {
	            return node.id ? node : null;
	        }
	
	        node = node.parent;
	    }
	
	    return null;
	}
	
	/**
	 * Updates the "modified" flags of given loop conditions with given modifiers.
	 *
	 * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.
	 * @param {escope.Reference[]} modifiers - The references to update.
	 * @returns {void}
	 */
	function updateModifiedFlag(conditions, modifiers) {
	    let funcNode, funcVar;
	
	    for (let i = 0; i < conditions.length; ++i) {
	        const condition = conditions[i];
	
	        for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
	            const modifier = modifiers[j];
	
	            /*
	             * Besides checking for the condition being in the loop, we want to
	             * check the function that this modifier is belonging to is called
	             * in the loop.
	             * FIXME: This should probably be extracted to a function.
	             */
	            const inLoop = condition.isInLoop(modifier) || Boolean(
	                (funcNode = getEncloseFunctionDeclaration(modifier)) &&
	                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&
	                funcVar.references.some(condition.isInLoop)
	            );
	
	            condition.modified = inLoop;
	        }
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unmodified loop conditions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let groupMap = null;
	
	        /**
	         * Reports a given condition info.
	         *
	         * @param {LoopConditionInfo} condition - A loop condition info to report.
	         * @returns {void}
	         */
	        function report(condition) {
	            const node = condition.reference.identifier;
	
	            context.report({
	                node,
	                message: "'{{name}}' is not modified in this loop.",
	                data: node
	            });
	        }
	
	        /**
	         * Registers given conditions to the group the condition belongs to.
	         *
	         * @param {LoopConditionInfo[]} conditions - A loop condition info to
	         *      register.
	         * @returns {void}
	         */
	        function registerConditionsToGroup(conditions) {
	            for (let i = 0; i < conditions.length; ++i) {
	                const condition = conditions[i];
	
	                if (condition.group) {
	                    let group = groupMap.get(condition.group);
	
	                    if (!group) {
	                        group = [];
	                        groupMap.set(condition.group, group);
	                    }
	                    group.push(condition);
	                }
	            }
	        }
	
	        /**
	         * Reports references which are inside of unmodified groups.
	         *
	         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.
	         * @returns {void}
	         */
	        function checkConditionsInGroup(conditions) {
	            if (conditions.every(isUnmodified)) {
	                conditions.forEach(report);
	            }
	        }
	
	        /**
	         * Finds unmodified references which are inside of a loop condition.
	         * Then reports the references which are outside of groups.
	         *
	         * @param {escope.Variable} variable - A variable to report.
	         * @returns {void}
	         */
	        function checkReferences(variable) {
	
	            // Gets references that exist in loop conditions.
	            const conditions = variable
	                .references
	                .map(toLoopCondition)
	                .filter(Boolean);
	
	            if (conditions.length === 0) {
	                return;
	            }
	
	            // Registers the conditions to belonging groups.
	            registerConditionsToGroup(conditions);
	
	            // Check the conditions are modified.
	            const modifiers = variable.references.filter(isWriteReference);
	
	            if (modifiers.length > 0) {
	                updateModifiedFlag(conditions, modifiers);
	            }
	
	            /*
	             * Reports the conditions which are not belonging to groups.
	             * Others will be reported after all variables are done.
	             */
	            conditions
	                .filter(isUnmodifiedAndNotBelongToGroup)
	                .forEach(report);
	        }
	
	        return {
	            "Program:exit"() {
	                const queue = [context.getScope()];
	
	                groupMap = new Map();
	
	                let scope;
	
	                while ((scope = queue.pop())) {
	                    pushAll(queue, scope.childScopes);
	                    scope.variables.forEach(checkReferences);
	                }
	
	                groupMap.forEach(checkConditionsInGroup);
	                groupMap = null;
	            }
	        };
	    }
	};


/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Wrapper around estraverse
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const estraverse = __webpack_require__(57);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const KEY_BLACKLIST = [
	    "parent",
	    "leadingComments",
	    "trailingComments"
	];
	
	/**
	 * Wrapper around an estraverse controller that ensures the correct keys
	 * are visited.
	 * @constructor
	 */
	function Traverser() {
	
	    const controller = Object.create(new estraverse.Controller()),
	        originalTraverse = controller.traverse;
	
	    // intercept call to traverse() and add the fallback key to the visitor
	    controller.traverse = function(node, visitor) {
	        visitor.fallback = Traverser.getKeys;
	        return originalTraverse.call(this, node, visitor);
	    };
	
	    return controller;
	}
	
	/**
	 * Calculates the keys to use for traversal.
	 * @param {ASTNode} node The node to read keys from.
	 * @returns {string[]} An array of keys to visit on the node.
	 * @private
	 */
	Traverser.getKeys = function(node) {
	    return Object.keys(node).filter(function(key) {
	        return KEY_BLACKLIST.indexOf(key) === -1;
	    });
	};
	
	module.exports = Traverser;
	
	


/***/ },
/* 304 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag no-unneeded-ternary
	 * @author Gyandeep Singh
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow ternary operators when simpler alternatives exist",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    defaultAssignment: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const defaultAssignment = options.defaultAssignment !== false;
	
	        /**
	         * Test if the node is a boolean literal
	         * @param {ASTNode} node - The node to report.
	         * @returns {boolean} True if the its a boolean literal
	         * @private
	         */
	        function isBooleanLiteral(node) {
	            return node.type === "Literal" && typeof node.value === "boolean";
	        }
	
	        /**
	         * Test if the node matches the pattern id ? id : expression
	         * @param {ASTNode} node - The ConditionalExpression to check.
	         * @returns {boolean} True if the pattern is matched, and false otherwise
	         * @private
	         */
	        function matchesDefaultAssignment(node) {
	            return node.test.type === "Identifier" &&
	                   node.consequent.type === "Identifier" &&
	                   node.test.name === node.consequent.name;
	        }
	
	        return {
	
	            ConditionalExpression(node) {
	                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
	                    context.report(node, node.consequent.loc.start, "Unnecessary use of boolean literals in conditional expression.");
	                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
	                    context.report(node, node.consequent.loc.start, "Unnecessary use of conditional expression for default assignment.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 305 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Checks for unreachable code due to return, throws, break, and continue.
	 * @author Joel Feenstra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given variable declarator has the initializer.
	 * @param {ASTNode} node - A VariableDeclarator node to check.
	 * @returns {boolean} `true` if the node has the initializer.
	 */
	function isInitialized(node) {
	    return Boolean(node.init);
	}
	
	/**
	 * Checks whether or not a given code path segment is unreachable.
	 * @param {CodePathSegment} segment - A CodePathSegment to check.
	 * @returns {boolean} `true` if the segment is unreachable.
	 */
	function isUnreachable(segment) {
	    return !segment.reachable;
	}
	
	/**
	 * The class to distinguish consecutive unreachable statements.
	 */
	class ConsecutiveRange {
	    constructor(sourceCode) {
	        this.sourceCode = sourceCode;
	        this.startNode = null;
	        this.endNode = null;
	    }
	
	    /**
	     * The location object of this range.
	     * @type {Object}
	     */
	    get location() {
	        return {
	            start: this.startNode.loc.start,
	            end: this.endNode.loc.end
	        };
	    }
	
	    /**
	     * `true` if this range is empty.
	     * @type {boolean}
	     */
	    get isEmpty() {
	        return !(this.startNode && this.endNode);
	    }
	
	    /**
	     * Checks whether the given node is inside of this range.
	     * @param {ASTNode|Token} node - The node to check.
	     * @returns {boolean} `true` if the node is inside of this range.
	     */
	    contains(node) {
	        return (
	            node.range[0] >= this.startNode.range[0] &&
	            node.range[1] <= this.endNode.range[1]
	        );
	    }
	
	    /**
	     * Checks whether the given node is consecutive to this range.
	     * @param {ASTNode} node - The node to check.
	     * @returns {boolean} `true` if the node is consecutive to this range.
	     */
	    isConsecutive(node) {
	        return this.contains(this.sourceCode.getTokenBefore(node));
	    }
	
	    /**
	     * Merges the given node to this range.
	     * @param {ASTNode} node - The node to merge.
	     * @returns {void}
	     */
	    merge(node) {
	        this.endNode = node;
	    }
	
	    /**
	     * Resets this range by the given node or null.
	     * @param {ASTNode|null} node - The node to reset, or null.
	     * @returns {void}
	     */
	    reset(node) {
	        this.startNode = this.endNode = node;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let currentCodePath = null;
	
	        const range = new ConsecutiveRange(context.getSourceCode());
	
	        /**
	         * Reports a given node if it's unreachable.
	         * @param {ASTNode} node - A statement node to report.
	         * @returns {void}
	         */
	        function reportIfUnreachable(node) {
	            let nextNode = null;
	
	            if (node && currentCodePath.currentSegments.every(isUnreachable)) {
	
	                // Store this statement to distinguish consecutive statements.
	                if (range.isEmpty) {
	                    range.reset(node);
	                    return;
	                }
	
	                // Skip if this statement is inside of the current range.
	                if (range.contains(node)) {
	                    return;
	                }
	
	                // Merge if this statement is consecutive to the current range.
	                if (range.isConsecutive(node)) {
	                    range.merge(node);
	                    return;
	                }
	
	                nextNode = node;
	            }
	
	            // Report the current range since this statement is reachable or is
	            // not consecutive to the current range.
	            if (!range.isEmpty) {
	                context.report({
	                    message: "Unreachable code.",
	                    loc: range.location,
	                    node: range.startNode
	                });
	            }
	
	            // Update the current range.
	            range.reset(nextNode);
	        }
	
	        return {
	
	            // Manages the current code path.
	            onCodePathStart(codePath) {
	                currentCodePath = codePath;
	            },
	
	            onCodePathEnd() {
	                currentCodePath = currentCodePath.upper;
	            },
	
	            // Registers for all statement nodes (excludes FunctionDeclaration).
	            BlockStatement: reportIfUnreachable,
	            BreakStatement: reportIfUnreachable,
	            ClassDeclaration: reportIfUnreachable,
	            ContinueStatement: reportIfUnreachable,
	            DebuggerStatement: reportIfUnreachable,
	            DoWhileStatement: reportIfUnreachable,
	            EmptyStatement: reportIfUnreachable,
	            ExpressionStatement: reportIfUnreachable,
	            ForInStatement: reportIfUnreachable,
	            ForOfStatement: reportIfUnreachable,
	            ForStatement: reportIfUnreachable,
	            IfStatement: reportIfUnreachable,
	            ImportDeclaration: reportIfUnreachable,
	            LabeledStatement: reportIfUnreachable,
	            ReturnStatement: reportIfUnreachable,
	            SwitchStatement: reportIfUnreachable,
	            ThrowStatement: reportIfUnreachable,
	            TryStatement: reportIfUnreachable,
	
	            VariableDeclaration(node) {
	                if (node.kind !== "var" || node.declarations.some(isInitialized)) {
	                    reportIfUnreachable(node);
	                }
	            },
	
	            WhileStatement: reportIfUnreachable,
	            WithStatement: reportIfUnreachable,
	            ExportNamedDeclaration: reportIfUnreachable,
	            ExportDefaultDeclaration: reportIfUnreachable,
	            ExportAllDeclaration: reportIfUnreachable,
	
	            "Program:exit"() {
	                reportIfUnreachable();
	            }
	        };
	    }
	};


/***/ },
/* 306 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag unsafe statements in finally block
	 * @author Onur Temizkan
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/;
	const SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/;
	const SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/;
	
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow control flow statements in `finally` blocks",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	    create(context) {
	
	        /**
	         * Checks if the node is the finalizer of a TryStatement
	         *
	         * @param {ASTNode} node - node to check.
	         * @returns {boolean} - true if the node is the finalizer of a TryStatement
	         */
	        function isFinallyBlock(node) {
	            return node.parent.type === "TryStatement" && node.parent.finalizer === node;
	        }
	
	        /**
	         * Climbs up the tree if the node is not a sentinel node
	         *
	         * @param {ASTNode} node - node to check.
	         * @param {string} label - label of the break or continue statement
	         * @returns {boolean} - return whether the node is a finally block or a sentinel node
	         */
	        function isInFinallyBlock(node, label) {
	            let labelInside = false;
	            let sentinelNodeType;
	
	            if (node.type === "BreakStatement" && !node.label) {
	                sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
	            } else if (node.type === "ContinueStatement") {
	                sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
	            } else {
	                sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
	            }
	
	            while (node && !sentinelNodeType.test(node.type)) {
	                if (node.parent.label && label && (node.parent.label.name === label.name)) {
	                    labelInside = true;
	                }
	                if (isFinallyBlock(node)) {
	                    if (label && labelInside) {
	                        return false;
	                    }
	                    return true;
	                }
	                node = node.parent;
	            }
	            return false;
	        }
	
	        /**
	         * Checks whether the possibly-unsafe statement is inside a finally block.
	         *
	         * @param {ASTNode} node - node to check.
	         * @returns {void}
	         */
	        function check(node) {
	            if (isInFinallyBlock(node, node.label)) {
	                context.report({
	                    message: "Unsafe usage of {{nodeType}}.",
	                    data: {
	                        nodeType: node.type
	                    },
	                    node,
	                    line: node.loc.line,
	                    column: node.loc.column
	                });
	            }
	        }
	
	        return {
	            ReturnStatement: check,
	            ThrowStatement: check,
	            BreakStatement: check,
	            ContinueStatement: check
	        };
	    }
	};


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow negating the left operand of relational operators
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether the given operator is a relational operator or not.
	 *
	 * @param {string} op - The operator type to check.
	 * @returns {boolean} `true` if the operator is a relational operator.
	 */
	function isRelationalOperator(op) {
	    return op === "in" || op === "instanceof";
	}
	
	/**
	 * Checks whether the given node is a logical negation expression or not.
	 *
	 * @param {ASTNode} node - The node to check.
	 * @returns {boolean} `true` if the node is a logical negation expression.
	 */
	function isNegation(node) {
	    return node.type === "UnaryExpression" && node.operator === "!";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow negating the left operand of relational operators",
	            category: "Possible Errors",
	            recommended: false
	        },
	        schema: [],
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            BinaryExpression(node) {
	                if (isRelationalOperator(node.operator) &&
	                    isNegation(node.left) &&
	                    !astUtils.isParenthesised(sourceCode, node.left)
	                ) {
	                    context.report({
	                        node,
	                        loc: node.left.loc,
	                        message: "Unexpected negating the left operand of '{{operator}}' operator.",
	                        data: node,
	
	                        fix(fixer) {
	                            const negationToken = sourceCode.getFirstToken(node.left);
	                            const fixRange = [negationToken.range[1], node.range[1]];
	                            const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
	
	                            return fixer.replaceTextRange(fixRange, `(${text})`);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 308 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Flag expressions in statement position that do not side effect
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unused expressions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowShortCircuit: {
	                        type: "boolean"
	                    },
	                    allowTernary: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const config = context.options[0] || {},
	            allowShortCircuit = config.allowShortCircuit || false,
	            allowTernary = config.allowTernary || false;
	
	        /**
	         * @param {ASTNode} node - any node
	         * @returns {boolean} whether the given node structurally represents a directive
	         */
	        function looksLikeDirective(node) {
	            return node.type === "ExpressionStatement" &&
	                node.expression.type === "Literal" && typeof node.expression.value === "string";
	        }
	
	        /**
	         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination
	         * @param {a[]} list - the input list
	         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate
	         */
	        function takeWhile(predicate, list) {
	            for (let i = 0; i < list.length; ++i) {
	                if (!predicate(list[i])) {
	                    return list.slice(0, i);
	                }
	            }
	            return list.slice();
	        }
	
	        /**
	         * @param {ASTNode} node - a Program or BlockStatement node
	         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body
	         */
	        function directives(node) {
	            return takeWhile(looksLikeDirective, node.body);
	        }
	
	        /**
	         * @param {ASTNode} node - any node
	         * @param {ASTNode[]} ancestors - the given node's ancestors
	         * @returns {boolean} whether the given node is considered a directive in its current position
	         */
	        function isDirective(node, ancestors) {
	            const parent = ancestors[ancestors.length - 1],
	                grandparent = ancestors[ancestors.length - 2];
	
	            return (parent.type === "Program" || parent.type === "BlockStatement" &&
	                    (/Function/.test(grandparent.type))) &&
	                    directives(parent).indexOf(node) >= 0;
	        }
	
	        /**
	         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.
	         * @param {ASTNode} node - any node
	         * @returns {boolean} whether the given node is a valid expression
	         */
	        function isValidExpression(node) {
	            if (allowTernary) {
	
	                // Recursive check for ternary and logical expressions
	                if (node.type === "ConditionalExpression") {
	                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);
	                }
	            }
	            if (allowShortCircuit) {
	                if (node.type === "LogicalExpression") {
	                    return isValidExpression(node.right);
	                }
	            }
	
	            return /^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(node.type) ||
	                (node.type === "UnaryExpression" && ["delete", "void"].indexOf(node.operator) >= 0);
	        }
	
	        return {
	            ExpressionStatement(node) {
	                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {
	                    context.report(node, "Expected an assignment or function call and instead saw an expression.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 309 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow unused labels.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unused labels",
	            category: "Best Practices",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        let scopeInfo = null;
	
	        /**
	         * Adds a scope info to the stack.
	         *
	         * @param {ASTNode} node - A node to add. This is a LabeledStatement.
	         * @returns {void}
	         */
	        function enterLabeledScope(node) {
	            scopeInfo = {
	                label: node.label.name,
	                used: false,
	                upper: scopeInfo
	            };
	        }
	
	        /**
	         * Removes the top of the stack.
	         * At the same time, this reports the label if it's never used.
	         *
	         * @param {ASTNode} node - A node to report. This is a LabeledStatement.
	         * @returns {void}
	         */
	        function exitLabeledScope(node) {
	            if (!scopeInfo.used) {
	                context.report({
	                    node: node.label,
	                    message: "'{{name}}:' is defined but never used.",
	                    data: node.label
	                });
	            }
	
	            scopeInfo = scopeInfo.upper;
	        }
	
	        /**
	         * Marks the label of a given node as used.
	         *
	         * @param {ASTNode} node - A node to mark. This is a BreakStatement or
	         *      ContinueStatement.
	         * @returns {void}
	         */
	        function markAsUsed(node) {
	            if (!node.label) {
	                return;
	            }
	
	            const label = node.label.name;
	            let info = scopeInfo;
	
	            while (info) {
	                if (info.label === label) {
	                    info.used = true;
	                    break;
	                }
	                info = info.upper;
	            }
	        }
	
	        return {
	            LabeledStatement: enterLabeledScope,
	            "LabeledStatement:exit": exitLabeledScope,
	            BreakStatement: markAsUsed,
	            ContinueStatement: markAsUsed
	        };
	    }
	};


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag declared but unused variables
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unused variables",
	            category: "Variables",
	            recommended: true
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["all", "local"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            vars: {
	                                enum: ["all", "local"]
	                            },
	                            varsIgnorePattern: {
	                                type: "string"
	                            },
	                            args: {
	                                enum: ["all", "after-used", "none"]
	                            },
	                            argsIgnorePattern: {
	                                type: "string"
	                            },
	                            caughtErrors: {
	                                enum: ["all", "none"]
	                            },
	                            caughtErrorsIgnorePattern: {
	                                type: "string"
	                            }
	                        }
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const DEFINED_MESSAGE = "'{{name}}' is defined but never used.";
	        const ASSIGNED_MESSAGE = "'{{name}}' is assigned a value but never used.";
	
	        const config = {
	            vars: "all",
	            args: "after-used",
	            caughtErrors: "none"
	        };
	
	        const firstOption = context.options[0];
	
	        if (firstOption) {
	            if (typeof firstOption === "string") {
	                config.vars = firstOption;
	            } else {
	                config.vars = firstOption.vars || config.vars;
	                config.args = firstOption.args || config.args;
	                config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
	
	                if (firstOption.varsIgnorePattern) {
	                    config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern);
	                }
	
	                if (firstOption.argsIgnorePattern) {
	                    config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern);
	                }
	
	                if (firstOption.caughtErrorsIgnorePattern) {
	                    config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern);
	                }
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const STATEMENT_TYPE = /(?:Statement|Declaration)$/;
	
	        /**
	         * Determines if a given variable is being exported from a module.
	         * @param {Variable} variable - EScope variable object.
	         * @returns {boolean} True if the variable is exported, false if not.
	         * @private
	         */
	        function isExported(variable) {
	
	            const definition = variable.defs[0];
	
	            if (definition) {
	
	                let node = definition.node;
	
	                if (node.type === "VariableDeclarator") {
	                    node = node.parent;
	                } else if (definition.type === "Parameter") {
	                    return false;
	                }
	
	                return node.parent.type.indexOf("Export") === 0;
	            } else {
	                return false;
	            }
	        }
	
	        /**
	         * Determines if a reference is a read operation.
	         * @param {Reference} ref - An escope Reference
	         * @returns {boolean} whether the given reference represents a read operation
	         * @private
	         */
	        function isReadRef(ref) {
	            return ref.isRead();
	        }
	
	        /**
	         * Determine if an identifier is referencing an enclosing function name.
	         * @param {Reference} ref - The reference to check.
	         * @param {ASTNode[]} nodes - The candidate function nodes.
	         * @returns {boolean} True if it's a self-reference, false if not.
	         * @private
	         */
	        function isSelfReference(ref, nodes) {
	            let scope = ref.from;
	
	            while (scope) {
	                if (nodes.indexOf(scope.block) >= 0) {
	                    return true;
	                }
	
	                scope = scope.upper;
	            }
	
	            return false;
	        }
	
	        /**
	         * Checks whether a given node is inside of a loop or not.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} `true` if the node is inside of a loop.
	         * @private
	         */
	        function isInsideOfLoop(node) {
	            while (node) {
	                if (astUtils.isLoop(node)) {
	                    return true;
	                }
	                if (astUtils.isFunction(node)) {
	                    return false;
	                }
	
	                node = node.parent;
	            }
	
	            return false;
	        }
	
	        /**
	         * Checks the position of given nodes.
	         *
	         * @param {ASTNode} inner - A node which is expected as inside.
	         * @param {ASTNode} outer - A node which is expected as outside.
	         * @returns {boolean} `true` if the `inner` node exists in the `outer` node.
	         * @private
	         */
	        function isInside(inner, outer) {
	            return (
	                inner.range[0] >= outer.range[0] &&
	                inner.range[1] <= outer.range[1]
	            );
	        }
	
	        /**
	         * If a given reference is left-hand side of an assignment, this gets
	         * the right-hand side node of the assignment.
	         *
	         * In the following cases, this returns null.
	         *
	         * - The reference is not the LHS of an assignment expression.
	         * - The reference is inside of a loop.
	         * - The reference is inside of a function scope which is different from
	         *   the declaration.
	         *
	         * @param {escope.Reference} ref - A reference to check.
	         * @param {ASTNode} prevRhsNode - The previous RHS node.
	         * @returns {ASTNode|null} The RHS node or null.
	         * @private
	         */
	        function getRhsNode(ref, prevRhsNode) {
	            const id = ref.identifier;
	            const parent = id.parent;
	            const granpa = parent.parent;
	            const refScope = ref.from.variableScope;
	            const varScope = ref.resolved.scope.variableScope;
	            const canBeUsedLater = refScope !== varScope || isInsideOfLoop(id);
	
	            /*
	             * Inherits the previous node if this reference is in the node.
	             * This is for `a = a + a`-like code.
	             */
	            if (prevRhsNode && isInside(id, prevRhsNode)) {
	                return prevRhsNode;
	            }
	
	            if (parent.type === "AssignmentExpression" &&
	                granpa.type === "ExpressionStatement" &&
	                id === parent.left &&
	                !canBeUsedLater
	            ) {
	                return parent.right;
	            }
	            return null;
	        }
	
	        /**
	         * Checks whether a given function node is stored to somewhere or not.
	         * If the function node is stored, the function can be used later.
	         *
	         * @param {ASTNode} funcNode - A function node to check.
	         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
	         * @returns {boolean} `true` if under the following conditions:
	         *      - the funcNode is assigned to a variable.
	         *      - the funcNode is bound as an argument of a function call.
	         *      - the function is bound to a property and the object satisfies above conditions.
	         * @private
	         */
	        function isStorableFunction(funcNode, rhsNode) {
	            let node = funcNode;
	            let parent = funcNode.parent;
	
	            while (parent && isInside(parent, rhsNode)) {
	                switch (parent.type) {
	                    case "SequenceExpression":
	                        if (parent.expressions[parent.expressions.length - 1] !== node) {
	                            return false;
	                        }
	                        break;
	
	                    case "CallExpression":
	                    case "NewExpression":
	                        return parent.callee !== node;
	
	                    case "AssignmentExpression":
	                    case "TaggedTemplateExpression":
	                    case "YieldExpression":
	                        return true;
	
	                    default:
	                        if (STATEMENT_TYPE.test(parent.type)) {
	
	                            /*
	                             * If it encountered statements, this is a complex pattern.
	                             * Since analyzeing complex patterns is hard, this returns `true` to avoid false positive.
	                             */
	                            return true;
	                        }
	                }
	
	                node = parent;
	                parent = parent.parent;
	            }
	
	            return false;
	        }
	
	        /**
	         * Checks whether a given Identifier node exists inside of a function node which can be used later.
	         *
	         * "can be used later" means:
	         * - the function is assigned to a variable.
	         * - the function is bound to a property and the object can be used later.
	         * - the function is bound as an argument of a function call.
	         *
	         * If a reference exists in a function which can be used later, the reference is read when the function is called.
	         *
	         * @param {ASTNode} id - An Identifier node to check.
	         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
	         * @returns {boolean} `true` if the `id` node exists inside of a function node which can be used later.
	         * @private
	         */
	        function isInsideOfStorableFunction(id, rhsNode) {
	            const funcNode = astUtils.getUpperFunction(id);
	
	            return (
	                funcNode &&
	                isInside(funcNode, rhsNode) &&
	                isStorableFunction(funcNode, rhsNode)
	            );
	        }
	
	        /**
	         * Checks whether a given reference is a read to update itself or not.
	         *
	         * @param {escope.Reference} ref - A reference to check.
	         * @param {ASTNode} rhsNode - The RHS node of the previous assignment.
	         * @returns {boolean} The reference is a read to update itself.
	         * @private
	         */
	        function isReadForItself(ref, rhsNode) {
	            const id = ref.identifier;
	            const parent = id.parent;
	            const granpa = parent.parent;
	
	            return ref.isRead() && (
	
	                // self update. e.g. `a += 1`, `a++`
	                (
	                    parent.type === "AssignmentExpression" &&
	                    granpa.type === "ExpressionStatement" &&
	                    parent.left === id
	                ) ||
	                (
	                    parent.type === "UpdateExpression" &&
	                    granpa.type === "ExpressionStatement"
	                ) ||
	
	                // in RHS of an assignment for itself. e.g. `a = a + 1`
	                (
	                    rhsNode &&
	                    isInside(id, rhsNode) &&
	                    !isInsideOfStorableFunction(id, rhsNode)
	                )
	            );
	        }
	
	        /**
	         * Determine if an identifier is used either in for-in loops.
	         *
	         * @param {Reference} ref - The reference to check.
	         * @returns {boolean} whether reference is used in the for-in loops
	         * @private
	         */
	        function isForInRef(ref) {
	            let target = ref.identifier.parent;
	
	
	            // "for (var ...) { return; }"
	            if (target.type === "VariableDeclarator") {
	                target = target.parent.parent;
	            }
	
	            if (target.type !== "ForInStatement") {
	                return false;
	            }
	
	            // "for (...) { return; }"
	            if (target.body.type === "BlockStatement") {
	                target = target.body.body[0];
	
	            // "for (...) return;"
	            } else {
	                target = target.body;
	            }
	
	            // For empty loop body
	            if (!target) {
	                return false;
	            }
	
	            return target.type === "ReturnStatement";
	        }
	
	        /**
	         * Determines if the variable is used.
	         * @param {Variable} variable - The variable to check.
	         * @returns {boolean} True if the variable is used
	         * @private
	         */
	        function isUsedVariable(variable) {
	            const functionNodes = variable.defs.filter(function(def) {
	                    return def.type === "FunctionName";
	                }).map(function(def) {
	                    return def.node;
	                }),
	                isFunctionDefinition = functionNodes.length > 0;
	            let rhsNode = null;
	
	            return variable.references.some(function(ref) {
	                if (isForInRef(ref)) {
	                    return true;
	                }
	
	                const forItself = isReadForItself(ref, rhsNode);
	
	                rhsNode = getRhsNode(ref, rhsNode);
	
	                return (
	                    isReadRef(ref) &&
	                    !forItself &&
	                    !(isFunctionDefinition && isSelfReference(ref, functionNodes))
	                );
	            });
	        }
	
	        /**
	         * Checks whether the given variable is the last parameter in the non-ignored parameters.
	         *
	         * @param {escope.Variable} variable - The variable to check.
	         * @returns {boolean} `true` if the variable is the last.
	         */
	        function isLastInNonIgnoredParameters(variable) {
	            const def = variable.defs[0];
	
	            // This is the last.
	            if (def.index === def.node.params.length - 1) {
	                return true;
	            }
	
	            // if all parameters preceded by this variable are ignored and unused, this is the last.
	            if (config.argsIgnorePattern) {
	                const params = context.getDeclaredVariables(def.node);
	                const posteriorParams = params.slice(params.indexOf(variable) + 1);
	
	                if (posteriorParams.every(v => v.references.length === 0 && config.argsIgnorePattern.test(v.name))) {
	                    return true;
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Gets an array of variables without read references.
	         * @param {Scope} scope - an escope Scope object.
	         * @param {Variable[]} unusedVars - an array that saving result.
	         * @returns {Variable[]} unused variables of the scope and descendant scopes.
	         * @private
	         */
	        function collectUnusedVariables(scope, unusedVars) {
	            const variables = scope.variables;
	            const childScopes = scope.childScopes;
	            let i, l;
	
	            if (scope.type !== "TDZ" && (scope.type !== "global" || config.vars === "all")) {
	                for (i = 0, l = variables.length; i < l; ++i) {
	                    const variable = variables[i];
	
	                    // skip a variable of class itself name in the class scope
	                    if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
	                        continue;
	                    }
	
	                    // skip function expression names and variables marked with markVariableAsUsed()
	                    if (scope.functionExpressionScope || variable.eslintUsed) {
	                        continue;
	                    }
	
	                    // skip implicit "arguments" variable
	                    if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
	                        continue;
	                    }
	
	                    // explicit global variables don't have definitions.
	                    const def = variable.defs[0];
	
	                    if (def) {
	                        const type = def.type;
	
	                        // skip catch variables
	                        if (type === "CatchClause") {
	                            if (config.caughtErrors === "none") {
	                                continue;
	                            }
	
	                            // skip ignored parameters
	                            if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
	                                continue;
	                            }
	                        }
	
	                        if (type === "Parameter") {
	
	                            // skip any setter argument
	                            if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
	                                continue;
	                            }
	
	                            // if "args" option is "none", skip any parameter
	                            if (config.args === "none") {
	                                continue;
	                            }
	
	                            // skip ignored parameters
	                            if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
	                                continue;
	                            }
	
	                            // if "args" option is "after-used", skip all but the last parameter
	                            if (config.args === "after-used" && !isLastInNonIgnoredParameters(variable)) {
	                                continue;
	                            }
	                        } else {
	
	                            // skip ignored variables
	                            if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
	                                continue;
	                            }
	                        }
	                    }
	
	                    if (!isUsedVariable(variable) && !isExported(variable)) {
	                        unusedVars.push(variable);
	                    }
	                }
	            }
	
	            for (i = 0, l = childScopes.length; i < l; ++i) {
	                collectUnusedVariables(childScopes[i], unusedVars);
	            }
	
	            return unusedVars;
	        }
	
	        /**
	         * Gets the index of a given variable name in a given comment.
	         * @param {escope.Variable} variable - A variable to get.
	         * @param {ASTNode} comment - A comment node which includes the variable name.
	         * @returns {number} The index of the variable name's location.
	         * @private
	         */
	        function getColumnInComment(variable, comment) {
	            const namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(variable.name)}(?:$|[\\s,:])`, "g");
	
	            // To ignore the first text "global".
	            namePattern.lastIndex = comment.value.indexOf("global") + 6;
	
	            // Search a given variable name.
	            const match = namePattern.exec(comment.value);
	
	            return match ? match.index + 1 : 0;
	        }
	
	        /**
	         * Creates the correct location of a given variables.
	         * The location is at its name string in a `/*global` comment.
	         *
	         * @param {escope.Variable} variable - A variable to get its location.
	         * @returns {{line: number, column: number}} The location object for the variable.
	         * @private
	         */
	        function getLocation(variable) {
	            const comment = variable.eslintExplicitGlobalComment;
	            const baseLoc = comment.loc.start;
	            let column = getColumnInComment(variable, comment);
	            const prefix = comment.value.slice(0, column);
	            const lineInComment = (prefix.match(/\n/g) || []).length;
	
	            if (lineInComment > 0) {
	                column -= 1 + prefix.lastIndexOf("\n");
	            } else {
	
	                // 2 is for `/*`
	                column += baseLoc.column + 2;
	            }
	
	            return {
	                line: baseLoc.line + lineInComment,
	                column
	            };
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            "Program:exit"(programNode) {
	                const unusedVars = collectUnusedVariables(context.getScope(), []);
	
	                for (let i = 0, l = unusedVars.length; i < l; ++i) {
	                    const unusedVar = unusedVars[i];
	
	                    if (unusedVar.eslintExplicitGlobal) {
	                        context.report({
	                            node: programNode,
	                            loc: getLocation(unusedVar),
	                            message: DEFINED_MESSAGE,
	                            data: unusedVar
	                        });
	                    } else if (unusedVar.defs.length > 0) {
	                        context.report({
	                            node: unusedVar.identifiers[0],
	                            message: unusedVar.references.some(ref => ref.isWrite()) ? ASSIGNED_MESSAGE : DEFINED_MESSAGE,
	                            data: unusedVar
	                        });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 311 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of variables before they are defined
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;
	const FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/;
	
	/**
	 * Parses a given value as options.
	 *
	 * @param {any} options - A value to parse.
	 * @returns {Object} The parsed options.
	 */
	function parseOptions(options) {
	    let functions = true;
	    let classes = true;
	
	    if (typeof options === "string") {
	        functions = (options !== "nofunc");
	    } else if (typeof options === "object" && options !== null) {
	        functions = options.functions !== false;
	        classes = options.classes !== false;
	    }
	
	    return {functions, classes};
	}
	
	/**
	 * @returns {boolean} `false`.
	 */
	function alwaysFalse() {
	    return false;
	}
	
	/**
	 * Checks whether or not a given variable is a function declaration.
	 *
	 * @param {escope.Variable} variable - A variable to check.
	 * @returns {boolean} `true` if the variable is a function declaration.
	 */
	function isFunction(variable) {
	    return variable.defs[0].type === "FunctionName";
	}
	
	/**
	 * Checks whether or not a given variable is a class declaration in an upper function scope.
	 *
	 * @param {escope.Variable} variable - A variable to check.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the variable is a class declaration.
	 */
	function isOuterClass(variable, reference) {
	    return (
	        variable.defs[0].type === "ClassName" &&
	        variable.scope.variableScope !== reference.from.variableScope
	    );
	}
	
	/**
	 * Checks whether or not a given variable is a function declaration or a class declaration in an upper function scope.
	 *
	 * @param {escope.Variable} variable - A variable to check.
	 * @param {escope.Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the variable is a function declaration or a class declaration.
	 */
	function isFunctionOrOuterClass(variable, reference) {
	    return isFunction(variable, reference) || isOuterClass(variable, reference);
	}
	
	/**
	 * Checks whether or not a given location is inside of the range of a given node.
	 *
	 * @param {ASTNode} node - An node to check.
	 * @param {number} location - A location to check.
	 * @returns {boolean} `true` if the location is inside of the range of the node.
	 */
	function isInRange(node, location) {
	    return node && node.range[0] <= location && location <= node.range[1];
	}
	
	/**
	 * Checks whether or not a given reference is inside of the initializers of a given variable.
	 *
	 * This returns `true` in the following cases:
	 *
	 *     var a = a
	 *     var [a = a] = list
	 *     var {a = a} = obj
	 *     for (var a in a) {}
	 *     for (var a of a) {}
	 *
	 * @param {Variable} variable - A variable to check.
	 * @param {Reference} reference - A reference to check.
	 * @returns {boolean} `true` if the reference is inside of the initializers.
	 */
	function isInInitializer(variable, reference) {
	    if (variable.scope !== reference.from) {
	        return false;
	    }
	
	    let node = variable.identifiers[0].parent;
	    const location = reference.identifier.range[1];
	
	    while (node) {
	        if (node.type === "VariableDeclarator") {
	            if (isInRange(node.init, location)) {
	                return true;
	            }
	            if (FOR_IN_OF_TYPE.test(node.parent.parent.type) &&
	                isInRange(node.parent.parent.right, location)
	            ) {
	                return true;
	            }
	            break;
	        } else if (node.type === "AssignmentPattern") {
	            if (isInRange(node.right, location)) {
	                return true;
	            }
	        } else if (SENTINEL_TYPE.test(node.type)) {
	            break;
	        }
	
	        node = node.parent;
	    }
	
	    return false;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow the use of variables before they are defined",
	            category: "Variables",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["nofunc"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            functions: {type: "boolean"},
	                            classes: {type: "boolean"}
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const options = parseOptions(context.options[0]);
	
	        // Defines a function which checks whether or not a reference is allowed according to the option.
	        let isAllowed;
	
	        if (options.functions && options.classes) {
	            isAllowed = alwaysFalse;
	        } else if (options.functions) {
	            isAllowed = isOuterClass;
	        } else if (options.classes) {
	            isAllowed = isFunction;
	        } else {
	            isAllowed = isFunctionOrOuterClass;
	        }
	
	        /**
	         * Finds and validates all variables in a given scope.
	         * @param {Scope} scope The scope object.
	         * @returns {void}
	         * @private
	         */
	        function findVariablesInScope(scope) {
	            scope.references.forEach(function(reference) {
	                const variable = reference.resolved;
	
	                // Skips when the reference is:
	                // - initialization's.
	                // - referring to an undefined variable.
	                // - referring to a global environment variable (there're no identifiers).
	                // - located preceded by the variable (except in initializers).
	                // - allowed by options.
	                if (reference.init ||
	                    !variable ||
	                    variable.identifiers.length === 0 ||
	                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||
	                    isAllowed(variable, reference)
	                ) {
	                    return;
	                }
	
	                // Reports.
	                context.report({
	                    node: reference.identifier,
	                    message: "'{{name}}' was used before it was defined.",
	                    data: reference.identifier
	                });
	            });
	        }
	
	        /**
	         * Validates variables inside of a node's scope.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         * @private
	         */
	        function findVariables() {
	            const scope = context.getScope();
	
	            findVariablesInScope(scope);
	        }
	
	        const ruleDefinition = {
	            "Program:exit"(node) {
	                const scope = context.getScope(),
	                    ecmaFeatures = context.parserOptions.ecmaFeatures || {};
	
	                findVariablesInScope(scope);
	
	                // both Node.js and Modules have an extra scope
	                if (ecmaFeatures.globalReturn || node.sourceType === "module") {
	                    findVariablesInScope(scope.childScopes[0]);
	                }
	            }
	        };
	
	        if (context.parserOptions.ecmaVersion >= 6) {
	            ruleDefinition["BlockStatement:exit"] =
	                ruleDefinition["SwitchStatement:exit"] = findVariables;
	
	            ruleDefinition["ArrowFunctionExpression:exit"] = function(node) {
	                if (node.body.type !== "BlockStatement") {
	                    findVariables(node);
	                }
	            };
	        } else {
	            ruleDefinition["FunctionExpression:exit"] =
	                ruleDefinition["FunctionDeclaration:exit"] =
	                ruleDefinition["ArrowFunctionExpression:exit"] = findVariables;
	        }
	
	        return ruleDefinition;
	    }
	};


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a node is a `.call()`/`.apply()`.
	 * @param {ASTNode} node - A CallExpression node to check.
	 * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.
	 */
	function isCallOrNonVariadicApply(node) {
	    return (
	        node.callee.type === "MemberExpression" &&
	        node.callee.property.type === "Identifier" &&
	        node.callee.computed === false &&
	        (
	            (node.callee.property.name === "call" && node.arguments.length >= 1) ||
	            (node.callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression")
	        )
	    );
	}
	
	/**
	 * Checks whether or not the tokens of two given nodes are same.
	 * @param {ASTNode} left - A node 1 to compare.
	 * @param {ASTNode} right - A node 2 to compare.
	 * @param {SourceCode} sourceCode - The ESLint source code object.
	 * @returns {boolean} the source code for the given node.
	 */
	function equalTokens(left, right, sourceCode) {
	    const tokensL = sourceCode.getTokens(left);
	    const tokensR = sourceCode.getTokens(right);
	
	    if (tokensL.length !== tokensR.length) {
	        return false;
	    }
	    for (let i = 0; i < tokensL.length; ++i) {
	        if (tokensL[i].type !== tokensR[i].type ||
	            tokensL[i].value !== tokensR[i].value
	        ) {
	            return false;
	        }
	    }
	
	    return true;
	}
	
	/**
	 * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.
	 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
	 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.
	 * @param {SourceCode} sourceCode - The ESLint source code object.
	 * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.
	 */
	function isValidThisArg(expectedThis, thisArg, sourceCode) {
	    if (!expectedThis) {
	        return astUtils.isNullOrUndefined(thisArg);
	    }
	    return equalTokens(expectedThis, thisArg, sourceCode);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary calls to `.call()` and `.apply()`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            CallExpression(node) {
	                if (!isCallOrNonVariadicApply(node)) {
	                    return;
	                }
	
	                const applied = node.callee.object;
	                const expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
	                const thisArg = node.arguments[0];
	
	                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
	                    context.report(
	                        node,
	                        "unnecessary '.{{name}}()'.",
	                        {name: node.callee.property.name});
	                }
	            }
	        };
	    }
	};


/***/ },
/* 313 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow unnecessary computed property keys in object literals
	 * @author Burak Yigit Kaya
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	const MESSAGE_UNNECESSARY_COMPUTED = "Unnecessarily computed property [{{property}}] found.";
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary computed property keys in object literals",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            Property(node) {
	                if (!node.computed) {
	                    return;
	                }
	
	                const key = node.key,
	                    nodeType = typeof key.value;
	
	                if (key.type === "Literal" && (nodeType === "string" || nodeType === "number")) {
	                    context.report({
	                        node,
	                        message: MESSAGE_UNNECESSARY_COMPUTED,
	                        data: { property: sourceCode.getText(key) },
	                        fix(fixer) {
	                            const leftSquareBracket = sourceCode.getFirstToken(node, node.value.generator || node.value.async ? 1 : 0);
	                            const rightSquareBracket = sourceCode.getTokensBetween(node.key, node.value).find(token => token.value === "]");
	
	                            const tokensBetween = sourceCode.getTokensBetween(leftSquareBracket, rightSquareBracket, 1);
	
	                            if (tokensBetween.slice(0, -1).some((token, index) => sourceCode.getText().slice(token.range[1], tokensBetween[index + 1].range[0]).trim())) {
	
	                                // If there are comments between the brackets and the property name, don't do a fix.
	                                return null;
	                            }
	                            return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], key.raw);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview disallow unncessary concatenation of template strings
	 * @author Henry Zhu
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is a concatenation.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a concatenation.
	 */
	function isConcatenation(node) {
	    return node.type === "BinaryExpression" && node.operator === "+";
	}
	
	/**
	 * Get's the right most node on the left side of a BinaryExpression with + operator.
	 * @param {ASTNode} node - A BinaryExpression node to check.
	 * @returns {ASTNode} node
	 */
	function getLeft(node) {
	    let left = node.left;
	
	    while (isConcatenation(left)) {
	        left = left.right;
	    }
	    return left;
	}
	
	/**
	 * Get's the left most node on the right side of a BinaryExpression with + operator.
	 * @param {ASTNode} node - A BinaryExpression node to check.
	 * @returns {ASTNode} node
	 */
	function getRight(node) {
	    let right = node.right;
	
	    while (isConcatenation(right)) {
	        right = right.left;
	    }
	    return right;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary concatenation of literals or template literals",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            BinaryExpression(node) {
	
	                // check if not concatenation
	                if (node.operator !== "+") {
	                    return;
	                }
	
	                // account for the `foo + "a" + "b"` case
	                const left = getLeft(node);
	                const right = getRight(node);
	
	                if (astUtils.isStringLiteral(left) &&
	                    astUtils.isStringLiteral(right) &&
	                    astUtils.isTokenOnSameLine(left, right)
	                ) {
	
	                    // move warning location to operator
	                    let operatorToken = sourceCode.getTokenAfter(left);
	
	                    while (operatorToken.value !== "+") {
	                        operatorToken = sourceCode.getTokenAfter(operatorToken);
	                    }
	
	                    context.report(
	                        node,
	                        operatorToken.loc.start,
	                        "Unexpected string concatenation of literals.");
	                }
	            }
	        };
	    }
	};


/***/ },
/* 315 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag the use of redundant constructors in classes.
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether a given array of statements is a single call of `super`.
	 *
	 * @param {ASTNode[]} body - An array of statements to check.
	 * @returns {boolean} `true` if the body is a single call of `super`.
	 */
	function isSingleSuperCall(body) {
	    return (
	        body.length === 1 &&
	        body[0].type === "ExpressionStatement" &&
	        body[0].expression.type === "CallExpression" &&
	        body[0].expression.callee.type === "Super"
	    );
	}
	
	/**
	 * Checks whether a given node is a pattern which doesn't have any side effects.
	 * Default parameters and Destructuring parameters can have side effects.
	 *
	 * @param {ASTNode} node - A pattern node.
	 * @returns {boolean} `true` if the node doesn't have any side effects.
	 */
	function isSimple(node) {
	    return node.type === "Identifier" || node.type === "RestElement";
	}
	
	/**
	 * Checks whether a given array of expressions is `...arguments` or not.
	 * `super(...arguments)` passes all arguments through.
	 *
	 * @param {ASTNode[]} superArgs - An array of expressions to check.
	 * @returns {boolean} `true` if the superArgs is `...arguments`.
	 */
	function isSpreadArguments(superArgs) {
	    return (
	        superArgs.length === 1 &&
	        superArgs[0].type === "SpreadElement" &&
	        superArgs[0].argument.type === "Identifier" &&
	        superArgs[0].argument.name === "arguments"
	    );
	}
	
	/**
	 * Checks whether given 2 nodes are identifiers which have the same name or not.
	 *
	 * @param {ASTNode} ctorParam - A node to check.
	 * @param {ASTNode} superArg - A node to check.
	 * @returns {boolean} `true` if the nodes are identifiers which have the same
	 *      name.
	 */
	function isValidIdentifierPair(ctorParam, superArg) {
	    return (
	        ctorParam.type === "Identifier" &&
	        superArg.type === "Identifier" &&
	        ctorParam.name === superArg.name
	    );
	}
	
	/**
	 * Checks whether given 2 nodes are a rest/spread pair which has the same values.
	 *
	 * @param {ASTNode} ctorParam - A node to check.
	 * @param {ASTNode} superArg - A node to check.
	 * @returns {boolean} `true` if the nodes are a rest/spread pair which has the
	 *      same values.
	 */
	function isValidRestSpreadPair(ctorParam, superArg) {
	    return (
	        ctorParam.type === "RestElement" &&
	        superArg.type === "SpreadElement" &&
	        isValidIdentifierPair(ctorParam.argument, superArg.argument)
	    );
	}
	
	/**
	 * Checks whether given 2 nodes have the same value or not.
	 *
	 * @param {ASTNode} ctorParam - A node to check.
	 * @param {ASTNode} superArg - A node to check.
	 * @returns {boolean} `true` if the nodes have the same value or not.
	 */
	function isValidPair(ctorParam, superArg) {
	    return (
	        isValidIdentifierPair(ctorParam, superArg) ||
	        isValidRestSpreadPair(ctorParam, superArg)
	    );
	}
	
	/**
	 * Checks whether the parameters of a constructor and the arguments of `super()`
	 * have the same values or not.
	 *
	 * @param {ASTNode} ctorParams - The parameters of a constructor to check.
	 * @param {ASTNode} superArgs - The arguments of `super()` to check.
	 * @returns {boolean} `true` if those have the same values.
	 */
	function isPassingThrough(ctorParams, superArgs) {
	    if (ctorParams.length !== superArgs.length) {
	        return false;
	    }
	
	    for (let i = 0; i < ctorParams.length; ++i) {
	        if (!isValidPair(ctorParams[i], superArgs[i])) {
	            return false;
	        }
	    }
	
	    return true;
	}
	
	/**
	 * Checks whether the constructor body is a redundant super call.
	 *
	 * @param {Array} body - constructor body content.
	 * @param {Array} ctorParams - The params to check against super call.
	 * @returns {boolean} true if the construtor body is redundant
	 */
	function isRedundantSuperCall(body, ctorParams) {
	    return (
	        isSingleSuperCall(body) &&
	        ctorParams.every(isSimple) &&
	        (
	            isSpreadArguments(body[0].expression.arguments) ||
	            isPassingThrough(ctorParams, body[0].expression.arguments)
	        )
	    );
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary constructors",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Checks whether a node is a redundant constructor
	         * @param {ASTNode} node - node to check
	         * @returns {void}
	         */
	        function checkForConstructor(node) {
	            if (node.kind !== "constructor") {
	                return;
	            }
	
	            const body = node.value.body.body;
	            const ctorParams = node.value.params;
	            const superClass = node.parent.parent.superClass;
	
	            if (superClass ? isRedundantSuperCall(body, ctorParams) : (body.length === 0)) {
	                context.report({
	                    node,
	                    message: "Useless constructor."
	                });
	            }
	        }
	
	        return {
	            MethodDefinition: checkForConstructor
	        };
	    }
	};


/***/ },
/* 316 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Look for useless escapes in strings and regexes
	 * @author Onur Temizkan
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	/**
	* Returns the union of two sets.
	* @param {Set} setA The first set
	* @param {Set} setB The second set
	* @returns {Set} The union of the two sets
	*/
	function union(setA, setB) {
	    return new Set(function *() {
	        yield* setA;
	        yield* setB;
	    }());
	}
	
	const VALID_STRING_ESCAPES = new Set("\\nrvtbfux\n\r");
	const REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnrsStvwWxu0123456789");
	const REGEX_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("]"));
	const REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()B"));
	
	/**
	* Parses a regular expression into a list of characters with character class info.
	* @param {string} regExpText The raw text used to create the regular expression
	* @returns {Object[]} A list of characters, each with info on escaping and whether they're in a character class.
	* @example
	*
	* parseRegExp('a\\b[cd-]')
	*
	* returns:
	* [
	*   {text: 'a', index: 0, escaped: false, inCharClass: false, startsCharClass: false, endsCharClass: false},
	*   {text: 'b', index: 2, escaped: true, inCharClass: false, startsCharClass: false, endsCharClass: false},
	*   {text: 'c', index: 4, escaped: false, inCharClass: true, startsCharClass: true, endsCharClass: false},
	*   {text: 'd', index: 5, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false},
	*   {text: '-', index: 6, escaped: false, inCharClass: true, startsCharClass: false, endsCharClass: false}
	* ]
	*/
	function parseRegExp(regExpText) {
	    const charList = [];
	
	    regExpText.split("").reduce((state, char, index) => {
	        if (!state.escapeNextChar) {
	            if (char === "\\") {
	                return Object.assign(state, {escapeNextChar: true});
	            }
	            if (char === "[" && !state.inCharClass) {
	                return Object.assign(state, {inCharClass: true, startingCharClass: true});
	            }
	            if (char === "]" && state.inCharClass) {
	                if (charList.length && charList[charList.length - 1].inCharClass) {
	                    charList[charList.length - 1].endsCharClass = true;
	                }
	                return Object.assign(state, {inCharClass: false, startingCharClass: false});
	            }
	        }
	        charList.push({text: char, index, escaped: state.escapeNextChar, inCharClass: state.inCharClass, startsCharClass: state.startingCharClass, endsCharClass: false});
	        return Object.assign(state, {escapeNextChar: false, startingCharClass: false});
	    }, {escapeNextChar: false, inCharClass: false, startingCharClass: false});
	
	    return charList;
	}
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow unnecessary escape characters",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Reports a node
	         * @param {ASTNode} node The node to report
	         * @param {number} startOffset The backslash's offset from the start of the node
	         * @param {string} character The uselessly escaped character (not including the backslash)
	         * @returns {void}
	         */
	        function report(node, startOffset, character) {
	            context.report({
	                node,
	                loc: {
	                    line: node.loc.start.line,
	                    column: node.loc.start.column + startOffset
	                },
	                message: "Unnecessary escape character: \\{{character}}.",
	                data: {character}
	            });
	        }
	
	        /**
	         * Checks if the escape character in given string slice is unnecessary.
	         *
	         * @private
	         * @param {ASTNode} node - node to validate.
	         * @param {string} match - string slice to validate.
	         * @returns {void}
	         */
	        function validateString(node, match) {
	            const isTemplateElement = node.type === "TemplateElement";
	            const escapedChar = match[0][1];
	            let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
	            let isQuoteEscape;
	
	            if (isTemplateElement) {
	                isQuoteEscape = escapedChar === "`";
	
	                if (escapedChar === "$") {
	
	                    // Warn if `\$` is not followed by `{`
	                    isUnnecessaryEscape = match.input[match.index + 2] !== "{";
	                } else if (escapedChar === "{") {
	
	                    /* Warn if `\{` is not preceded by `$`. If preceded by `$`, escaping
	                     * is necessary and the rule should not warn. If preceded by `/$`, the rule
	                     * will warn for the `/$` instead, as it is the first unnecessarily escaped character.
	                     */
	                    isUnnecessaryEscape = match.input[match.index - 1] !== "$";
	                }
	            } else {
	                isQuoteEscape = escapedChar === node.raw[0];
	            }
	
	            if (isUnnecessaryEscape && !isQuoteEscape) {
	                report(node, match.index, match[0].slice(1));
	            }
	        }
	
	        /**
	         * Checks if a node has an escape.
	         *
	         * @param {ASTNode} node - node to check.
	         * @returns {void}
	         */
	        function check(node) {
	            const isTemplateElement = node.type === "TemplateElement";
	            const value = isTemplateElement ? node.value.raw : node.raw;
	            const pattern = /\\[^\d]/g;
	
	            if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression") {
	
	                // Don't report tagged template literals, because the backslash character is accessible to the tag function.
	                return;
	            }
	
	            if (typeof node.value === "string" || isTemplateElement) {
	
	                /*
	                 * JSXAttribute doesn't have any escape sequence: https://facebook.github.io/jsx/.
	                 * In addition, backticks are not supported by JSX yet: https://github.com/facebook/jsx/issues/25.
	                 */
	                if (node.parent.type === "JSXAttribute") {
	                    return;
	                }
	
	                let match;
	
	                while ((match = pattern.exec(value))) {
	                    validateString(node, match);
	                }
	            } else if (node.regex) {
	                parseRegExp(node.regex.pattern)
	
	                    /*
	                     * The '-' character is a special case, because it's only valid to escape it if it's in a character
	                     * class, and is not at either edge of the character class. To account for this, don't consider '-'
	                     * characters to be valid in general, and filter out '-' characters that appear in the middle of a
	                     * character class.
	                     */
	                    .filter(charInfo => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass))
	
	                    /*
	                     * The '^' character is also a special case; it must always be escaped outside of character classes, but
	                     * it only needs to be escaped in character classes if it's at the beginning of the character class. To
	                     * account for this, consider it to be a valid escape character outside of character classes, and filter
	                     * out '^' characters that appear at the start of a character class.
	                     */
	                    .filter(charInfo => !(charInfo.text === "^" && charInfo.startsCharClass))
	
	                    // Filter out characters that aren't escaped.
	                    .filter(charInfo => charInfo.escaped)
	
	                    // Filter out characters that are valid to escape, based on their position in the regular expression.
	                    .filter(charInfo => !(charInfo.inCharClass ? REGEX_CHARCLASS_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text))
	
	                    // Report all the remaining characters.
	                    .forEach(charInfo => report(node, charInfo.index, charInfo.text));
	            }
	
	        }
	
	        return {
	            Literal: check,
	            TemplateElement: check
	        };
	    }
	};


/***/ },
/* 317 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Disallow renaming import, export, and destructured assignments to the same name.
	 * @author Kai Cataldo
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow renaming import, export, and destructured assignments to the same name",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	        fixable: "code",
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    ignoreDestructuring: { type: "boolean" },
	                    ignoreImport: { type: "boolean" },
	                    ignoreExport: { type: "boolean" }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {},
	            ignoreDestructuring = options.ignoreDestructuring === true,
	            ignoreImport = options.ignoreImport === true,
	            ignoreExport = options.ignoreExport === true;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Reports error for unnecessarily renamed assignments
	         * @param {ASTNode} node - node to report
	         * @param {ASTNode} initial - node with initial name value
	         * @param {ASTNode} result - node with new name value
	         * @param {string} type - the type of the offending node
	         * @returns {void}
	         */
	        function reportError(node, initial, result, type) {
	            const name = initial.type === "Identifier" ? initial.name : initial.value;
	
	            return context.report({
	                node,
	                message: "{{type}} {{name}} unnecessarily renamed.",
	                data: {
	                    name,
	                    type
	                },
	                fix(fixer) {
	                    return fixer.replaceTextRange([
	                        initial.range[0],
	                        result.range[1]
	                    ], name);
	                }
	            });
	        }
	
	        /**
	         * Checks whether a destructured assignment is unnecessarily renamed
	         * @param {ASTNode} node - node to check
	         * @returns {void}
	         */
	        function checkDestructured(node) {
	            if (ignoreDestructuring) {
	                return;
	            }
	
	            const properties = node.properties;
	
	            for (let i = 0; i < properties.length; i++) {
	                if (properties[i].shorthand) {
	                    continue;
	                }
	
	                /**
	                 * If an ObjectPattern property is computed, we have no idea
	                 * if a rename is useless or not. If an ObjectPattern property
	                 * lacks a key, it is likely an ExperimentalRestProperty and
	                 * so there is no "renaming" occurring here.
	                 */
	                if (properties[i].computed || !properties[i].key) {
	                    continue;
	                }
	
	                if (properties[i].key.type === "Identifier" && properties[i].key.name === properties[i].value.name ||
	                        properties[i].key.type === "Literal" && properties[i].key.value === properties[i].value.name) {
	                    reportError(properties[i], properties[i].key, properties[i].value, "Destructuring assignment");
	                }
	            }
	        }
	
	        /**
	         * Checks whether an import is unnecessarily renamed
	         * @param {ASTNode} node - node to check
	         * @returns {void}
	         */
	        function checkImport(node) {
	            if (ignoreImport) {
	                return;
	            }
	
	            if (node.imported.name === node.local.name &&
	                    node.imported.range[0] !== node.local.range[0]) {
	                reportError(node, node.imported, node.local, "Import");
	            }
	        }
	
	        /**
	         * Checks whether an export is unnecessarily renamed
	         * @param {ASTNode} node - node to check
	         * @returns {void}
	         */
	        function checkExport(node) {
	            if (ignoreExport) {
	                return;
	            }
	
	            if (node.local.name === node.exported.name &&
	                    node.local.range[0] !== node.exported.range[0]) {
	                reportError(node, node.local, node.exported, "Export");
	            }
	
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ObjectPattern: checkDestructured,
	            ImportSpecifier: checkImport,
	            ExportSpecifier: checkExport
	        };
	    }
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallow redundant return statements
	 * @author Teddy Katz
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Adds all elements of 2nd argument into 1st argument.
	 *
	 * @param {Array} array - The destination array to add.
	 * @param {Array} elements - The source array to add.
	 * @returns {void}
	 */
	const pushAll = Function.apply.bind(Array.prototype.push);
	
	/**
	 * Removes the given element from the array.
	 *
	 * @param {Array} array - The source array to remove.
	 * @param {any} element - The target item to remove.
	 * @returns {void}
	 */
	function remove(array, element) {
	    const index = array.indexOf(element);
	
	    if (index !== -1) {
	        array.splice(index, 1);
	    }
	}
	
	/**
	 * Checks whether it can remove the given return statement or not.
	 *
	 * @param {ASTNode} node - The return statement node to check.
	 * @returns {boolean} `true` if the node is removeable.
	 */
	function isRemovable(node) {
	    const parent = node.parent;
	
	    return (
	        parent.type === "Program" ||
	        parent.type === "BlockStatement" ||
	        parent.type === "SwitchCase"
	    );
	}
	
	/**
	 * Checks whether the given return statement is in a loop or not.
	 *
	 * @param {ASTNode} node - The return statement node to check.
	 * @returns {boolean} `true` if the node is in a loop.
	 */
	function isInLoop(node) {
	    while (node && !astUtils.isFunction(node)) {
	        if (astUtils.isLoop(node)) {
	            return true;
	        }
	
	        node = node.parent;
	    }
	
	    return false;
	}
	
	/**
	 * Checks whether the given return statement is in a `finally` block or not.
	 *
	 * @param {ASTNode} node - The return statement node to check.
	 * @returns {boolean} `true` if the node is in a `finally` block.
	 */
	function isInFinally(node) {
	    while (node && node.parent && !astUtils.isFunction(node)) {
	        if (node.parent.type === "TryStatement" && node.parent.finalizer === node) {
	            return true;
	        }
	
	        node = node.parent;
	    }
	
	    return false;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow redundant return statements",
	            category: "Best Practices",
	            recommended: false
	        },
	        fixable: "code",
	        schema: []
	    },
	
	    create(context) {
	        const segmentInfoMap = new WeakMap();
	        let scopeInfo = null;
	
	        /**
	         * Checks whether the given segment is terminated by a return statement or not.
	         *
	         * @param {CodePathSegment} segment - The segment to check.
	         * @returns {boolean} `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
	         */
	        function isReturned(segment) {
	            const info = segmentInfoMap.get(segment);
	
	            return !info || info.returned;
	        }
	
	        /**
	         * Collects useless return statements from the given previous segments.
	         *
	         * A previous segment may be an unreachable segment.
	         * In that case, the information object of the unreachable segment is not
	         * initialized because `onCodePathSegmentStart` event is not notified for
	         * unreachable segments.
	         * This goes to the previous segments of the unreachable segment recursively
	         * if the unreachable segment was generated by a return statement. Otherwise,
	         * this ignores the unreachable segment.
	         *
	         * This behavior would simulate code paths for the case that the return
	         * statement does not exist.
	         *
	         * @param {ASTNode[]} uselessReturns - The collected return statements.
	         * @param {CodePathSegment[]} prevSegments - The previous segments to traverse.
	         * @returns {ASTNode[]} `uselessReturns`.
	         */
	        function getUselessReturns(uselessReturns, prevSegments) {
	            for (const segment of prevSegments) {
	                if (!segment.reachable) {
	                    getUselessReturns(
	                        uselessReturns,
	                        segment.allPrevSegments.filter(isReturned)
	                    );
	                    continue;
	                }
	
	                pushAll(uselessReturns, segmentInfoMap.get(segment).uselessReturns);
	            }
	
	            return uselessReturns;
	        }
	
	        /**
	         * Removes the return statements on the given segment from the useless return
	         * statement list.
	         *
	         * This segment may be an unreachable segment.
	         * In that case, the information object of the unreachable segment is not
	         * initialized because `onCodePathSegmentStart` event is not notified for
	         * unreachable segments.
	         * This goes to the previous segments of the unreachable segment recursively
	         * if the unreachable segment was generated by a return statement. Otherwise,
	         * this ignores the unreachable segment.
	         *
	         * This behavior would simulate code paths for the case that the return
	         * statement does not exist.
	         *
	         * @param {CodePathSegment} segment - The segment to get return statements.
	         * @returns {void}
	         */
	        function markReturnStatementsOnSegmentAsUsed(segment) {
	            if (!segment.reachable) {
	                segment.allPrevSegments
	                    .filter(isReturned)
	                    .forEach(markReturnStatementsOnSegmentAsUsed);
	                return;
	            }
	
	            const info = segmentInfoMap.get(segment);
	
	            for (const node of info.uselessReturns) {
	                remove(scopeInfo.uselessReturns, node);
	            }
	            info.uselessReturns = [];
	        }
	
	        /**
	         * Removes the return statements on the current segments from the useless
	         * return statement list.
	         *
	         * This function will be called at every statement except FunctionDeclaration,
	         * BlockStatement, and BreakStatement.
	         *
	         * - FunctionDeclarations are always executed whether it's returned or not.
	         * - BlockStatements do nothing.
	         * - BreakStatements go the next merely.
	         *
	         * @returns {void}
	         */
	        function markReturnStatementsOnCurrentSegmentsAsUsed() {
	            scopeInfo
	                .codePath
	                .currentSegments
	                .forEach(markReturnStatementsOnSegmentAsUsed);
	        }
	
	        //----------------------------------------------------------------------
	        // Public
	        //----------------------------------------------------------------------
	
	        return {
	
	            // Makes and pushs a new scope information.
	            onCodePathStart(codePath) {
	                scopeInfo = {
	                    upper: scopeInfo,
	                    uselessReturns: [],
	                    codePath,
	                };
	            },
	
	            // Reports useless return statements if exist.
	            onCodePathEnd() {
	                for (const node of scopeInfo.uselessReturns) {
	                    context.report({
	                        node,
	                        loc: node.loc,
	                        message: "Unnecessary return statement.",
	                        fix(fixer) {
	                            return isRemovable(node) ? fixer.remove(node) : null;
	                        },
	                    });
	                }
	
	                scopeInfo = scopeInfo.upper;
	            },
	
	            // Initializes segments.
	            // NOTE: This event is notified for only reachable segments.
	            onCodePathSegmentStart(segment) {
	                const info = {
	                    uselessReturns: getUselessReturns([], segment.allPrevSegments),
	                    returned: false,
	                };
	
	                // Stores the info.
	                segmentInfoMap.set(segment, info);
	            },
	
	            // Adds ReturnStatement node to check whether it's useless or not.
	            ReturnStatement(node) {
	                if (node.argument) {
	                    markReturnStatementsOnCurrentSegmentsAsUsed();
	                }
	                if (node.argument || isInLoop(node) || isInFinally(node)) {
	                    return;
	                }
	
	                for (const segment of scopeInfo.codePath.currentSegments) {
	                    const info = segmentInfoMap.get(segment);
	
	                    if (info) {
	                        info.uselessReturns.push(node);
	                        info.returned = true;
	                    }
	                }
	                scopeInfo.uselessReturns.push(node);
	            },
	
	            // Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
	            // Removes return statements of the current segments from the useless return statement list.
	            ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	            LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	            WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	            ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
	        };
	    }
	};


/***/ },
/* 319 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for the usage of var.
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/;
	
	/**
	 * Gets the scope node which directly contains a given node.
	 *
	 * @param {ASTNode} node - A node to get. This is a `VariableDeclaration` or
	 *      an `Identifier`.
	 * @returns {ASTNode} A scope node. This is one of `Program`, `BlockStatement`,
	 *      `SwitchStatement`, `ForStatement`, `ForInStatement`, and
	 *      `ForOfStatement`.
	 */
	function getScopeNode(node) {
	    while (node) {
	        if (SCOPE_NODE_TYPE.test(node.type)) {
	            return node;
	        }
	
	        node = node.parent;
	    }
	
	    /* istanbul ignore next : unreachable */
	    return null;
	}
	
	/**
	 * Checks whether a given variable is redeclared or not.
	 *
	 * @param {escope.Variable} variable - A variable to check.
	 * @returns {boolean} `true` if the variable is redeclared.
	 */
	function isRedeclared(variable) {
	    return variable.defs.length >= 2;
	}
	
	/**
	 * Checks whether a given variable is used from outside of the specified scope.
	 *
	 * @param {ASTNode} scopeNode - A scope node to check.
	 * @returns {Function} The predicate function which checks whether a given
	 *      variable is used from outside of the specified scope.
	 */
	function isUsedFromOutsideOf(scopeNode) {
	
	    /**
	     * Checks whether a given reference is inside of the specified scope or not.
	     *
	     * @param {escope.Reference} reference - A reference to check.
	     * @returns {boolean} `true` if the reference is inside of the specified
	     *      scope.
	     */
	    function isOutsideOfScope(reference) {
	        const scope = scopeNode.range;
	        const id = reference.identifier.range;
	
	        return id[0] < scope[0] || id[1] > scope[1];
	    }
	
	    return function(variable) {
	        return variable.references.some(isOutsideOfScope);
	    };
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `let` or `const` instead of `var`",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [],
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Checks whether it can fix a given variable declaration or not.
	         * It cannot fix if the following cases:
	         *
	         * - A variable is declared on a SwitchCase node.
	         * - A variable is redeclared.
	         * - A variable is used from outside the scope.
	         *
	         * ## A variable is declared on a SwitchCase node.
	         *
	         * If this rule modifies 'var' declarations on a SwitchCase node, it
	         * would generate the warnings of 'no-case-declarations' rule. And the
	         * 'eslint:recommended' preset includes 'no-case-declarations' rule, so
	         * this rule doesn't modify those declarations.
	         *
	         * ## A variable is redeclared.
	         *
	         * The language spec disallows redeclarations of `let` declarations.
	         * Those variables would cause syntax errors.
	         *
	         * ## A variable is used from outside the scope.
	         *
	         * The language spec disallows accesses from outside of the scope for
	         * `let` declarations. Those variables would cause reference errors.
	         *
	         * @param {ASTNode} node - A variable declaration node to check.
	         * @returns {boolean} `true` if it can fix the node.
	         */
	        function canFix(node) {
	            const variables = context.getDeclaredVariables(node);
	            const scopeNode = getScopeNode(node);
	
	            return !(
	                node.parent.type === "SwitchCase" ||
	                variables.some(isRedeclared) ||
	                variables.some(isUsedFromOutsideOf(scopeNode))
	            );
	        }
	
	        /**
	         * Reports a given variable declaration node.
	         *
	         * @param {ASTNode} node - A variable declaration node to report.
	         * @returns {void}
	         */
	        function report(node) {
	            const varToken = sourceCode.getFirstToken(node);
	
	            context.report({
	                node,
	                message: "Unexpected var, use let or const instead.",
	
	                fix(fixer) {
	                    if (canFix(node)) {
	                        return fixer.replaceText(varToken, "let");
	                    }
	                    return null;
	                }
	            });
	        }
	
	        return {
	            VariableDeclaration(node) {
	                if (node.kind === "var") {
	                    report(node);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 320 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow use of void operator.
	 * @author Mike Sidorov
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `void` operators",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            UnaryExpression(node) {
	                if (node.operator === "void") {
	                    context.report(node, "Expected 'undefined' and instead saw 'void'.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule that warns about used warning comments
	 * @author Alexander Schmidt <https://github.com/lxanders>
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow specified warning terms in comments",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    terms: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    location: {
	                        enum: ["start", "anywhere"]
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const configuration = context.options[0] || {},
	            warningTerms = configuration.terms || ["todo", "fixme", "xxx"],
	            location = configuration.location || "start",
	            selfConfigRegEx = /\bno-warning-comments\b/;
	
	        /**
	         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified
	         * location ("start" or "anywhere"). If the term starts or ends with non word characters, then the match will not
	         * require word boundaries on that side.
	         *
	         * @param {string} term A term to convert to a RegExp
	         * @returns {RegExp} The term converted to a RegExp
	         */
	        function convertToRegExp(term) {
	            const escaped = term.replace(/[-/\\$^*+?.()|[\]{}]/g, "\\$&");
	            let prefix;
	
	            /*
	             * If the term ends in a word character (a-z0-9_), ensure a word
	             * boundary at the end, so that substrings do not get falsely
	             * matched. eg "todo" in a string such as "mastodon".
	             * If the term ends in a non-word character, then \b won't match on
	             * the boundary to the next non-word character, which would likely
	             * be a space. For example `/\bFIX!\b/.test('FIX! blah') === false`.
	             * In these cases, use no bounding match. Same applies for the
	             * prefix, handled below.
	             */
	            const suffix = /\w$/.test(term) ? "\\b" : "";
	
	            if (location === "start") {
	
	                /*
	                 * When matching at the start, ignore leading whitespace, and
	                 * there's no need to worry about word boundaries.
	                 */
	                prefix = "^\\s*";
	            } else if (/^\w/.test(term)) {
	                prefix = "\\b";
	            } else {
	                prefix = "";
	            }
	
	            return new RegExp(prefix + escaped + suffix, "i");
	        }
	
	        const warningRegExps = warningTerms.map(convertToRegExp);
	
	        /**
	         * Checks the specified comment for matches of the configured warning terms and returns the matches.
	         * @param {string} comment The comment which is checked.
	         * @returns {Array} All matched warning terms for this comment.
	         */
	        function commentContainsWarningTerm(comment) {
	            const matches = [];
	
	            warningRegExps.forEach(function(regex, index) {
	                if (regex.test(comment)) {
	                    matches.push(warningTerms[index]);
	                }
	            });
	
	            return matches;
	        }
	
	        /**
	         * Checks the specified node for matching warning comments and reports them.
	         * @param {ASTNode} node The AST node being checked.
	         * @returns {void} undefined.
	         */
	        function checkComment(node) {
	            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {
	                return;
	            }
	
	            const matches = commentContainsWarningTerm(node.value);
	
	            matches.forEach(function(matchedTerm) {
	                context.report({
	                    node,
	                    message: "Unexpected '{{matchedTerm}}' comment.",
	                    data: {
	                        matchedTerm
	                    }
	                });
	            });
	        }
	
	        return {
	            BlockComment: checkComment,
	            LineComment: checkComment
	        };
	    }
	};


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to disallow whitespace before properties
	 * @author Kai Cataldo
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow whitespace before properties",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	        schema: []
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Finds opening bracket token of node's computed property
	         * @param {ASTNode} node - the node to check
	         * @returns {Token} opening bracket token of node's computed property
	         * @private
	         */
	        function findOpeningBracket(node) {
	            let token = sourceCode.getTokenBefore(node.property);
	
	            while (token.value !== "[") {
	                token = sourceCode.getTokenBefore(token);
	            }
	            return token;
	        }
	
	        /**
	         * Reports whitespace before property token
	         * @param {ASTNode} node - the node to report in the event of an error
	         * @param {Token} leftToken - the left token
	         * @param {Token} rightToken - the right token
	         * @returns {void}
	         * @private
	         */
	        function reportError(node, leftToken, rightToken) {
	            const replacementText = node.computed ? "" : ".";
	
	            context.report({
	                node,
	                message: "Unexpected whitespace before property {{propName}}.",
	                data: {
	                    propName: sourceCode.getText(node.property)
	                },
	                fix(fixer) {
	                    if (!node.computed && astUtils.isDecimalInteger(node.object)) {
	
	                        // If the object is a number literal, fixing it to something like 5.toString() would cause a SyntaxError.
	                        // Don't fix this case.
	                        return null;
	                    }
	                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
	                }
	            });
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            MemberExpression(node) {
	                let rightToken;
	                let leftToken;
	
	                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
	                    return;
	                }
	
	                if (node.computed) {
	                    rightToken = findOpeningBracket(node);
	                    leftToken = sourceCode.getTokenBefore(rightToken);
	                } else {
	                    rightToken = sourceCode.getFirstToken(node.property);
	                    leftToken = sourceCode.getTokenBefore(rightToken, 1);
	                }
	
	                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
	                    reportError(node, leftToken, rightToken);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 323 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag use of with statement
	 * @author Nicholas C. Zakas
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `with` statements",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            WithStatement(node) {
	                context.report(node, "Unexpected use of 'with' statement.");
	            }
	        };
	
	    }
	};


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to require or disallow line breaks inside braces.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	// Schema objects.
	const OPTION_VALUE = {
	    oneOf: [
	        {
	            enum: ["always", "never"]
	        },
	        {
	            type: "object",
	            properties: {
	                multiline: {
	                    type: "boolean"
	                },
	                minProperties: {
	                    type: "integer",
	                    minimum: 0
	                }
	            },
	            additionalProperties: false,
	            minProperties: 1
	        }
	    ]
	};
	
	/**
	 * Normalizes a given option value.
	 *
	 * @param {string|Object|undefined} value - An option value to parse.
	 * @returns {{multiline: boolean, minProperties: number}} Normalized option object.
	 */
	function normalizeOptionValue(value) {
	    let multiline = false;
	    let minProperties = Number.POSITIVE_INFINITY;
	
	    if (value) {
	        if (value === "always") {
	            minProperties = 0;
	        } else if (value === "never") {
	            minProperties = Number.POSITIVE_INFINITY;
	        } else {
	            multiline = Boolean(value.multiline);
	            minProperties = value.minProperties || Number.POSITIVE_INFINITY;
	        }
	    } else {
	        multiline = true;
	    }
	
	    return {multiline, minProperties};
	}
	
	/**
	 * Normalizes a given option value.
	 *
	 * @param {string|Object|undefined} options - An option value to parse.
	 * @returns {{ObjectExpression: {multiline: boolean, minProperties: number}, ObjectPattern: {multiline: boolean, minProperties: number}}} Normalized option object.
	 */
	function normalizeOptions(options) {
	    if (options && (options.ObjectExpression || options.ObjectPattern)) {
	        return {
	            ObjectExpression: normalizeOptionValue(options.ObjectExpression),
	            ObjectPattern: normalizeOptionValue(options.ObjectPattern)
	        };
	    }
	
	    const value = normalizeOptionValue(options);
	
	    return {ObjectExpression: value, ObjectPattern: value};
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent line breaks inside braces",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        fixable: "whitespace",
	        schema: [
	            {
	                oneOf: [
	                    OPTION_VALUE,
	                    {
	                        type: "object",
	                        properties: {
	                            ObjectExpression: OPTION_VALUE,
	                            ObjectPattern: OPTION_VALUE
	                        },
	                        additionalProperties: false,
	                        minProperties: 1
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const normalizedOptions = normalizeOptions(context.options[0]);
	
	        /**
	         * Reports a given node if it violated this rule.
	         *
	         * @param {ASTNode} node - A node to check. This is an ObjectExpression node or an ObjectPattern node.
	         * @param {{multiline: boolean, minProperties: number}} options - An option object.
	         * @returns {void}
	         */
	        function check(node) {
	            const options = normalizedOptions[node.type];
	            const openBrace = sourceCode.getFirstToken(node);
	            const closeBrace = sourceCode.getLastToken(node);
	            let first = sourceCode.getTokenOrCommentAfter(openBrace);
	            let last = sourceCode.getTokenOrCommentBefore(closeBrace);
	            const needsLinebreaks = (
	                node.properties.length >= options.minProperties ||
	                (
	                    options.multiline &&
	                    node.properties.length > 0 &&
	                    first.loc.start.line !== last.loc.end.line
	                )
	            );
	
	            /*
	             * Use tokens or comments to check multiline or not.
	             * But use only tokens to check whether line breaks are needed.
	             * This allows:
	             *     var obj = { // eslint-disable-line foo
	             *         a: 1
	             *     }
	             */
	            first = sourceCode.getTokenAfter(openBrace);
	            last = sourceCode.getTokenBefore(closeBrace);
	
	            if (needsLinebreaks) {
	                if (astUtils.isTokenOnSameLine(openBrace, first)) {
	                    context.report({
	                        message: "Expected a line break after this opening brace.",
	                        node,
	                        loc: openBrace.loc.start,
	                        fix(fixer) {
	                            return fixer.insertTextAfter(openBrace, "\n");
	                        }
	                    });
	                }
	                if (astUtils.isTokenOnSameLine(last, closeBrace)) {
	                    context.report({
	                        message: "Expected a line break before this closing brace.",
	                        node,
	                        loc: closeBrace.loc.start,
	                        fix(fixer) {
	                            return fixer.insertTextBefore(closeBrace, "\n");
	                        }
	                    });
	                }
	            } else {
	                if (!astUtils.isTokenOnSameLine(openBrace, first)) {
	                    context.report({
	                        message: "Unexpected line break after this opening brace.",
	                        node,
	                        loc: openBrace.loc.start,
	                        fix(fixer) {
	                            return fixer.removeRange([
	                                openBrace.range[1],
	                                first.range[0]
	                            ]);
	                        }
	                    });
	                }
	                if (!astUtils.isTokenOnSameLine(last, closeBrace)) {
	                    context.report({
	                        message: "Unexpected line break before this closing brace.",
	                        node,
	                        loc: closeBrace.loc.start,
	                        fix(fixer) {
	                            return fixer.removeRange([
	                                last.range[1],
	                                closeBrace.range[0]
	                            ]);
	                        }
	                    });
	                }
	            }
	        }
	
	        return {
	            ObjectExpression: check,
	            ObjectPattern: check
	        };
	    }
	};


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of object literals.
	 * @author Jamund Ferguson
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing inside braces",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            },
	            {
	                type: "object",
	                properties: {
	                    arraysInObjects: {
	                        type: "boolean"
	                    },
	                    objectsInObjects: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const spaced = context.options[0] === "always",
	            sourceCode = context.getSourceCode();
	
	        /**
	         * Determines whether an option is set, relative to the spacing option.
	         * If spaced is "always", then check whether option is set to false.
	         * If spaced is "never", then check whether option is set to true.
	         * @param {Object} option - The option to exclude.
	         * @returns {boolean} Whether or not the property is excluded.
	         */
	        function isOptionSet(option) {
	            return context.options[1] ? context.options[1][option] === !spaced : false;
	        }
	
	        const options = {
	            spaced,
	            arraysInObjectsException: isOptionSet("arraysInObjects"),
	            objectsInObjectsException: isOptionSet("objectsInObjects")
	        };
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	        * Reports that there shouldn't be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportNoBeginningSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space after '{{token}}'.",
	                data: {
	                    token: token.value
	                },
	                fix(fixer) {
	                    const nextToken = context.getSourceCode().getTokenAfter(token);
	
	                    return fixer.removeRange([token.range[1], nextToken.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there shouldn't be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportNoEndingSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "There should be no space before '{{token}}'.",
	                data: {
	                    token: token.value
	                },
	                fix(fixer) {
	                    const previousToken = context.getSourceCode().getTokenBefore(token);
	
	                    return fixer.removeRange([previousToken.range[1], token.range[0]]);
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space after the first token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredBeginningSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required after '{{token}}'.",
	                data: {
	                    token: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextAfter(token, " ");
	                }
	            });
	        }
	
	        /**
	        * Reports that there should be a space before the last token
	        * @param {ASTNode} node - The node to report in the event of an error.
	        * @param {Token} token - The token to use for the report.
	        * @returns {void}
	        */
	        function reportRequiredEndingSpace(node, token) {
	            context.report({
	                node,
	                loc: token.loc.start,
	                message: "A space is required before '{{token}}'.",
	                data: {
	                    token: token.value
	                },
	                fix(fixer) {
	                    return fixer.insertTextBefore(token, " ");
	                }
	            });
	        }
	
	        /**
	         * Determines if spacing in curly braces is valid.
	         * @param {ASTNode} node The AST node to check.
	         * @param {Token} first The first token to check (should be the opening brace)
	         * @param {Token} second The second token to check (should be first after the opening brace)
	         * @param {Token} penultimate The penultimate token to check (should be last before closing brace)
	         * @param {Token} last The last token to check (should be closing brace)
	         * @returns {void}
	         */
	        function validateBraceSpacing(node, first, second, penultimate, last) {
	            if (astUtils.isTokenOnSameLine(first, second)) {
	                const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
	
	                if (options.spaced && !firstSpaced) {
	                    reportRequiredBeginningSpace(node, first);
	                }
	                if (!options.spaced && firstSpaced) {
	                    reportNoBeginningSpace(node, first);
	                }
	            }
	
	            if (astUtils.isTokenOnSameLine(penultimate, last)) {
	                const shouldCheckPenultimate = (
	                    options.arraysInObjectsException && penultimate.value === "]" ||
	                    options.objectsInObjectsException && penultimate.value === "}"
	                );
	                const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.start).type;
	
	                const closingCurlyBraceMustBeSpaced = (
	                    options.arraysInObjectsException && penultimateType === "ArrayExpression" ||
	                    options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern")
	                ) ? !options.spaced : options.spaced;
	
	                const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
	
	                if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
	                    reportRequiredEndingSpace(node, last);
	                }
	                if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
	                    reportNoEndingSpace(node, last);
	                }
	            }
	        }
	
	        /**
	         * Gets '}' token of an object node.
	         *
	         * Because the last token of object patterns might be a type annotation,
	         * this traverses tokens preceded by the last property, then returns the
	         * first '}' token.
	         *
	         * @param {ASTNode} node - The node to get. This node is an
	         *      ObjectExpression or an ObjectPattern. And this node has one or
	         *      more properties.
	         * @returns {Token} '}' token.
	         */
	        function getClosingBraceOfObject(node) {
	            const lastProperty = node.properties[node.properties.length - 1];
	            let token = sourceCode.getTokenAfter(lastProperty);
	
	            // skip ')' and trailing commas.
	            while (token.type !== "Punctuator" || token.value !== "}") {
	                token = sourceCode.getTokenAfter(token);
	            }
	
	            return token;
	        }
	
	        /**
	         * Reports a given object node if spacing in curly braces is invalid.
	         * @param {ASTNode} node - An ObjectExpression or ObjectPattern node to check.
	         * @returns {void}
	         */
	        function checkForObject(node) {
	            if (node.properties.length === 0) {
	                return;
	            }
	
	            const first = sourceCode.getFirstToken(node),
	                last = getClosingBraceOfObject(node),
	                second = sourceCode.getTokenAfter(first),
	                penultimate = sourceCode.getTokenBefore(last);
	
	            validateBraceSpacing(node, first, second, penultimate, last);
	        }
	
	        /**
	         * Reports a given import node if spacing in curly braces is invalid.
	         * @param {ASTNode} node - An ImportDeclaration node to check.
	         * @returns {void}
	         */
	        function checkForImport(node) {
	            if (node.specifiers.length === 0) {
	                return;
	            }
	
	            let firstSpecifier = node.specifiers[0];
	            const lastSpecifier = node.specifiers[node.specifiers.length - 1];
	
	            if (lastSpecifier.type !== "ImportSpecifier") {
	                return;
	            }
	            if (firstSpecifier.type !== "ImportSpecifier") {
	                firstSpecifier = node.specifiers[1];
	            }
	
	            const first = sourceCode.getTokenBefore(firstSpecifier);
	            let last = sourceCode.getTokenAfter(lastSpecifier);
	
	            // to support a trailing comma.
	            if (last.value === ",") {
	                last = sourceCode.getTokenAfter(last);
	            }
	
	            const second = sourceCode.getTokenAfter(first),
	                penultimate = sourceCode.getTokenBefore(last);
	
	            validateBraceSpacing(node, first, second, penultimate, last);
	        }
	
	        /**
	         * Reports a given export node if spacing in curly braces is invalid.
	         * @param {ASTNode} node - An ExportNamedDeclaration node to check.
	         * @returns {void}
	         */
	        function checkForExport(node) {
	            if (node.specifiers.length === 0) {
	                return;
	            }
	
	            const firstSpecifier = node.specifiers[0],
	                lastSpecifier = node.specifiers[node.specifiers.length - 1],
	                first = sourceCode.getTokenBefore(firstSpecifier);
	            let last = sourceCode.getTokenAfter(lastSpecifier);
	
	            // to support a trailing comma.
	            if (last.value === ",") {
	                last = sourceCode.getTokenAfter(last);
	            }
	
	            const second = sourceCode.getTokenAfter(first),
	                penultimate = sourceCode.getTokenBefore(last);
	
	            validateBraceSpacing(node, first, second, penultimate, last);
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            // var {x} = y;
	            ObjectPattern: checkForObject,
	
	            // var y = {x: 'y'}
	            ObjectExpression: checkForObject,
	
	            // import {y} from 'x';
	            ImportDeclaration: checkForImport,
	
	            // export {name} from 'yo';
	            ExportNamedDeclaration: checkForExport
	        };
	
	    }
	};


/***/ },
/* 326 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce placing object properties on separate lines.
	 * @author Vitor Balocco
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce placing object properties on separate lines",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowMultiplePropertiesPerLine: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const allowSameLine = context.options[0] && Boolean(context.options[0].allowMultiplePropertiesPerLine);
	        const errorMessage = allowSameLine ?
	            "Object properties must go on a new line if they aren't all on the same line." :
	            "Object properties must go on a new line.";
	
	        const sourceCode = context.getSourceCode();
	
	        return {
	            ObjectExpression(node) {
	                if (allowSameLine) {
	                    if (node.properties.length > 1) {
	                        const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
	                        const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
	
	                        if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
	
	                            // All keys and values are on the same line
	                            return;
	                        }
	                    }
	                }
	
	                for (let i = 1; i < node.properties.length; i++) {
	                    const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
	                    const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
	
	                    if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
	                        context.report({
	                            node,
	                            loc: firstTokenOfCurrentProperty.loc.start,
	                            message: errorMessage
	                        });
	                    }
	                }
	            }
	        };
	    }
	};


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to enforce concise object methods and properties.
	 * @author Jamund Ferguson
	 */
	
	"use strict";
	
	const OPTIONS = {
	    always: "always",
	    never: "never",
	    methods: "methods",
	    properties: "properties",
	    consistent: "consistent",
	    consistentAsNeeded: "consistent-as-needed"
	};
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow method and property shorthand syntax for object literals",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "methods", "properties"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                avoidQuotes: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "methods"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                ignoreConstructors: {
	                                    type: "boolean"
	                                },
	                                avoidQuotes: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        }
	    },
	
	    create(context) {
	        const APPLY = context.options[0] || OPTIONS.always;
	        const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
	        const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
	        const APPLY_NEVER = APPLY === OPTIONS.never;
	        const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
	        const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
	
	        const PARAMS = context.options[1] || {};
	        const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
	        const AVOID_QUOTES = PARAMS.avoidQuotes;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Determines if the first character of the name is a capital letter.
	         * @param {string} name The name of the node to evaluate.
	         * @returns {boolean} True if the first character of the property name is a capital letter, false if not.
	         * @private
	         */
	        function isConstructor(name) {
	            const firstChar = name.charAt(0);
	
	            return firstChar === firstChar.toUpperCase();
	        }
	
	        /**
	         * Determines if the property can have a shorthand form.
	         * @param {ASTNode} property Property AST node
	         * @returns {boolean} True if the property can have a shorthand form
	         * @private
	         **/
	        function canHaveShorthand(property) {
	            return (property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty");
	        }
	
	        /**
	          * Checks whether a node is a string literal.
	          * @param   {ASTNode} node - Any AST node.
	          * @returns {boolean} `true` if it is a string literal.
	          */
	        function isStringLiteral(node) {
	            return node.type === "Literal" && typeof node.value === "string";
	        }
	
	        /**
	         * Determines if the property is a shorthand or not.
	         * @param {ASTNode} property Property AST node
	         * @returns {boolean} True if the property is considered shorthand, false if not.
	         * @private
	         **/
	        function isShorthand(property) {
	
	            // property.method is true when `{a(){}}`.
	            return (property.shorthand || property.method);
	        }
	
	        /**
	         * Determines if the property's key and method or value are named equally.
	         * @param {ASTNode} property Property AST node
	         * @returns {boolean} True if the key and value are named equally, false if not.
	         * @private
	         **/
	        function isRedundant(property) {
	            const value = property.value;
	
	            if (value.type === "FunctionExpression") {
	                return !value.id; // Only anonymous should be shorthand method.
	            }
	            if (value.type === "Identifier") {
	                return astUtils.getStaticPropertyName(property) === value.name;
	            }
	
	            return false;
	        }
	
	        /**
	         * Ensures that an object's properties are consistently shorthand, or not shorthand at all.
	         * @param   {ASTNode} node Property AST node
	         * @param   {boolean} checkRedundancy Whether to check longform redundancy
	         * @returns {void}
	         **/
	        function checkConsistency(node, checkRedundancy) {
	
	            // We are excluding getters/setters and spread properties as they are considered neither longform nor shorthand.
	            const properties = node.properties.filter(canHaveShorthand);
	
	            // Do we still have properties left after filtering the getters and setters?
	            if (properties.length > 0) {
	                const shorthandProperties = properties.filter(isShorthand);
	
	                // If we do not have an equal number of longform properties as
	                // shorthand properties, we are using the annotations inconsistently
	                if (shorthandProperties.length !== properties.length) {
	
	                    // We have at least 1 shorthand property
	                    if (shorthandProperties.length > 0) {
	                        context.report(node, "Unexpected mix of shorthand and non-shorthand properties.");
	                    } else if (checkRedundancy) {
	
	                        // If all properties of the object contain a method or value with a name matching it's key,
	                        // all the keys are redundant.
	                        const canAlwaysUseShorthand = properties.every(isRedundant);
	
	                        if (canAlwaysUseShorthand) {
	                            context.report(node, "Expected shorthand for all properties.");
	                        }
	                    }
	                }
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ObjectExpression(node) {
	                if (APPLY_CONSISTENT) {
	                    checkConsistency(node, false);
	                } else if (APPLY_CONSISTENT_AS_NEEDED) {
	                    checkConsistency(node, true);
	                }
	            },
	
	            Property(node) {
	                const isConciseProperty = node.method || node.shorthand;
	
	                // Ignore destructuring assignment
	                if (node.parent.type === "ObjectPattern") {
	                    return;
	                }
	
	                // getters and setters are ignored
	                if (node.kind === "get" || node.kind === "set") {
	                    return;
	                }
	
	                // only computed methods can fail the following checks
	                if (node.computed && node.value.type !== "FunctionExpression") {
	                    return;
	                }
	
	                //--------------------------------------------------------------
	                // Checks for property/method shorthand.
	                if (isConciseProperty) {
	
	                    // if we're "never" and concise we should warn now
	                    if (APPLY_NEVER) {
	                        const type = node.method ? "method" : "property";
	
	                        context.report({
	                            node,
	                            message: "Expected longform {{type}} syntax.",
	                            data: {
	                                type
	                            },
	                            fix(fixer) {
	                                if (node.method) {
	                                    if (node.value.generator) {
	                                        return fixer.replaceTextRange([node.range[0], node.key.range[1]], `${node.key.name}: function*`);
	                                    }
	
	                                    return fixer.insertTextAfter(node.key, ": function");
	                                }
	
	                                return fixer.insertTextAfter(node.key, `: ${node.key.name}`);
	                            }
	                        });
	                    }
	
	                    // {'xyz'() {}} should be written as {'xyz': function() {}}
	                    if (AVOID_QUOTES && isStringLiteral(node.key)) {
	                        context.report({
	                            node,
	                            message: "Expected longform method syntax for string literal keys.",
	                            fix(fixer) {
	                                if (node.computed) {
	                                    return fixer.insertTextAfterRange([node.key.range[0], node.key.range[1] + 1], ": function");
	                                }
	
	                                return fixer.insertTextAfter(node.key, ": function");
	                            }
	                        });
	                    }
	
	                    return;
	                }
	
	                //--------------------------------------------------------------
	                // Checks for longform properties.
	                if (node.value.type === "FunctionExpression" && !node.value.id && APPLY_TO_METHODS) {
	                    if (IGNORE_CONSTRUCTORS && isConstructor(node.key.name)) {
	                        return;
	                    }
	                    if (AVOID_QUOTES && isStringLiteral(node.key)) {
	                        return;
	                    }
	
	                    // {[x]: function(){}} should be written as {[x]() {}}
	                    if (node.computed) {
	                        context.report({
	                            node,
	                            message: "Expected method shorthand.",
	                            fix(fixer) {
	                                if (node.value.generator) {
	                                    return fixer.replaceTextRange(
	                                        [node.key.range[0], node.value.range[0] + "function*".length],
	                                        `*[${node.key.name}]`
	                                    );
	                                }
	
	                                return fixer.removeRange([node.key.range[1] + 1, node.value.range[0] + "function".length]);
	                            }
	                        });
	                        return;
	                    }
	
	                    // {x: function(){}} should be written as {x() {}}
	                    context.report({
	                        node,
	                        message: "Expected method shorthand.",
	                        fix(fixer) {
	                            if (node.value.generator) {
	                                return fixer.replaceTextRange(
	                                    [node.key.range[0], node.value.range[0] + "function*".length],
	                                    `*${node.key.name}`
	                                );
	                            }
	
	                            return fixer.removeRange([node.key.range[1], node.value.range[0] + "function".length]);
	                        }
	                    });
	                } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
	
	                    // {x: x} should be written as {x}
	                    context.report({
	                        node,
	                        message: "Expected property shorthand.",
	                        fix(fixer) {
	                            return fixer.replaceText(node, node.value.name);
	                        }
	                    });
	                } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
	                    if (AVOID_QUOTES) {
	                        return;
	                    }
	
	                    // {"x": x} should be written as {x}
	                    context.report({
	                        node,
	                        message: "Expected property shorthand.",
	                        fix(fixer) {
	                            return fixer.replaceText(node, node.value.name);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 328 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check multiple var declarations per line
	 * @author Alberto Rodrguez
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow newlines around variable declarations",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["always", "initializations"]
	            }
	        ],
	
	        fixable: "whitespace"
	    },
	
	    create(context) {
	
	        const ERROR_MESSAGE = "Expected variable declaration to be on a new line.";
	        const always = context.options[0] === "always";
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	
	        /**
	         * Determine if provided keyword is a variant of for specifiers
	         * @private
	         * @param {string} keyword - keyword to test
	         * @returns {boolean} True if `keyword` is a variant of for specifier
	         */
	        function isForTypeSpecifier(keyword) {
	            return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
	        }
	
	        /**
	         * Checks newlines around variable declarations.
	         * @private
	         * @param {ASTNode} node - `VariableDeclaration` node to test
	         * @returns {void}
	         */
	        function checkForNewLine(node) {
	            if (isForTypeSpecifier(node.parent.type)) {
	                return;
	            }
	
	            const declarations = node.declarations;
	            let prev;
	
	            declarations.forEach(function(current) {
	                if (prev && prev.loc.end.line === current.loc.start.line) {
	                    if (always || prev.init || current.init) {
	                        context.report({
	                            node,
	                            message: ERROR_MESSAGE,
	                            loc: current.loc.start,
	                            fix: fixer => fixer.insertTextBefore(current, "\n")
	                        });
	                    }
	                }
	                prev = current;
	            });
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            VariableDeclaration: checkForNewLine
	        };
	
	    }
	};


/***/ },
/* 329 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to control the use of single variable declarations.
	 * @author Ian Christian Myers
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce variables to be declared either together or separately in functions",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["always", "never"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            var: {
	                                enum: ["always", "never"]
	                            },
	                            let: {
	                                enum: ["always", "never"]
	                            },
	                            const: {
	                                enum: ["always", "never"]
	                            }
	                        },
	                        additionalProperties: false
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            initialized: {
	                                enum: ["always", "never"]
	                            },
	                            uninitialized: {
	                                enum: ["always", "never"]
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const MODE_ALWAYS = "always",
	            MODE_NEVER = "never";
	
	        const mode = context.options[0] || MODE_ALWAYS;
	
	        const options = {
	        };
	
	        if (typeof mode === "string") { // simple options configuration with just a string
	            options.var = { uninitialized: mode, initialized: mode};
	            options.let = { uninitialized: mode, initialized: mode};
	            options.const = { uninitialized: mode, initialized: mode};
	        } else if (typeof mode === "object") { // options configuration is an object
	            if (mode.hasOwnProperty("var") && typeof mode.var === "string") {
	                options.var = { uninitialized: mode.var, initialized: mode.var};
	            }
	            if (mode.hasOwnProperty("let") && typeof mode.let === "string") {
	                options.let = { uninitialized: mode.let, initialized: mode.let};
	            }
	            if (mode.hasOwnProperty("const") && typeof mode.const === "string") {
	                options.const = { uninitialized: mode.const, initialized: mode.const};
	            }
	            if (mode.hasOwnProperty("uninitialized")) {
	                if (!options.var) {
	                    options.var = {};
	                }
	                if (!options.let) {
	                    options.let = {};
	                }
	                if (!options.const) {
	                    options.const = {};
	                }
	                options.var.uninitialized = mode.uninitialized;
	                options.let.uninitialized = mode.uninitialized;
	                options.const.uninitialized = mode.uninitialized;
	            }
	            if (mode.hasOwnProperty("initialized")) {
	                if (!options.var) {
	                    options.var = {};
	                }
	                if (!options.let) {
	                    options.let = {};
	                }
	                if (!options.const) {
	                    options.const = {};
	                }
	                options.var.initialized = mode.initialized;
	                options.let.initialized = mode.initialized;
	                options.const.initialized = mode.initialized;
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        const functionStack = [];
	        const blockStack = [];
	
	        /**
	         * Increments the blockStack counter.
	         * @returns {void}
	         * @private
	         */
	        function startBlock() {
	            blockStack.push({
	                let: {initialized: false, uninitialized: false},
	                const: {initialized: false, uninitialized: false}
	            });
	        }
	
	        /**
	         * Increments the functionStack counter.
	         * @returns {void}
	         * @private
	         */
	        function startFunction() {
	            functionStack.push({initialized: false, uninitialized: false});
	            startBlock();
	        }
	
	        /**
	         * Decrements the blockStack counter.
	         * @returns {void}
	         * @private
	         */
	        function endBlock() {
	            blockStack.pop();
	        }
	
	        /**
	         * Decrements the functionStack counter.
	         * @returns {void}
	         * @private
	         */
	        function endFunction() {
	            functionStack.pop();
	            endBlock();
	        }
	
	        /**
	         * Records whether initialized or uninitialized variables are defined in current scope.
	         * @param {string} statementType node.kind, one of: "var", "let", or "const"
	         * @param {ASTNode[]} declarations List of declarations
	         * @param {Object} currentScope The scope being investigated
	         * @returns {void}
	         * @private
	         */
	        function recordTypes(statementType, declarations, currentScope) {
	            for (let i = 0; i < declarations.length; i++) {
	                if (declarations[i].init === null) {
	                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
	                        currentScope.uninitialized = true;
	                    }
	                } else {
	                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
	                        currentScope.initialized = true;
	                    }
	                }
	            }
	        }
	
	        /**
	         * Determines the current scope (function or block)
	         * @param  {string} statementType node.kind, one of: "var", "let", or "const"
	         * @returns {Object} The scope associated with statementType
	         */
	        function getCurrentScope(statementType) {
	            let currentScope;
	
	            if (statementType === "var") {
	                currentScope = functionStack[functionStack.length - 1];
	            } else if (statementType === "let") {
	                currentScope = blockStack[blockStack.length - 1].let;
	            } else if (statementType === "const") {
	                currentScope = blockStack[blockStack.length - 1].const;
	            }
	            return currentScope;
	        }
	
	        /**
	         * Counts the number of initialized and uninitialized declarations in a list of declarations
	         * @param {ASTNode[]} declarations List of declarations
	         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations
	         * @private
	         */
	        function countDeclarations(declarations) {
	            const counts = { uninitialized: 0, initialized: 0 };
	
	            for (let i = 0; i < declarations.length; i++) {
	                if (declarations[i].init === null) {
	                    counts.uninitialized++;
	                } else {
	                    counts.initialized++;
	                }
	            }
	            return counts;
	        }
	
	        /**
	         * Determines if there is more than one var statement in the current scope.
	         * @param {string} statementType node.kind, one of: "var", "let", or "const"
	         * @param {ASTNode[]} declarations List of declarations
	         * @returns {boolean} Returns true if it is the first var declaration, false if not.
	         * @private
	         */
	        function hasOnlyOneStatement(statementType, declarations) {
	
	            const declarationCounts = countDeclarations(declarations);
	            const currentOptions = options[statementType] || {};
	            const currentScope = getCurrentScope(statementType);
	
	            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
	                if (currentScope.uninitialized || currentScope.initialized) {
	                    return false;
	                }
	            }
	
	            if (declarationCounts.uninitialized > 0) {
	                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
	                    return false;
	                }
	            }
	            if (declarationCounts.initialized > 0) {
	                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
	                    return false;
	                }
	            }
	            recordTypes(statementType, declarations, currentScope);
	            return true;
	        }
	
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: startFunction,
	            FunctionDeclaration: startFunction,
	            FunctionExpression: startFunction,
	            ArrowFunctionExpression: startFunction,
	            BlockStatement: startBlock,
	            ForStatement: startBlock,
	            ForInStatement: startBlock,
	            ForOfStatement: startBlock,
	            SwitchStatement: startBlock,
	
	            VariableDeclaration(node) {
	                const parent = node.parent;
	                const type = node.kind;
	
	                if (!options[type]) {
	                    return;
	                }
	
	                const declarations = node.declarations;
	                const declarationCounts = countDeclarations(declarations);
	
	                // always
	                if (!hasOnlyOneStatement(type, declarations)) {
	                    if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
	                        context.report({
	                            node,
	                            message: "Combine this with the previous '{{type}}' statement.",
	                            data: {
	                                type
	                            }
	                        });
	                    } else {
	                        if (options[type].initialized === MODE_ALWAYS) {
	                            context.report({
	                                node,
	                                message: "Combine this with the previous '{{type}}' statement with initialized variables.",
	                                data: {
	                                    type
	                                }
	                            });
	                        }
	                        if (options[type].uninitialized === MODE_ALWAYS) {
	                            if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
	                                return;
	                            }
	                            context.report({
	                                node,
	                                message: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
	                                data: {
	                                    type
	                                }
	                            });
	                        }
	                    }
	                }
	
	                // never
	                if (parent.type !== "ForStatement" || parent.init !== node) {
	                    const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
	
	                    if (totalDeclarations > 1) {
	
	                        if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
	
	                            // both initialized and uninitialized
	                            context.report({
	                                node,
	                                message: "Split '{{type}}' declarations into multiple statements.",
	                                data: {
	                                    type
	                                }
	                            });
	                        } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
	
	                            // initialized
	                            context.report({
	                                node,
	                                message: "Split initialized '{{type}}' declarations into multiple statements.",
	                                data: {
	                                    type
	                                }
	                            });
	                        } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
	
	                            // uninitialized
	                            context.report({
	                                node,
	                                message: "Split uninitialized '{{type}}' declarations into multiple statements.",
	                                data: {
	                                    type
	                                }
	                            });
	                        }
	                    }
	                }
	            },
	
	            "ForStatement:exit": endBlock,
	            "ForOfStatement:exit": endBlock,
	            "ForInStatement:exit": endBlock,
	            "SwitchStatement:exit": endBlock,
	            "BlockStatement:exit": endBlock,
	            "Program:exit": endFunction,
	            "FunctionDeclaration:exit": endFunction,
	            "FunctionExpression:exit": endFunction,
	            "ArrowFunctionExpression:exit": endFunction
	        };
	
	    }
	};


/***/ },
/* 330 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to replace assignment expressions with operator assignment
	 * @author Brandon Mills
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether an operator is commutative and has an operator assignment
	 * shorthand form.
	 * @param   {string}  operator Operator to check.
	 * @returns {boolean}          True if the operator is commutative and has a
	 *     shorthand form.
	 */
	function isCommutativeOperatorWithShorthand(operator) {
	    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
	}
	
	/**
	 * Checks whether an operator is not commuatative and has an operator assignment
	 * shorthand form.
	 * @param   {string}  operator Operator to check.
	 * @returns {boolean}          True if the operator is not commuatative and has
	 *     a shorthand form.
	 */
	function isNonCommutativeOperatorWithShorthand(operator) {
	    return ["+", "-", "/", "%", "<<", ">>", ">>>"].indexOf(operator) >= 0;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether two expressions reference the same value. For example:
	 *     a = a
	 *     a.b = a.b
	 *     a[0] = a[0]
	 *     a['b'] = a['b']
	 * @param   {ASTNode} a Left side of the comparison.
	 * @param   {ASTNode} b Right side of the comparison.
	 * @returns {boolean}   True if both sides match and reference the same value.
	 */
	function same(a, b) {
	    if (a.type !== b.type) {
	        return false;
	    }
	
	    switch (a.type) {
	        case "Identifier":
	            return a.name === b.name;
	
	        case "Literal":
	            return a.value === b.value;
	
	        case "MemberExpression":
	
	            /*
	             * x[0] = x[0]
	             * x[y] = x[y]
	             * x.y = x.y
	             */
	            return same(a.object, b.object) && same(a.property, b.property);
	
	        default:
	            return false;
	    }
	}
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow assignment operator shorthand where possible",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	
	        /**
	         * Ensures that an assignment uses the shorthand form where possible.
	         * @param   {ASTNode} node An AssignmentExpression node.
	         * @returns {void}
	         */
	        function verify(node) {
	            if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
	                return;
	            }
	
	            const left = node.left;
	            const expr = node.right;
	            const operator = expr.operator;
	
	            if (isCommutativeOperatorWithShorthand(operator)) {
	                if (same(left, expr.left) || same(left, expr.right)) {
	                    context.report(node, "Assignment can be replaced with operator assignment.");
	                }
	            } else if (isNonCommutativeOperatorWithShorthand(operator)) {
	                if (same(left, expr.left)) {
	                    context.report(node, "Assignment can be replaced with operator assignment.");
	                }
	            }
	        }
	
	        /**
	         * Warns if an assignment expression uses operator assignment shorthand.
	         * @param   {ASTNode} node An AssignmentExpression node.
	         * @returns {void}
	         */
	        function prohibit(node) {
	            if (node.operator !== "=") {
	                context.report(node, "Unexpected operator assignment shorthand.");
	            }
	        }
	
	        return {
	            AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
	        };
	
	    }
	};


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before
	 * @author Benot Zugmeyer
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent linebreak style for operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["after", "before", "none", null]
	            },
	            {
	                type: "object",
	                properties: {
	                    overrides: {
	                        type: "object",
	                        properties: {
	                            anyOf: {
	                                type: "string",
	                                enum: ["after", "before", "none", "ignore"]
	                            }
	                        }
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const usedDefaultGlobal = !context.options[0];
	        const globalStyle = context.options[0] || "after";
	        const options = context.options[1] || {};
	        const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
	
	        if (usedDefaultGlobal && !styleOverrides["?"]) {
	            styleOverrides["?"] = "before";
	        }
	
	        if (usedDefaultGlobal && !styleOverrides[":"]) {
	            styleOverrides[":"] = "before";
	        }
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Checks the operator placement
	         * @param {ASTNode} node The node to check
	         * @param {ASTNode} leftSide The node that comes before the operator in `node`
	         * @private
	         * @returns {void}
	         */
	        function validateNode(node, leftSide) {
	            let leftToken = sourceCode.getLastToken(leftSide);
	            let operatorToken = sourceCode.getTokenAfter(leftToken);
	
	            // When the left part of a binary expression is a single expression wrapped in
	            // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression
	            // and operatorToken will be the closing parenthesis.
	            // The leftToken should be the last closing parenthesis, and the operatorToken
	            // should be the token right after that.
	            while (operatorToken.value === ")") {
	                leftToken = operatorToken;
	                operatorToken = sourceCode.getTokenAfter(operatorToken);
	            }
	
	            const rightToken = sourceCode.getTokenAfter(operatorToken);
	            const operator = operatorToken.value;
	            const operatorStyleOverride = styleOverrides[operator];
	            const style = operatorStyleOverride || globalStyle;
	
	            // if single line
	            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
	                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
	
	                // do nothing.
	
	            } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&
	                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
	
	                // lone operator
	                context.report({
	                    node,
	                    loc: {
	                        line: operatorToken.loc.end.line,
	                        column: operatorToken.loc.end.column
	                    },
	                    message: "Bad line breaking before and after '{{operator}}'.",
	                    data: {
	                        operator
	                    }
	                });
	
	            } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
	
	                context.report({
	                    node,
	                    loc: {
	                        line: operatorToken.loc.end.line,
	                        column: operatorToken.loc.end.column
	                    },
	                    message: "'{{operator}}' should be placed at the beginning of the line.",
	                    data: {
	                        operator
	                    }
	                });
	
	            } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
	
	                context.report({
	                    node,
	                    loc: {
	                        line: operatorToken.loc.end.line,
	                        column: operatorToken.loc.end.column
	                    },
	                    message: "'{{operator}}' should be placed at the end of the line.",
	                    data: {
	                        operator
	                    }
	                });
	
	            } else if (style === "none") {
	
	                context.report({
	                    node,
	                    loc: {
	                        line: operatorToken.loc.end.line,
	                        column: operatorToken.loc.end.column
	                    },
	                    message: "There should be no line break before or after '{{operator}}'.",
	                    data: {
	                        operator
	                    }
	                });
	
	            }
	        }
	
	        /**
	         * Validates a binary expression using `validateNode`
	         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated
	         * @returns {void}
	         */
	        function validateBinaryExpression(node) {
	            validateNode(node, node.left);
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            BinaryExpression: validateBinaryExpression,
	            LogicalExpression: validateBinaryExpression,
	            AssignmentExpression: validateBinaryExpression,
	            VariableDeclarator(node) {
	                if (node.init) {
	                    validateNode(node, node.id);
	                }
	            },
	            ConditionalExpression(node) {
	                validateNode(node, node.test);
	                validateNode(node, node.consequent);
	            }
	        };
	    }
	};


/***/ },
/* 332 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to ensure blank lines within blocks.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow padding within blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["always", "never"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            blocks: {
	                                enum: ["always", "never"]
	                            },
	                            switches: {
	                                enum: ["always", "never"]
	                            },
	                            classes: {
	                                enum: ["always", "never"]
	                            }
	                        },
	                        additionalProperties: false,
	                        minProperties: 1
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const options = {};
	        const config = context.options[0] || "always";
	
	        if (typeof config === "string") {
	            options.blocks = config === "always";
	        } else {
	            if (config.hasOwnProperty("blocks")) {
	                options.blocks = config.blocks === "always";
	            }
	            if (config.hasOwnProperty("switches")) {
	                options.switches = config.switches === "always";
	            }
	            if (config.hasOwnProperty("classes")) {
	                options.classes = config.classes === "always";
	            }
	        }
	
	        const ALWAYS_MESSAGE = "Block must be padded by blank lines.",
	            NEVER_MESSAGE = "Block must not be padded by blank lines.";
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Gets the open brace token from a given node.
	         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.
	         * @returns {Token} The token of the open brace.
	         */
	        function getOpenBrace(node) {
	            if (node.type === "SwitchStatement") {
	                return sourceCode.getTokenBefore(node.cases[0]);
	            }
	            return sourceCode.getFirstToken(node);
	        }
	
	        /**
	         * Checks if the given parameter is a comment node
	         * @param {ASTNode|Token} node An AST node or token
	         * @returns {boolean} True if node is a comment
	         */
	        function isComment(node) {
	            return node.type === "Line" || node.type === "Block";
	        }
	
	        /**
	         * Checks if the given token has a blank line after it.
	         * @param {Token} token The token to check.
	         * @returns {boolean} Whether or not the token is followed by a blank line.
	         */
	        function isTokenTopPadded(token) {
	            const tokenStartLine = token.loc.start.line,
	                expectedFirstLine = tokenStartLine + 2;
	            let first = token;
	
	            do {
	                first = sourceCode.getTokenOrCommentAfter(first);
	            } while (isComment(first) && first.loc.start.line === tokenStartLine);
	
	            const firstLine = first.loc.start.line;
	
	            return expectedFirstLine <= firstLine;
	        }
	
	        /**
	         * Checks if the given token is preceeded by a blank line.
	         * @param {Token} token The token to check
	         * @returns {boolean} Whether or not the token is preceeded by a blank line
	         */
	        function isTokenBottomPadded(token) {
	            const blockEnd = token.loc.end.line,
	                expectedLastLine = blockEnd - 2;
	            let last = token;
	
	            do {
	                last = sourceCode.getTokenOrCommentBefore(last);
	            } while (isComment(last) && last.loc.end.line === blockEnd);
	
	            const lastLine = last.loc.end.line;
	
	            return lastLine <= expectedLastLine;
	        }
	
	        /**
	         * Checks if a node should be padded, according to the rule config.
	         * @param {ASTNode} node The AST node to check.
	         * @returns {boolean} True if the node should be padded, false otherwise.
	         */
	        function requirePaddingFor(node) {
	            switch (node.type) {
	                case "BlockStatement":
	                    return options.blocks;
	                case "SwitchStatement":
	                    return options.switches;
	                case "ClassBody":
	                    return options.classes;
	
	                /* istanbul ignore next */
	                default:
	                    throw new Error("unreachable");
	            }
	        }
	
	        /**
	         * Checks the given BlockStatement node to be padded if the block is not empty.
	         * @param {ASTNode} node The AST node of a BlockStatement.
	         * @returns {void} undefined.
	         */
	        function checkPadding(node) {
	            const openBrace = getOpenBrace(node),
	                closeBrace = sourceCode.getLastToken(node),
	                blockHasTopPadding = isTokenTopPadded(openBrace),
	                blockHasBottomPadding = isTokenBottomPadded(closeBrace);
	
	            if (requirePaddingFor(node)) {
	                if (!blockHasTopPadding) {
	                    context.report({
	                        node,
	                        loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
	                        fix(fixer) {
	                            return fixer.insertTextAfter(openBrace, "\n");
	                        },
	                        message: ALWAYS_MESSAGE
	                    });
	                }
	                if (!blockHasBottomPadding) {
	                    context.report({
	                        node,
	                        loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
	                        fix(fixer) {
	                            return fixer.insertTextBefore(closeBrace, "\n");
	                        },
	                        message: ALWAYS_MESSAGE
	                    });
	                }
	            } else {
	                if (blockHasTopPadding) {
	                    const nextToken = sourceCode.getTokenOrCommentAfter(openBrace);
	
	                    context.report({
	                        node,
	                        loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },
	                        fix(fixer) {
	                            return fixer.replaceTextRange([openBrace.end, nextToken.start - nextToken.loc.start.column], "\n");
	                        },
	                        message: NEVER_MESSAGE
	                    });
	                }
	
	                if (blockHasBottomPadding) {
	                    const previousToken = sourceCode.getTokenOrCommentBefore(closeBrace);
	
	                    context.report({
	                        node,
	                        loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },
	                        message: NEVER_MESSAGE,
	                        fix(fixer) {
	                            return fixer.replaceTextRange([previousToken.end, closeBrace.start - closeBrace.loc.start.column], "\n");
	                        }
	                    });
	                }
	            }
	        }
	
	        const rule = {};
	
	        if (options.hasOwnProperty("switches")) {
	            rule.SwitchStatement = function(node) {
	                if (node.cases.length === 0) {
	                    return;
	                }
	                checkPadding(node);
	            };
	        }
	
	        if (options.hasOwnProperty("blocks")) {
	            rule.BlockStatement = function(node) {
	                if (node.body.length === 0) {
	                    return;
	                }
	                checkPadding(node);
	            };
	        }
	
	        if (options.hasOwnProperty("classes")) {
	            rule.ClassBody = function(node) {
	                if (node.body.length === 0) {
	                    return;
	                }
	                checkPadding(node);
	            };
	        }
	
	        return rule;
	    }
	};


/***/ },
/* 333 */
/***/ function(module, exports) {

	/**
	 * @fileoverview A rule to suggest using arrow functions as callbacks.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given variable is a function name.
	 * @param {escope.Variable} variable - A variable to check.
	 * @returns {boolean} `true` if the variable is a function name.
	 */
	function isFunctionName(variable) {
	    return variable && variable.defs[0].type === "FunctionName";
	}
	
	/**
	 * Checks whether or not a given MetaProperty node equals to a given value.
	 * @param {ASTNode} node - A MetaProperty node to check.
	 * @param {string} metaName - The name of `MetaProperty.meta`.
	 * @param {string} propertyName - The name of `MetaProperty.property`.
	 * @returns {boolean} `true` if the node is the specific value.
	 */
	function checkMetaProperty(node, metaName, propertyName) {
	    return node.meta.name === metaName && node.property.name === propertyName;
	}
	
	/**
	 * Gets the variable object of `arguments` which is defined implicitly.
	 * @param {escope.Scope} scope - A scope to get.
	 * @returns {escope.Variable} The found variable object.
	 */
	function getVariableOfArguments(scope) {
	    const variables = scope.variables;
	
	    for (let i = 0; i < variables.length; ++i) {
	        const variable = variables[i];
	
	        if (variable.name === "arguments") {
	
	            /*
	             * If there was a parameter which is named "arguments", the
	             * implicit "arguments" is not defined.
	             * So does fast return with null.
	             */
	            return (variable.identifiers.length === 0) ? variable : null;
	        }
	    }
	
	    /* istanbul ignore next */
	    return null;
	}
	
	/**
	 * Checkes whether or not a given node is a callback.
	 * @param {ASTNode} node - A node to check.
	 * @returns {Object}
	 *   {boolean} retv.isCallback - `true` if the node is a callback.
	 *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.
	 */
	function getCallbackInfo(node) {
	    const retv = {isCallback: false, isLexicalThis: false};
	    let parent = node.parent;
	
	    while (node) {
	        switch (parent.type) {
	
	            // Checks parents recursively.
	
	            case "LogicalExpression":
	            case "ConditionalExpression":
	                break;
	
	            // Checks whether the parent node is `.bind(this)` call.
	            case "MemberExpression":
	                if (parent.object === node &&
	                    !parent.property.computed &&
	                    parent.property.type === "Identifier" &&
	                    parent.property.name === "bind" &&
	                    parent.parent.type === "CallExpression" &&
	                    parent.parent.callee === parent
	                ) {
	                    retv.isLexicalThis = (
	                        parent.parent.arguments.length === 1 &&
	                        parent.parent.arguments[0].type === "ThisExpression"
	                    );
	                    node = parent;
	                    parent = parent.parent;
	                } else {
	                    return retv;
	                }
	                break;
	
	            // Checks whether the node is a callback.
	            case "CallExpression":
	            case "NewExpression":
	                if (parent.callee !== node) {
	                    retv.isCallback = true;
	                }
	                return retv;
	
	            default:
	                return retv;
	        }
	
	        node = parent;
	        parent = parent.parent;
	    }
	
	    /* istanbul ignore next */
	    throw new Error("unreachable");
	}
	
	/**
	* Checks whether a simple list of parameters contains any duplicates. This does not handle complex
	parameter lists (e.g. with destructuring), since complex parameter lists are a SyntaxError with duplicate
	parameter names anyway. Instead, it always returns `false` for complex parameter lists.
	* @param {ASTNode[]} paramsList The list of parameters for a function
	* @returns {boolean} `true` if the list of parameters contains any duplicates
	*/
	function hasDuplicateParams(paramsList) {
	    return paramsList.every(param => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map(param => param.name)).size;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require arrow functions as callbacks",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    allowNamedFunctions: {
	                        type: "boolean"
	                    },
	                    allowUnboundThis: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	
	        const allowUnboundThis = options.allowUnboundThis !== false;  // default to true
	        const allowNamedFunctions = options.allowNamedFunctions;
	        const sourceCode = context.getSourceCode();
	
	        /*
	         * {Array<{this: boolean, super: boolean, meta: boolean}>}
	         * - this - A flag which shows there are one or more ThisExpression.
	         * - super - A flag which shows there are one or more Super.
	         * - meta - A flag which shows there are one or more MethProperty.
	         */
	        let stack = [];
	
	        /**
	         * Pushes new function scope with all `false` flags.
	         * @returns {void}
	         */
	        function enterScope() {
	            stack.push({this: false, super: false, meta: false});
	        }
	
	        /**
	         * Pops a function scope from the stack.
	         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.
	         */
	        function exitScope() {
	            return stack.pop();
	        }
	
	        return {
	
	            // Reset internal state.
	            Program() {
	                stack = [];
	            },
	
	            // If there are below, it cannot replace with arrow functions merely.
	            ThisExpression() {
	                const info = stack[stack.length - 1];
	
	                if (info) {
	                    info.this = true;
	                }
	            },
	
	            Super() {
	                const info = stack[stack.length - 1];
	
	                if (info) {
	                    info.super = true;
	                }
	            },
	
	            MetaProperty(node) {
	                const info = stack[stack.length - 1];
	
	                if (info && checkMetaProperty(node, "new", "target")) {
	                    info.meta = true;
	                }
	            },
	
	            // To skip nested scopes.
	            FunctionDeclaration: enterScope,
	            "FunctionDeclaration:exit": exitScope,
	
	            // Main.
	            FunctionExpression: enterScope,
	            "FunctionExpression:exit"(node) {
	                const scopeInfo = exitScope();
	
	                // Skip named function expressions
	                if (allowNamedFunctions && node.id && node.id.name) {
	                    return;
	                }
	
	                // Skip generators.
	                if (node.generator) {
	                    return;
	                }
	
	                // Skip recursive functions.
	                const nameVar = context.getDeclaredVariables(node)[0];
	
	                if (isFunctionName(nameVar) && nameVar.references.length > 0) {
	                    return;
	                }
	
	                // Skip if it's using arguments.
	                const variable = getVariableOfArguments(context.getScope());
	
	                if (variable && variable.references.length > 0) {
	                    return;
	                }
	
	                // Reports if it's a callback which can replace with arrows.
	                const callbackInfo = getCallbackInfo(node);
	
	                if (callbackInfo.isCallback &&
	                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&
	                    !scopeInfo.super &&
	                    !scopeInfo.meta
	                ) {
	                    context.report({
	                        node,
	                        message: "Unexpected function expression.",
	                        fix(fixer) {
	                            if ((!callbackInfo.isLexicalThis && scopeInfo.this) || hasDuplicateParams(node.params)) {
	
	                                // If the callback function does not have .bind(this) and contains a reference to `this`, there
	                                // is no way to determine what `this` should be, so don't perform any fixes.
	                                // If the callback function has duplicates in its list of parameters (possible in sloppy mode),
	                                // don't replace it with an arrow function, because this is a SyntaxError with arrow functions.
	                                return null;
	                            }
	
	                            const paramsLeftParen = node.params.length ? sourceCode.getTokenBefore(node.params[0]) : sourceCode.getTokenBefore(node.body, 1);
	                            const paramsRightParen = sourceCode.getTokenBefore(node.body);
	                            const asyncKeyword = node.async ? "async " : "";
	                            const paramsFullText = sourceCode.text.slice(paramsLeftParen.range[0], paramsRightParen.range[1]);
	
	                            if (callbackInfo.isLexicalThis) {
	
	                                // If the callback function has `.bind(this)`, replace it with an arrow function and remove the binding.
	                                return fixer.replaceText(node.parent.parent, `${asyncKeyword}${paramsFullText} => ${sourceCode.getText(node.body)}`);
	                            }
	
	                            // Otherwise, only replace the `function` keyword and parameters with the arrow function parameters.
	                            return fixer.replaceTextRange([node.start, node.body.start], `${asyncKeyword}${paramsFullText} => `);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const PATTERN_TYPE = /^(?:.+?Pattern|RestElement|Property)$/;
	const DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;
	const DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;
	
	/**
	 * Adds multiple items to the tail of an array.
	 *
	 * @param {any[]} array - A destination to add.
	 * @param {any[]} values - Items to be added.
	 * @returns {void}
	 */
	const pushAll = Function.apply.bind(Array.prototype.push);
	
	/**
	 * Checks whether a given node is located at `ForStatement.init` or not.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is located at `ForStatement.init`.
	 */
	function isInitOfForStatement(node) {
	    return node.parent.type === "ForStatement" && node.parent.init === node;
	}
	
	/**
	 * Checks whether a given Identifier node becomes a VariableDeclaration or not.
	 *
	 * @param {ASTNode} identifier - An Identifier node to check.
	 * @returns {boolean} `true` if the node can become a VariableDeclaration.
	 */
	function canBecomeVariableDeclaration(identifier) {
	    let node = identifier.parent;
	
	    while (PATTERN_TYPE.test(node.type)) {
	        node = node.parent;
	    }
	
	    return (
	        node.type === "VariableDeclarator" ||
	        (
	            node.type === "AssignmentExpression" &&
	            node.parent.type === "ExpressionStatement" &&
	            DECLARATION_HOST_TYPE.test(node.parent.parent.type)
	        )
	    );
	}
	
	/**
	 * Gets an identifier node of a given variable.
	 *
	 * If the initialization exists or one or more reading references exist before
	 * the first assignment, the identifier node is the node of the declaration.
	 * Otherwise, the identifier node is the node of the first assignment.
	 *
	 * If the variable should not change to const, this function returns null.
	 * - If the variable is reassigned.
	 * - If the variable is never initialized nor assigned.
	 * - If the variable is initialized in a different scope from the declaration.
	 * - If the unique assignment of the variable cannot change to a declaration.
	 *   e.g. `if (a) b = 1` / `return (b = 1)`
	 * - If the variable is declared in the global scope and `eslintUsed` is `true`.
	 *   `/*exported foo` directive comment makes such variables. This rule does not
	 *   warn such variables because this rule cannot distinguish whether the
	 *   exported variables are reassigned or not.
	 *
	 * @param {escope.Variable} variable - A variable to get.
	 * @param {boolean} ignoreReadBeforeAssign -
	 *      The value of `ignoreReadBeforeAssign` option.
	 * @returns {ASTNode|null}
	 *      An Identifier node if the variable should change to const.
	 *      Otherwise, null.
	 */
	function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
	    if (variable.eslintUsed && variable.scope.type === "global") {
	        return null;
	    }
	
	    // Finds the unique WriteReference.
	    let writer = null;
	    let isReadBeforeInit = false;
	    const references = variable.references;
	
	    for (let i = 0; i < references.length; ++i) {
	        const reference = references[i];
	
	        if (reference.isWrite()) {
	            const isReassigned = (
	                writer !== null &&
	                writer.identifier !== reference.identifier
	            );
	
	            if (isReassigned) {
	                return null;
	            }
	            writer = reference;
	
	        } else if (reference.isRead() && writer === null) {
	            if (ignoreReadBeforeAssign) {
	                return null;
	            }
	            isReadBeforeInit = true;
	        }
	    }
	
	    // If the assignment is from a different scope, ignore it.
	    // If the assignment cannot change to a declaration, ignore it.
	    const shouldBeConst = (
	        writer !== null &&
	        writer.from === variable.scope &&
	        canBecomeVariableDeclaration(writer.identifier)
	    );
	
	    if (!shouldBeConst) {
	        return null;
	    }
	    if (isReadBeforeInit) {
	        return variable.defs[0].name;
	    }
	    return writer.identifier;
	}
	
	/**
	 * Gets the VariableDeclarator/AssignmentExpression node that a given reference
	 * belongs to.
	 * This is used to detect a mix of reassigned and never reassigned in a
	 * destructuring.
	 *
	 * @param {escope.Reference} reference - A reference to get.
	 * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or
	 *      null.
	 */
	function getDestructuringHost(reference) {
	    if (!reference.isWrite()) {
	        return null;
	    }
	    let node = reference.identifier.parent;
	
	    while (PATTERN_TYPE.test(node.type)) {
	        node = node.parent;
	    }
	
	    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
	        return null;
	    }
	    return node;
	}
	
	/**
	 * Groups by the VariableDeclarator/AssignmentExpression node that each
	 * reference of given variables belongs to.
	 * This is used to detect a mix of reassigned and never reassigned in a
	 * destructuring.
	 *
	 * @param {escope.Variable[]} variables - Variables to group by destructuring.
	 * @param {boolean} ignoreReadBeforeAssign -
	 *      The value of `ignoreReadBeforeAssign` option.
	 * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.
	 */
	function groupByDestructuring(variables, ignoreReadBeforeAssign) {
	    const identifierMap = new Map();
	
	    for (let i = 0; i < variables.length; ++i) {
	        const variable = variables[i];
	        const references = variable.references;
	        const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
	        let prevId = null;
	
	        for (let j = 0; j < references.length; ++j) {
	            const reference = references[j];
	            const id = reference.identifier;
	
	            // Avoid counting a reference twice or more for default values of
	            // destructuring.
	            if (id === prevId) {
	                continue;
	            }
	            prevId = id;
	
	            // Add the identifier node into the destructuring group.
	            const group = getDestructuringHost(reference);
	
	            if (group) {
	                if (identifierMap.has(group)) {
	                    identifierMap.get(group).push(identifier);
	                } else {
	                    identifierMap.set(group, [identifier]);
	                }
	            }
	        }
	    }
	
	    return identifierMap;
	}
	
	/**
	 * Finds the nearest parent of node with a given type.
	 *
	 * @param {ASTNode} node  The node to search from.
	 * @param {string} type  The type field of the parent node.
	 * @param {Function} shouldStop  a predicate that returns true if the traversal should stop, and false otherwise.
	 * @returns {ASTNode} The closest ancestor with the specified type; null if no such ancestor exists.
	 */
	function findUp(node, type, shouldStop) {
	    if (!node || shouldStop(node)) {
	        return null;
	    }
	    if (node.type === type) {
	        return node;
	    }
	    return findUp(node.parent, type, shouldStop);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `const` declarations for variables that are never reassigned after declared",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    destructuring: {enum: ["any", "all"]},
	                    ignoreReadBeforeAssign: {type: "boolean"}
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options[0] || {};
	        const checkingMixedDestructuring = options.destructuring !== "all";
	        const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
	        let variables = null;
	
	        /**
	         * Reports a given Identifier node.
	         *
	         * @param {ASTNode} node - An Identifier node to report.
	         * @returns {void}
	         */
	        function report(node) {
	            const reportArgs = {
	                    node,
	                    message: "'{{name}}' is never reassigned. Use 'const' instead.",
	                    data: node
	                },
	                varDeclParent = findUp(node, "VariableDeclaration", function(parentNode) {
	                    return lodash.endsWith(parentNode.type, "Statement");
	                }),
	                isNormalVarDecl = (node.parent.parent.parent.type === "ForInStatement" ||
	                        node.parent.parent.parent.type === "ForOfStatement" ||
	                        node.parent.init),
	
	                isDestructuringVarDecl =
	
	                    // {let {a} = obj} should be written as {const {a} = obj}
	                    (node.parent.parent.type === "ObjectPattern" &&
	
	                        // If options.destucturing is "all", then this warning will not occur unless
	                        // every assignment in the destructuring should be const. In that case, it's safe
	                        // to apply the fix. Otherwise, it's safe to apply the fix if there's only one
	                        // assignment occurring. If there is more than one assignment and options.destructuring
	                        // is not "all", then it's not clear how the developer would want to resolve the issue,
	                        // so we should not attempt to do it programmatically.
	                        (options.destructuring === "all" || node.parent.parent.properties.length === 1)) ||
	
	                    // {let [a] = [1]} should be written as {const [a] = [1]}
	                    (node.parent.type === "ArrayPattern" &&
	
	                        // See note above about fixing multiple warnings at once.
	                        (options.destructuring === "all" || node.parent.elements.length === 1));
	
	            if (varDeclParent &&
	                    (isNormalVarDecl || isDestructuringVarDecl) &&
	
	                    // If there are multiple variable declarations, like {let a = 1, b = 2}, then
	                    // do not attempt to fix if one of the declarations should be `const`. It's
	                    // too hard to know how the developer would want to automatically resolve the issue.
	                    varDeclParent.declarations.length === 1) {
	
	                reportArgs.fix = function(fixer) {
	                    return fixer.replaceTextRange(
	                        [varDeclParent.start, varDeclParent.start + "let".length],
	                        "const"
	                    );
	                };
	            }
	
	            context.report(reportArgs);
	        }
	
	        /**
	         * Reports a given variable if the variable should be declared as const.
	         *
	         * @param {escope.Variable} variable - A variable to report.
	         * @returns {void}
	         */
	        function checkVariable(variable) {
	            const node = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
	
	            if (node) {
	                report(node);
	            }
	        }
	
	        /**
	         * Reports given identifier nodes if all of the nodes should be declared
	         * as const.
	         *
	         * The argument 'nodes' is an array of Identifier nodes.
	         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's
	         * nullable. In simple declaration or assignment cases, the length of
	         * the array is 1. In destructuring cases, the length of the array can
	         * be 2 or more.
	         *
	         * @param {(escope.Reference|null)[]} nodes -
	         *      References which are grouped by destructuring to report.
	         * @returns {void}
	         */
	        function checkGroup(nodes) {
	            if (nodes.every(Boolean)) {
	                nodes.forEach(report);
	            }
	        }
	
	        return {
	            Program() {
	                variables = [];
	            },
	
	            "Program:exit"() {
	                if (checkingMixedDestructuring) {
	                    variables.forEach(checkVariable);
	                } else {
	                    groupByDestructuring(variables, ignoreReadBeforeAssign)
	                        .forEach(checkGroup);
	                }
	
	                variables = null;
	            },
	
	            VariableDeclaration(node) {
	                if (node.kind === "let" && !isInitOfForStatement(node)) {
	                    pushAll(variables, context.getDeclaredVariables(node));
	                }
	            }
	        };
	    }
	};


/***/ },
/* 335 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to disallow `parseInt()` in favor of binary, octal, and hexadecimal literals
	 * @author Annie Zhang, Henry Zhu
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "disallow `parseInt()` in favor of binary, octal, and hexadecimal literals",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const radixMap = {
	            2: "binary",
	            8: "octal",
	            16: "hexadecimal"
	        };
	
	        const prefixMap = {
	            2: "0b",
	            8: "0o",
	            16: "0x"
	        };
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            CallExpression(node) {
	
	                // doesn't check parseInt() if it doesn't have a radix argument
	                if (node.arguments.length !== 2) {
	                    return;
	                }
	
	                // only error if the radix is 2, 8, or 16
	                const radixName = radixMap[node.arguments[1].value];
	
	                if (node.callee.type === "Identifier" &&
	                    node.callee.name === "parseInt" &&
	                    radixName &&
	                    node.arguments[0].type === "Literal"
	                ) {
	                    context.report({
	                        node,
	                        message: "Use {{radixName}} literals instead of parseInt().",
	                        data: {
	                            radixName
	                        },
	                        fix(fixer) {
	                            const newPrefix = prefixMap[node.arguments[1].value];
	
	                            if (+(newPrefix + node.arguments[0].value) !== parseInt(node.arguments[0].value, node.arguments[1].value)) {
	
	                                // If the newly-produced literal would be invalid, (e.g. 0b1234),
	                                // or it would yield an incorrect parseInt result for some other reason, don't make a fix.
	                                return null;
	                            }
	                            return fixer.replaceText(node, prefixMap[node.arguments[1].value] + node.arguments[0].value);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 336 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to suggest using "Reflect" api over Function/Object methods
	 * @author Keith Cirkel <http://keithcirkel.co.uk>
	 * @deprecated in ESLint v3.9.0
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `Reflect` methods where applicable",
	            category: "ECMAScript 6",
	            recommended: false,
	            replacedBy: []
	        },
	
	        deprecated: true,
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {
	                            enum: [
	                                "apply",
	                                "call",
	                                "delete",
	                                "defineProperty",
	                                "getOwnPropertyDescriptor",
	                                "getPrototypeOf",
	                                "setPrototypeOf",
	                                "isExtensible",
	                                "getOwnPropertyNames",
	                                "preventExtensions"
	                            ]
	                        },
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const existingNames = {
	            apply: "Function.prototype.apply",
	            call: "Function.prototype.call",
	            defineProperty: "Object.defineProperty",
	            getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
	            getPrototypeOf: "Object.getPrototypeOf",
	            setPrototypeOf: "Object.setPrototypeOf",
	            isExtensible: "Object.isExtensible",
	            getOwnPropertyNames: "Object.getOwnPropertyNames",
	            preventExtensions: "Object.preventExtensions"
	        };
	
	        const reflectSubsitutes = {
	            apply: "Reflect.apply",
	            call: "Reflect.apply",
	            defineProperty: "Reflect.defineProperty",
	            getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
	            getPrototypeOf: "Reflect.getPrototypeOf",
	            setPrototypeOf: "Reflect.setPrototypeOf",
	            isExtensible: "Reflect.isExtensible",
	            getOwnPropertyNames: "Reflect.getOwnPropertyNames",
	            preventExtensions: "Reflect.preventExtensions"
	        };
	
	        const exceptions = (context.options[0] || {}).exceptions || [];
	
	        /**
	         * Reports the Reflect violation based on the `existing` and `substitute`
	         * @param {Object} node The node that violates the rule.
	         * @param {string} existing The existing method name that has been used.
	         * @param {string} substitute The Reflect substitute that should be used.
	         * @returns {void}
	         */
	        function report(node, existing, substitute) {
	            context.report(node, "Avoid using {{existing}}, instead use {{substitute}}.", {
	                existing,
	                substitute
	            });
	        }
	
	        return {
	            CallExpression(node) {
	                const methodName = (node.callee.property || {}).name;
	                const isReflectCall = (node.callee.object || {}).name === "Reflect";
	                const hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);
	                const userConfiguredException = exceptions.indexOf(methodName) !== -1;
	
	                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {
	                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);
	                }
	            },
	            UnaryExpression(node) {
	                const isDeleteOperator = node.operator === "delete";
	                const targetsIdentifier = node.argument.type === "Identifier";
	                const userConfiguredException = exceptions.indexOf("delete") !== -1;
	
	                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
	                    report(node, "the delete keyword", "Reflect.deleteProperty");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 337 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Gets the variable object of `arguments` which is defined implicitly.
	 * @param {escope.Scope} scope - A scope to get.
	 * @returns {escope.Variable} The found variable object.
	 */
	function getVariableOfArguments(scope) {
	    const variables = scope.variables;
	
	    for (let i = 0; i < variables.length; ++i) {
	        const variable = variables[i];
	
	        if (variable.name === "arguments") {
	
	            // If there was a parameter which is named "arguments", the implicit "arguments" is not defined.
	            // So does fast return with null.
	            return (variable.identifiers.length === 0) ? variable : null;
	        }
	    }
	
	    /* istanbul ignore next : unreachable */
	    return null;
	}
	
	/**
	 * Checks if the given reference is not normal member access.
	 *
	 * - arguments         .... true    // not member access
	 * - arguments[i]      .... true    // computed member access
	 * - arguments[0]      .... true    // computed member access
	 * - arguments.length  .... false   // normal member access
	 *
	 * @param {escope.Reference} reference - The reference to check.
	 * @returns {boolean} `true` if the reference is not normal member access.
	 */
	function isNotNormalMemberAccess(reference) {
	    const id = reference.identifier;
	    const parent = id.parent;
	
	    return !(
	        parent.type === "MemberExpression" &&
	        parent.object === id &&
	        !parent.computed
	    );
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require rest parameters instead of `arguments`",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Reports a given reference.
	         *
	         * @param {escope.Reference} reference - A reference to report.
	         * @returns {void}
	         */
	        function report(reference) {
	            context.report({
	                node: reference.identifier,
	                loc: reference.identifier.loc,
	                message: "Use the rest parameters instead of 'arguments'."
	            });
	        }
	
	        /**
	         * Reports references of the implicit `arguments` variable if exist.
	         *
	         * @returns {void}
	         */
	        function checkForArguments() {
	            const argumentsVar = getVariableOfArguments(context.getScope());
	
	            if (argumentsVar) {
	                argumentsVar
	                    .references
	                    .filter(isNotNormalMemberAccess)
	                    .forEach(report);
	            }
	        }
	
	        return {
	            "FunctionDeclaration:exit": checkForArguments,
	            "FunctionExpression:exit": checkForArguments
	        };
	    }
	};


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a node is a `.apply()` for variadic.
	 * @param {ASTNode} node - A CallExpression node to check.
	 * @returns {boolean} Whether or not the node is a `.apply()` for variadic.
	 */
	function isVariadicApplyCalling(node) {
	    return (
	        node.callee.type === "MemberExpression" &&
	        node.callee.property.type === "Identifier" &&
	        node.callee.property.name === "apply" &&
	        node.callee.computed === false &&
	        node.arguments.length === 2 &&
	        node.arguments[1].type !== "ArrayExpression" &&
	        node.arguments[1].type !== "SpreadElement"
	    );
	}
	
	/**
	 * Checks whether or not the tokens of two given nodes are same.
	 * @param {ASTNode} left - A node 1 to compare.
	 * @param {ASTNode} right - A node 2 to compare.
	 * @param {SourceCode} sourceCode - The ESLint source code object.
	 * @returns {boolean} the source code for the given node.
	 */
	function equalTokens(left, right, sourceCode) {
	    const tokensL = sourceCode.getTokens(left);
	    const tokensR = sourceCode.getTokens(right);
	
	    if (tokensL.length !== tokensR.length) {
	        return false;
	    }
	    for (let i = 0; i < tokensL.length; ++i) {
	        if (tokensL[i].type !== tokensR[i].type ||
	            tokensL[i].value !== tokensR[i].value
	        ) {
	            return false;
	        }
	    }
	
	    return true;
	}
	
	/**
	 * Checks whether or not `thisArg` is not changed by `.apply()`.
	 * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.
	 * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.
	 * @param {RuleContext} context - The ESLint rule context object.
	 * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.
	 */
	function isValidThisArg(expectedThis, thisArg, context) {
	    if (!expectedThis) {
	        return astUtils.isNullOrUndefined(thisArg);
	    }
	    return equalTokens(expectedThis, thisArg, context);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require spread operators instead of `.apply()`",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	            CallExpression(node) {
	                if (!isVariadicApplyCalling(node)) {
	                    return;
	                }
	
	                const applied = node.callee.object;
	                const expectedThis = (applied.type === "MemberExpression") ? applied.object : null;
	                const thisArg = node.arguments[0];
	
	                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
	                    context.report({
	                        node,
	                        message: "Use the spread operator instead of '.apply()'.",
	                        fix(fixer) {
	                            if (expectedThis && expectedThis.type !== "Identifier") {
	
	                                // Don't fix cases where the `this` value could be a computed expression.
	                                return null;
	                            }
	
	                            const propertyDot = sourceCode.getTokensBetween(applied, node.callee.property).find(token => token.value === ".");
	
	                            return fixer.replaceTextRange([propertyDot.range[0], node.range[1]], `(...${sourceCode.getText(node.arguments[1])})`);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to suggest using template literals instead of string concatenation.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Checks whether or not a given node is a concatenation.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a concatenation.
	 */
	function isConcatenation(node) {
	    return node.type === "BinaryExpression" && node.operator === "+";
	}
	
	/**
	 * Gets the top binary expression node for concatenation in parents of a given node.
	 * @param {ASTNode} node - A node to get.
	 * @returns {ASTNode} the top binary expression node in parents of a given node.
	 */
	function getTopConcatBinaryExpression(node) {
	    while (isConcatenation(node.parent)) {
	        node = node.parent;
	    }
	    return node;
	}
	
	/**
	* Checks whether or not a given binary expression has string literals.
	* @param {ASTNode} node - A node to check.
	* @returns {boolean} `true` if the node has string literals.
	*/
	function hasStringLiteral(node) {
	    if (isConcatenation(node)) {
	
	        // `left` is deeper than `right` normally.
	        return hasStringLiteral(node.right) || hasStringLiteral(node.left);
	    }
	    return astUtils.isStringLiteral(node);
	}
	
	/**
	 * Checks whether or not a given binary expression has non string literals.
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node has non string literals.
	 */
	function hasNonStringLiteral(node) {
	    if (isConcatenation(node)) {
	
	        // `left` is deeper than `right` normally.
	        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
	    }
	    return !astUtils.isStringLiteral(node);
	}
	
	/**
	* Determines whether a given node will start with a template curly expression (`${}`) when being converted to a template literal.
	* @param {ASTNode} node The node that will be fixed to a template literal
	* @returns {boolean} `true` if the node will start with a template curly.
	*/
	function startsWithTemplateCurly(node) {
	    if (node.type === "BinaryExpression") {
	        return startsWithTemplateCurly(node.left);
	    }
	    if (node.type === "TemplateLiteral") {
	        return node.expressions.length && node.quasis.length && node.quasis[0].start === node.quasis[0].end;
	    }
	    return node.type !== "Literal" || typeof node.value !== "string";
	}
	
	/**
	* Determines whether a given node end with a template curly expression (`${}`) when being converted to a template literal.
	* @param {ASTNode} node The node that will be fixed to a template literal
	* @returns {boolean} `true` if the node will end with a template curly.
	*/
	function endsWithTemplateCurly(node) {
	    if (node.type === "BinaryExpression") {
	        return startsWithTemplateCurly(node.right);
	    }
	    if (node.type === "TemplateLiteral") {
	        return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].start === node.quasis[node.quasis.length - 1].end;
	    }
	    return node.type !== "Literal" || typeof node.value !== "string";
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require template literals instead of string concatenation",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        let done = Object.create(null);
	
	        /**
	        * Gets the non-token text between two nodes, ignoring any other tokens that appear between the two tokens.
	        * @param {ASTNode} node1 The first node
	        * @param {ASTNode} node2 The second node
	        * @returns {string} The text between the nodes, excluding other tokens
	        */
	        function getTextBetween(node1, node2) {
	            const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
	            const sourceText = sourceCode.getText();
	
	            return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
	        }
	
	        /**
	        * Returns a template literal form of the given node.
	        * @param {ASTNode} currentNode A node that should be converted to a template literal
	        * @param {string} textBeforeNode Text that should appear before the node
	        * @param {string} textAfterNode Text that should appear after the node
	        * @returns {string} A string form of this node, represented as a template literal
	        */
	        function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
	            if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
	
	                // If the current node is a string literal, escape any instances of ${ or ` to prevent them from being interpreted
	                // as a template placeholder. However, if the code already contains a backslash before the ${ or `
	                // for some reason, don't add another backslash, because that would change the meaning of the code (it would cause
	                // an actual backslash character to appear before the dollar sign).
	                return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\${|`)/g, matched => {
	                    if (matched.lastIndexOf("\\") % 2) {
	                        return `\\${matched}`;
	                    }
	                    return matched;
	
	                // Unescape any quotes that appear in the original Literal that no longer need to be escaped.
	                }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "g"), currentNode.raw[0])}\``;
	            }
	
	            if (currentNode.type === "TemplateLiteral") {
	                return sourceCode.getText(currentNode);
	            }
	
	            if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
	                const plusSign = sourceCode.getTokensBetween(currentNode.left, currentNode.right).find(token => token.value === "+");
	                const textBeforePlus = getTextBetween(currentNode.left, plusSign);
	                const textAfterPlus = getTextBetween(plusSign, currentNode.right);
	                const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
	                const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);
	
	                if (leftEndsWithCurly) {
	
	                    // If the left side of the expression ends with a template curly, add the extra text to the end of the curly bracket.
	                    // `foo${bar}` /* comment */ + 'baz' --> `foo${bar /* comment */  }${baz}`
	                    return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) +
	                        getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
	                }
	                if (rightStartsWithCurly) {
	
	                    // Otherwise, if the right side of the expression starts with a template curly, add the text there.
	                    // 'foo' /* comment */ + `${bar}baz` --> `foo${ /* comment */  bar}baz`
	                    return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) +
	                        getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
	                }
	
	                // Otherwise, these nodes should not be combined into a template curly, since there is nowhere to put
	                // the text between them.
	                return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
	            }
	
	            return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
	        }
	
	        /**
	         * Reports if a given node is string concatenation with non string literals.
	         *
	         * @param {ASTNode} node - A node to check.
	         * @returns {void}
	         */
	        function checkForStringConcat(node) {
	            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
	                return;
	            }
	
	            const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
	
	            // Checks whether or not this node had been checked already.
	            if (done[topBinaryExpr.range[0]]) {
	                return;
	            }
	            done[topBinaryExpr.range[0]] = true;
	
	            if (hasNonStringLiteral(topBinaryExpr)) {
	                context.report({
	                    node: topBinaryExpr,
	                    message: "Unexpected string concatenation.",
	                    fix(fixer) {
	                        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
	                    }
	                });
	            }
	        }
	
	        return {
	            Program() {
	                done = Object.create(null);
	            },
	
	            Literal: checkForStringConcat,
	            TemplateLiteral: checkForStringConcat
	        };
	    }
	};


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag non-quoted property names in object literals.
	 * @author Mathias Bynens <http://mathiasbynens.be/>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const espree = __webpack_require__(230),
	    keywords = __webpack_require__(148);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require quotes around object literal property names",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                keywords: {
	                                    type: "boolean"
	                                },
	                                unnecessary: {
	                                    type: "boolean"
	                                },
	                                numbers: {
	                                    type: "boolean"
	                                }
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        },
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const MODE = context.options[0],
	            KEYWORDS = context.options[1] && context.options[1].keywords,
	            CHECK_UNNECESSARY = !context.options[1] || context.options[1].unnecessary !== false,
	            NUMBERS = context.options[1] && context.options[1].numbers,
	
	            MESSAGE_UNNECESSARY = "Unnecessarily quoted property '{{property}}' found.",
	            MESSAGE_UNQUOTED = "Unquoted property '{{property}}' found.",
	            MESSAGE_NUMERIC = "Unquoted number literal '{{property}}' used as key.",
	            MESSAGE_RESERVED = "Unquoted reserved word '{{property}}' used as key.",
	            sourceCode = context.getSourceCode();
	
	
	        /**
	         * Checks whether a certain string constitutes an ES3 token
	         * @param   {string} tokenStr - The string to be checked.
	         * @returns {boolean} `true` if it is an ES3 token.
	         */
	        function isKeyword(tokenStr) {
	            return keywords.indexOf(tokenStr) >= 0;
	        }
	
	        /**
	         * Checks if an espree-tokenized key has redundant quotes (i.e. whether quotes are unnecessary)
	         * @param   {string} rawKey The raw key value from the source
	         * @param   {espreeTokens} tokens The espree-tokenized node key
	         * @param   {boolean} [skipNumberLiterals=false] Indicates whether number literals should be checked
	         * @returns {boolean} Whether or not a key has redundant quotes.
	         * @private
	         */
	        function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
	            return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length &&
	                (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 ||
	                (tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value));
	        }
	
	        /**
	        * Returns a string representation of a property node with quotes removed
	        * @param {ASTNode} key Key AST Node, which may or may not be quoted
	        * @returns {string} A replacement string for this property
	        */
	        function getUnquotedKey(key) {
	            return key.type === "Identifier" ? key.name : key.value;
	        }
	
	        /**
	        * Returns a string representation of a property node with quotes added
	        * @param {ASTNode} key Key AST Node, which may or may not be quoted
	        * @returns {string} A replacement string for this property
	        */
	        function getQuotedKey(key) {
	            if (key.type === "Literal" && typeof key.value === "string") {
	
	                // If the key is already a string literal, don't replace the quotes with double quotes.
	                return sourceCode.getText(key);
	            }
	
	            // Otherwise, the key is either an identifier or a number literal.
	            return `"${key.type === "Identifier" ? key.name : key.value}"`;
	        }
	
	        /**
	         * Ensures that a property's key is quoted only when necessary
	         * @param   {ASTNode} node Property AST node
	         * @returns {void}
	         */
	        function checkUnnecessaryQuotes(node) {
	            const key = node.key;
	            let tokens;
	
	            if (node.method || node.computed || node.shorthand) {
	                return;
	            }
	
	            if (key.type === "Literal" && typeof key.value === "string") {
	                try {
	                    tokens = espree.tokenize(key.value);
	                } catch (e) {
	                    return;
	                }
	
	                if (tokens.length !== 1) {
	                    return;
	                }
	
	                const isKeywordToken = isKeyword(tokens[0].value);
	
	                if (isKeywordToken && KEYWORDS) {
	                    return;
	                }
	
	                if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
	                    context.report({
	                        node,
	                        message: MESSAGE_UNNECESSARY,
	                        data: {property: key.value},
	                        fix: fixer => fixer.replaceText(key, getUnquotedKey(key))
	                    });
	                }
	            } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
	                context.report({
	                    node,
	                    message: MESSAGE_RESERVED,
	                    data: {property: key.name},
	                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
	                });
	            } else if (NUMBERS && key.type === "Literal" && typeof key.value === "number") {
	                context.report({
	                    node,
	                    message: MESSAGE_NUMERIC,
	                    data: {property: key.value},
	                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
	                });
	            }
	        }
	
	        /**
	         * Ensures that a property's key is quoted
	         * @param   {ASTNode} node Property AST node
	         * @returns {void}
	         */
	        function checkOmittedQuotes(node) {
	            const key = node.key;
	
	            if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
	                context.report({
	                    node,
	                    message: MESSAGE_UNQUOTED,
	                    data: {property: key.name || key.value},
	                    fix: fixer => fixer.replaceText(key, getQuotedKey(key))
	                });
	            }
	        }
	
	        /**
	         * Ensures that an object's keys are consistently quoted, optionally checks for redundancy of quotes
	         * @param   {ASTNode} node Property AST node
	         * @param   {boolean} checkQuotesRedundancy Whether to check quotes' redundancy
	         * @returns {void}
	         */
	        function checkConsistency(node, checkQuotesRedundancy) {
	            const quotedProps = [],
	                unquotedProps = [];
	            let keywordKeyName = null,
	                necessaryQuotes = false;
	
	            node.properties.forEach(function(property) {
	                const key = property.key;
	                let tokens;
	
	                if (!key || property.method || property.computed || property.shorthand) {
	                    return;
	                }
	
	                if (key.type === "Literal" && typeof key.value === "string") {
	
	                    quotedProps.push(property);
	
	                    if (checkQuotesRedundancy) {
	                        try {
	                            tokens = espree.tokenize(key.value);
	                        } catch (e) {
	                            necessaryQuotes = true;
	                            return;
	                        }
	
	                        necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
	                    }
	                } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
	                    unquotedProps.push(property);
	                    necessaryQuotes = true;
	                    keywordKeyName = key.name;
	                } else {
	                    unquotedProps.push(property);
	                }
	            });
	
	            if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
	                quotedProps.forEach(property => {
	                    context.report({
	                        node: property,
	                        message: "Properties shouldn't be quoted as all quotes are redundant.",
	                        fix: fixer => fixer.replaceText(property.key, getUnquotedKey(property.key))
	                    });
	                });
	            } else if (unquotedProps.length && keywordKeyName) {
	                unquotedProps.forEach(property => {
	                    context.report({
	                        node: property,
	                        message: "Properties should be quoted as '{{property}}' is a reserved word.",
	                        data: {property: keywordKeyName},
	                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
	                    });
	                });
	            } else if (quotedProps.length && unquotedProps.length) {
	                unquotedProps.forEach(property => {
	                    context.report({
	                        node: property,
	                        message: "Inconsistently quoted property '{{key}}' found.",
	                        data: {key: property.key.name || property.key.value},
	                        fix: fixer => fixer.replaceText(property.key, getQuotedKey(property.key))
	                    });
	                });
	            }
	        }
	
	        return {
	            Property(node) {
	                if (MODE === "always" || !MODE) {
	                    checkOmittedQuotes(node);
	                }
	                if (MODE === "as-needed") {
	                    checkUnnecessaryQuotes(node);
	                }
	            },
	            ObjectExpression(node) {
	                if (MODE === "consistent") {
	                    checkConsistency(node, false);
	                }
	                if (MODE === "consistent-as-needed") {
	                    checkConsistency(node, true);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to choose between single and double quote marks
	 * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const QUOTE_SETTINGS = {
	    double: {
	        quote: "\"",
	        alternateQuote: "'",
	        description: "doublequote"
	    },
	    single: {
	        quote: "'",
	        alternateQuote: "\"",
	        description: "singlequote"
	    },
	    backtick: {
	        quote: "`",
	        alternateQuote: "\"",
	        description: "backtick"
	    }
	};
	
	/**
	 * Switches quoting of javascript string between ' " and `
	 * escaping and unescaping as necessary.
	 * Only escaping of the minimal set of characters is changed.
	 * Note: escaping of newlines when switching from backtick to other quotes is not handled.
	 * @param {string} str - A string to convert.
	 * @returns {string} The string with changed quotes.
	 * @private
	 */
	QUOTE_SETTINGS.double.convert =
	QUOTE_SETTINGS.single.convert =
	QUOTE_SETTINGS.backtick.convert = function(str) {
	    const newQuote = this.quote;
	    const oldQuote = str[0];
	
	    if (newQuote === oldQuote) {
	        return str;
	    }
	    return newQuote + str.slice(1, -1).replace(/\\(\${|\r\n?|\n|.)|["'`]|\${|(\r\n?|\n)/g, function(match, escaped, newline) {
	        if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
	            return escaped; // unescape
	        }
	        if (match === newQuote || newQuote === "`" && match === "${") {
	            return `\\${match}`; // escape
	        }
	        if (newline && oldQuote === "`") {
	            return "\\n"; // escape newlines
	        }
	        return match;
	    }) + newQuote;
	};
	
	const AVOID_ESCAPE = "avoid-escape";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce the consistent use of either backticks, double, or single quotes",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: [
	            {
	                enum: ["single", "double", "backtick"]
	            },
	            {
	                anyOf: [
	                    {
	                        enum: ["avoid-escape"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            avoidEscape: {
	                                type: "boolean"
	                            },
	                            allowTemplateLiterals: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const quoteOption = context.options[0],
	            settings = QUOTE_SETTINGS[quoteOption || "double"],
	            options = context.options[1],
	            allowTemplateLiterals = options && options.allowTemplateLiterals === true,
	            sourceCode = context.getSourceCode();
	        let avoidEscape = options && options.avoidEscape === true;
	
	        // deprecated
	        if (options === AVOID_ESCAPE) {
	            avoidEscape = true;
	        }
	
	        /**
	         * Determines if a given node is part of JSX syntax.
	         *
	         * This function returns `true` in the following cases:
	         *
	         * - `<div className="foo"></div>` ... If the literal is an attribute value, the parent of the literal is `JSXAttribute`.
	         * - `<div>foo</div>` ... If the literal is a text content, the parent of the literal is `JSXElement`.
	         *
	         * In particular, this function returns `false` in the following cases:
	         *
	         * - `<div className={"foo"}></div>`
	         * - `<div>{"foo"}</div>`
	         *
	         * In both cases, inside of the braces is handled as normal JavaScript.
	         * The braces are `JSXExpressionContainer` nodes.
	         *
	         * @param {ASTNode} node The Literal node to check.
	         * @returns {boolean} True if the node is a part of JSX, false if not.
	         * @private
	         */
	        function isJSXLiteral(node) {
	            return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement";
	        }
	
	        /**
	         * Checks whether or not a given node is a directive.
	         * The directive is a `ExpressionStatement` which has only a string literal.
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} Whether or not the node is a directive.
	         * @private
	         */
	        function isDirective(node) {
	            return (
	                node.type === "ExpressionStatement" &&
	                node.expression.type === "Literal" &&
	                typeof node.expression.value === "string"
	            );
	        }
	
	        /**
	         * Checks whether or not a given node is a part of directive prologues.
	         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} Whether or not the node is a part of directive prologues.
	         * @private
	         */
	        function isPartOfDirectivePrologue(node) {
	            const block = node.parent.parent;
	
	            if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
	                return false;
	            }
	
	            // Check the node is at a prologue.
	            for (let i = 0; i < block.body.length; ++i) {
	                const statement = block.body[i];
	
	                if (statement === node.parent) {
	                    return true;
	                }
	                if (!isDirective(statement)) {
	                    break;
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Checks whether or not a given node is allowed as non backtick.
	         * @param {ASTNode} node - A node to check.
	         * @returns {boolean} Whether or not the node is allowed as non backtick.
	         * @private
	         */
	        function isAllowedAsNonBacktick(node) {
	            const parent = node.parent;
	
	            switch (parent.type) {
	
	                // Directive Prologues.
	                case "ExpressionStatement":
	                    return isPartOfDirectivePrologue(node);
	
	                // LiteralPropertyName.
	                case "Property":
	                    return parent.key === node && !parent.computed;
	
	                // ModuleSpecifier.
	                case "ImportDeclaration":
	                case "ExportNamedDeclaration":
	                case "ExportAllDeclaration":
	                    return parent.source === node;
	
	                // Others don't allow.
	                default:
	                    return false;
	            }
	        }
	
	        return {
	
	            Literal(node) {
	                const val = node.value,
	                    rawVal = node.raw;
	                let isValid;
	
	                if (settings && typeof val === "string") {
	                    isValid = (quoteOption === "backtick" && isAllowedAsNonBacktick(node)) ||
	                        isJSXLiteral(node) ||
	                        astUtils.isSurroundedBy(rawVal, settings.quote);
	
	                    if (!isValid && avoidEscape) {
	                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
	                    }
	
	                    if (!isValid) {
	                        context.report({
	                            node,
	                            message: "Strings must use {{description}}.",
	                            data: {
	                                description: settings.description
	                            },
	                            fix(fixer) {
	                                return fixer.replaceText(node, settings.convert(node.raw));
	                            }
	                        });
	                    }
	                }
	            },
	
	            TemplateLiteral(node) {
	
	                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors
	                if (allowTemplateLiterals || quoteOption === "backtick" || node.parent.type === "TaggedTemplateExpression") {
	                    return;
	                }
	
	                const shouldWarn = node.quasis.length === 1 && (node.quasis[0].value.cooked.indexOf("\n") === -1);
	
	                if (shouldWarn) {
	                    context.report({
	                        node,
	                        message: "Strings must use {{description}}.",
	                        data: {
	                            description: settings.description,
	                        },
	                        fix(fixer) {
	                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag use of parseInt without a radix argument
	 * @author James Allardice
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const MODE_ALWAYS = "always",
	    MODE_AS_NEEDED = "as-needed";
	
	/**
	 * Checks whether a given variable is shadowed or not.
	 *
	 * @param {escope.Variable} variable - A variable to check.
	 * @returns {boolean} `true` if the variable is shadowed.
	 */
	function isShadowed(variable) {
	    return variable.defs.length >= 1;
	}
	
	/**
	 * Checks whether a given node is a MemberExpression of `parseInt` method or not.
	 *
	 * @param {ASTNode} node - A node to check.
	 * @returns {boolean} `true` if the node is a MemberExpression of `parseInt`
	 *      method.
	 */
	function isParseIntMethod(node) {
	    return (
	        node.type === "MemberExpression" &&
	        !node.computed &&
	        node.property.type === "Identifier" &&
	        node.property.name === "parseInt"
	    );
	}
	
	/**
	 * Checks whether a given node is a valid value of radix or not.
	 *
	 * The following values are invalid.
	 *
	 * - A literal except numbers.
	 * - undefined.
	 *
	 * @param {ASTNode} radix - A node of radix to check.
	 * @returns {boolean} `true` if the node is valid.
	 */
	function isValidRadix(radix) {
	    return !(
	        (radix.type === "Literal" && typeof radix.value !== "number") ||
	        (radix.type === "Identifier" && radix.name === "undefined")
	    );
	}
	
	/**
	 * Checks whether a given node is a default value of radix or not.
	 *
	 * @param {ASTNode} radix - A node of radix to check.
	 * @returns {boolean} `true` if the node is the literal node of `10`.
	 */
	function isDefaultRadix(radix) {
	    return radix.type === "Literal" && radix.value === 10;
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce the consistent use of the radix argument when using `parseInt()`",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["always", "as-needed"]
	            }
	        ]
	    },
	
	    create(context) {
	        const mode = context.options[0] || MODE_ALWAYS;
	
	        /**
	         * Checks the arguments of a given CallExpression node and reports it if it
	         * offends this rule.
	         *
	         * @param {ASTNode} node - A CallExpression node to check.
	         * @returns {void}
	         */
	        function checkArguments(node) {
	            const args = node.arguments;
	
	            switch (args.length) {
	                case 0:
	                    context.report({
	                        node,
	                        message: "Missing parameters."
	                    });
	                    break;
	
	                case 1:
	                    if (mode === MODE_ALWAYS) {
	                        context.report({
	                            node,
	                            message: "Missing radix parameter."
	                        });
	                    }
	                    break;
	
	                default:
	                    if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
	                        context.report({
	                            node,
	                            message: "Redundant radix parameter."
	                        });
	                    } else if (!isValidRadix(args[1])) {
	                        context.report({
	                            node,
	                            message: "Invalid radix parameter."
	                        });
	                    }
	                    break;
	            }
	        }
	
	        return {
	            "Program:exit"() {
	                const scope = context.getScope();
	                let variable;
	
	                // Check `parseInt()`
	                variable = astUtils.getVariableByName(scope, "parseInt");
	                if (!isShadowed(variable)) {
	                    variable.references.forEach(function(reference) {
	                        const node = reference.identifier;
	
	                        if (astUtils.isCallee(node)) {
	                            checkArguments(node.parent);
	                        }
	                    });
	                }
	
	                // Check `Number.parseInt()`
	                variable = astUtils.getVariableByName(scope, "Number");
	                if (!isShadowed(variable)) {
	                    variable.references.forEach(function(reference) {
	                        const node = reference.identifier.parent;
	
	                        if (isParseIntMethod(node) && astUtils.isCallee(node)) {
	                            checkArguments(node.parent);
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 343 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check for jsdoc presence.
	 * @author Gyandeep Singh
	 */
	"use strict";
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require JSDoc comments",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    require: {
	                        type: "object",
	                        properties: {
	                            ClassDeclaration: {
	                                type: "boolean"
	                            },
	                            MethodDefinition: {
	                                type: "boolean"
	                            },
	                            FunctionDeclaration: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const source = context.getSourceCode();
	        const DEFAULT_OPTIONS = {
	            FunctionDeclaration: true,
	            MethodDefinition: false,
	            ClassDeclaration: false
	        };
	        const options = Object.assign(DEFAULT_OPTIONS, context.options[0] && context.options[0].require || {});
	
	        /**
	         * Report the error message
	         * @param {ASTNode} node node to report
	         * @returns {void}
	         */
	        function report(node) {
	            context.report(node, "Missing JSDoc comment.");
	        }
	
	        /**
	         * Check if the jsdoc comment is present for class methods
	         * @param {ASTNode} node node to examine
	         * @returns {void}
	         */
	        function checkClassMethodJsDoc(node) {
	            if (node.parent.type === "MethodDefinition") {
	                const jsdocComment = source.getJSDocComment(node);
	
	                if (!jsdocComment) {
	                    report(node);
	                }
	            }
	        }
	
	        /**
	         * Check if the jsdoc comment is present or not.
	         * @param {ASTNode} node node to examine
	         * @returns {void}
	         */
	        function checkJsDoc(node) {
	            const jsdocComment = source.getJSDocComment(node);
	
	            if (!jsdocComment) {
	                report(node);
	            }
	        }
	
	        return {
	            FunctionDeclaration(node) {
	                if (options.FunctionDeclaration) {
	                    checkJsDoc(node);
	                }
	            },
	            FunctionExpression(node) {
	                if (options.MethodDefinition) {
	                    checkClassMethodJsDoc(node);
	                }
	            },
	            ClassDeclaration(node) {
	                if (options.ClassDeclaration) {
	                    checkJsDoc(node);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 344 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag the generator functions that does not have yield.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require generator functions to contain `yield`",
	            category: "ECMAScript 6",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const stack = [];
	
	        /**
	         * If the node is a generator function, start counting `yield` keywords.
	         * @param {Node} node - A function node to check.
	         * @returns {void}
	         */
	        function beginChecking(node) {
	            if (node.generator) {
	                stack.push(0);
	            }
	        }
	
	        /**
	         * If the node is a generator function, end counting `yield` keywords, then
	         * reports result.
	         * @param {Node} node - A function node to check.
	         * @returns {void}
	         */
	        function endChecking(node) {
	            if (!node.generator) {
	                return;
	            }
	
	            const countYield = stack.pop();
	
	            if (countYield === 0 && node.body.body.length > 0) {
	                context.report(
	                    node,
	                    "This generator function does not have 'yield'.");
	            }
	        }
	
	        return {
	            FunctionDeclaration: beginChecking,
	            "FunctionDeclaration:exit": endChecking,
	            FunctionExpression: beginChecking,
	            "FunctionExpression:exit": endChecking,
	
	            // Increases the count of `yield` keyword.
	            YieldExpression() {
	
	                /* istanbul ignore else */
	                if (stack.length > 0) {
	                    stack[stack.length - 1] += 1;
	                }
	            }
	        };
	    }
	};


/***/ },
/* 345 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Enforce spacing between rest and spread operators and their expressions.
	 * @author Kai Cataldo
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce spacing between rest and spread operators and their expressions",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	        fixable: "whitespace",
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode(),
	            alwaysSpace = context.options[0] === "always";
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Checks whitespace between rest/spread operators and their expressions
	         * @param {ASTNode} node - The node to check
	         * @returns {void}
	         */
	        function checkWhiteSpace(node) {
	            const operator = sourceCode.getFirstToken(node),
	                nextToken = sourceCode.getTokenAfter(operator),
	                hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
	            let type;
	
	            switch (node.type) {
	                case "SpreadElement":
	                    type = "spread";
	                    break;
	                case "RestElement":
	                    type = "rest";
	                    break;
	                case "ExperimentalSpreadProperty":
	                    type = "spread property";
	                    break;
	                case "ExperimentalRestProperty":
	                    type = "rest property";
	                    break;
	                default:
	                    return;
	            }
	
	            if (alwaysSpace && !hasWhitespace) {
	                context.report({
	                    node,
	                    loc: {
	                        line: operator.loc.end.line,
	                        column: operator.loc.end.column
	                    },
	                    message: "Expected whitespace after {{type}} operator.",
	                    data: {
	                        type
	                    },
	                    fix(fixer) {
	                        return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
	                    }
	                });
	            } else if (!alwaysSpace && hasWhitespace) {
	                context.report({
	                    node,
	                    loc: {
	                        line: operator.loc.end.line,
	                        column: operator.loc.end.column
	                    },
	                    message: "Unexpected whitespace after {{type}} operator.",
	                    data: {
	                        type
	                    },
	                    fix(fixer) {
	                        return fixer.removeRange([operator.range[1], nextToken.range[0]]);
	                    }
	                });
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            SpreadElement: checkWhiteSpace,
	            RestElement: checkWhiteSpace,
	            ExperimentalSpreadProperty: checkWhiteSpace,
	            ExperimentalRestProperty: checkWhiteSpace
	        };
	    }
	};


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates spacing before and after semicolon
	 * @author Mathias Schreck
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before and after semicolons",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    before: {
	                        type: "boolean"
	                    },
	                    after: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const config = context.options[0],
	            sourceCode = context.getSourceCode();
	        let requireSpaceBefore = false,
	            requireSpaceAfter = true;
	
	        if (typeof config === "object") {
	            if (config.hasOwnProperty("before")) {
	                requireSpaceBefore = config.before;
	            }
	            if (config.hasOwnProperty("after")) {
	                requireSpaceAfter = config.after;
	            }
	        }
	
	        /**
	         * Checks if a given token has leading whitespace.
	         * @param {Object} token The token to check.
	         * @returns {boolean} True if the given token has leading space, false if not.
	         */
	        function hasLeadingSpace(token) {
	            const tokenBefore = sourceCode.getTokenBefore(token);
	
	            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
	        }
	
	        /**
	         * Checks if a given token has trailing whitespace.
	         * @param {Object} token The token to check.
	         * @returns {boolean} True if the given token has trailing space, false if not.
	         */
	        function hasTrailingSpace(token) {
	            const tokenAfter = sourceCode.getTokenAfter(token);
	
	            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
	        }
	
	        /**
	         * Checks if the given token is the last token in its line.
	         * @param {Token} token The token to check.
	         * @returns {boolean} Whether or not the token is the last in its line.
	         */
	        function isLastTokenInCurrentLine(token) {
	            const tokenAfter = sourceCode.getTokenAfter(token);
	
	            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
	        }
	
	        /**
	         * Checks if the given token is the first token in its line
	         * @param {Token} token The token to check.
	         * @returns {boolean} Whether or not the token is the first in its line.
	         */
	        function isFirstTokenInCurrentLine(token) {
	            const tokenBefore = sourceCode.getTokenBefore(token);
	
	            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
	        }
	
	        /**
	         * Checks if the next token of a given token is a closing parenthesis.
	         * @param {Token} token The token to check.
	         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.
	         */
	        function isBeforeClosingParen(token) {
	            const nextToken = sourceCode.getTokenAfter(token);
	
	            return (
	                nextToken &&
	                nextToken.type === "Punctuator" &&
	                (nextToken.value === "}" || nextToken.value === ")")
	            );
	        }
	
	        /**
	         * Checks if the given token is a semicolon.
	         * @param {Token} token The token to check.
	         * @returns {boolean} Whether or not the given token is a semicolon.
	         */
	        function isSemicolon(token) {
	            return token.type === "Punctuator" && token.value === ";";
	        }
	
	        /**
	         * Reports if the given token has invalid spacing.
	         * @param {Token} token The semicolon token to check.
	         * @param {ASTNode} node The corresponding node of the token.
	         * @returns {void}
	         */
	        function checkSemicolonSpacing(token, node) {
	            if (isSemicolon(token)) {
	                const location = token.loc.start;
	
	                if (hasLeadingSpace(token)) {
	                    if (!requireSpaceBefore) {
	                        context.report({
	                            node,
	                            loc: location,
	                            message: "Unexpected whitespace before semicolon.",
	                            fix(fixer) {
	                                const tokenBefore = sourceCode.getTokenBefore(token);
	
	                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
	                            }
	                        });
	                    }
	                } else {
	                    if (requireSpaceBefore) {
	                        context.report({
	                            node,
	                            loc: location,
	                            message: "Missing whitespace before semicolon.",
	                            fix(fixer) {
	                                return fixer.insertTextBefore(token, " ");
	                            }
	                        });
	                    }
	                }
	
	                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
	                    if (hasTrailingSpace(token)) {
	                        if (!requireSpaceAfter) {
	                            context.report({
	                                node,
	                                loc: location,
	                                message: "Unexpected whitespace after semicolon.",
	                                fix(fixer) {
	                                    const tokenAfter = sourceCode.getTokenAfter(token);
	
	                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
	                                }
	                            });
	                        }
	                    } else {
	                        if (requireSpaceAfter) {
	                            context.report({
	                                node,
	                                loc: location,
	                                message: "Missing whitespace after semicolon.",
	                                fix(fixer) {
	                                    return fixer.insertTextAfter(token, " ");
	                                }
	                            });
	                        }
	                    }
	                }
	            }
	        }
	
	        /**
	         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         */
	        function checkNode(node) {
	            const token = sourceCode.getLastToken(node);
	
	            checkSemicolonSpacing(token, node);
	        }
	
	        return {
	            VariableDeclaration: checkNode,
	            ExpressionStatement: checkNode,
	            BreakStatement: checkNode,
	            ContinueStatement: checkNode,
	            DebuggerStatement: checkNode,
	            ReturnStatement: checkNode,
	            ThrowStatement: checkNode,
	            ForStatement(node) {
	                if (node.init) {
	                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
	                }
	
	                if (node.test) {
	                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
	                }
	            }
	        };
	    }
	};


/***/ },
/* 347 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag missing semicolons.
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow semicolons instead of ASI",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "code",
	
	        schema: {
	            anyOf: [
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["never"]
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 1
	                },
	                {
	                    type: "array",
	                    items: [
	                        {
	                            enum: ["always"]
	                        },
	                        {
	                            type: "object",
	                            properties: {
	                                omitLastInOneLineBlock: {type: "boolean"}
	                            },
	                            additionalProperties: false
	                        }
	                    ],
	                    minItems: 0,
	                    maxItems: 2
	                }
	            ]
	        }
	    },
	
	    create(context) {
	
	        const OPT_OUT_PATTERN = /^[-[(/+]$/; // One of [(/+-, but not ++ or --
	        const options = context.options[1];
	        const never = context.options[0] === "never",
	            exceptOneLine = options && options.omitLastInOneLineBlock === true,
	            sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * Reports a semicolon error with appropriate location and message.
	         * @param {ASTNode} node The node with an extra or missing semicolon.
	         * @param {boolean} missing True if the semicolon is missing.
	         * @returns {void}
	         */
	        function report(node, missing) {
	            const lastToken = sourceCode.getLastToken(node);
	            let message,
	                fix,
	                loc = lastToken.loc;
	
	            if (!missing) {
	                message = "Missing semicolon.";
	                loc = loc.end;
	                fix = function(fixer) {
	                    return fixer.insertTextAfter(lastToken, ";");
	                };
	            } else {
	                message = "Extra semicolon.";
	                loc = loc.start;
	                fix = function(fixer) {
	                    return fixer.remove(lastToken);
	                };
	            }
	
	            context.report({
	                node,
	                loc,
	                message,
	                fix
	            });
	
	        }
	
	        /**
	         * Checks whether a token is a semicolon punctuator.
	         * @param {Token} token The token.
	         * @returns {boolean} True if token is a semicolon punctuator.
	         */
	        function isSemicolon(token) {
	            return (token.type === "Punctuator" && token.value === ";");
	        }
	
	        /**
	         * Check if a semicolon is unnecessary, only true if:
	         *   - next token is on a new line and is not one of the opt-out tokens
	         *   - next token is a valid statement divider
	         * @param {Token} lastToken last token of current node.
	         * @returns {boolean} whether the semicolon is unnecessary.
	         */
	        function isUnnecessarySemicolon(lastToken) {
	            if (!isSemicolon(lastToken)) {
	                return false;
	            }
	
	            const nextToken = sourceCode.getTokenAfter(lastToken);
	
	            if (!nextToken) {
	                return true;
	            }
	
	            const lastTokenLine = lastToken.loc.end.line;
	            const nextTokenLine = nextToken.loc.start.line;
	            const isOptOutToken = OPT_OUT_PATTERN.test(nextToken.value);
	            const isDivider = (nextToken.value === "}" || nextToken.value === ";");
	
	            return (lastTokenLine !== nextTokenLine && !isOptOutToken) || isDivider;
	        }
	
	        /**
	         * Checks a node to see if it's in a one-liner block statement.
	         * @param {ASTNode} node The node to check.
	         * @returns {boolean} whether the node is in a one-liner block statement.
	         */
	        function isOneLinerBlock(node) {
	            const nextToken = sourceCode.getTokenAfter(node);
	
	            if (!nextToken || nextToken.value !== "}") {
	                return false;
	            }
	
	            const parent = node.parent;
	
	            return parent && parent.type === "BlockStatement" &&
	              parent.loc.start.line === parent.loc.end.line;
	        }
	
	        /**
	         * Checks a node to see if it's followed by a semicolon.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         */
	        function checkForSemicolon(node) {
	            const lastToken = sourceCode.getLastToken(node);
	
	            if (never) {
	                if (isUnnecessarySemicolon(lastToken)) {
	                    report(node, true);
	                }
	            } else {
	                if (!isSemicolon(lastToken)) {
	                    if (!exceptOneLine || !isOneLinerBlock(node)) {
	                        report(node);
	                    }
	                } else {
	                    if (exceptOneLine && isOneLinerBlock(node)) {
	                        report(node, true);
	                    }
	                }
	            }
	        }
	
	        /**
	         * Checks to see if there's a semicolon after a variable declaration.
	         * @param {ASTNode} node The node to check.
	         * @returns {void}
	         */
	        function checkForSemicolonForVariableDeclaration(node) {
	            const ancestors = context.getAncestors(),
	                parentIndex = ancestors.length - 1,
	                parent = ancestors[parentIndex];
	
	            if ((parent.type !== "ForStatement" || parent.init !== node) &&
	                (!/^For(?:In|Of)Statement/.test(parent.type) || parent.left !== node)
	            ) {
	                checkForSemicolon(node);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            VariableDeclaration: checkForSemicolonForVariableDeclaration,
	            ExpressionStatement: checkForSemicolon,
	            ReturnStatement: checkForSemicolon,
	            ThrowStatement: checkForSemicolon,
	            DoWhileStatement: checkForSemicolon,
	            DebuggerStatement: checkForSemicolon,
	            BreakStatement: checkForSemicolon,
	            ContinueStatement: checkForSemicolon,
	            ImportDeclaration: checkForSemicolon,
	            ExportAllDeclaration: checkForSemicolon,
	            ExportNamedDeclaration(node) {
	                if (!node.declaration) {
	                    checkForSemicolon(node);
	                }
	            },
	            ExportDefaultDeclaration(node) {
	                if (!/(?:Class|Function)Declaration/.test(node.declaration.type)) {
	                    checkForSemicolon(node);
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 348 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require sorting of import declarations
	 * @author Christian Schuller
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce sorted import declarations within modules",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    ignoreCase: {
	                        type: "boolean"
	                    },
	                    memberSyntaxSortOrder: {
	                        type: "array",
	                        items: {
	                            enum: ["none", "all", "multiple", "single"]
	                        },
	                        uniqueItems: true,
	                        minItems: 4,
	                        maxItems: 4
	                    },
	                    ignoreMemberSort: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const configuration = context.options[0] || {},
	            ignoreCase = configuration.ignoreCase || false,
	            ignoreMemberSort = configuration.ignoreMemberSort || false,
	            memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"];
	        let previousDeclaration = null;
	
	        /**
	         * Gets the used member syntax style.
	         *
	         * import "my-module.js" --> none
	         * import * as myModule from "my-module.js" --> all
	         * import {myMember} from "my-module.js" --> single
	         * import {foo, bar} from  "my-module.js" --> multiple
	         *
	         * @param {ASTNode} node - the ImportDeclaration node.
	         * @returns {string} used member parameter style, ["all", "multiple", "single"]
	         */
	        function usedMemberSyntax(node) {
	            if (node.specifiers.length === 0) {
	                return "none";
	            } else if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
	                return "all";
	            } else if (node.specifiers.length === 1) {
	                return "single";
	            } else {
	                return "multiple";
	            }
	        }
	
	        /**
	         * Gets the group by member parameter index for given declaration.
	         * @param {ASTNode} node - the ImportDeclaration node.
	         * @returns {number} the declaration group by member index.
	         */
	        function getMemberParameterGroupIndex(node) {
	            return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
	        }
	
	        /**
	         * Gets the local name of the first imported module.
	         * @param {ASTNode} node - the ImportDeclaration node.
	         * @returns {?string} the local name of the first imported module.
	         */
	        function getFirstLocalMemberName(node) {
	            if (node.specifiers[0]) {
	                return node.specifiers[0].local.name;
	            } else {
	                return null;
	            }
	        }
	
	        return {
	            ImportDeclaration(node) {
	                if (previousDeclaration) {
	                    const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node),
	                        previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
	                    let currentLocalMemberName = getFirstLocalMemberName(node),
	                        previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
	
	                    if (ignoreCase) {
	                        previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
	                        currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
	                    }
	
	                    // When the current declaration uses a different member syntax,
	                    // then check if the ordering is correct.
	                    // Otherwise, make a default string compare (like rule sort-vars to be consistent) of the first used local member name.
	                    if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
	                        if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
	                            context.report({
	                                node,
	                                message: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax.",
	                                data: {
	                                    syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
	                                    syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
	                                }
	                            });
	                        }
	                    } else {
	                        if (previousLocalMemberName &&
	                            currentLocalMemberName &&
	                            currentLocalMemberName < previousLocalMemberName
	                        ) {
	                            context.report({
	                                node,
	                                message: "Imports should be sorted alphabetically."
	                            });
	                        }
	                    }
	                }
	
	                // Multiple members of an import declaration should also be sorted alphabetically.
	                if (!ignoreMemberSort && node.specifiers.length > 1) {
	                    let previousSpecifier = null;
	                    let previousSpecifierName = null;
	
	                    for (let i = 0; i < node.specifiers.length; ++i) {
	                        const currentSpecifier = node.specifiers[i];
	
	                        if (currentSpecifier.type !== "ImportSpecifier") {
	                            continue;
	                        }
	
	                        let currentSpecifierName = currentSpecifier.local.name;
	
	                        if (ignoreCase) {
	                            currentSpecifierName = currentSpecifierName.toLowerCase();
	                        }
	
	                        if (previousSpecifier && currentSpecifierName < previousSpecifierName) {
	                            context.report({
	                                node: currentSpecifier,
	                                message: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
	                                data: {
	                                    memberName: currentSpecifier.local.name
	                                }
	                            });
	                        }
	
	                        previousSpecifier = currentSpecifier;
	                        previousSpecifierName = currentSpecifierName;
	                    }
	                }
	
	                previousDeclaration = node;
	            }
	        };
	    }
	};


/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to require object keys to be sorted
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109),
	    naturalCompare = __webpack_require__(350);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Gets the property name of the given `Property` node.
	 *
	 * - If the property's key is an `Identifier` node, this returns the key's name
	 *   whether it's a computed property or not.
	 * - If the property has a static name, this returns the static name.
	 * - Otherwise, this returns null.
	 *
	 * @param {ASTNode} node - The `Property` node to get.
	 * @returns {string|null} The property name or null.
	 * @private
	 */
	function getPropertyName(node) {
	    return astUtils.getStaticPropertyName(node) || node.key.name || null;
	}
	
	/**
	 * Functions which check that the given 2 names are in specific order.
	 *
	 * Postfix `I` is meant insensitive.
	 * Postfix `N` is meant natual.
	 *
	 * @private
	 */
	const isValidOrders = {
	    asc(a, b) {
	        return a <= b;
	    },
	    ascI(a, b) {
	        return a.toLowerCase() <= b.toLowerCase();
	    },
	    ascN(a, b) {
	        return naturalCompare(a, b) <= 0;
	    },
	    ascIN(a, b) {
	        return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
	    },
	    desc(a, b) {
	        return isValidOrders.asc(b, a);
	    },
	    descI(a, b) {
	        return isValidOrders.ascI(b, a);
	    },
	    descN(a, b) {
	        return isValidOrders.ascN(b, a);
	    },
	    descIN(a, b) {
	        return isValidOrders.ascIN(b, a);
	    },
	};
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require object keys to be sorted",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	        schema: [
	            {
	                enum: ["asc", "desc"]
	            },
	            {
	                type: "object",
	                properties: {
	                    caseSensitive: {
	                        type: "boolean"
	                    },
	                    natural: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // Parse options.
	        const order = context.options[0] || "asc";
	        const options = context.options[1];
	        const insensitive = (options && options.caseSensitive) === false;
	        const natual = Boolean(options && options.natural);
	        const isValidOrder = isValidOrders[
	            order + (insensitive ? "I" : "") + (natual ? "N" : "")
	        ];
	
	        // The stack to save the previous property's name for each object literals.
	        let stack = null;
	
	        return {
	            ObjectExpression() {
	                stack = {
	                    upper: stack,
	                    prevName: null
	                };
	            },
	
	            "ObjectExpression:exit"() {
	                stack = stack.upper;
	            },
	
	            Property(node) {
	                if (node.parent.type === "ObjectPattern") {
	                    return;
	                }
	
	                const prevName = stack.prevName;
	                const thisName = getPropertyName(node);
	
	                stack.prevName = thisName || prevName;
	
	                if (!prevName || !thisName) {
	                    return;
	                }
	
	                if (!isValidOrder(prevName, thisName)) {
	                    context.report({
	                        node,
	                        loc: node.key.loc,
	                        message: "Expected object keys to be in {{natual}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'.",
	                        data: {
	                            thisName,
	                            prevName,
	                            order,
	                            insensitive: insensitive ? "insensitive " : "",
	                            natual: natual ? "natural " : "",
	                        }
	                    });
	                }
	            }
	        };
	    }
	};


/***/ },
/* 350 */
/***/ function(module, exports) {

	
	
	
	/*
	 * @version    1.4.0
	 * @date       2015-10-26
	 * @stability  3 - Stable
	 * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
	 * @license    MIT License
	 */
	
	
	var naturalCompare = function(a, b) {
		var i, codeA
		, codeB = 1
		, posA = 0
		, posB = 0
		, alphabet = String.alphabet
	
		function getCode(str, pos, code) {
			if (code) {
				for (i = pos; code = getCode(str, i), code < 76 && code > 65;) ++i;
				return +str.slice(pos - 1, i)
			}
			code = alphabet && alphabet.indexOf(str.charAt(pos))
			return code > -1 ? code + 76 : ((code = str.charCodeAt(pos) || 0), code < 45 || code > 127) ? code
				: code < 46 ? 65               // -
				: code < 48 ? code - 1
				: code < 58 ? code + 18        // 0-9
				: code < 65 ? code - 11
				: code < 91 ? code + 11        // A-Z
				: code < 97 ? code - 37
				: code < 123 ? code + 5        // a-z
				: code - 63
		}
	
	
		if ((a+="") != (b+="")) for (;codeB;) {
			codeA = getCode(a, posA++)
			codeB = getCode(b, posB++)
	
			if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
				codeA = getCode(a, posA, posA)
				codeB = getCode(b, posB, posA = i)
				posB = i
			}
	
			if (codeA != codeB) return (codeA < codeB) ? -1 : 1
		}
		return 0
	}
	
	try {
		module.exports = naturalCompare;
	} catch (e) {
		String.naturalCompare = naturalCompare;
	}


/***/ },
/* 351 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require sorting of variables within a single Variable Declaration block
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require variables within the same declaration block to be sorted",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    ignoreCase: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const configuration = context.options[0] || {},
	            ignoreCase = configuration.ignoreCase || false;
	
	        return {
	            VariableDeclaration(node) {
	                node.declarations.reduce(function(memo, decl) {
	                    if (decl.id.type === "ObjectPattern" || decl.id.type === "ArrayPattern") {
	                        return memo;
	                    }
	
	                    let lastVariableName = memo.id.name,
	                        currenVariableName = decl.id.name;
	
	                    if (ignoreCase) {
	                        lastVariableName = lastVariableName.toLowerCase();
	                        currenVariableName = currenVariableName.toLowerCase();
	                    }
	
	                    if (currenVariableName < lastVariableName) {
	                        context.report(decl, "Variables within the same declaration block should be sorted alphabetically.");
	                        return memo;
	                    } else {
	                        return decl;
	                    }
	                }, node.declarations[0]);
	            }
	        };
	    }
	};


/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview A rule to ensure whitespace before blocks.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before blocks",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["always", "never"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            keywords: {
	                                enum: ["always", "never"]
	                            },
	                            functions: {
	                                enum: ["always", "never"]
	                            },
	                            classes: {
	                                enum: ["always", "never"]
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const config = context.options[0],
	            sourceCode = context.getSourceCode();
	        let checkFunctions = true,
	            checkKeywords = true,
	            checkClasses = true;
	
	        if (typeof config === "object") {
	            checkFunctions = config.functions !== "never";
	            checkKeywords = config.keywords !== "never";
	            checkClasses = config.classes !== "never";
	        } else if (config === "never") {
	            checkFunctions = false;
	            checkKeywords = false;
	            checkClasses = false;
	        }
	
	        /**
	         * Checks whether or not a given token is an arrow operator (=>) or a keyword
	         * in order to avoid to conflict with `arrow-spacing` and `keyword-spacing`.
	         *
	         * @param {Token} token - A token to check.
	         * @returns {boolean} `true` if the token is an arrow operator.
	         */
	        function isConflicted(token) {
	            return (token.type === "Punctuator" && token.value === "=>") || token.type === "Keyword";
	        }
	
	        /**
	         * Checks the given BlockStatement node has a preceding space if it doesnt start on a new line.
	         * @param {ASTNode|Token} node The AST node of a BlockStatement.
	         * @returns {void} undefined.
	         */
	        function checkPrecedingSpace(node) {
	            const precedingToken = sourceCode.getTokenBefore(node);
	            let requireSpace;
	
	            if (precedingToken && !isConflicted(precedingToken) && astUtils.isTokenOnSameLine(precedingToken, node)) {
	                const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
	                const parent = context.getAncestors().pop();
	
	                if (parent.type === "FunctionExpression" || parent.type === "FunctionDeclaration") {
	                    requireSpace = checkFunctions;
	                } else if (node.type === "ClassBody") {
	                    requireSpace = checkClasses;
	                } else {
	                    requireSpace = checkKeywords;
	                }
	
	                if (requireSpace) {
	                    if (!hasSpace) {
	                        context.report({
	                            node,
	                            message: "Missing space before opening brace.",
	                            fix(fixer) {
	                                return fixer.insertTextBefore(node, " ");
	                            }
	                        });
	                    }
	                } else {
	                    if (hasSpace) {
	                        context.report({
	                            node,
	                            message: "Unexpected space before opening brace.",
	                            fix(fixer) {
	                                return fixer.removeRange([precedingToken.range[1], node.range[0]]);
	                            }
	                        });
	                    }
	                }
	            }
	        }
	
	        /**
	         * Checks if the CaseBlock of an given SwitchStatement node has a preceding space.
	         * @param {ASTNode} node The node of a SwitchStatement.
	         * @returns {void} undefined.
	         */
	        function checkSpaceBeforeCaseBlock(node) {
	            const cases = node.cases;
	            let openingBrace;
	
	            if (cases.length > 0) {
	                openingBrace = sourceCode.getTokenBefore(cases[0]);
	            } else {
	                openingBrace = sourceCode.getLastToken(node, 1);
	            }
	
	            checkPrecedingSpace(openingBrace);
	        }
	
	        return {
	            BlockStatement: checkPrecedingSpace,
	            ClassBody: checkPrecedingSpace,
	            SwitchStatement: checkSpaceBeforeCaseBlock
	        };
	
	    }
	};


/***/ },
/* 353 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to validate spacing before function paren.
	 * @author Mathias Schreck <https://github.com/lo1tuma>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before `function` definition opening parenthesis",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["always", "never"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            anonymous: {
	                                enum: ["always", "never", "ignore"]
	                            },
	                            named: {
	                                enum: ["always", "never", "ignore"]
	                            },
	                            asyncArrow: {
	                                enum: ["always", "never", "ignore"]
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	
	        const configuration = context.options[0],
	            sourceCode = context.getSourceCode();
	        let requireAnonymousFunctionSpacing = true,
	            forbidAnonymousFunctionSpacing = false,
	            requireNamedFunctionSpacing = true,
	            forbidNamedFunctionSpacing = false,
	            requireArrowFunctionSpacing = false,
	            forbidArrowFunctionSpacing = false;
	
	        if (typeof configuration === "object") {
	            requireAnonymousFunctionSpacing = (
	                !configuration.anonymous || configuration.anonymous === "always");
	            forbidAnonymousFunctionSpacing = configuration.anonymous === "never";
	            requireNamedFunctionSpacing = (
	                !configuration.named || configuration.named === "always");
	            forbidNamedFunctionSpacing = configuration.named === "never";
	            requireArrowFunctionSpacing = configuration.asyncArrow === "always";
	            forbidArrowFunctionSpacing = configuration.asyncArrow === "never";
	        } else if (configuration === "never") {
	            requireAnonymousFunctionSpacing = false;
	            forbidAnonymousFunctionSpacing = true;
	            requireNamedFunctionSpacing = false;
	            forbidNamedFunctionSpacing = true;
	        }
	
	        /**
	         * Determines whether a function has a name.
	         * @param {ASTNode} node The function node.
	         * @returns {boolean} Whether the function has a name.
	         */
	        function isNamedFunction(node) {
	            if (node.id) {
	                return true;
	            }
	
	            const parent = node.parent;
	
	            return parent.type === "MethodDefinition" ||
	                (parent.type === "Property" &&
	                    (
	                        parent.kind === "get" ||
	                        parent.kind === "set" ||
	                        parent.method
	                    )
	                );
	        }
	
	        /**
	         * Validates the spacing before function parentheses.
	         * @param {ASTNode} node The node to be validated.
	         * @returns {void}
	         */
	        function validateSpacingBeforeParentheses(node) {
	            const isArrow = node.type === "ArrowFunctionExpression";
	            const isNamed = !isArrow && isNamedFunction(node);
	            const isAnonymousGenerator = node.generator && !isNamed;
	            const isNormalArrow = isArrow && !node.async;
	            const isArrowWithoutParens = isArrow && sourceCode.getFirstToken(node, 1).value !== "(";
	            let forbidSpacing, requireSpacing, rightToken;
	
	            // isAnonymousGenerator  `generator-star-spacing` should warn it. E.g. `function* () {}`
	            // isNormalArrow  ignore always.
	            // isArrowWithoutParens  ignore always. E.g. `async a => a`
	            if (isAnonymousGenerator || isNormalArrow || isArrowWithoutParens) {
	                return;
	            }
	
	            if (isArrow) {
	                forbidSpacing = forbidArrowFunctionSpacing;
	                requireSpacing = requireArrowFunctionSpacing;
	            } else if (isNamed) {
	                forbidSpacing = forbidNamedFunctionSpacing;
	                requireSpacing = requireNamedFunctionSpacing;
	            } else {
	                forbidSpacing = forbidAnonymousFunctionSpacing;
	                requireSpacing = requireAnonymousFunctionSpacing;
	            }
	
	            rightToken = sourceCode.getFirstToken(node);
	            while (rightToken.value !== "(") {
	                rightToken = sourceCode.getTokenAfter(rightToken);
	            }
	            const leftToken = sourceCode.getTokenBefore(rightToken);
	            const location = leftToken.loc.end;
	
	            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
	                if (forbidSpacing) {
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Unexpected space before function parentheses.",
	                        fix(fixer) {
	                            return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
	                        }
	                    });
	                }
	            } else {
	                if (requireSpacing) {
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Missing space before function parentheses.",
	                        fix(fixer) {
	                            return fixer.insertTextAfter(leftToken, " ");
	                        }
	                    });
	                }
	            }
	        }
	
	        return {
	            FunctionDeclaration: validateSpacingBeforeParentheses,
	            FunctionExpression: validateSpacingBeforeParentheses,
	            ArrowFunctionExpression: validateSpacingBeforeParentheses,
	        };
	    }
	};


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Disallows or enforces spaces inside of parentheses.
	 * @author Jonathan Rajavuori
	 */
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing inside parentheses",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            },
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {
	                            enum: ["{}", "[]", "()", "empty"]
	                        },
	                        uniqueItems: true
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const MISSING_SPACE_MESSAGE = "There must be a space inside this paren.",
	            REJECTED_SPACE_MESSAGE = "There should be no spaces inside this paren.",
	            ALWAYS = context.options[0] === "always",
	
	            exceptionsArrayOptions = (context.options.length === 2) ? context.options[1].exceptions : [],
	            options = {};
	        let exceptions;
	
	        if (exceptionsArrayOptions.length) {
	            options.braceException = exceptionsArrayOptions.indexOf("{}") !== -1;
	            options.bracketException = exceptionsArrayOptions.indexOf("[]") !== -1;
	            options.parenException = exceptionsArrayOptions.indexOf("()") !== -1;
	            options.empty = exceptionsArrayOptions.indexOf("empty") !== -1;
	        }
	
	        /**
	         * Produces an object with the opener and closer exception values
	         * @param {Object} opts The exception options
	         * @returns {Object} `openers` and `closers` exception values
	         * @private
	         */
	        function getExceptions() {
	            const openers = [],
	                closers = [];
	
	            if (options.braceException) {
	                openers.push("{");
	                closers.push("}");
	            }
	
	            if (options.bracketException) {
	                openers.push("[");
	                closers.push("]");
	            }
	
	            if (options.parenException) {
	                openers.push("(");
	                closers.push(")");
	            }
	
	            if (options.empty) {
	                openers.push(")");
	                closers.push("(");
	            }
	
	            return {
	                openers,
	                closers
	            };
	        }
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Determines if a token is one of the exceptions for the opener paren
	         * @param {Object} token The token to check
	         * @returns {boolean} True if the token is one of the exceptions for the opener paren
	         */
	        function isOpenerException(token) {
	            return token.type === "Punctuator" && exceptions.openers.indexOf(token.value) >= 0;
	        }
	
	        /**
	         * Determines if a token is one of the exceptions for the closer paren
	         * @param {Object} token The token to check
	         * @returns {boolean} True if the token is one of the exceptions for the closer paren
	         */
	        function isCloserException(token) {
	            return token.type === "Punctuator" && exceptions.closers.indexOf(token.value) >= 0;
	        }
	
	        /**
	         * Determines if an opener paren should have a missing space after it
	         * @param {Object} left The paren token
	         * @param {Object} right The token after it
	         * @returns {boolean} True if the paren should have a space
	         */
	        function shouldOpenerHaveSpace(left, right) {
	            if (sourceCode.isSpaceBetweenTokens(left, right)) {
	                return false;
	            }
	
	            if (ALWAYS) {
	                if (right.type === "Punctuator" && right.value === ")") {
	                    return false;
	                }
	                return !isOpenerException(right);
	            } else {
	                return isOpenerException(right);
	            }
	        }
	
	        /**
	         * Determines if an closer paren should have a missing space after it
	         * @param {Object} left The token before the paren
	         * @param {Object} right The paren token
	         * @returns {boolean} True if the paren should have a space
	         */
	        function shouldCloserHaveSpace(left, right) {
	            if (left.type === "Punctuator" && left.value === "(") {
	                return false;
	            }
	
	            if (sourceCode.isSpaceBetweenTokens(left, right)) {
	                return false;
	            }
	
	            if (ALWAYS) {
	                return !isCloserException(left);
	            } else {
	                return isCloserException(left);
	            }
	        }
	
	        /**
	         * Determines if an opener paren should not have an existing space after it
	         * @param {Object} left The paren token
	         * @param {Object} right The token after it
	         * @returns {boolean} True if the paren should reject the space
	         */
	        function shouldOpenerRejectSpace(left, right) {
	            if (right.type === "Line") {
	                return false;
	            }
	
	            if (!astUtils.isTokenOnSameLine(left, right)) {
	                return false;
	            }
	
	            if (!sourceCode.isSpaceBetweenTokens(left, right)) {
	                return false;
	            }
	
	            if (ALWAYS) {
	                return isOpenerException(right);
	            } else {
	                return !isOpenerException(right);
	            }
	        }
	
	        /**
	         * Determines if an closer paren should not have an existing space after it
	         * @param {Object} left The token before the paren
	         * @param {Object} right The paren token
	         * @returns {boolean} True if the paren should reject the space
	         */
	        function shouldCloserRejectSpace(left, right) {
	            if (left.type === "Punctuator" && left.value === "(") {
	                return false;
	            }
	
	            if (!astUtils.isTokenOnSameLine(left, right)) {
	                return false;
	            }
	
	            if (!sourceCode.isSpaceBetweenTokens(left, right)) {
	                return false;
	            }
	
	            if (ALWAYS) {
	                return isCloserException(left);
	            } else {
	                return !isCloserException(left);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            Program: function checkParenSpaces(node) {
	                exceptions = getExceptions();
	                const tokens = sourceCode.tokensAndComments;
	
	                tokens.forEach(function(token, i) {
	                    const prevToken = tokens[i - 1];
	                    const nextToken = tokens[i + 1];
	
	                    if (token.type !== "Punctuator") {
	                        return;
	                    }
	
	                    if (token.value !== "(" && token.value !== ")") {
	                        return;
	                    }
	
	                    if (token.value === "(" && shouldOpenerHaveSpace(token, nextToken)) {
	                        context.report({
	                            node,
	                            loc: token.loc.start,
	                            message: MISSING_SPACE_MESSAGE,
	                            fix(fixer) {
	                                return fixer.insertTextAfter(token, " ");
	                            }
	                        });
	                    } else if (token.value === "(" && shouldOpenerRejectSpace(token, nextToken)) {
	                        context.report({
	                            node,
	                            loc: token.loc.start,
	                            message: REJECTED_SPACE_MESSAGE,
	                            fix(fixer) {
	                                return fixer.removeRange([token.range[1], nextToken.range[0]]);
	                            }
	                        });
	                    } else if (token.value === ")" && shouldCloserHaveSpace(prevToken, token)) {
	
	                        // context.report(node, token.loc.start, MISSING_SPACE_MESSAGE);
	                        context.report({
	                            node,
	                            loc: token.loc.start,
	                            message: MISSING_SPACE_MESSAGE,
	                            fix(fixer) {
	                                return fixer.insertTextBefore(token, " ");
	                            }
	                        });
	                    } else if (token.value === ")" && shouldCloserRejectSpace(prevToken, token)) {
	                        context.report({
	                            node,
	                            loc: token.loc.start,
	                            message: REJECTED_SPACE_MESSAGE,
	                            fix(fixer) {
	                                return fixer.removeRange([prevToken.range[1], token.range[0]]);
	                            }
	                        });
	                    }
	                });
	            }
	        };
	
	    }
	};


/***/ },
/* 355 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Require spaces around infix operators
	 * @author Michael Ficarra
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require spacing around infix operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    int32Hint: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const int32Hint = context.options[0] ? context.options[0].int32Hint === true : false;
	
	        const OPERATORS = [
	            "*", "/", "%", "+", "-", "<<", ">>", ">>>", "<", "<=", ">", ">=", "in",
	            "instanceof", "==", "!=", "===", "!==", "&", "^", "|", "&&", "||", "=",
	            "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "&=", "^=", "|=",
	            "?", ":", ",", "**"
	        ];
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Returns the first token which violates the rule
	         * @param {ASTNode} left - The left node of the main node
	         * @param {ASTNode} right - The right node of the main node
	         * @returns {Object} The violator token or null
	         * @private
	         */
	        function getFirstNonSpacedToken(left, right) {
	            const tokens = sourceCode.getTokensBetween(left, right, 1);
	
	            for (let i = 1, l = tokens.length - 1; i < l; ++i) {
	                const op = tokens[i];
	
	                if (
	                    op.type === "Punctuator" &&
	                    OPERATORS.indexOf(op.value) >= 0 &&
	                    (tokens[i - 1].range[1] >= op.range[0] || op.range[1] >= tokens[i + 1].range[0])
	                ) {
	                    return op;
	                }
	            }
	            return null;
	        }
	
	        /**
	         * Reports an AST node as a rule violation
	         * @param {ASTNode} mainNode - The node to report
	         * @param {Object} culpritToken - The token which has a problem
	         * @returns {void}
	         * @private
	         */
	        function report(mainNode, culpritToken) {
	            context.report({
	                node: mainNode,
	                loc: culpritToken.loc.start,
	                message: "Infix operators must be spaced.",
	                fix(fixer) {
	                    const previousToken = sourceCode.getTokenBefore(culpritToken);
	                    const afterToken = sourceCode.getTokenAfter(culpritToken);
	                    let fixString = "";
	
	                    if (culpritToken.range[0] - previousToken.range[1] === 0) {
	                        fixString = " ";
	                    }
	
	                    fixString += culpritToken.value;
	
	                    if (afterToken.range[0] - culpritToken.range[1] === 0) {
	                        fixString += " ";
	                    }
	
	                    return fixer.replaceText(culpritToken, fixString);
	                }
	            });
	        }
	
	        /**
	         * Check if the node is binary then report
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkBinary(node) {
	            if (node.left.typeAnnotation) {
	                return;
	            }
	
	            const nonSpacedNode = getFirstNonSpacedToken(node.left, node.right);
	
	            if (nonSpacedNode) {
	                if (!(int32Hint && sourceCode.getText(node).substr(-2) === "|0")) {
	                    report(node, nonSpacedNode);
	                }
	            }
	        }
	
	        /**
	         * Check if the node is conditional
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkConditional(node) {
	            const nonSpacedConsequesntNode = getFirstNonSpacedToken(node.test, node.consequent);
	            const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate);
	
	            if (nonSpacedConsequesntNode) {
	                report(node, nonSpacedConsequesntNode);
	            } else if (nonSpacedAlternateNode) {
	                report(node, nonSpacedAlternateNode);
	            }
	        }
	
	        /**
	         * Check if the node is a variable
	         * @param {ASTNode} node node to evaluate
	         * @returns {void}
	         * @private
	         */
	        function checkVar(node) {
	            if (node.init) {
	                const nonSpacedNode = getFirstNonSpacedToken(node.id, node.init);
	
	                if (nonSpacedNode) {
	                    report(node, nonSpacedNode);
	                }
	            }
	        }
	
	        return {
	            AssignmentExpression: checkBinary,
	            AssignmentPattern: checkBinary,
	            BinaryExpression: checkBinary,
	            LogicalExpression: checkBinary,
	            ConditionalExpression: checkConditional,
	            VariableDeclarator: checkVar
	        };
	
	    }
	};


/***/ },
/* 356 */
/***/ function(module, exports) {

	/**
	 * @fileoverview This rule shoud require or disallow spaces before or after unary operations.
	 * @author Marcin Kumorek
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing before or after unary operators",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    words: {
	                        type: "boolean"
	                    },
	                    nonwords: {
	                        type: "boolean"
	                    },
	                    overrides: {
	                        type: "object",
	                        additionalProperties: {
	                            type: "boolean"
	                        }
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	        const options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };
	
	        const sourceCode = context.getSourceCode();
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	        * Check if the node is the first "!" in a "!!" convert to Boolean expression
	        * @param {ASTnode} node AST node
	        * @returns {boolean} Whether or not the node is first "!" in "!!"
	        */
	        function isFirstBangInBangBangExpression(node) {
	            return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
	                node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
	        }
	
	        /**
	        * Check if the node's child argument is an "ObjectExpression"
	        * @param {ASTnode} node AST node
	        * @returns {boolean} Whether or not the argument's type is "ObjectExpression"
	        */
	        function isArgumentObjectExpression(node) {
	            return node.argument && node.argument.type && node.argument.type === "ObjectExpression";
	        }
	
	        /**
	        * Checks if an override exists for a given operator.
	        * @param {ASTnode} node AST node
	        * @param {string} operator Operator
	        * @returns {boolean} Whether or not an override has been provided for the operator
	        */
	        function overrideExistsForOperator(node, operator) {
	            return options.overrides && options.overrides.hasOwnProperty(operator);
	        }
	
	        /**
	        * Gets the value that the override was set to for this operator
	        * @param {ASTnode} node AST node
	        * @param {string} operator Operator
	        * @returns {boolean} Whether or not an override enforces a space with this operator
	        */
	        function overrideEnforcesSpaces(node, operator) {
	            return options.overrides[operator];
	        }
	
	        /**
	        * Verify Unary Word Operator has spaces after the word operator
	        * @param {ASTnode} node AST node
	        * @param {Object} firstToken first token from the AST node
	        * @param {Object} secondToken second token from the AST node
	        * @param {string} word The word to be used for reporting
	        * @returns {void}
	        */
	        function verifyWordHasSpaces(node, firstToken, secondToken, word) {
	            if (secondToken.range[0] === firstToken.range[1]) {
	                context.report({
	                    node,
	                    message: "Unary word operator '{{word}}' must be followed by whitespace.",
	                    data: {
	                        word
	                    },
	                    fix(fixer) {
	                        return fixer.insertTextAfter(firstToken, " ");
	                    }
	                });
	            }
	        }
	
	        /**
	        * Verify Unary Word Operator doesn't have spaces after the word operator
	        * @param {ASTnode} node AST node
	        * @param {Object} firstToken first token from the AST node
	        * @param {Object} secondToken second token from the AST node
	        * @param {string} word The word to be used for reporting
	        * @returns {void}
	        */
	        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
	            if (isArgumentObjectExpression(node)) {
	                if (secondToken.range[0] > firstToken.range[1]) {
	                    context.report({
	                        node,
	                        message: "Unexpected space after unary word operator '{{word}}'.",
	                        data: {
	                            word
	                        },
	                        fix(fixer) {
	                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
	                        }
	                    });
	                }
	            }
	        }
	
	        /**
	        * Check Unary Word Operators for spaces after the word operator
	        * @param {ASTnode} node AST node
	        * @param {Object} firstToken first token from the AST node
	        * @param {Object} secondToken second token from the AST node
	        * @param {string} word The word to be used for reporting
	        * @returns {void}
	        */
	        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
	            word = word || firstToken.value;
	
	            if (overrideExistsForOperator(node, word)) {
	                if (overrideEnforcesSpaces(node, word)) {
	                    verifyWordHasSpaces(node, firstToken, secondToken, word);
	                } else {
	                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
	                }
	            } else if (options.words) {
	                verifyWordHasSpaces(node, firstToken, secondToken, word);
	            } else {
	                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
	            }
	        }
	
	        /**
	        * Verifies YieldExpressions satisfy spacing requirements
	        * @param {ASTnode} node AST node
	        * @returns {void}
	        */
	        function checkForSpacesAfterYield(node) {
	            const tokens = sourceCode.getFirstTokens(node, 3),
	                word = "yield";
	
	            if (!node.argument || node.delegate) {
	                return;
	            }
	
	            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
	        }
	
	        /**
	        * Verifies AwaitExpressions satisfy spacing requirements
	        * @param {ASTNode} node AwaitExpression AST node
	        * @returns {void}
	        */
	        function checkForSpacesAfterAwait(node) {
	            const tokens = sourceCode.getFirstTokens(node, 3);
	
	            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
	        }
	
	        /**
	        * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
	        * @param {ASTnode} node AST node
	        * @param {Object} firstToken First token in the expression
	        * @param {Object} secondToken Second token in the expression
	        * @returns {void}
	        */
	        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
	            if (node.prefix) {
	                if (isFirstBangInBangBangExpression(node)) {
	                    return;
	                }
	                if (firstToken.range[1] === secondToken.range[0]) {
	                    context.report({
	                        node,
	                        message: "Unary operator '{{operator}}' must be followed by whitespace.",
	                        data: {
	                            operator: firstToken.value
	                        },
	                        fix(fixer) {
	                            return fixer.insertTextAfter(firstToken, " ");
	                        }
	                    });
	                }
	            } else {
	                if (firstToken.range[1] === secondToken.range[0]) {
	                    context.report({
	                        node,
	                        message: "Space is required before unary expressions '{{token}}'.",
	                        data: {
	                            token: secondToken.value
	                        },
	                        fix(fixer) {
	                            return fixer.insertTextBefore(secondToken, " ");
	                        }
	                    });
	                }
	            }
	        }
	
	        /**
	        * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator
	        * @param {ASTnode} node AST node
	        * @param {Object} firstToken First token in the expression
	        * @param {Object} secondToken Second token in the expression
	        * @returns {void}
	        */
	        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
	            if (node.prefix) {
	                if (secondToken.range[0] > firstToken.range[1]) {
	                    context.report({
	                        node,
	                        message: "Unexpected space after unary operator '{{operator}}'.",
	                        data: {
	                            operator: firstToken.value
	                        },
	                        fix(fixer) {
	                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
	                        }
	                    });
	                }
	            } else {
	                if (secondToken.range[0] > firstToken.range[1]) {
	                    context.report({
	                        node,
	                        message: "Unexpected space before unary operator '{{operator}}'.",
	                        data: {
	                            operator: secondToken.value
	                        },
	                        fix(fixer) {
	                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
	                        }
	                    });
	                }
	            }
	        }
	
	        /**
	        * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements
	        * @param {ASTnode} node AST node
	        * @returns {void}
	        */
	        function checkForSpaces(node) {
	            const tokens = sourceCode.getFirstTokens(node, 2),
	                firstToken = tokens[0],
	                secondToken = tokens[1];
	
	            if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
	                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);
	                return;
	            }
	
	            const operator = node.prefix ? tokens[0].value : tokens[1].value;
	
	            if (overrideExistsForOperator(node, operator)) {
	                if (overrideEnforcesSpaces(node, operator)) {
	                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);
	                } else {
	                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
	                }
	            } else if (options.nonwords) {
	                verifyNonWordsHaveSpaces(node, firstToken, secondToken);
	            } else {
	                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            UnaryExpression: checkForSpaces,
	            UpdateExpression: checkForSpaces,
	            NewExpression: checkForSpaces,
	            YieldExpression: checkForSpacesAfterYield,
	            AwaitExpression: checkForSpacesAfterAwait
	        };
	
	    }
	};


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Source code for spaced-comments rule
	 * @author Gyandeep Singh
	 */
	"use strict";
	
	const lodash = __webpack_require__(135);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Escapes the control characters of a given string.
	 * @param {string} s - A string to escape.
	 * @returns {string} An escaped string.
	 */
	function escape(s) {
	    const isOneChar = s.length === 1;
	
	    s = lodash.escapeRegExp(s);
	    return isOneChar ? s : `(?:${s})`;
	}
	
	/**
	 * Escapes the control characters of a given string.
	 * And adds a repeat flag.
	 * @param {string} s - A string to escape.
	 * @returns {string} An escaped string.
	 */
	function escapeAndRepeat(s) {
	    return `${escape(s)}+`;
	}
	
	/**
	 * Parses `markers` option.
	 * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
	 * @param {string[]} [markers] - A marker list.
	 * @returns {string[]} A marker list.
	 */
	function parseMarkersOption(markers) {
	    markers = markers ? markers.slice(0) : [];
	
	    // `*` is a marker for JSDoc comments.
	    if (markers.indexOf("*") === -1) {
	        markers.push("*");
	    }
	
	    return markers;
	}
	
	/**
	 * Creates string pattern for exceptions.
	 * Generated pattern:
	 *
	 * 1. A space or an exception pattern sequence.
	 *
	 * @param {string[]} exceptions - An exception pattern list.
	 * @returns {string} A regular expression string for exceptions.
	 */
	function createExceptionsPattern(exceptions) {
	    let pattern = "";
	
	    /*
	     * A space or an exception pattern sequence.
	     * []                 ==> "\s"
	     * ["-"]              ==> "(?:\s|\-+$)"
	     * ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
	     * ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
	     */
	    if (exceptions.length === 0) {
	
	        // a space.
	        pattern += "\\s";
	    } else {
	
	        // a space or...
	        pattern += "(?:\\s|";
	
	        if (exceptions.length === 1) {
	
	            // a sequence of the exception pattern.
	            pattern += escapeAndRepeat(exceptions[0]);
	        } else {
	
	            // a sequence of one of the exception patterns.
	            pattern += "(?:";
	            pattern += exceptions.map(escapeAndRepeat).join("|");
	            pattern += ")";
	        }
	
	        pattern += "(?:$|[\n\r]))";
	    }
	
	    return pattern;
	}
	
	/**
	 * Creates RegExp object for `always` mode.
	 * Generated pattern for beginning of comment:
	 *
	 * 1. First, a marker or nothing.
	 * 2. Next, a space or an exception pattern sequence.
	 *
	 * @param {string[]} markers - A marker list.
	 * @param {string[]} exceptions - An exception pattern list.
	 * @returns {RegExp} A RegExp object for the beginning of a comment in `always` mode.
	 */
	function createAlwaysStylePattern(markers, exceptions) {
	    let pattern = "^";
	
	    /*
	     * A marker or nothing.
	     * ["*"]            ==> "\*?"
	     * ["*", "!"]       ==> "(?:\*|!)?"
	     * ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
	     */
	    if (markers.length === 1) {
	
	        // the marker.
	        pattern += escape(markers[0]);
	    } else {
	
	        // one of markers.
	        pattern += "(?:";
	        pattern += markers.map(escape).join("|");
	        pattern += ")";
	    }
	
	    pattern += "?"; // or nothing.
	    pattern += createExceptionsPattern(exceptions);
	
	    return new RegExp(pattern);
	}
	
	/**
	 * Creates RegExp object for `never` mode.
	 * Generated pattern for beginning of comment:
	 *
	 * 1. First, a marker or nothing (captured).
	 * 2. Next, a space or a tab.
	 *
	 * @param {string[]} markers - A marker list.
	 * @returns {RegExp} A RegExp object for `never` mode.
	 */
	function createNeverStylePattern(markers) {
	    const pattern = `^(${markers.map(escape).join("|")})?[ \t]+`;
	
	    return new RegExp(pattern);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce consistent spacing after the `//` or `/*` in a comment",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            },
	            {
	                type: "object",
	                properties: {
	                    exceptions: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    markers: {
	                        type: "array",
	                        items: {
	                            type: "string"
	                        }
	                    },
	                    line: {
	                        type: "object",
	                        properties: {
	                            exceptions: {
	                                type: "array",
	                                items: {
	                                    type: "string"
	                                }
	                            },
	                            markers: {
	                                type: "array",
	                                items: {
	                                    type: "string"
	                                }
	                            }
	                        },
	                        additionalProperties: false
	                    },
	                    block: {
	                        type: "object",
	                        properties: {
	                            exceptions: {
	                                type: "array",
	                                items: {
	                                    type: "string"
	                                }
	                            },
	                            markers: {
	                                type: "array",
	                                items: {
	                                    type: "string"
	                                }
	                            },
	                            balanced: {
	                                type: "boolean"
	                            }
	                        },
	                        additionalProperties: false
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        // Unless the first option is never, require a space
	        const requireSpace = context.options[0] !== "never";
	
	        /*
	         * Parse the second options.
	         * If markers don't include `"*"`, it's added automatically for JSDoc
	         * comments.
	         */
	        const config = context.options[1] || {};
	        const balanced = config.block && config.block.balanced;
	
	        const styleRules = ["block", "line"].reduce(function(rule, type) {
	            const markers = parseMarkersOption(config[type] && config[type].markers || config.markers);
	            const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
	            const endNeverPattern = "[ \t]+$";
	
	            // Create RegExp object for valid patterns.
	            rule[type] = {
	                beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
	                endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`) : new RegExp(endNeverPattern),
	                hasExceptions: exceptions.length > 0,
	                markers: new RegExp(`^(${markers.map(escape).join("|")})`)
	            };
	
	            return rule;
	        }, {});
	
	        /**
	         * Reports a beginning spacing error with an appropriate message.
	         * @param {ASTNode} node - A comment node to check.
	         * @param {string} message - An error message to report.
	         * @param {Array} match - An array of match results for markers.
	         * @param {string} refChar - Character used for reference in the error message.
	         * @returns {void}
	         */
	        function reportBegin(node, message, match, refChar) {
	            const type = node.type.toLowerCase(),
	                commentIdentifier = type === "block" ? "/*" : "//";
	
	            context.report({
	                node,
	                fix(fixer) {
	                    const start = node.range[0];
	                    let end = start + 2;
	
	                    if (requireSpace) {
	                        if (match) {
	                            end += match[0].length;
	                        }
	                        return fixer.insertTextAfterRange([start, end], " ");
	                    } else {
	                        end += match[0].length;
	                        return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
	                    }
	                },
	                message,
	                data: { refChar }
	            });
	        }
	
	        /**
	         * Reports an ending spacing error with an appropriate message.
	         * @param {ASTNode} node - A comment node to check.
	         * @param {string} message - An error message to report.
	         * @param {string} match - An array of the matched whitespace characters.
	         * @returns {void}
	         */
	        function reportEnd(node, message, match) {
	            context.report({
	                node,
	                fix(fixer) {
	                    if (requireSpace) {
	                        return fixer.insertTextAfterRange([node.start, node.end - 2], " ");
	                    } else {
	                        const end = node.end - 2,
	                            start = end - match[0].length;
	
	                        return fixer.replaceTextRange([start, end], "");
	                    }
	                },
	                message
	            });
	        }
	
	        /**
	         * Reports a given comment if it's invalid.
	         * @param {ASTNode} node - a comment node to check.
	         * @returns {void}
	         */
	        function checkCommentForSpace(node) {
	            const type = node.type.toLowerCase(),
	                rule = styleRules[type],
	                commentIdentifier = type === "block" ? "/*" : "//";
	
	            // Ignores empty comments.
	            if (node.value.length === 0) {
	                return;
	            }
	
	            const beginMatch = rule.beginRegex.exec(node.value);
	            const endMatch = rule.endRegex.exec(node.value);
	
	            // Checks.
	            if (requireSpace) {
	                if (!beginMatch) {
	                    const hasMarker = rule.markers.exec(node.value);
	                    const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
	
	                    if (rule.hasExceptions) {
	                        reportBegin(node, "Expected exception block, space or tab after '{{refChar}}' in comment.", hasMarker, marker);
	                    } else {
	                        reportBegin(node, "Expected space or tab after '{{refChar}}' in comment.", hasMarker, marker);
	                    }
	                }
	
	                if (balanced && type === "block" && !endMatch) {
	                    reportEnd(node, "Expected space or tab before '*/' in comment.");
	                }
	            } else {
	                if (beginMatch) {
	                    if (!beginMatch[1]) {
	                        reportBegin(node, "Unexpected space or tab after '{{refChar}}' in comment.", beginMatch, commentIdentifier);
	                    } else {
	                        reportBegin(node, "Unexpected space or tab after marker ({{refChar}}) in comment.", beginMatch, beginMatch[1]);
	                    }
	                }
	
	                if (balanced && type === "block" && endMatch) {
	                    reportEnd(node, "Unexpected space or tab before '*/' in comment.", endMatch);
	                }
	            }
	        }
	
	        return {
	
	            LineComment: checkCommentForSpace,
	            BlockComment: checkCommentForSpace
	
	        };
	    }
	};


/***/ },
/* 358 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to control usage of strict mode directives.
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const messages = {
	    function: "Use the function form of 'use strict'.",
	    global: "Use the global form of 'use strict'.",
	    multiple: "Multiple 'use strict' directives.",
	    never: "Strict mode is not permitted.",
	    unnecessary: "Unnecessary 'use strict' directive.",
	    module: "'use strict' is unnecessary inside of modules.",
	    implied: "'use strict' is unnecessary when implied strict mode is enabled.",
	    unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
	    nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
	    wrap: "Wrap this function in a function with 'use strict' directive."
	};
	
	/**
	 * Gets all of the Use Strict Directives in the Directive Prologue of a group of
	 * statements.
	 * @param {ASTNode[]} statements Statements in the program or function body.
	 * @returns {ASTNode[]} All of the Use Strict Directives.
	 */
	function getUseStrictDirectives(statements) {
	    const directives = [];
	
	    for (let i = 0; i < statements.length; i++) {
	        const statement = statements[i];
	
	        if (
	            statement.type === "ExpressionStatement" &&
	            statement.expression.type === "Literal" &&
	            statement.expression.value === "use strict"
	        ) {
	            directives[i] = statement;
	        } else {
	            break;
	        }
	    }
	
	    return directives;
	}
	
	/**
	 * Checks whether a given parameter is a simple parameter.
	 *
	 * @param {ASTNode} node - A pattern node to check.
	 * @returns {boolean} `true` if the node is an Identifier node.
	 */
	function isSimpleParameter(node) {
	    return node.type === "Identifier";
	}
	
	/**
	 * Checks whether a given parameter list is a simple parameter list.
	 *
	 * @param {ASTNode[]} params - A parameter list to check.
	 * @returns {boolean} `true` if the every parameter is an Identifier node.
	 */
	function isSimpleParameterList(params) {
	    return params.every(isSimpleParameter);
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow strict mode directives",
	            category: "Strict Mode",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["never", "global", "function", "safe"]
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const ecmaFeatures = context.parserOptions.ecmaFeatures || {},
	            scopes = [],
	            classScopes = [];
	        let mode = context.options[0] || "safe";
	
	        if (ecmaFeatures.impliedStrict) {
	            mode = "implied";
	        } else if (mode === "safe") {
	            mode = ecmaFeatures.globalReturn ? "global" : "function";
	        }
	
	        /**
	        * Determines whether a reported error should be fixed, depending on the error type.
	        * @param {string} errorType The type of error
	        * @returns {boolean} `true` if the reported error should be fixed
	        */
	        function shouldFix(errorType) {
	            return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
	        }
	
	        /**
	        * Gets a fixer function to remove a given 'use strict' directive.
	        * @param {ASTNode} node The directive that should be removed
	        * @returns {Function} A fixer function
	        */
	        function getFixFunction(node) {
	            return fixer => fixer.remove(node);
	        }
	
	        /**
	         * Report a slice of an array of nodes with a given message.
	         * @param {ASTNode[]} nodes Nodes.
	         * @param {string} start Index to start from.
	         * @param {string} end Index to end before.
	         * @param {string} message Message to display.
	         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
	         * @returns {void}
	         */
	        function reportSlice(nodes, start, end, message, fix) {
	            nodes.slice(start, end).forEach(node => {
	                context.report({node, message, fix: fix ? getFixFunction(node) : null});
	            });
	        }
	
	        /**
	         * Report all nodes in an array with a given message.
	         * @param {ASTNode[]} nodes Nodes.
	         * @param {string} message Message to display.
	         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
	         * @returns {void}
	         */
	        function reportAll(nodes, message, fix) {
	            reportSlice(nodes, 0, nodes.length, message, fix);
	        }
	
	        /**
	         * Report all nodes in an array, except the first, with a given message.
	         * @param {ASTNode[]} nodes Nodes.
	         * @param {string} message Message to display.
	         * @param {boolean} fix `true` if the directive should be fixed (i.e. removed)
	         * @returns {void}
	         */
	        function reportAllExceptFirst(nodes, message, fix) {
	            reportSlice(nodes, 1, nodes.length, message, fix);
	        }
	
	        /**
	         * Entering a function in 'function' mode pushes a new nested scope onto the
	         * stack. The new scope is true if the nested function is strict mode code.
	         * @param {ASTNode} node The function declaration or expression.
	         * @param {ASTNode[]} useStrictDirectives The Use Strict Directives of the node.
	         * @returns {void}
	         */
	        function enterFunctionInFunctionMode(node, useStrictDirectives) {
	            const isInClass = classScopes.length > 0,
	                isParentGlobal = scopes.length === 0 && classScopes.length === 0,
	                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
	                isStrict = useStrictDirectives.length > 0;
	
	            if (isStrict) {
	                if (!isSimpleParameterList(node.params)) {
	                    context.report(useStrictDirectives[0], messages.nonSimpleParameterList);
	                } else if (isParentStrict) {
	                    context.report({node: useStrictDirectives[0], message: messages.unnecessary, fix: getFixFunction(useStrictDirectives[0])});
	                } else if (isInClass) {
	                    context.report({node: useStrictDirectives[0], message: messages.unnecessaryInClasses, fix: getFixFunction(useStrictDirectives[0])});
	                }
	
	                reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
	            } else if (isParentGlobal) {
	                if (isSimpleParameterList(node.params)) {
	                    context.report(node, messages.function);
	                } else {
	                    context.report(node, messages.wrap);
	                }
	            }
	
	            scopes.push(isParentStrict || isStrict);
	        }
	
	        /**
	         * Exiting a function in 'function' mode pops its scope off the stack.
	         * @returns {void}
	         */
	        function exitFunctionInFunctionMode() {
	            scopes.pop();
	        }
	
	        /**
	         * Enter a function and either:
	         * - Push a new nested scope onto the stack (in 'function' mode).
	         * - Report all the Use Strict Directives (in the other modes).
	         * @param {ASTNode} node The function declaration or expression.
	         * @returns {void}
	         */
	        function enterFunction(node) {
	            const isBlock = node.body.type === "BlockStatement",
	                useStrictDirectives = isBlock ?
	                    getUseStrictDirectives(node.body.body) : [];
	
	            if (mode === "function") {
	                enterFunctionInFunctionMode(node, useStrictDirectives);
	            } else if (useStrictDirectives.length > 0) {
	                if (isSimpleParameterList(node.params)) {
	                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
	                } else {
	                    context.report(useStrictDirectives[0], messages.nonSimpleParameterList);
	                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
	                }
	            }
	        }
	
	        const rule = {
	            Program(node) {
	                const useStrictDirectives = getUseStrictDirectives(node.body);
	
	                if (node.sourceType === "module") {
	                    mode = "module";
	                }
	
	                if (mode === "global") {
	                    if (node.body.length > 0 && useStrictDirectives.length === 0) {
	                        context.report(node, messages.global);
	                    }
	                    reportAllExceptFirst(useStrictDirectives, messages.multiple, true);
	                } else {
	                    reportAll(useStrictDirectives, messages[mode], shouldFix(mode));
	                }
	            },
	            FunctionDeclaration: enterFunction,
	            FunctionExpression: enterFunction,
	            ArrowFunctionExpression: enterFunction
	        };
	
	        if (mode === "function") {
	            Object.assign(rule, {
	
	                // Inside of class bodies are always strict mode.
	                ClassBody() {
	                    classScopes.push(true);
	                },
	                "ClassBody:exit"() {
	                    classScopes.pop();
	                },
	
	                "FunctionDeclaration:exit": exitFunctionInFunctionMode,
	                "FunctionExpression:exit": exitFunctionInFunctionMode,
	                "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
	            });
	        }
	
	        return rule;
	    }
	};


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to enforce description with the `Symbol` object
	 * @author Jarek Rencz
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require symbol descriptions",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        /**
	         * Reports if node does not conform the rule in case rule is set to
	         * report missing description
	         *
	         * @param {ASTNode} node - A CallExpression node to check.
	         * @returns {void}
	         */
	        function checkArgument(node) {
	            if (node.arguments.length === 0) {
	                context.report({
	                    node,
	                    message: "Expected Symbol to have a description."
	                });
	            }
	        }
	
	        return {
	            "Program:exit"() {
	                const scope = context.getScope();
	                const variable = astUtils.getVariableByName(scope, "Symbol");
	
	                if (variable && variable.defs.length === 0) {
	                    variable.references.forEach(function(reference) {
	                        const node = reference.identifier;
	
	                        if (astUtils.isCallee(node)) {
	                            checkArgument(node.parent);
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 360 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to enforce spacing around embedded expressions of template strings
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const OPEN_PAREN = /\$\{$/;
	const CLOSE_PAREN = /^\}/;
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow spacing around embedded expressions of template strings",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {enum: ["always", "never"]}
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	        const always = context.options[0] === "always";
	        const prefix = always ? "Expected" : "Unexpected";
	
	        /**
	         * Checks spacing before `}` of a given token.
	         * @param {Token} token - A token to check. This is a Template token.
	         * @returns {void}
	         */
	        function checkSpacingBefore(token) {
	            const prevToken = sourceCode.getTokenBefore(token);
	
	            if (prevToken &&
	                CLOSE_PAREN.test(token.value) &&
	                astUtils.isTokenOnSameLine(prevToken, token) &&
	                sourceCode.isSpaceBetweenTokens(prevToken, token) !== always
	            ) {
	                context.report({
	                    loc: token.loc.start,
	                    message: "{{prefix}} space(s) before '}'.",
	                    data: {
	                        prefix
	                    },
	                    fix(fixer) {
	                        if (always) {
	                            return fixer.insertTextBefore(token, " ");
	                        }
	                        return fixer.removeRange([
	                            prevToken.range[1],
	                            token.range[0]
	                        ]);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Checks spacing after `${` of a given token.
	         * @param {Token} token - A token to check. This is a Template token.
	         * @returns {void}
	         */
	        function checkSpacingAfter(token) {
	            const nextToken = sourceCode.getTokenAfter(token);
	
	            if (nextToken &&
	                OPEN_PAREN.test(token.value) &&
	                astUtils.isTokenOnSameLine(token, nextToken) &&
	                sourceCode.isSpaceBetweenTokens(token, nextToken) !== always
	            ) {
	                context.report({
	                    loc: {
	                        line: token.loc.end.line,
	                        column: token.loc.end.column - 2
	                    },
	                    message: "{{prefix}} space(s) after '${'.",
	                    data: {
	                        prefix
	                    },
	                    fix(fixer) {
	                        if (always) {
	                            return fixer.insertTextAfter(token, " ");
	                        }
	                        return fixer.removeRange([
	                            token.range[1],
	                            nextToken.range[0]
	                        ]);
	                    }
	                });
	            }
	        }
	
	        return {
	            TemplateElement(node) {
	                const token = sourceCode.getFirstToken(node);
	
	                checkSpacingBefore(token);
	                checkSpacingAfter(token);
	            }
	        };
	    }
	};


/***/ },
/* 361 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Require or disallow Unicode BOM
	 * @author Andrew Johnston <https://github.com/ehjay>
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow Unicode byte order mark (BOM)",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            }
	        ]
	    },
	
	    create(context) {
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            Program: function checkUnicodeBOM(node) {
	
	                const sourceCode = context.getSourceCode(),
	                    location = {column: 0, line: 1},
	                    requireBOM = context.options[0] || "never";
	
	                if (!sourceCode.hasBOM && (requireBOM === "always")) {
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Expected Unicode BOM (Byte Order Mark).",
	                        fix(fixer) {
	                            return fixer.insertTextBefore(node, "\uFEFF");
	                        }
	                    });
	                } else if (sourceCode.hasBOM && (requireBOM === "never")) {
	                    context.report({
	                        node,
	                        loc: location,
	                        message: "Unexpected Unicode BOM (Byte Order Mark).",
	                        fix(fixer) {
	                            return fixer.removeRange([-1, 0]);
	                        }
	                    });
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 362 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag comparisons to the value NaN
	 * @author James Allardice
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require calls to `isNaN()` when checking for `NaN`",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: []
	    },
	
	    create(context) {
	
	        return {
	            BinaryExpression(node) {
	                if (/^(?:[<>]|[!=]=)=?$/.test(node.operator) && (node.left.name === "NaN" || node.right.name === "NaN")) {
	                    context.report(node, "Use the isNaN function to compare with NaN.");
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Validates JSDoc comments are syntactically correct
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const doctrine = __webpack_require__(364);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce valid JSDoc comments",
	            category: "Possible Errors",
	            recommended: false
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    prefer: {
	                        type: "object",
	                        additionalProperties: {
	                            type: "string"
	                        }
	                    },
	                    preferType: {
	                        type: "object",
	                        additionalProperties: {
	                            type: "string"
	                        }
	                    },
	                    requireReturn: {
	                        type: "boolean"
	                    },
	                    requireParamDescription: {
	                        type: "boolean"
	                    },
	                    requireReturnDescription: {
	                        type: "boolean"
	                    },
	                    matchDescription: {
	                        type: "string"
	                    },
	                    requireReturnType: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const options = context.options[0] || {},
	            prefer = options.prefer || {},
	            sourceCode = context.getSourceCode(),
	
	            // these both default to true, so you have to explicitly make them false
	            requireReturn = options.requireReturn !== false,
	            requireParamDescription = options.requireParamDescription !== false,
	            requireReturnDescription = options.requireReturnDescription !== false,
	            requireReturnType = options.requireReturnType !== false,
	            preferType = options.preferType || {},
	            checkPreferType = Object.keys(preferType).length !== 0;
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        // Using a stack to store if a function returns or not (handling nested functions)
	        const fns = [];
	
	        /**
	         * Check if node type is a Class
	         * @param {ASTNode} node node to check.
	         * @returns {boolean} True is its a class
	         * @private
	         */
	        function isTypeClass(node) {
	            return node.type === "ClassExpression" || node.type === "ClassDeclaration";
	        }
	
	        /**
	         * When parsing a new function, store it in our function stack.
	         * @param {ASTNode} node A function node to check.
	         * @returns {void}
	         * @private
	         */
	        function startFunction(node) {
	            fns.push({
	                returnPresent: (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") ||
	                    isTypeClass(node)
	            });
	        }
	
	        /**
	         * Indicate that return has been found in the current function.
	         * @param {ASTNode} node The return node.
	         * @returns {void}
	         * @private
	         */
	        function addReturn(node) {
	            const functionState = fns[fns.length - 1];
	
	            if (functionState && node.argument !== null) {
	                functionState.returnPresent = true;
	            }
	        }
	
	        /**
	         * Check if return tag type is void or undefined
	         * @param {Object} tag JSDoc tag
	         * @returns {boolean} True if its of type void or undefined
	         * @private
	         */
	        function isValidReturnType(tag) {
	            return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
	        }
	
	        /**
	         * Check if type should be validated based on some exceptions
	         * @param {Object} type JSDoc tag
	         * @returns {boolean} True if it can be validated
	         * @private
	         */
	        function canTypeBeValidated(type) {
	            return type !== "UndefinedLiteral" && // {undefined} as there is no name property available.
	                   type !== "NullLiteral" && // {null}
	                   type !== "NullableLiteral" && // {?}
	                   type !== "FunctionType" && // {function(a)}
	                   type !== "AllLiteral"; // {*}
	        }
	
	        /**
	         * Extract the current and expected type based on the input type object
	         * @param {Object} type JSDoc tag
	         * @returns {Object} current and expected type object
	         * @private
	         */
	        function getCurrentExpectedTypes(type) {
	            let currentType;
	
	            if (type.name) {
	                currentType = type.name;
	            } else if (type.expression) {
	                currentType = type.expression.name;
	            }
	
	            const expectedType = currentType && preferType[currentType];
	
	            return {
	                currentType,
	                expectedType
	            };
	        }
	
	        /**
	         * Validate type for a given JSDoc node
	         * @param {Object} jsdocNode JSDoc node
	         * @param {Object} type JSDoc tag
	         * @returns {void}
	         * @private
	         */
	        function validateType(jsdocNode, type) {
	            if (!type || !canTypeBeValidated(type.type)) {
	                return;
	            }
	
	            const typesToCheck = [];
	            let elements = [];
	
	            switch (type.type) {
	                case "TypeApplication":  // {Array.<String>}
	                    elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
	                    typesToCheck.push(getCurrentExpectedTypes(type));
	                    break;
	                case "RecordType":  // {{20:String}}
	                    elements = type.fields;
	                    break;
	                case "UnionType":  // {String|number|Test}
	                case "ArrayType":  // {[String, number, Test]}
	                    elements = type.elements;
	                    break;
	                case "FieldType":  // Array.<{count: number, votes: number}>
	                    if (type.value) {
	                        typesToCheck.push(getCurrentExpectedTypes(type.value));
	                    }
	                    break;
	                default:
	                    typesToCheck.push(getCurrentExpectedTypes(type));
	            }
	
	            elements.forEach(validateType.bind(null, jsdocNode));
	
	            typesToCheck.forEach(function(typeToCheck) {
	                if (typeToCheck.expectedType &&
	                    typeToCheck.expectedType !== typeToCheck.currentType) {
	                    context.report({
	                        node: jsdocNode,
	                        message: "Use '{{expectedType}}' instead of '{{currentType}}'.",
	                        data: {
	                            currentType: typeToCheck.currentType,
	                            expectedType: typeToCheck.expectedType
	                        }
	                    });
	                }
	            });
	        }
	
	        /**
	         * Validate the JSDoc node and output warnings if anything is wrong.
	         * @param {ASTNode} node The AST node to check.
	         * @returns {void}
	         * @private
	         */
	        function checkJSDoc(node) {
	            const jsdocNode = sourceCode.getJSDocComment(node),
	                functionData = fns.pop(),
	                params = Object.create(null);
	            let hasReturns = false,
	                hasConstructor = false,
	                isInterface = false,
	                isOverride = false,
	                isAbstract = false,
	                jsdoc;
	
	            // make sure only to validate JSDoc comments
	            if (jsdocNode) {
	
	                try {
	                    jsdoc = doctrine.parse(jsdocNode.value, {
	                        strict: true,
	                        unwrap: true,
	                        sloppy: true
	                    });
	                } catch (ex) {
	
	                    if (/braces/i.test(ex.message)) {
	                        context.report(jsdocNode, "JSDoc type missing brace.");
	                    } else {
	                        context.report(jsdocNode, "JSDoc syntax error.");
	                    }
	
	                    return;
	                }
	
	                jsdoc.tags.forEach(function(tag) {
	
	                    switch (tag.title.toLowerCase()) {
	
	                        case "param":
	                        case "arg":
	                        case "argument":
	                            if (!tag.type) {
	                                context.report(jsdocNode, "Missing JSDoc parameter type for '{{name}}'.", { name: tag.name });
	                            }
	
	                            if (!tag.description && requireParamDescription) {
	                                context.report(jsdocNode, "Missing JSDoc parameter description for '{{name}}'.", { name: tag.name });
	                            }
	
	                            if (params[tag.name]) {
	                                context.report(jsdocNode, "Duplicate JSDoc parameter '{{name}}'.", { name: tag.name });
	                            } else if (tag.name.indexOf(".") === -1) {
	                                params[tag.name] = 1;
	                            }
	                            break;
	
	                        case "return":
	                        case "returns":
	                            hasReturns = true;
	
	                            if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag)) && !isAbstract) {
	                                context.report({
	                                    node: jsdocNode,
	                                    message: "Unexpected @{{title}} tag; function has no return statement.",
	                                    data: {
	                                        title: tag.title
	                                    }
	                                });
	                            } else {
	                                if (requireReturnType && !tag.type) {
	                                    context.report(jsdocNode, "Missing JSDoc return type.");
	                                }
	
	                                if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {
	                                    context.report(jsdocNode, "Missing JSDoc return description.");
	                                }
	                            }
	
	                            break;
	
	                        case "constructor":
	                        case "class":
	                            hasConstructor = true;
	                            break;
	
	                        case "override":
	                        case "inheritdoc":
	                            isOverride = true;
	                            break;
	
	                        case "abstract":
	                        case "virtual":
	                            isAbstract = true;
	                            break;
	
	                        case "interface":
	                            isInterface = true;
	                            break;
	
	                        // no default
	                    }
	
	                    // check tag preferences
	                    if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {
	                        context.report(jsdocNode, "Use @{{name}} instead.", { name: prefer[tag.title] });
	                    }
	
	                    // validate the types
	                    if (checkPreferType && tag.type) {
	                        validateType(jsdocNode, tag.type);
	                    }
	                });
	
	                // check for functions missing @returns
	                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&
	                    node.parent.kind !== "get" && node.parent.kind !== "constructor" &&
	                    node.parent.kind !== "set" && !isTypeClass(node)) {
	                    if (requireReturn || functionData.returnPresent) {
	                        context.report({
	                            node: jsdocNode,
	                            message: "Missing JSDoc @{{returns}} for function.",
	                            data: {
	                                returns: prefer.returns || "returns"
	                            }
	                        });
	                    }
	                }
	
	                // check the parameters
	                const jsdocParams = Object.keys(params);
	
	                if (node.params) {
	                    node.params.forEach(function(param, i) {
	                        if (param.type === "AssignmentPattern") {
	                            param = param.left;
	                        }
	
	                        const name = param.name;
	
	                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params
	                        if (param.type === "Identifier") {
	                            if (jsdocParams[i] && (name !== jsdocParams[i])) {
	                                context.report(jsdocNode, "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.", {
	                                    name,
	                                    jsdocName: jsdocParams[i]
	                                });
	                            } else if (!params[name] && !isOverride) {
	                                context.report(jsdocNode, "Missing JSDoc for parameter '{{name}}'.", {
	                                    name
	                                });
	                            }
	                        }
	                    });
	                }
	
	                if (options.matchDescription) {
	                    const regex = new RegExp(options.matchDescription);
	
	                    if (!regex.test(jsdoc.description)) {
	                        context.report(jsdocNode, "JSDoc description does not satisfy the regex pattern.");
	                    }
	                }
	
	            }
	
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            ArrowFunctionExpression: startFunction,
	            FunctionExpression: startFunction,
	            FunctionDeclaration: startFunction,
	            ClassExpression: startFunction,
	            ClassDeclaration: startFunction,
	            "ArrowFunctionExpression:exit": checkJSDoc,
	            "FunctionExpression:exit": checkJSDoc,
	            "FunctionDeclaration:exit": checkJSDoc,
	            "ClassExpression:exit": checkJSDoc,
	            "ClassDeclaration:exit": checkJSDoc,
	            ReturnStatement: addReturn
	        };
	
	    }
	};


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Main Doctrine object
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 * @author Dan Tao <daniel.tao@gmail.com>
	 * @author Andrew Eisenberg <andrew@eisenberg.as>
	 */
	
	(function () {
	    'use strict';
	
	    var typed,
	        utility,
	        isArray,
	        jsdoc,
	        esutils,
	        hasOwnProperty;
	
	    esutils = __webpack_require__(110);
	    isArray = __webpack_require__(365);
	    typed = __webpack_require__(366);
	    utility = __webpack_require__(367);
	
	    function sliceSource(source, index, last) {
	        return source.slice(index, last);
	    }
	
	    hasOwnProperty = (function () {
	        var func = Object.prototype.hasOwnProperty;
	        return function hasOwnProperty(obj, name) {
	            return func.call(obj, name);
	        };
	    }());
	
	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	
	    function isASCIIAlphanumeric(ch) {
	        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
	            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
	            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
	    }
	
	    function isParamTitle(title) {
	        return title === 'param' || title === 'argument' || title === 'arg';
	    }
	
	    function isReturnTitle(title) {
	        return title === 'return' || title === 'returns';
	    }
	
	    function isProperty(title) {
	        return title === 'property' || title === 'prop';
	    }
	
	    function isNameParameterRequired(title) {
	        return isParamTitle(title) || isProperty(title) ||
	            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
	    }
	
	    function isAllowedName(title) {
	        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
	    }
	
	    function isAllowedNested(title) {
	        return isProperty(title) || isParamTitle(title);
	    }
	
	    function isAllowedOptional(title) {
	        return isProperty(title) || isParamTitle(title);
	    }
	
	    function isTypeParameterRequired(title) {
	        return isParamTitle(title) || isReturnTitle(title) ||
	            title === 'define' || title === 'enum' ||
	            title === 'implements' || title === 'this' ||
	            title === 'type' || title === 'typedef' || isProperty(title);
	    }
	
	    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
	    // This would require changes to 'parseType'
	    function isAllowedType(title) {
	        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
	            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
	            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
	            title === 'public' || title === 'private' || title === 'protected';
	    }
	
	    function trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    function unwrapComment(doc) {
	        // JSDoc comment is following form
	        //   /**
	        //    * .......
	        //    */
	        // remove /**, */ and *
	        var BEFORE_STAR = 0,
	            STAR = 1,
	            AFTER_STAR = 2,
	            index,
	            len,
	            mode,
	            result,
	            ch;
	
	        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
	        index = 0;
	        len = doc.length;
	        mode = BEFORE_STAR;
	        result = '';
	
	        while (index < len) {
	            ch = doc.charCodeAt(index);
	            switch (mode) {
	            case BEFORE_STAR:
	                if (esutils.code.isLineTerminator(ch)) {
	                    result += String.fromCharCode(ch);
	                } else if (ch === 0x2A  /* '*' */) {
	                    mode = STAR;
	                } else if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                    mode = AFTER_STAR;
	                }
	                break;
	
	            case STAR:
	                if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                }
	                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
	                break;
	
	            case AFTER_STAR:
	                result += String.fromCharCode(ch);
	                if (esutils.code.isLineTerminator(ch)) {
	                    mode = BEFORE_STAR;
	                }
	                break;
	            }
	            index += 1;
	        }
	
	        return result.replace(/\s+$/, '');
	    }
	
	    // JSDoc Tag Parser
	
	    (function (exports) {
	        var Rules,
	            index,
	            lineNumber,
	            length,
	            source,
	            recoverable,
	            sloppy,
	            strict;
	
	        function advance() {
	            var ch = source.charCodeAt(index);
	            index += 1;
	            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) {
	                lineNumber += 1;
	            }
	            return String.fromCharCode(ch);
	        }
	
	        function scanTitle() {
	            var title = '';
	            // waste '@'
	            advance();
	
	            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
	                title += advance();
	            }
	
	            return title;
	        }
	
	        function seekContent() {
	            var ch, waiting, last = index;
	
	            waiting = false;
	            while (last < length) {
	                ch = source.charCodeAt(last);
	                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) {
	                    waiting = true;
	                } else if (waiting) {
	                    if (ch === 0x40  /* '@' */) {
	                        break;
	                    }
	                    if (!esutils.code.isWhiteSpace(ch)) {
	                        waiting = false;
	                    }
	                }
	                last += 1;
	            }
	            return last;
	        }
	
	        // type expression may have nest brace, such as,
	        // { { ok: string } }
	        //
	        // therefore, scanning type expression with balancing braces.
	        function parseType(title, last) {
	            var ch, brace, type, direct = false;
	
	
	            // search '{'
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isWhiteSpace(ch)) {
	                    advance();
	                } else if (ch === 0x7B  /* '{' */) {
	                    advance();
	                    break;
	                } else {
	                    // this is direct pattern
	                    direct = true;
	                    break;
	                }
	            }
	
	
	            if (direct) {
	                return null;
	            }
	
	            // type expression { is found
	            brace = 1;
	            type = '';
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isLineTerminator(ch)) {
	                    advance();
	                } else {
	                    if (ch === 0x7D  /* '}' */) {
	                        brace -= 1;
	                        if (brace === 0) {
	                            advance();
	                            break;
	                        }
	                    } else if (ch === 0x7B  /* '{' */) {
	                        brace += 1;
	                    }
	                    type += advance();
	                }
	            }
	
	            if (brace !== 0) {
	                // braces is not balanced
	                return utility.throwError('Braces are not balanced');
	            }
	
	            if (isAllowedOptional(title)) {
	                return typed.parseParamType(type);
	            }
	
	            return typed.parseType(type);
	        }
	
	        function scanIdentifier(last) {
	            var identifier;
	            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
	                return null;
	            }
	            identifier = advance();
	            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
	                identifier += advance();
	            }
	            return identifier;
	        }
	
	        function skipWhiteSpace(last) {
	            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
	                advance();
	            }
	        }
	
	        function parseName(last, allowBrackets, allowNestedParams) {
	            var name = '',
	                useBrackets,
	                insideString;
	
	
	            skipWhiteSpace(last);
	
	            if (index >= last) {
	                return null;
	            }
	
	            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) {
	                useBrackets = true;
	                name = advance();
	            }
	
	            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
	                return null;
	            }
	
	            name += scanIdentifier(last);
	
	            if (allowNestedParams) {
	                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
	                        name === 'module' ||
	                        name === 'external' ||
	                        name === 'event')) {
	                    name += advance();
	                    name += scanIdentifier(last);
	
	                }
	                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){
	                    name += advance();
	                    name += advance();
	                }
	                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
	                        source.charCodeAt(index) === 0x2F  /* '/' */ ||
	                        source.charCodeAt(index) === 0x23  /* '#' */ ||
	                        source.charCodeAt(index) === 0x2D  /* '-' */ ||
	                        source.charCodeAt(index) === 0x7E  /* '~' */) {
	                    name += advance();
	                    name += scanIdentifier(last);
	                }
	            }
	
	            if (useBrackets) {
	                skipWhiteSpace(last);
	                // do we have a default value for this?
	                if (source.charCodeAt(index) === 0x3D  /* '=' */) {
	                    // consume the '='' symbol
	                    name += advance();
	                    skipWhiteSpace(last);
	
	                    var ch;
	                    var bracketDepth = 1;
	
	                    // scan in the default value
	                    while (index < last) {
	                        ch = source.charCodeAt(index);
	
	                        if (esutils.code.isWhiteSpace(ch)) {
	                            if (!insideString) {
	                                skipWhiteSpace(last);
	                                ch = source.charCodeAt(index);
	                            }
	                        }
	
	                        if (ch === 0x27 /* ''' */) {
	                            if (!insideString) {
	                                insideString = '\'';
	                            } else {
	                                if (insideString === '\'') {
	                                    insideString = '';
	                                }
	                            }
	                        }
	
	                        if (ch === 0x22 /* '"' */) {
	                            if (!insideString) {
	                                insideString = '"';
	                            } else {
	                                if (insideString === '"') {
	                                    insideString = '';
	                                }
	                            }
	                        }
	
	                        if (ch === 0x5B /* '[' */) {
	                            bracketDepth++;
	                        } else if (ch === 0x5D  /* ']' */ &&
	                            --bracketDepth === 0) {
	                            break;
	                        }
	
	                        name += advance();
	                    }
	                }
	
	                skipWhiteSpace(last);
	
	                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {
	                    // we never found a closing ']'
	                    return null;
	                }
	
	                // collect the last ']'
	                name += advance();
	            }
	
	            return name;
	        }
	
	        function skipToTag() {
	            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {
	                advance();
	            }
	            if (index >= length) {
	                return false;
	            }
	            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
	            return true;
	        }
	
	        function TagParser(options, title) {
	            this._options = options;
	            this._title = title.toLowerCase();
	            this._tag = {
	                title: title,
	                description: null
	            };
	            if (this._options.lineNumbers) {
	                this._tag.lineNumber = lineNumber;
	            }
	            this._last = 0;
	            // space to save special information for title parsers.
	            this._extra = { };
	        }
	
	        // addError(err, ...)
	        TagParser.prototype.addError = function addError(errorText) {
	            var args = Array.prototype.slice.call(arguments, 1),
	                msg = errorText.replace(
	                    /%(\d)/g,
	                    function (whole, index) {
	                        utility.assert(index < args.length, 'Message reference must be in range');
	                        return args[index];
	                    }
	                );
	
	            if (!this._tag.errors) {
	                this._tag.errors = [];
	            }
	            if (strict) {
	                utility.throwError(msg);
	            }
	            this._tag.errors.push(msg);
	            return recoverable;
	        };
	
	        TagParser.prototype.parseType = function () {
	            // type required titles
	            if (isTypeParameterRequired(this._title)) {
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                    if (!this._tag.type) {
	                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
	                            if (!this.addError('Missing or invalid tag type')) {
	                                return false;
	                            }
	                        }
	                    }
	                } catch (error) {
	                    this._tag.type = null;
	                    if (!this.addError(error.message)) {
	                        return false;
	                    }
	                }
	            } else if (isAllowedType(this._title)) {
	                // optional types
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                } catch (e) {
	                    //For optional types, lets drop the thrown error when we hit the end of the file
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype._parseNamePath = function (optional) {
	            var name;
	            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
	            if (!name) {
	                if (!optional) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }
	            this._tag.name = name;
	            return true;
	        };
	
	        TagParser.prototype.parseNamePath = function () {
	            return this._parseNamePath(false);
	        };
	
	        TagParser.prototype.parseNamePathOptional = function () {
	            return this._parseNamePath(true);
	        };
	
	
	        TagParser.prototype.parseName = function () {
	            var assign, name;
	
	            // param, property requires name
	            if (isAllowedName(this._title)) {
	                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
	                if (!this._tag.name) {
	                    if (!isNameParameterRequired(this._title)) {
	                        return true;
	                    }
	
	                    // it's possible the name has already been parsed but interpreted as a type
	                    // it's also possible this is a sloppy declaration, in which case it will be
	                    // fixed at the end
	                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
	                        this._extra.name = this._tag.type;
	                        this._tag.name = this._tag.type.name;
	                        this._tag.type = null;
	                    } else {
	                        if (!this.addError('Missing or invalid tag name')) {
	                            return false;
	                        }
	                    }
	                } else {
	                    name = this._tag.name;
	                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
	                        // extract the default value if there is one
	                        // example: @param {string} [somebody=John Doe] description
	                        assign = name.substring(1, name.length - 1).split('=');
	                        if (assign[1]) {
	                            this._tag['default'] = assign[1];
	                        }
	                        this._tag.name = assign[0];
	
	                        // convert to an optional type
	                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {
	                            this._tag.type = {
	                                type: 'OptionalType',
	                                expression: this._tag.type
	                            };
	                        }
	                    }
	                }
	            }
	
	
	            return true;
	        };
	
	        TagParser.prototype.parseDescription = function parseDescription() {
	            var description = trim(sliceSource(source, index, this._last));
	            if (description) {
	                if ((/^-\s+/).test(description)) {
	                    description = description.substring(2);
	                }
	                this._tag.description = description;
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseCaption = function parseDescription() {
	            var description = trim(sliceSource(source, index, this._last));
	            var captionStartTag = '<caption>';
	            var captionEndTag = '</caption>';
	            var captionStart = description.indexOf(captionStartTag);
	            var captionEnd = description.indexOf(captionEndTag);
	            if (captionStart >= 0 && captionEnd >= 0) {
	                this._tag.caption = trim(description.substring(
	                    captionStart + captionStartTag.length, captionEnd));
	                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
	            } else {
	                this._tag.description = description;
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseKind = function parseKind() {
	            var kind, kinds;
	            kinds = {
	                'class': true,
	                'constant': true,
	                'event': true,
	                'external': true,
	                'file': true,
	                'function': true,
	                'member': true,
	                'mixin': true,
	                'module': true,
	                'namespace': true,
	                'typedef': true
	            };
	            kind = trim(sliceSource(source, index, this._last));
	            this._tag.kind = kind;
	            if (!hasOwnProperty(kinds, kind)) {
	                if (!this.addError('Invalid kind name \'%0\'', kind)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseAccess = function parseAccess() {
	            var access;
	            access = trim(sliceSource(source, index, this._last));
	            this._tag.access = access;
	            if (access !== 'private' && access !== 'protected' && access !== 'public') {
	                if (!this.addError('Invalid access name \'%0\'', access)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseThis = function parseAccess() {
	            // this name may be a name expression (e.g. {foo.bar})
	            // or a name path (e.g. foo.bar)
	            var value = trim(sliceSource(source, index, this._last));
	            if (value && value.charAt(0) === '{') {
	                var gotType = this.parseType();
	                if (gotType && this._tag.type.type === 'NameExpression') {
	                    this._tag.name = this._tag.type.name;
	                    return true;
	                } else {
	                    return this.addError('Invalid name for this');
	                }
	            } else {
	                return this.parseNamePath();
	            }
	        };
	
	        TagParser.prototype.parseVariation = function parseVariation() {
	            var variation, text;
	            text = trim(sliceSource(source, index, this._last));
	            variation = parseFloat(text, 10);
	            this._tag.variation = variation;
	            if (isNaN(variation)) {
	                if (!this.addError('Invalid variation \'%0\'', text)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.ensureEnd = function () {
	            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
	            if (shouldBeEmpty) {
	                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.epilogue = function epilogue() {
	            var description;
	
	            description = this._tag.description;
	            // un-fix potentially sloppy declaration
	            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
	                this._tag.type = this._extra.name;
	                if (!this._tag.name) {
	                    this._tag.name = undefined;
	                }
	
	                if (!sloppy) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }
	
	            return true;
	        };
	
	        Rules = {
	            // http://usejsdoc.org/tags-access.html
	            'access': ['parseAccess'],
	            // http://usejsdoc.org/tags-alias.html
	            'alias': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-augments.html
	            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-constructor.html
	            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-constructor.html
	            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-extends.html
	            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-example.html
	            'example': ['parseCaption'],
	            // http://usejsdoc.org/tags-deprecated.html
	            'deprecated': ['parseDescription'],
	            // http://usejsdoc.org/tags-global.html
	            'global': ['ensureEnd'],
	            // http://usejsdoc.org/tags-inner.html
	            'inner': ['ensureEnd'],
	            // http://usejsdoc.org/tags-instance.html
	            'instance': ['ensureEnd'],
	            // http://usejsdoc.org/tags-kind.html
	            'kind': ['parseKind'],
	            // http://usejsdoc.org/tags-mixes.html
	            'mixes': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-mixin.html
	            'mixin': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-member.html
	            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-method.html
	            'method': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-module.html
	            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'func': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'function': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-member.html
	            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-name.html
	            'name': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-namespace.html
	            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-private.html
	            'private': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-protected.html
	            'protected': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-public.html
	            'public': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-readonly.html
	            'readonly': ['ensureEnd'],
	            // http://usejsdoc.org/tags-requires.html
	            'requires': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-since.html
	            'since': ['parseDescription'],
	            // http://usejsdoc.org/tags-static.html
	            'static': ['ensureEnd'],
	            // http://usejsdoc.org/tags-summary.html
	            'summary': ['parseDescription'],
	            // http://usejsdoc.org/tags-this.html
	            'this': ['parseThis', 'ensureEnd'],
	            // http://usejsdoc.org/tags-todo.html
	            'todo': ['parseDescription'],
	            // http://usejsdoc.org/tags-typedef.html
	            'typedef': ['parseType', 'parseNamePathOptional'],
	            // http://usejsdoc.org/tags-variation.html
	            'variation': ['parseVariation'],
	            // http://usejsdoc.org/tags-version.html
	            'version': ['parseDescription']
	        };
	
	        TagParser.prototype.parse = function parse() {
	            var i, iz, sequences, method;
	
	
	            // empty title
	            if (!this._title) {
	                if (!this.addError('Missing or invalid title')) {
	                    return null;
	                }
	            }
	
	            // Seek to content last index.
	            this._last = seekContent(this._title);
	
	            if (hasOwnProperty(Rules, this._title)) {
	                sequences = Rules[this._title];
	            } else {
	                // default sequences
	                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
	            }
	
	            for (i = 0, iz = sequences.length; i < iz; ++i) {
	                method = sequences[i];
	                if (!this[method]()) {
	                    return null;
	                }
	            }
	
	            return this._tag;
	        };
	
	        function parseTag(options) {
	            var title, parser, tag;
	
	            // skip to tag
	            if (!skipToTag()) {
	                return null;
	            }
	
	            // scan title
	            title = scanTitle();
	
	            // construct tag parser
	            parser = new TagParser(options, title);
	            tag = parser.parse();
	
	            // Seek global index to end of this tag.
	            while (index < parser._last) {
	                advance();
	            }
	
	            return tag;
	        }
	
	        //
	        // Parse JSDoc
	        //
	
	        function scanJSDocDescription(preserveWhitespace) {
	            var description = '', ch, atAllowed;
	
	            atAllowed = true;
	            while (index < length) {
	                ch = source.charCodeAt(index);
	
	                if (atAllowed && ch === 0x40  /* '@' */) {
	                    break;
	                }
	
	                if (esutils.code.isLineTerminator(ch)) {
	                    atAllowed = true;
	                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
	                    atAllowed = false;
	                }
	
	                description += advance();
	            }
	
	            return preserveWhitespace ? description : trim(description);
	        }
	
	        function parse(comment, options) {
	            var tags = [], tag, description, interestingTags, i, iz;
	
	            if (options === undefined) {
	                options = {};
	            }
	
	            if (typeof options.unwrap === 'boolean' && options.unwrap) {
	                source = unwrapComment(comment);
	            } else {
	                source = comment;
	            }
	
	            // array of relevant tags
	            if (options.tags) {
	                if (isArray(options.tags)) {
	                    interestingTags = { };
	                    for (i = 0, iz = options.tags.length; i < iz; i++) {
	                        if (typeof options.tags[i] === 'string') {
	                            interestingTags[options.tags[i]] = true;
	                        } else {
	                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                        }
	                    }
	                } else {
	                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                }
	            }
	
	            length = source.length;
	            index = 0;
	            lineNumber = 0;
	            recoverable = options.recoverable;
	            sloppy = options.sloppy;
	            strict = options.strict;
	
	            description = scanJSDocDescription(options.preserveWhitespace);
	
	            while (true) {
	                tag = parseTag(options);
	                if (!tag) {
	                    break;
	                }
	                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
	                    tags.push(tag);
	                }
	            }
	
	            return {
	                description: description,
	                tags: tags
	            };
	        }
	        exports.parse = parse;
	    }(jsdoc = {}));
	
	    exports.version = utility.VERSION;
	    exports.parse = jsdoc.parse;
	    exports.parseType = typed.parseType;
	    exports.parseParamType = typed.parseParamType;
	    exports.unwrapComment = unwrapComment;
	    exports.Syntax = shallowCopy(typed.Syntax);
	    exports.Error = utility.DoctrineError;
	    exports.type = {
	        Syntax: exports.Syntax,
	        parseType: typed.parseType,
	        parseParamType: typed.parseParamType,
	        stringify: typed.stringify
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 365 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Type expression parser.
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 * @author Dan Tao <daniel.tao@gmail.com>
	 * @author Andrew Eisenberg <andrew@eisenberg.as>
	 */
	
	// "typed", the Type Expression Parser for doctrine.
	
	(function () {
	    'use strict';
	
	    var Syntax,
	        Token,
	        source,
	        length,
	        index,
	        previous,
	        token,
	        value,
	        esutils,
	        utility;
	
	    esutils = __webpack_require__(110);
	    utility = __webpack_require__(367);
	
	    Syntax = {
	        NullableLiteral: 'NullableLiteral',
	        AllLiteral: 'AllLiteral',
	        NullLiteral: 'NullLiteral',
	        UndefinedLiteral: 'UndefinedLiteral',
	        VoidLiteral: 'VoidLiteral',
	        UnionType: 'UnionType',
	        ArrayType: 'ArrayType',
	        RecordType: 'RecordType',
	        FieldType: 'FieldType',
	        FunctionType: 'FunctionType',
	        ParameterType: 'ParameterType',
	        RestType: 'RestType',
	        NonNullableType: 'NonNullableType',
	        OptionalType: 'OptionalType',
	        NullableType: 'NullableType',
	        NameExpression: 'NameExpression',
	        TypeApplication: 'TypeApplication',
	        StringLiteralType: 'StringLiteralType',
	        NumericLiteralType: 'NumericLiteralType',
	        BooleanLiteralType: 'BooleanLiteralType'
	    };
	
	    Token = {
	        ILLEGAL: 0,    // ILLEGAL
	        DOT_LT: 1,     // .<
	        REST: 2,       // ...
	        LT: 3,         // <
	        GT: 4,         // >
	        LPAREN: 5,     // (
	        RPAREN: 6,     // )
	        LBRACE: 7,     // {
	        RBRACE: 8,     // }
	        LBRACK: 9,    // [
	        RBRACK: 10,    // ]
	        COMMA: 11,     // ,
	        COLON: 12,     // :
	        STAR: 13,      // *
	        PIPE: 14,      // |
	        QUESTION: 15,  // ?
	        BANG: 16,      // !
	        EQUAL: 17,     // =
	        NAME: 18,      // name token
	        STRING: 19,    // string
	        NUMBER: 20,    // number
	        EOF: 21
	    };
	
	    function isTypeName(ch) {
	        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
	    }
	
	    function Context(previous, index, token, value) {
	        this._previous = previous;
	        this._index = index;
	        this._token = token;
	        this._value = value;
	    }
	
	    Context.prototype.restore = function () {
	        previous = this._previous;
	        index = this._index;
	        token = this._token;
	        value = this._value;
	    };
	
	    Context.save = function () {
	        return new Context(previous, index, token, value);
	    };
	
	    function advance() {
	        var ch = source.charAt(index);
	        index += 1;
	        return ch;
	    }
	
	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;
	
	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
	                ch = advance();
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }
	
	    function scanString() {
	        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false
	        quote = source.charAt(index);
	        ++index;
	
	        while (index < length) {
	            ch = advance();
	
	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = advance();
	                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        restore = index;
	                        unescaped = scanHexEscape(ch);
	                        if (unescaped) {
	                            str += unescaped;
	                        } else {
	                            index = restore;
	                            str += ch;
	                        }
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\v';
	                        break;
	
	                    default:
	                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
	                            code = '01234567'.indexOf(ch);
	
	                            // \0 is not octal escape sequence
	                            // Deprecating unused code. TODO review removal
	                            //if (code !== 0) {
	                            //    octal = true;
	                            //}
	
	                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                //TODO Review Removal octal = true;
	                                code = code * 8 + '01234567'.indexOf(advance());
	
	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                    code = code * 8 + '01234567'.indexOf(advance());
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    if (ch ===  '\r' && source.charCodeAt(index) === 0x0A  /* '\n' */) {
	                        ++index;
	                    }
	                }
	            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }
	
	        if (quote !== '') {
	            utility.throwError('unexpected quote');
	        }
	
	        value = str;
	        return Token.STRING;
	    }
	
	    function scanNumber() {
	        var number, ch;
	
	        number = '';
	        ch = source.charCodeAt(index);
	
	        if (ch !== 0x2E  /* '.' */) {
	            number = advance();
	            ch = source.charCodeAt(index);
	
	            if (number === '0') {
	                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isHexDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }
	
	                    if (number.length <= 2) {
	                        // only 0x
	                        utility.throwError('unexpected token');
	                    }
	
	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStartES5(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 16);
	                    return Token.NUMBER;
	                }
	
	                if (esutils.code.isOctalDigit(ch)) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isOctalDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }
	
	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 8);
	                    return Token.NUMBER;
	                }
	
	                if (esutils.code.isDecimalDigit(ch)) {
	                    utility.throwError('unexpected token');
	                }
	            }
	
	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }
	
	        if (ch === 0x2E  /* '.' */) {
	            number += advance();
	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }
	
	        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {
	            number += advance();
	
	            ch = source.charCodeAt(index);
	            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {
	                number += advance();
	            }
	
	            ch = source.charCodeAt(index);
	            if (esutils.code.isDecimalDigit(ch)) {
	                number += advance();
	                while (index < length) {
	                    ch = source.charCodeAt(index);
	                    if (!esutils.code.isDecimalDigit(ch)) {
	                        break;
	                    }
	                    number += advance();
	                }
	            } else {
	                utility.throwError('unexpected token');
	            }
	        }
	
	        if (index < length) {
	            ch = source.charCodeAt(index);
	            if (esutils.code.isIdentifierStartES5(ch)) {
	                utility.throwError('unexpected token');
	            }
	        }
	
	        value = parseFloat(number);
	        return Token.NUMBER;
	    }
	
	
	    function scanTypeName() {
	        var ch, ch2;
	
	        value = advance();
	        while (index < length && isTypeName(source.charCodeAt(index))) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x2E  /* '.' */) {
	                if ((index + 1) >= length) {
	                    return Token.ILLEGAL;
	                }
	                ch2 = source.charCodeAt(index + 1);
	                if (ch2 === 0x3C  /* '<' */) {
	                    break;
	                }
	            }
	            value += advance();
	        }
	        return Token.NAME;
	    }
	
	    function next() {
	        var ch;
	
	        previous = index;
	
	        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
	            advance();
	        }
	        if (index >= length) {
	            token = Token.EOF;
	            return token;
	        }
	
	        ch = source.charCodeAt(index);
	        switch (ch) {
	        case 0x27:  /* ''' */
	        case 0x22:  /* '"' */
	            token = scanString();
	            return token;
	
	        case 0x3A:  /* ':' */
	            advance();
	            token = Token.COLON;
	            return token;
	
	        case 0x2C:  /* ',' */
	            advance();
	            token = Token.COMMA;
	            return token;
	
	        case 0x28:  /* '(' */
	            advance();
	            token = Token.LPAREN;
	            return token;
	
	        case 0x29:  /* ')' */
	            advance();
	            token = Token.RPAREN;
	            return token;
	
	        case 0x5B:  /* '[' */
	            advance();
	            token = Token.LBRACK;
	            return token;
	
	        case 0x5D:  /* ']' */
	            advance();
	            token = Token.RBRACK;
	            return token;
	
	        case 0x7B:  /* '{' */
	            advance();
	            token = Token.LBRACE;
	            return token;
	
	        case 0x7D:  /* '}' */
	            advance();
	            token = Token.RBRACE;
	            return token;
	
	        case 0x2E:  /* '.' */
	            if (index + 1 < length) {
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x3C  /* '<' */) {
	                    advance();  // '.'
	                    advance();  // '<'
	                    token = Token.DOT_LT;
	                    return token;
	                }
	
	                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {
	                    advance();  // '.'
	                    advance();  // '.'
	                    advance();  // '.'
	                    token = Token.REST;
	                    return token;
	                }
	
	                if (esutils.code.isDecimalDigit(ch)) {
	                    token = scanNumber();
	                    return token;
	                }
	            }
	            token = Token.ILLEGAL;
	            return token;
	
	        case 0x3C:  /* '<' */
	            advance();
	            token = Token.LT;
	            return token;
	
	        case 0x3E:  /* '>' */
	            advance();
	            token = Token.GT;
	            return token;
	
	        case 0x2A:  /* '*' */
	            advance();
	            token = Token.STAR;
	            return token;
	
	        case 0x7C:  /* '|' */
	            advance();
	            token = Token.PIPE;
	            return token;
	
	        case 0x3F:  /* '?' */
	            advance();
	            token = Token.QUESTION;
	            return token;
	
	        case 0x21:  /* '!' */
	            advance();
	            token = Token.BANG;
	            return token;
	
	        case 0x3D:  /* '=' */
	            advance();
	            token = Token.EQUAL;
	            return token;
	
	        case 0x2D: /* '-' */
	            token = scanNumber();
	            return token;
	
	        default:
	            if (esutils.code.isDecimalDigit(ch)) {
	                token = scanNumber();
	                return token;
	            }
	
	            // type string permits following case,
	            //
	            // namespace.module.MyClass
	            //
	            // this reduced 1 token TK_NAME
	            utility.assert(isTypeName(ch));
	            token = scanTypeName();
	            return token;
	        }
	    }
	
	    function consume(target, text) {
	        utility.assert(token === target, text || 'consumed token not matched');
	        next();
	    }
	
	    function expect(target, message) {
	        if (token !== target) {
	            utility.throwError(message || 'unexpected token');
	        }
	        next();
	    }
	
	    // UnionType := '(' TypeUnionList ')'
	    //
	    // TypeUnionList :=
	    //     <<empty>>
	    //   | NonemptyTypeUnionList
	    //
	    // NonemptyTypeUnionList :=
	    //     TypeExpression
	    //   | TypeExpression '|' NonemptyTypeUnionList
	    function parseUnionType() {
	        var elements;
	        consume(Token.LPAREN, 'UnionType should start with (');
	        elements = [];
	        if (token !== Token.RPAREN) {
	            while (true) {
	                elements.push(parseTypeExpression());
	                if (token === Token.RPAREN) {
	                    break;
	                }
	                expect(Token.PIPE);
	            }
	        }
	        consume(Token.RPAREN, 'UnionType should end with )');
	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }
	
	    // ArrayType := '[' ElementTypeList ']'
	    //
	    // ElementTypeList :=
	    //     <<empty>>
	    //  | TypeExpression
	    //  | '...' TypeExpression
	    //  | TypeExpression ',' ElementTypeList
	    function parseArrayType() {
	        var elements;
	        consume(Token.LBRACK, 'ArrayType should start with [');
	        elements = [];
	        while (token !== Token.RBRACK) {
	            if (token === Token.REST) {
	                consume(Token.REST);
	                elements.push({
	                    type: Syntax.RestType,
	                    expression: parseTypeExpression()
	                });
	                break;
	            } else {
	                elements.push(parseTypeExpression());
	            }
	            if (token !== Token.RBRACK) {
	                expect(Token.COMMA);
	            }
	        }
	        expect(Token.RBRACK);
	        return {
	            type: Syntax.ArrayType,
	            elements: elements
	        };
	    }
	
	    function parseFieldName() {
	        var v = value;
	        if (token === Token.NAME || token === Token.STRING) {
	            next();
	            return v;
	        }
	
	        if (token === Token.NUMBER) {
	            consume(Token.NUMBER);
	            return String(v);
	        }
	
	        utility.throwError('unexpected token');
	    }
	
	    // FieldType :=
	    //     FieldName
	    //   | FieldName ':' TypeExpression
	    //
	    // FieldName :=
	    //     NameExpression
	    //   | StringLiteral
	    //   | NumberLiteral
	    //   | ReservedIdentifier
	    function parseFieldType() {
	        var key;
	
	        key = parseFieldName();
	        if (token === Token.COLON) {
	            consume(Token.COLON);
	            return {
	                type: Syntax.FieldType,
	                key: key,
	                value: parseTypeExpression()
	            };
	        }
	        return {
	            type: Syntax.FieldType,
	            key: key,
	            value: null
	        };
	    }
	
	    // RecordType := '{' FieldTypeList '}'
	    //
	    // FieldTypeList :=
	    //     <<empty>>
	    //   | FieldType
	    //   | FieldType ',' FieldTypeList
	    function parseRecordType() {
	        var fields;
	
	        consume(Token.LBRACE, 'RecordType should start with {');
	        fields = [];
	        if (token === Token.COMMA) {
	            consume(Token.COMMA);
	        } else {
	            while (token !== Token.RBRACE) {
	                fields.push(parseFieldType());
	                if (token !== Token.RBRACE) {
	                    expect(Token.COMMA);
	                }
	            }
	        }
	        expect(Token.RBRACE);
	        return {
	            type: Syntax.RecordType,
	            fields: fields
	        };
	    }
	
	    // NameExpression :=
	    //    Identifier
	    //  | TagIdentifier ':' Identifier
	    //
	    // Tag identifier is one of "module", "external" or "event"
	    // Identifier is the same as Token.NAME, including any dots, something like
	    // namespace.module.MyClass
	    function parseNameExpression() {
	        var name = value;
	        expect(Token.NAME);
	
	        if (token === Token.COLON && (
	                name === 'module' ||
	                name === 'external' ||
	                name === 'event')) {
	            consume(Token.COLON);
	            name += ':' + value;
	            expect(Token.NAME);
	        }
	
	        return {
	            type: Syntax.NameExpression,
	            name: name
	        };
	    }
	
	    // TypeExpressionList :=
	    //     TopLevelTypeExpression
	    //   | TopLevelTypeExpression ',' TypeExpressionList
	    function parseTypeExpressionList() {
	        var elements = [];
	
	        elements.push(parseTop());
	        while (token === Token.COMMA) {
	            consume(Token.COMMA);
	            elements.push(parseTop());
	        }
	        return elements;
	    }
	
	    // TypeName :=
	    //     NameExpression
	    //   | NameExpression TypeApplication
	    //
	    // TypeApplication :=
	    //     '.<' TypeExpressionList '>'
	    //   | '<' TypeExpressionList '>'   // this is extension of doctrine
	    function parseTypeName() {
	        var expr, applications;
	
	        expr = parseNameExpression();
	        if (token === Token.DOT_LT || token === Token.LT) {
	            next();
	            applications = parseTypeExpressionList();
	            expect(Token.GT);
	            return {
	                type: Syntax.TypeApplication,
	                expression: expr,
	                applications: applications
	            };
	        }
	        return expr;
	    }
	
	    // ResultType :=
	    //     <<empty>>
	    //   | ':' void
	    //   | ':' TypeExpression
	    //
	    // BNF is above
	    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON
	    function parseResultType() {
	        consume(Token.COLON, 'ResultType should start with :');
	        if (token === Token.NAME && value === 'void') {
	            consume(Token.NAME);
	            return {
	                type: Syntax.VoidLiteral
	            };
	        }
	        return parseTypeExpression();
	    }
	
	    // ParametersType :=
	    //     RestParameterType
	    //   | NonRestParametersType
	    //   | NonRestParametersType ',' RestParameterType
	    //
	    // RestParameterType :=
	    //     '...'
	    //     '...' Identifier
	    //
	    // NonRestParametersType :=
	    //     ParameterType ',' NonRestParametersType
	    //   | ParameterType
	    //   | OptionalParametersType
	    //
	    // OptionalParametersType :=
	    //     OptionalParameterType
	    //   | OptionalParameterType, OptionalParametersType
	    //
	    // OptionalParameterType := ParameterType=
	    //
	    // ParameterType := TypeExpression | Identifier ':' TypeExpression
	    //
	    // Identifier is "new" or "this"
	    function parseParametersType() {
	        var params = [], optionalSequence = false, expr, rest = false;
	
	        while (token !== Token.RPAREN) {
	            if (token === Token.REST) {
	                // RestParameterType
	                consume(Token.REST);
	                rest = true;
	            }
	
	            expr = parseTypeExpression();
	            if (expr.type === Syntax.NameExpression && token === Token.COLON) {
	                // Identifier ':' TypeExpression
	                consume(Token.COLON);
	                expr = {
	                    type: Syntax.ParameterType,
	                    name: expr.name,
	                    expression: parseTypeExpression()
	                };
	            }
	            if (token === Token.EQUAL) {
	                consume(Token.EQUAL);
	                expr = {
	                    type: Syntax.OptionalType,
	                    expression: expr
	                };
	                optionalSequence = true;
	            } else {
	                if (optionalSequence) {
	                    utility.throwError('unexpected token');
	                }
	            }
	            if (rest) {
	                expr = {
	                    type: Syntax.RestType,
	                    expression: expr
	                };
	            }
	            params.push(expr);
	            if (token !== Token.RPAREN) {
	                expect(Token.COMMA);
	            }
	        }
	        return params;
	    }
	
	    // FunctionType := 'function' FunctionSignatureType
	    //
	    // FunctionSignatureType :=
	    //   | TypeParameters '(' ')' ResultType
	    //   | TypeParameters '(' ParametersType ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType
	    function parseFunctionType() {
	        var isNew, thisBinding, params, result, fnType;
	        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
	        consume(Token.NAME);
	
	        // Google Closure Compiler is not implementing TypeParameters.
	        // So we do not. if we don't get '(', we see it as error.
	        expect(Token.LPAREN);
	
	        isNew = false;
	        params = [];
	        thisBinding = null;
	        if (token !== Token.RPAREN) {
	            // ParametersType or 'this'
	            if (token === Token.NAME &&
	                    (value === 'this' || value === 'new')) {
	                // 'this' or 'new'
	                // 'new' is Closure Compiler extension
	                isNew = value === 'new';
	                consume(Token.NAME);
	                expect(Token.COLON);
	                thisBinding = parseTypeName();
	                if (token === Token.COMMA) {
	                    consume(Token.COMMA);
	                    params = parseParametersType();
	                }
	            } else {
	                params = parseParametersType();
	            }
	        }
	
	        expect(Token.RPAREN);
	
	        result = null;
	        if (token === Token.COLON) {
	            result = parseResultType();
	        }
	
	        fnType = {
	            type: Syntax.FunctionType,
	            params: params,
	            result: result
	        };
	        if (thisBinding) {
	            // avoid adding null 'new' and 'this' properties
	            fnType['this'] = thisBinding;
	            if (isNew) {
	                fnType['new'] = true;
	            }
	        }
	        return fnType;
	    }
	
	    // BasicTypeExpression :=
	    //     '*'
	    //   | 'null'
	    //   | 'undefined'
	    //   | TypeName
	    //   | FunctionType
	    //   | UnionType
	    //   | RecordType
	    //   | ArrayType
	    function parseBasicTypeExpression() {
	        var context;
	        switch (token) {
	        case Token.STAR:
	            consume(Token.STAR);
	            return {
	                type: Syntax.AllLiteral
	            };
	
	        case Token.LPAREN:
	            return parseUnionType();
	
	        case Token.LBRACK:
	            return parseArrayType();
	
	        case Token.LBRACE:
	            return parseRecordType();
	
	        case Token.NAME:
	            if (value === 'null') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.NullLiteral
	                };
	            }
	
	            if (value === 'undefined') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.UndefinedLiteral
	                };
	            }
	
	            if (value === 'true' || value === 'false') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.BooleanLiteralType,
	                    value: value === 'true'
	                };
	            }
	
	            context = Context.save();
	            if (value === 'function') {
	                try {
	                    return parseFunctionType();
	                } catch (e) {
	                    context.restore();
	                }
	            }
	
	            return parseTypeName();
	
	        case Token.STRING:
	            next();
	            return {
	                type: Syntax.StringLiteralType,
	                value: value
	            };
	
	        case Token.NUMBER:
	            next();
	            return {
	                type: Syntax.NumericLiteralType,
	                value: value
	            };
	
	        default:
	            utility.throwError('unexpected token');
	        }
	    }
	
	    // TypeExpression :=
	    //     BasicTypeExpression
	    //   | '?' BasicTypeExpression
	    //   | '!' BasicTypeExpression
	    //   | BasicTypeExpression '?'
	    //   | BasicTypeExpression '!'
	    //   | '?'
	    //   | BasicTypeExpression '[]'
	    function parseTypeExpression() {
	        var expr;
	
	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
	                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
	                    token === Token.RBRACK || token === Token.GT) {
	                return {
	                    type: Syntax.NullableLiteral
	                };
	            }
	            return {
	                type: Syntax.NullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }
	
	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }
	
	        expr = parseBasicTypeExpression();
	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: expr,
	                prefix: false
	            };
	        }
	
	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            return {
	                type: Syntax.NullableType,
	                expression: expr,
	                prefix: false
	            };
	        }
	
	        if (token === Token.LBRACK) {
	            consume(Token.LBRACK);
	            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
	            return {
	                type: Syntax.TypeApplication,
	                expression: {
	                    type: Syntax.NameExpression,
	                    name: 'Array'
	                },
	                applications: [expr]
	            };
	        }
	
	        return expr;
	    }
	
	    // TopLevelTypeExpression :=
	    //      TypeExpression
	    //    | TypeUnionList
	    //
	    // This rule is Google Closure Compiler extension, not ES4
	    // like,
	    //   { number | string }
	    // If strict to ES4, we should write it as
	    //   { (number|string) }
	    function parseTop() {
	        var expr, elements;
	
	        expr = parseTypeExpression();
	        if (token !== Token.PIPE) {
	            return expr;
	        }
	
	        elements = [expr];
	        consume(Token.PIPE);
	        while (true) {
	            elements.push(parseTypeExpression());
	            if (token !== Token.PIPE) {
	                break;
	            }
	            consume(Token.PIPE);
	        }
	
	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }
	
	    function parseTopParamType() {
	        var expr;
	
	        if (token === Token.REST) {
	            consume(Token.REST);
	            return {
	                type: Syntax.RestType,
	                expression: parseTop()
	            };
	        }
	
	        expr = parseTop();
	        if (token === Token.EQUAL) {
	            consume(Token.EQUAL);
	            return {
	                type: Syntax.OptionalType,
	                expression: expr
	            };
	        }
	
	        return expr;
	    }
	
	    function parseType(src, opt) {
	        var expr;
	
	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;
	
	        next();
	        expr = parseTop();
	
	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }
	
	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }
	
	        return expr;
	    }
	
	    function parseParamType(src, opt) {
	        var expr;
	
	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;
	
	        next();
	        expr = parseTopParamType();
	
	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }
	
	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }
	
	        return expr;
	    }
	
	    function stringifyImpl(node, compact, topLevel) {
	        var result, i, iz;
	
	        switch (node.type) {
	        case Syntax.NullableLiteral:
	            result = '?';
	            break;
	
	        case Syntax.AllLiteral:
	            result = '*';
	            break;
	
	        case Syntax.NullLiteral:
	            result = 'null';
	            break;
	
	        case Syntax.UndefinedLiteral:
	            result = 'undefined';
	            break;
	
	        case Syntax.VoidLiteral:
	            result = 'void';
	            break;
	
	        case Syntax.UnionType:
	            if (!topLevel) {
	                result = '(';
	            } else {
	                result = '';
	            }
	
	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += '|';
	                }
	            }
	
	            if (!topLevel) {
	                result += ')';
	            }
	            break;
	
	        case Syntax.ArrayType:
	            result = '[';
	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += ']';
	            break;
	
	        case Syntax.RecordType:
	            result = '{';
	            for (i = 0, iz = node.fields.length; i < iz; ++i) {
	                result += stringifyImpl(node.fields[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '}';
	            break;
	
	        case Syntax.FieldType:
	            if (node.value) {
	                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
	            } else {
	                result = node.key;
	            }
	            break;
	
	        case Syntax.FunctionType:
	            result = compact ? 'function(' : 'function (';
	
	            if (node['this']) {
	                if (node['new']) {
	                    result += (compact ? 'new:' : 'new: ');
	                } else {
	                    result += (compact ? 'this:' : 'this: ');
	                }
	
	                result += stringifyImpl(node['this'], compact);
	
	                if (node.params.length !== 0) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	
	            for (i = 0, iz = node.params.length; i < iz; ++i) {
	                result += stringifyImpl(node.params[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	
	            result += ')';
	
	            if (node.result) {
	                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
	            }
	            break;
	
	        case Syntax.ParameterType:
	            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
	            break;
	
	        case Syntax.RestType:
	            result = '...';
	            if (node.expression) {
	                result += stringifyImpl(node.expression, compact);
	            }
	            break;
	
	        case Syntax.NonNullableType:
	            if (node.prefix) {
	                result = '!' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '!';
	            }
	            break;
	
	        case Syntax.OptionalType:
	            result = stringifyImpl(node.expression, compact) + '=';
	            break;
	
	        case Syntax.NullableType:
	            if (node.prefix) {
	                result = '?' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '?';
	            }
	            break;
	
	        case Syntax.NameExpression:
	            result = node.name;
	            break;
	
	        case Syntax.TypeApplication:
	            result = stringifyImpl(node.expression, compact) + '.<';
	            for (i = 0, iz = node.applications.length; i < iz; ++i) {
	                result += stringifyImpl(node.applications[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '>';
	            break;
	
	        case Syntax.StringLiteralType:
	            result = '"' + node.value + '"';
	            break;
	
	        case Syntax.NumericLiteralType:
	            result = String(node.value);
	            break;
	
	        case Syntax.BooleanLiteralType:
	            result = String(node.value);
	            break;
	
	        default:
	            utility.throwError('Unknown type ' + node.type);
	        }
	
	        return result;
	    }
	
	    function stringify(node, options) {
	        if (options == null) {
	            options = {};
	        }
	        return stringifyImpl(node, options.compact, options.topLevel);
	    }
	
	    exports.parseType = parseType;
	    exports.parseParamType = parseParamType;
	    exports.stringify = stringify;
	    exports.Syntax = Syntax;
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Utilities for Doctrine
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 */
	
	
	(function () {
	    'use strict';
	
	    var VERSION;
	
	    VERSION = __webpack_require__(368).version;
	    exports.VERSION = VERSION;
	
	    function DoctrineError(message) {
	        this.name = 'DoctrineError';
	        this.message = message;
	    }
	    DoctrineError.prototype = (function () {
	        var Middle = function () { };
	        Middle.prototype = Error.prototype;
	        return new Middle();
	    }());
	    DoctrineError.prototype.constructor = DoctrineError;
	    exports.DoctrineError = DoctrineError;
	
	    function throwError(message) {
	        throw new DoctrineError(message);
	    }
	    exports.throwError = throwError;
	
	    exports.assert = __webpack_require__(3);
	}());
	
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 368 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "doctrine@^1.2.2",
					"scope": null,
					"escapedName": "doctrine",
					"name": "doctrine",
					"rawSpec": "^1.2.2",
					"spec": ">=1.2.2 <2.0.0",
					"type": "range"
				},
				"/home/joe/prog/googlejs-site/node_modules/eslint"
			]
		],
		"_from": "doctrine@>=1.2.2 <2.0.0",
		"_id": "doctrine@1.5.0",
		"_inCache": true,
		"_location": "/eslint/doctrine",
		"_nodeVersion": "4.4.7",
		"_npmOperationalInternal": {
			"host": "packages-16-east.internal.npmjs.com",
			"tmp": "tmp/doctrine-1.5.0.tgz_1476393949423_0.8078370734583586"
		},
		"_npmUser": {
			"name": "eslint",
			"email": "nicholas+eslint@nczconsulting.com"
		},
		"_npmVersion": "2.15.8",
		"_phantomChildren": {},
		"_requested": {
			"raw": "doctrine@^1.2.2",
			"scope": null,
			"escapedName": "doctrine",
			"name": "doctrine",
			"rawSpec": "^1.2.2",
			"spec": ">=1.2.2 <2.0.0",
			"type": "range"
		},
		"_requiredBy": [
			"/eslint"
		],
		"_resolved": "https://registry.npmjs.org/doctrine/-/doctrine-1.5.0.tgz",
		"_shasum": "379dce730f6166f76cefa4e6707a159b02c5a6fa",
		"_shrinkwrap": null,
		"_spec": "doctrine@^1.2.2",
		"_where": "/home/joe/prog/googlejs-site/node_modules/eslint",
		"bugs": {
			"url": "https://github.com/eslint/doctrine/issues"
		},
		"dependencies": {
			"esutils": "^2.0.2",
			"isarray": "^1.0.0"
		},
		"description": "JSDoc parser",
		"devDependencies": {
			"coveralls": "^2.11.2",
			"dateformat": "^1.0.11",
			"eslint": "^1.10.3",
			"eslint-release": "^0.10.0",
			"istanbul": "^0.4.1",
			"linefix": "^0.1.1",
			"mocha": "^2.3.3",
			"npm-license": "^0.3.1",
			"semver": "^5.0.3",
			"shelljs": "^0.5.3",
			"shelljs-nodecli": "^0.1.1",
			"should": "^5.0.1"
		},
		"directories": {
			"lib": "./lib"
		},
		"dist": {
			"shasum": "379dce730f6166f76cefa4e6707a159b02c5a6fa",
			"tarball": "https://registry.npmjs.org/doctrine/-/doctrine-1.5.0.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"files": [
			"lib",
			"LICENSE.BSD",
			"LICENSE.closure-compiler",
			"LICENSE.esprima",
			"README.md"
		],
		"gitHead": "dcd631feb5dd5bcd0899dd35548da2752ea2263e",
		"homepage": "https://github.com/eslint/doctrine",
		"licenses": [
			{
				"type": "BSD",
				"url": "http://github.com/eslint/doctrine/raw/master/LICENSE.BSD"
			}
		],
		"main": "lib/doctrine.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "eslint",
				"email": "nicholas+eslint@nczconsulting.com"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "doctrine",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/eslint/doctrine.git"
		},
		"scripts": {
			"alpharelease": "eslint-prerelease alpha",
			"betarelease": "eslint-prerelease beta",
			"ci-release": "eslint-ci-release",
			"lint": "eslint lib/",
			"release": "eslint-release",
			"test": "npm run lint && node Makefile.js test"
		},
		"version": "1.5.0"
	};

/***/ },
/* 369 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Ensures that the results of typeof are compared against a valid string
	 * @author Ian Christian Myers
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "enforce comparing `typeof` expressions against valid strings",
	            category: "Possible Errors",
	            recommended: true
	        },
	
	        schema: [
	            {
	                type: "object",
	                properties: {
	                    requireStringLiterals: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ]
	    },
	
	    create(context) {
	
	        const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function"],
	            OPERATORS = ["==", "===", "!=", "!=="];
	
	        const requireStringLiterals = context.options[0] && context.options[0].requireStringLiterals;
	
	        /**
	        * Determines whether a node is a typeof expression.
	        * @param {ASTNode} node The node
	        * @returns {boolean} `true` if the node is a typeof expression
	        */
	        function isTypeofExpression(node) {
	            return node.type === "UnaryExpression" && node.operator === "typeof";
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	
	            UnaryExpression(node) {
	                if (isTypeofExpression(node)) {
	                    const parent = context.getAncestors().pop();
	
	                    if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
	                        const sibling = parent.left === node ? parent.right : parent.left;
	
	                        if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
	                            const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
	
	                            if (VALID_TYPES.indexOf(value) === -1) {
	                                context.report(sibling, "Invalid typeof comparison value.");
	                            }
	                        } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
	                            context.report(sibling, "Typeof comparisons should be to string literals.");
	                        }
	                    }
	                }
	            }
	
	        };
	
	    }
	};


/***/ },
/* 370 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to enforce var declarations are only at the top of a function.
	 * @author Danny Fritz
	 * @author Gyandeep Singh
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require `var` declarations be placed at the top of their containing scope",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: []
	    },
	
	    create(context) {
	        const errorMessage = "All 'var' declarations must be at the top of the function scope.";
	
	        //--------------------------------------------------------------------------
	        // Helpers
	        //--------------------------------------------------------------------------
	
	        /**
	         * @param {ASTNode} node - any node
	         * @returns {boolean} whether the given node structurally represents a directive
	         */
	        function looksLikeDirective(node) {
	            return node.type === "ExpressionStatement" &&
	                node.expression.type === "Literal" && typeof node.expression.value === "string";
	        }
	
	        /**
	         * Check to see if its a ES6 import declaration
	         * @param {ASTNode} node - any node
	         * @returns {boolean} whether the given node represents a import declaration
	         */
	        function looksLikeImport(node) {
	            return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" ||
	                node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
	        }
	
	        /**
	         * Checks whether a given node is a variable declaration or not.
	         *
	         * @param {ASTNode} node - any node
	         * @returns {boolean} `true` if the node is a variable declaration.
	         */
	        function isVariableDeclaration(node) {
	            return (
	                node.type === "VariableDeclaration" ||
	                (
	                    node.type === "ExportNamedDeclaration" &&
	                    node.declaration &&
	                    node.declaration.type === "VariableDeclaration"
	                )
	            );
	        }
	
	        /**
	         * Checks whether this variable is on top of the block body
	         * @param {ASTNode} node - The node to check
	         * @param {ASTNode[]} statements - collection of ASTNodes for the parent node block
	         * @returns {boolean} True if var is on top otherwise false
	         */
	        function isVarOnTop(node, statements) {
	            const l = statements.length;
	            let i = 0;
	
	            // skip over directives
	            for (; i < l; ++i) {
	                if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
	                    break;
	                }
	            }
	
	            for (; i < l; ++i) {
	                if (!isVariableDeclaration(statements[i])) {
	                    return false;
	                }
	                if (statements[i] === node) {
	                    return true;
	                }
	            }
	
	            return false;
	        }
	
	        /**
	         * Checks whether variable is on top at the global level
	         * @param {ASTNode} node - The node to check
	         * @param {ASTNode} parent - Parent of the node
	         * @returns {void}
	         */
	        function globalVarCheck(node, parent) {
	            if (!isVarOnTop(node, parent.body)) {
	                context.report(node, errorMessage);
	            }
	        }
	
	        /**
	         * Checks whether variable is on top at functional block scope level
	         * @param {ASTNode} node - The node to check
	         * @param {ASTNode} parent - Parent of the node
	         * @param {ASTNode} grandParent - Parent of the node's parent
	         * @returns {void}
	         */
	        function blockScopeVarCheck(node, parent, grandParent) {
	            if (!(/Function/.test(grandParent.type) &&
	                    parent.type === "BlockStatement" &&
	                    isVarOnTop(node, parent.body))) {
	                context.report(node, errorMessage);
	            }
	        }
	
	        //--------------------------------------------------------------------------
	        // Public API
	        //--------------------------------------------------------------------------
	
	        return {
	            VariableDeclaration(node) {
	                const ancestors = context.getAncestors();
	                let parent = ancestors.pop();
	                let grandParent = ancestors.pop();
	
	                if (node.kind === "var") { // check variable is `var` type and not `let` or `const`
	                    if (parent.type === "ExportNamedDeclaration") {
	                        node = parent;
	                        parent = grandParent;
	                        grandParent = ancestors.pop();
	                    }
	
	                    if (parent.type === "Program") { // That means its a global variable
	                        globalVarCheck(node, parent);
	                    } else {
	                        blockScopeVarCheck(node, parent, grandParent);
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Rule to flag when IIFE is not wrapped in parens
	 * @author Ilya Volodin
	 */
	
	"use strict";
	
	const astUtils = __webpack_require__(109);
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require parentheses around immediate `function` invocations",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["outside", "inside", "any"]
	            },
	            {
	                type: "object",
	                properties: {
	                    functionPrototypeMethods: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        const style = context.options[0] || "outside";
	        const includeFunctionPrototypeMethods = (context.options[1] && context.options[1].functionPrototypeMethods) || false;
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Check if the node is wrapped in ()
	         * @param {ASTNode} node node to evaluate
	         * @returns {boolean} True if it is wrapped
	         * @private
	         */
	        function wrapped(node) {
	            const previousToken = sourceCode.getTokenBefore(node),
	                nextToken = sourceCode.getTokenAfter(node);
	
	            return previousToken && previousToken.value === "(" &&
	                nextToken && nextToken.value === ")";
	        }
	
	        /**
	        * Get the function node from an IIFE
	        * @param {ASTNode} node node to evaluate
	        * @returns {ASTNode} node that is the function expression of the given IIFE, or null if none exist
	        */
	        function getFunctionNodeFromIIFE(node) {
	            const callee = node.callee;
	
	            if (callee.type === "FunctionExpression") {
	                return callee;
	            }
	
	            if (includeFunctionPrototypeMethods &&
	                callee.type === "MemberExpression" &&
	                callee.object.type === "FunctionExpression" &&
	                (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")
	            ) {
	                return callee.object;
	            }
	
	            return null;
	        }
	
	
	        return {
	            CallExpression(node) {
	                const innerNode = getFunctionNodeFromIIFE(node);
	
	                if (!innerNode) {
	                    return;
	                }
	
	                const callExpressionWrapped = wrapped(node),
	                    functionExpressionWrapped = wrapped(innerNode);
	
	                if (!callExpressionWrapped && !functionExpressionWrapped) {
	                    context.report({
	                        node,
	                        message: "Wrap an immediate function invocation in parentheses.",
	                        fix(fixer) {
	                            const nodeToSurround = style === "inside" ? innerNode : node;
	
	                            return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
	                        }
	                    });
	                } else if (style === "inside" && !functionExpressionWrapped) {
	                    context.report({
	                        node,
	                        message: "Wrap only the function expression in parens.",
	                        fix(fixer) {
	
	                            /*
	                             * The outer call expression will always be wrapped at this point.
	                             * Replace the range between the end of the function expression and the end of the call expression.
	                             * for example, in `(function(foo) {}(bar))`, the range `(bar))` should get replaced with `)(bar)`.
	                             * Replace the parens from the outer expression, and parenthesize the function expression.
	                             */
	                            const parenAfter = sourceCode.getTokenAfter(node);
	
	                            return fixer.replaceTextRange(
	                                [innerNode.range[1], parenAfter.range[1]],
	                                `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`
	                            );
	                        }
	                    });
	                } else if (style === "outside" && !callExpressionWrapped) {
	                    context.report({
	                        node,
	                        message: "Move the invocation into the parens that contain the function.",
	                        fix(fixer) {
	
	                            /*
	                             * The inner function expression will always be wrapped at this point.
	                             * It's only necessary to replace the range between the end of the function expression
	                             * and the call expression. For example, in `(function(foo) {})(bar)`, the range `)(bar)`
	                             * should get replaced with `(bar))`.
	                             */
	                            const parenAfter = sourceCode.getTokenAfter(innerNode);
	
	                            return fixer.replaceTextRange(
	                                [parenAfter.range[0], node.range[1]],
	                                `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`
	                            );
	                        }
	                    });
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 372 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to flag when regex literals are not wrapped in parens
	 * @author Matt DuVall <http://www.mattduvall.com>
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require parenthesis around regex literals",
	            category: "Stylistic Issues",
	            recommended: false
	        },
	
	        schema: [],
	
	        fixable: "code"
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        return {
	
	            Literal(node) {
	                const token = sourceCode.getFirstToken(node),
	                    nodeType = token.type;
	
	                if (nodeType === "RegularExpression") {
	                    const source = sourceCode.getTokenBefore(node);
	                    const ancestors = context.getAncestors();
	                    const grandparent = ancestors[ancestors.length - 1];
	
	                    if (grandparent.type === "MemberExpression" && grandparent.object === node &&
	                        (!source || source.value !== "(")) {
	                        context.report({
	                            node,
	                            message: "Wrap the regexp literal in parens to disambiguate the slash.",
	                            fix: fixer => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
	                        });
	                    }
	                }
	            }
	        };
	
	    }
	};


/***/ },
/* 373 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to check the spacing around the * in yield* expressions.
	 * @author Bryan Smith
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow spacing around the `*` in `yield*` expressions",
	            category: "ECMAScript 6",
	            recommended: false
	        },
	
	        fixable: "whitespace",
	
	        schema: [
	            {
	                oneOf: [
	                    {
	                        enum: ["before", "after", "both", "neither"]
	                    },
	                    {
	                        type: "object",
	                        properties: {
	                            before: {type: "boolean"},
	                            after: {type: "boolean"}
	                        },
	                        additionalProperties: false
	                    }
	                ]
	            }
	        ]
	    },
	
	    create(context) {
	        const sourceCode = context.getSourceCode();
	
	        const mode = (function(option) {
	            if (!option || typeof option === "string") {
	                return {
	                    before: { before: true, after: false },
	                    after: { before: false, after: true },
	                    both: { before: true, after: true },
	                    neither: { before: false, after: false }
	                }[option || "after"];
	            }
	            return option;
	        }(context.options[0]));
	
	        /**
	         * Checks the spacing between two tokens before or after the star token.
	         * @param {string} side Either "before" or "after".
	         * @param {Token} leftToken `function` keyword token if side is "before", or
	         *     star token if side is "after".
	         * @param {Token} rightToken Star token if side is "before", or identifier
	         *     token if side is "after".
	         * @returns {void}
	         */
	        function checkSpacing(side, leftToken, rightToken) {
	            if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
	                const after = leftToken.value === "*";
	                const spaceRequired = mode[side];
	                const node = after ? leftToken : rightToken;
	                const type = spaceRequired ? "Missing" : "Unexpected";
	                const message = "{{type}} space {{side}} *.";
	
	                context.report({
	                    node,
	                    message,
	                    data: {
	                        type,
	                        side
	                    },
	                    fix(fixer) {
	                        if (spaceRequired) {
	                            if (after) {
	                                return fixer.insertTextAfter(node, " ");
	                            }
	                            return fixer.insertTextBefore(node, " ");
	                        }
	                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
	                    }
	                });
	            }
	        }
	
	        /**
	         * Enforces the spacing around the star if node is a yield* expression.
	         * @param {ASTNode} node A yield expression node.
	         * @returns {void}
	         */
	        function checkExpression(node) {
	            if (!node.delegate) {
	                return;
	            }
	
	            const tokens = sourceCode.getFirstTokens(node, 3);
	            const yieldToken = tokens[0];
	            const starToken = tokens[1];
	            const nextToken = tokens[2];
	
	            checkSpacing("before", yieldToken, starToken);
	            checkSpacing("after", starToken, nextToken);
	        }
	
	        return {
	            YieldExpression: checkExpression
	        };
	
	    }
	};


/***/ },
/* 374 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Rule to require or disallow yoda comparisons
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//--------------------------------------------------------------------------
	// Helpers
	//--------------------------------------------------------------------------
	
	/**
	 * Determines whether an operator is a comparison operator.
	 * @param {string} operator The operator to check.
	 * @returns {boolean} Whether or not it is a comparison operator.
	 */
	function isComparisonOperator(operator) {
	    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);
	}
	
	/**
	 * Determines whether an operator is an equality operator.
	 * @param {string} operator The operator to check.
	 * @returns {boolean} Whether or not it is an equality operator.
	 */
	function isEqualityOperator(operator) {
	    return (/^(==|===)$/).test(operator);
	}
	
	/**
	 * Determines whether an operator is one used in a range test.
	 * Allowed operators are `<` and `<=`.
	 * @param {string} operator The operator to check.
	 * @returns {boolean} Whether the operator is used in range tests.
	 */
	function isRangeTestOperator(operator) {
	    return ["<", "<="].indexOf(operator) >= 0;
	}
	
	/**
	 * Determines whether a non-Literal node is a negative number that should be
	 * treated as if it were a single Literal node.
	 * @param {ASTNode} node Node to test.
	 * @returns {boolean} True if the node is a negative number that looks like a
	 *                    real literal and should be treated as such.
	 */
	function looksLikeLiteral(node) {
	    return (node.type === "UnaryExpression" &&
	        node.operator === "-" &&
	        node.prefix &&
	        node.argument.type === "Literal" &&
	        typeof node.argument.value === "number");
	}
	
	/**
	 * Attempts to derive a Literal node from nodes that are treated like literals.
	 * @param {ASTNode} node Node to normalize.
	 * @returns {ASTNode} The original node if the node is already a Literal, or a
	 *                    normalized Literal node with the negative number as the
	 *                    value if the node represents a negative number literal,
	 *                    otherwise null if the node cannot be converted to a
	 *                    normalized literal.
	 */
	function getNormalizedLiteral(node) {
	    if (node.type === "Literal") {
	        return node;
	    }
	
	    if (looksLikeLiteral(node)) {
	        return {
	            type: "Literal",
	            value: -node.argument.value,
	            raw: `-${node.argument.value}`
	        };
	    }
	
	    return null;
	}
	
	/**
	 * Checks whether two expressions reference the same value. For example:
	 *     a = a
	 *     a.b = a.b
	 *     a[0] = a[0]
	 *     a['b'] = a['b']
	 * @param   {ASTNode} a Left side of the comparison.
	 * @param   {ASTNode} b Right side of the comparison.
	 * @returns {boolean}   True if both sides match and reference the same value.
	 */
	function same(a, b) {
	    if (a.type !== b.type) {
	        return false;
	    }
	
	    switch (a.type) {
	        case "Identifier":
	            return a.name === b.name;
	
	        case "Literal":
	            return a.value === b.value;
	
	        case "MemberExpression":
	
	            // x[0] = x[0]
	            // x[y] = x[y]
	            // x.y = x.y
	            return same(a.object, b.object) && same(a.property, b.property);
	
	        case "ThisExpression":
	            return true;
	
	        default:
	            return false;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	module.exports = {
	    meta: {
	        docs: {
	            description: "require or disallow \"Yoda\" conditions",
	            category: "Best Practices",
	            recommended: false
	        },
	
	        schema: [
	            {
	                enum: ["always", "never"]
	            },
	            {
	                type: "object",
	                properties: {
	                    exceptRange: {
	                        type: "boolean"
	                    },
	                    onlyEquality: {
	                        type: "boolean"
	                    }
	                },
	                additionalProperties: false
	            }
	        ],
	
	        fixable: "code"
	    },
	
	    create(context) {
	
	        // Default to "never" (!always) if no option
	        const always = (context.options[0] === "always");
	        const exceptRange = (context.options[1] && context.options[1].exceptRange);
	        const onlyEquality = (context.options[1] && context.options[1].onlyEquality);
	
	        const sourceCode = context.getSourceCode();
	
	        /**
	         * Determines whether node represents a range test.
	         * A range test is a "between" test like `(0 <= x && x < 1)` or an "outside"
	         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and
	         * both operators must be `<` or `<=`. Finally, the literal on the left side
	         * must be less than or equal to the literal on the right side so that the
	         * test makes any sense.
	         * @param {ASTNode} node LogicalExpression node to test.
	         * @returns {boolean} Whether node is a range test.
	         */
	        function isRangeTest(node) {
	            const left = node.left,
	                right = node.right;
	
	            /**
	             * Determines whether node is of the form `0 <= x && x < 1`.
	             * @returns {boolean} Whether node is a "between" range test.
	             */
	            function isBetweenTest() {
	                let leftLiteral, rightLiteral;
	
	                return (node.operator === "&&" &&
	                    (leftLiteral = getNormalizedLiteral(left.left)) &&
	                    (rightLiteral = getNormalizedLiteral(right.right)) &&
	                    leftLiteral.value <= rightLiteral.value &&
	                    same(left.right, right.left));
	            }
	
	            /**
	             * Determines whether node is of the form `x < 0 || 1 <= x`.
	             * @returns {boolean} Whether node is an "outside" range test.
	             */
	            function isOutsideTest() {
	                let leftLiteral, rightLiteral;
	
	                return (node.operator === "||" &&
	                    (leftLiteral = getNormalizedLiteral(left.right)) &&
	                    (rightLiteral = getNormalizedLiteral(right.left)) &&
	                    leftLiteral.value <= rightLiteral.value &&
	                    same(left.left, right.right));
	            }
	
	            /**
	             * Determines whether node is wrapped in parentheses.
	             * @returns {boolean} Whether node is preceded immediately by an open
	             *                    paren token and followed immediately by a close
	             *                    paren token.
	             */
	            function isParenWrapped() {
	                let tokenBefore, tokenAfter;
	
	                return ((tokenBefore = sourceCode.getTokenBefore(node)) &&
	                    tokenBefore.value === "(" &&
	                    (tokenAfter = sourceCode.getTokenAfter(node)) &&
	                    tokenAfter.value === ")");
	            }
	
	            return (node.type === "LogicalExpression" &&
	                left.type === "BinaryExpression" &&
	                right.type === "BinaryExpression" &&
	                isRangeTestOperator(left.operator) &&
	                isRangeTestOperator(right.operator) &&
	                (isBetweenTest() || isOutsideTest()) &&
	                isParenWrapped());
	        }
	
	        const OPERATOR_FLIP_MAP = {
	            "===": "===",
	            "!==": "!==",
	            "==": "==",
	            "!=": "!=",
	            "<": ">",
	            ">": "<",
	            "<=": ">=",
	            ">=": "<="
	        };
	
	        /**
	        * Returns a string representation of a BinaryExpression node with its sides/operator flipped around.
	        * @param {ASTNode} node The BinaryExpression node
	        * @returns {string} A string representation of the node with the sides and operator flipped
	        */
	        function getFlippedString(node) {
	            const operatorToken = sourceCode.getTokensBetween(node.left, node.right).find(token => token.value === node.operator);
	            const textBeforeOperator = sourceCode.getText().slice(sourceCode.getTokenBefore(operatorToken).range[1], operatorToken.range[0]);
	            const textAfterOperator = sourceCode.getText().slice(operatorToken.range[1], sourceCode.getTokenAfter(operatorToken).range[0]);
	            const leftText = sourceCode.getText().slice(sourceCode.getFirstToken(node).range[0], sourceCode.getTokenBefore(operatorToken).range[1]);
	            const rightText = sourceCode.getText().slice(sourceCode.getTokenAfter(operatorToken).range[0], sourceCode.getLastToken(node).range[1]);
	
	            return rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText;
	        }
	
	        //--------------------------------------------------------------------------
	        // Public
	        //--------------------------------------------------------------------------
	
	        return {
	            BinaryExpression(node) {
	                const expectedLiteral = always ? node.left : node.right;
	                const expectedNonLiteral = always ? node.right : node.left;
	
	                // If `expectedLiteral` is not a literal, and `expectedNonLiteral` is a literal, raise an error.
	                if (
	                    (expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) &&
	                    !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) &&
	                    !(!isEqualityOperator(node.operator) && onlyEquality) &&
	                    isComparisonOperator(node.operator) &&
	                    !(exceptRange && isRangeTest(context.getAncestors().pop()))
	                ) {
	                    context.report({
	                        node,
	                        message: "Expected literal to be on the {{expectedSide}} side of {{operator}}.",
	                        data: {
	                            operator: node.operator,
	                            expectedSide: always ? "left" : "right"
	                        },
	                        fix: fixer => fixer.replaceText(node, getFlippedString(node))
	                    });
	                }
	
	            }
	        };
	
	    }
	};


/***/ },
/* 375 */
/***/ function(module, exports) {

	function webpackContext(req) {
		throw new Error("Cannot find module '" + req + "'.");
	}
	webpackContext.keys = function() { return []; };
	webpackContext.resolve = webpackContext;
	module.exports = webpackContext;
	webpackContext.id = 375;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	var genobj = __webpack_require__(377)
	var genfun = __webpack_require__(379)
	var jsonpointer = __webpack_require__(380)
	var xtend = __webpack_require__(381)
	var formats = __webpack_require__(382)
	
	var get = function(obj, additionalSchemas, ptr) {
	
	  var visit = function(sub) {
	    if (sub && sub.id === ptr) return sub
	    if (typeof sub !== 'object' || !sub) return null
	    return Object.keys(sub).reduce(function(res, k) {
	      return res || visit(sub[k])
	    }, null)
	  }
	
	  var res = visit(obj)
	  if (res) return res
	
	  ptr = ptr.replace(/^#/, '')
	  ptr = ptr.replace(/\/$/, '')
	
	  try {
	    return jsonpointer.get(obj, decodeURI(ptr))
	  } catch (err) {
	    var end = ptr.indexOf('#')
	    var other
	    // external reference
	    if (end !== 0) {
	      // fragment doesn't exist.
	      if (end === -1) {
	        other = additionalSchemas[ptr]
	      } else {
	        var ext = ptr.slice(0, end)
	        other = additionalSchemas[ext]
	        var fragment = ptr.slice(end).replace(/^#/, '')
	        try {
	          return jsonpointer.get(other, fragment)
	        } catch (err) {}
	      }
	    } else {
	      other = additionalSchemas[ptr]
	    }
	    return other || null
	  }
	}
	
	var formatName = function(field) {
	  field = JSON.stringify(field)
	  var pattern = /\[([^\[\]"]+)\]/
	  while (pattern.test(field)) field = field.replace(pattern, '."+$1+"')
	  return field
	}
	
	var types = {}
	
	types.any = function() {
	  return 'true'
	}
	
	types.null = function(name) {
	  return name+' === null'
	}
	
	types.boolean = function(name) {
	  return 'typeof '+name+' === "boolean"'
	}
	
	types.array = function(name) {
	  return 'Array.isArray('+name+')'
	}
	
	types.object = function(name) {
	  return 'typeof '+name+' === "object" && '+name+' && !Array.isArray('+name+')'
	}
	
	types.number = function(name) {
	  return 'typeof '+name+' === "number"'
	}
	
	types.integer = function(name) {
	  return 'typeof '+name+' === "number" && (Math.floor('+name+') === '+name+' || '+name+' > 9007199254740992 || '+name+' < -9007199254740992)'
	}
	
	types.string = function(name) {
	  return 'typeof '+name+' === "string"'
	}
	
	var unique = function(array) {
	  var list = []
	  for (var i = 0; i < array.length; i++) {
	    list.push(typeof array[i] === 'object' ? JSON.stringify(array[i]) : array[i])
	  }
	  for (var i = 1; i < list.length; i++) {
	    if (list.indexOf(list[i]) !== i) return false
	  }
	  return true
	}
	
	var isMultipleOf = function(name, multipleOf) {
	  var res;
	  var factor = ((multipleOf | 0) !== multipleOf) ? Math.pow(10, multipleOf.toString().split('.').pop().length) : 1
	  if (factor > 1) {
	    var factorName = ((name | 0) !== name) ? Math.pow(10, name.toString().split('.').pop().length) : 1
	    if (factorName > factor) res = true
	    else res = Math.round(factor * name) % (factor * multipleOf)
	  }
	  else res = name % multipleOf;
	  return !res;
	}
	
	var toType = function(node) {
	  return node.type
	}
	
	var compile = function(schema, cache, root, reporter, opts) {
	  var fmts = opts ? xtend(formats, opts.formats) : formats
	  var scope = {unique:unique, formats:fmts, isMultipleOf:isMultipleOf}
	  var verbose = opts ? !!opts.verbose : false;
	  var greedy = opts && opts.greedy !== undefined ?
	    opts.greedy : false;
	
	  var syms = {}
	  var gensym = function(name) {
	    return name+(syms[name] = (syms[name] || 0)+1)
	  }
	
	  var reversePatterns = {}
	  var patterns = function(p) {
	    if (reversePatterns[p]) return reversePatterns[p]
	    var n = gensym('pattern')
	    scope[n] = new RegExp(p)
	    reversePatterns[p] = n
	    return n
	  }
	
	  var vars = ['i','j','k','l','m','n','o','p','q','r','s','t','u','v','x','y','z']
	  var genloop = function() {
	    var v = vars.shift()
	    vars.push(v+v[0])
	    return v
	  }
	
	  var visit = function(name, node, reporter, filter) {
	    var properties = node.properties
	    var type = node.type
	    var tuple = false
	
	    if (Array.isArray(node.items)) { // tuple type
	      properties = {}
	      node.items.forEach(function(item, i) {
	        properties[i] = item
	      })
	      type = 'array'
	      tuple = true
	    }
	
	    var indent = 0
	    var error = function(msg, prop, value) {
	      validate('errors++')
	      if (reporter === true) {
	        validate('if (validate.errors === null) validate.errors = []')
	        if (verbose) {
	          validate('validate.errors.push({field:%s,message:%s,value:%s,type:%s})', formatName(prop || name), JSON.stringify(msg), value || name, JSON.stringify(type))
	        } else {
	          validate('validate.errors.push({field:%s,message:%s})', formatName(prop || name), JSON.stringify(msg))
	        }
	      }
	    }
	
	    if (node.required === true) {
	      indent++
	      validate('if (%s === undefined) {', name)
	      error('is required')
	      validate('} else {')
	    } else {
	      indent++
	      validate('if (%s !== undefined) {', name)
	    }
	
	    var valid = [].concat(type)
	      .map(function(t) {
	        return types[t || 'any'](name)
	      })
	      .join(' || ') || 'true'
	
	    if (valid !== 'true') {
	      indent++
	      validate('if (!(%s)) {', valid)
	      error('is the wrong type')
	      validate('} else {')
	    }
	
	    if (tuple) {
	      if (node.additionalItems === false) {
	        validate('if (%s.length > %d) {', name, node.items.length)
	        error('has additional items')
	        validate('}')
	      } else if (node.additionalItems) {
	        var i = genloop()
	        validate('for (var %s = %d; %s < %s.length; %s++) {', i, node.items.length, i, name, i)
	        visit(name+'['+i+']', node.additionalItems, reporter, filter)
	        validate('}')
	      }
	    }
	
	    if (node.format && fmts[node.format]) {
	      if (type !== 'string' && formats[node.format]) validate('if (%s) {', types.string(name))
	      var n = gensym('format')
	      scope[n] = fmts[node.format]
	
	      if (typeof scope[n] === 'function') validate('if (!%s(%s)) {', n, name)
	      else validate('if (!%s.test(%s)) {', n, name)
	      error('must be '+node.format+' format')
	      validate('}')
	      if (type !== 'string' && formats[node.format]) validate('}')
	    }
	
	    if (Array.isArray(node.required)) {
	      var isUndefined = function(req) {
	        return genobj(name, req) + ' === undefined'
	      }
	
	      var checkRequired = function (req) {
	        var prop = genobj(name, req);
	        validate('if (%s === undefined) {', prop)
	        error('is required', prop)
	        validate('missing++')
	        validate('}')
	      }
	      validate('if ((%s)) {', type !== 'object' ? types.object(name) : 'true')
	      validate('var missing = 0')
	      node.required.map(checkRequired)
	      validate('}');
	      if (!greedy) {
	        validate('if (missing === 0) {')
	        indent++
	      }
	    }
	
	    if (node.uniqueItems) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	      validate('if (!(unique(%s))) {', name)
	      error('must be unique')
	      validate('}')
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.enum) {
	      var complex = node.enum.some(function(e) {
	        return typeof e === 'object'
	      })
	
	      var compare = complex ?
	        function(e) {
	          return 'JSON.stringify('+name+')'+' !== JSON.stringify('+JSON.stringify(e)+')'
	        } :
	        function(e) {
	          return name+' !== '+JSON.stringify(e)
	        }
	
	      validate('if (%s) {', node.enum.map(compare).join(' && ') || 'false')
	      error('must be an enum value')
	      validate('}')
	    }
	
	    if (node.dependencies) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      Object.keys(node.dependencies).forEach(function(key) {
	        var deps = node.dependencies[key]
	        if (typeof deps === 'string') deps = [deps]
	
	        var exists = function(k) {
	          return genobj(name, k) + ' !== undefined'
	        }
	
	        if (Array.isArray(deps)) {
	          validate('if (%s !== undefined && !(%s)) {', genobj(name, key), deps.map(exists).join(' && ') || 'true')
	          error('dependencies not set')
	          validate('}')
	        }
	        if (typeof deps === 'object') {
	          validate('if (%s !== undefined) {', genobj(name, key))
	          visit(name, deps, reporter, filter)
	          validate('}')
	        }
	      })
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.additionalProperties || node.additionalProperties === false) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      var i = genloop()
	      var keys = gensym('keys')
	
	      var toCompare = function(p) {
	        return keys+'['+i+'] !== '+JSON.stringify(p)
	      }
	
	      var toTest = function(p) {
	        return '!'+patterns(p)+'.test('+keys+'['+i+'])'
	      }
	
	      var additionalProp = Object.keys(properties || {}).map(toCompare)
	        .concat(Object.keys(node.patternProperties || {}).map(toTest))
	        .join(' && ') || 'true'
	
	      validate('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
	          ('if (%s) {', additionalProp)
	
	      if (node.additionalProperties === false) {
	        if (filter) validate('delete %s', name+'['+keys+'['+i+']]')
	        error('has additional properties', null, JSON.stringify(name+'.') + ' + ' + keys + '['+i+']')
	      } else {
	        visit(name+'['+keys+'['+i+']]', node.additionalProperties, reporter, filter)
	      }
	
	      validate
	          ('}')
	        ('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.$ref) {
	      var sub = get(root, opts && opts.schemas || {}, node.$ref)
	      if (sub) {
	        var fn = cache[node.$ref]
	        if (!fn) {
	          cache[node.$ref] = function proxy(data) {
	            return fn(data)
	          }
	          fn = compile(sub, cache, root, false, opts)
	        }
	        var n = gensym('ref')
	        scope[n] = fn
	        validate('if (!(%s(%s))) {', n, name)
	        error('referenced schema does not match')
	        validate('}')
	      }
	    }
	
	    if (node.not) {
	      var prev = gensym('prev')
	      validate('var %s = errors', prev)
	      visit(name, node.not, false, filter)
	      validate('if (%s === errors) {', prev)
	      error('negative schema matches')
	      validate('} else {')
	        ('errors = %s', prev)
	      ('}')
	    }
	
	    if (node.items && !tuple) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      var i = genloop()
	      validate('for (var %s = 0; %s < %s.length; %s++) {', i, i, name, i)
	      visit(name+'['+i+']', node.items, reporter, filter)
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.patternProperties) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	      var keys = gensym('keys')
	      var i = genloop()
	      validate
	        ('var %s = Object.keys(%s)', keys, name)
	        ('for (var %s = 0; %s < %s.length; %s++) {', i, i, keys, i)
	
	      Object.keys(node.patternProperties).forEach(function(key) {
	        var p = patterns(key)
	        validate('if (%s.test(%s)) {', p, keys+'['+i+']')
	        visit(name+'['+keys+'['+i+']]', node.patternProperties[key], reporter, filter)
	        validate('}')
	      })
	
	      validate('}')
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.pattern) {
	      var p = patterns(node.pattern)
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	      validate('if (!(%s.test(%s))) {', p, name)
	      error('pattern mismatch')
	      validate('}')
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.allOf) {
	      node.allOf.forEach(function(sch) {
	        visit(name, sch, reporter, filter)
	      })
	    }
	
	    if (node.anyOf && node.anyOf.length) {
	      var prev = gensym('prev')
	
	      node.anyOf.forEach(function(sch, i) {
	        if (i === 0) {
	          validate('var %s = errors', prev)
	        } else {
	          validate('if (errors !== %s) {', prev)
	            ('errors = %s', prev)
	        }
	        visit(name, sch, false, false)
	      })
	      node.anyOf.forEach(function(sch, i) {
	        if (i) validate('}')
	      })
	      validate('if (%s !== errors) {', prev)
	      error('no schemas match')
	      validate('}')
	    }
	
	    if (node.oneOf && node.oneOf.length) {
	      var prev = gensym('prev')
	      var passes = gensym('passes')
	
	      validate
	        ('var %s = errors', prev)
	        ('var %s = 0', passes)
	
	      node.oneOf.forEach(function(sch, i) {
	        visit(name, sch, false, false)
	        validate('if (%s === errors) {', prev)
	          ('%s++', passes)
	        ('} else {')
	          ('errors = %s', prev)
	        ('}')
	      })
	
	      validate('if (%s !== 1) {', passes)
	      error('no (or more than one) schemas match')
	      validate('}')
	    }
	
	    if (node.multipleOf !== undefined) {
	      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
	
	      validate('if (!isMultipleOf(%s, %d)) {', name, node.multipleOf)
	
	      error('has a remainder')
	      validate('}')
	
	      if (type !== 'number' && type !== 'integer') validate('}')
	    }
	
	    if (node.maxProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      validate('if (Object.keys(%s).length > %d) {', name, node.maxProperties)
	      error('has more properties than allowed')
	      validate('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.minProperties !== undefined) {
	      if (type !== 'object') validate('if (%s) {', types.object(name))
	
	      validate('if (Object.keys(%s).length < %d) {', name, node.minProperties)
	      error('has less properties than allowed')
	      validate('}')
	
	      if (type !== 'object') validate('}')
	    }
	
	    if (node.maxItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      validate('if (%s.length > %d) {', name, node.maxItems)
	      error('has more items than allowed')
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.minItems !== undefined) {
	      if (type !== 'array') validate('if (%s) {', types.array(name))
	
	      validate('if (%s.length < %d) {', name, node.minItems)
	      error('has less items than allowed')
	      validate('}')
	
	      if (type !== 'array') validate('}')
	    }
	
	    if (node.maxLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	
	      validate('if (%s.length > %d) {', name, node.maxLength)
	      error('has longer length than allowed')
	      validate('}')
	
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.minLength !== undefined) {
	      if (type !== 'string') validate('if (%s) {', types.string(name))
	
	      validate('if (%s.length < %d) {', name, node.minLength)
	      error('has less length than allowed')
	      validate('}')
	
	      if (type !== 'string') validate('}')
	    }
	
	    if (node.minimum !== undefined) {
	      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
	
	      validate('if (%s %s %d) {', name, node.exclusiveMinimum ? '<=' : '<', node.minimum)
	      error('is less than minimum')
	      validate('}')
	
	      if (type !== 'number' && type !== 'integer') validate('}')
	    }
	
	    if (node.maximum !== undefined) {
	      if (type !== 'number' && type !== 'integer') validate('if (%s) {', types.number(name))
	
	      validate('if (%s %s %d) {', name, node.exclusiveMaximum ? '>=' : '>', node.maximum)
	      error('is more than maximum')
	      validate('}')
	
	      if (type !== 'number' && type !== 'integer') validate('}')
	    }
	
	    if (properties) {
	      Object.keys(properties).forEach(function(p) {
	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('if (%s !== null) {', name)
	
	        visit(genobj(name, p), properties[p], reporter, filter)
	
	        if (Array.isArray(type) && type.indexOf('null') !== -1) validate('}')
	      })
	    }
	
	    while (indent--) validate('}')
	  }
	
	  var validate = genfun
	    ('function validate(data) {')
	      // Since undefined is not a valid JSON value, we coerce to null and other checks will catch this
	      ('if (data === undefined) data = null')
	      ('validate.errors = null')
	      ('var errors = 0')
	
	  visit('data', schema, reporter, opts && opts.filter)
	
	  validate
	      ('return errors === 0')
	    ('}')
	
	  validate = validate.toFunction(scope)
	  validate.errors = null
	
	  if (Object.defineProperty) {
	    Object.defineProperty(validate, 'error', {
	      get: function() {
	        if (!validate.errors) return ''
	        return validate.errors.map(function(err) {
	          return err.field + ' ' + err.message;
	        }).join('\n')
	      }
	    })
	  }
	
	  validate.toJSON = function() {
	    return schema
	  }
	
	  return validate
	}
	
	module.exports = function(schema, opts) {
	  if (typeof schema === 'string') schema = JSON.parse(schema)
	  return compile(schema, {}, schema, true, opts)
	}
	
	module.exports.filter = function(schema, opts) {
	  var validate = module.exports(schema, xtend(opts, {filter: true}))
	  return function(sch) {
	    validate(sch)
	    return sch
	  }
	}


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	var isProperty = __webpack_require__(378)
	
	var gen = function(obj, prop) {
	  return isProperty(prop) ? obj+'.'+prop : obj+'['+JSON.stringify(prop)+']'
	}
	
	gen.valid = isProperty
	gen.property = function (prop) {
	 return isProperty(prop) ? prop : JSON.stringify(prop)
	}
	
	module.exports = gen


/***/ },
/* 378 */
/***/ function(module, exports) {

	"use strict"
	function isProperty(str) {
	  return /^[$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc][$A-Z\_a-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc0-9\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19b0-\u19c0\u19c8\u19c9\u19d0-\u19d9\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1dc0-\u1de6\u1dfc-\u1dff\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f]*$/.test(str)
	}
	module.exports = isProperty

/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(4)
	
	var INDENT_START = /[\{\[]/
	var INDENT_END = /[\}\]]/
	
	module.exports = function() {
	  var lines = []
	  var indent = 0
	
	  var push = function(str) {
	    var spaces = ''
	    while (spaces.length < indent*2) spaces += '  '
	    lines.push(spaces+str)
	  }
	
	  var line = function(fmt) {
	    if (!fmt) return line
	
	    if (INDENT_END.test(fmt.trim()[0]) && INDENT_START.test(fmt[fmt.length-1])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_START.test(fmt[fmt.length-1])) {
	      push(util.format.apply(util, arguments))
	      indent++
	      return line
	    }
	    if (INDENT_END.test(fmt.trim()[0])) {
	      indent--
	      push(util.format.apply(util, arguments))
	      return line
	    }
	
	    push(util.format.apply(util, arguments))
	    return line
	  }
	
	  line.toString = function() {
	    return lines.join('\n')
	  }
	
	  line.toFunction = function(scope) {
	    var src = 'return ('+line.toString()+')'
	
	    var keys = Object.keys(scope || {}).map(function(key) {
	      return key
	    })
	
	    var vals = keys.map(function(key) {
	      return scope[key]
	    })
	
	    return Function.apply(null, keys.concat(src)).apply(null, vals)
	  }
	
	  if (arguments.length) line.apply(null, arguments)
	
	  return line
	}


/***/ },
/* 380 */
/***/ function(module, exports) {

	var hasExcape = /~/
	var escapeMatcher = /~[01]/g
	function escapeReplacer (m) {
	  switch (m) {
	    case '~1': return '/'
	    case '~0': return '~'
	  }
	  throw new Error('Invalid tilde escape: ' + m)
	}
	
	function untilde (str) {
	  if (!hasExcape.test(str)) return str
	  return str.replace(escapeMatcher, escapeReplacer)
	}
	
	function setter (obj, pointer, value) {
	  var part
	  var hasNextPart
	
	  for (var p = 1, len = pointer.length; p < len;) {
	    part = untilde(pointer[p++])
	    hasNextPart = len > p
	
	    if (typeof obj[part] === 'undefined') {
	      // support setting of /-
	      if (Array.isArray(obj) && part === '-') {
	        part = obj.length
	      }
	
	      // support nested objects/array when setting values
	      if (hasNextPart) {
	        if ((pointer[p] !== '' && pointer[p] < Infinity) || pointer[p] === '-') obj[part] = []
	        else obj[part] = {}
	      }
	    }
	
	    if (!hasNextPart) break
	    obj = obj[part]
	  }
	
	  var oldValue = obj[part]
	  if (value === undefined) delete obj[part]
	  else obj[part] = value
	  return oldValue
	}
	
	function compilePointer (pointer) {
	  if (typeof pointer === 'string') {
	    pointer = pointer.split('/')
	    if (pointer[0] === '') return pointer
	    throw new Error('Invalid JSON pointer.')
	  } else if (Array.isArray(pointer)) {
	    return pointer
	  }
	
	  throw new Error('Invalid JSON pointer.')
	}
	
	function get (obj, pointer) {
	  if (typeof obj !== 'object') throw new Error('Invalid input object.')
	  pointer = compilePointer(pointer)
	  var len = pointer.length
	  if (len === 1) return obj
	
	  for (var p = 1; p < len;) {
	    obj = obj[untilde(pointer[p++])]
	    if (len === p) return obj
	    if (typeof obj !== 'object') return undefined
	  }
	}
	
	function set (obj, pointer, value) {
	  if (typeof obj !== 'object') throw new Error('Invalid input object.')
	  pointer = compilePointer(pointer)
	  if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')
	  return setter(obj, pointer, value)
	}
	
	function compile (pointer) {
	  var compiled = compilePointer(pointer)
	  return {
	    get: function (object) {
	      return get(object, compiled)
	    },
	    set: function (object, value) {
	      return set(object, compiled, value)
	    }
	  }
	}
	
	exports.get = get
	exports.set = set
	exports.compile = compile


/***/ },
/* 381 */
/***/ function(module, exports) {

	module.exports = extend
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	function extend() {
	    var target = {}
	
	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]
	
	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }
	
	    return target
	}


/***/ },
/* 382 */
/***/ function(module, exports) {

	exports['date-time'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}[tT ]\d{2}:\d{2}:\d{2}(\.\d+)?([zZ]|[+-]\d{2}:\d{2})$/
	exports['date'] = /^\d{4}-(?:0[0-9]{1}|1[0-2]{1})-[0-9]{2}$/
	exports['time'] = /^\d{2}:\d{2}:\d{2}$/
	exports['email'] = /^\S+@\S+$/
	exports['ip-address'] = exports['ipv4'] = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/
	exports['ipv6'] = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/
	exports['uri'] = /^[a-zA-Z][a-zA-Z0-9+-.]*:[^\s]*$/
	exports['color'] = /(#?([0-9A-Fa-f]{3,6})\b)|(aqua)|(black)|(blue)|(fuchsia)|(gray)|(green)|(lime)|(maroon)|(navy)|(olive)|(orange)|(purple)|(red)|(silver)|(teal)|(white)|(yellow)|(rgb\(\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*,\s*\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\b\s*\))|(rgb\(\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*,\s*(\d?\d%|100%)+\s*\))/
	exports['hostname'] = /^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])(\.([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]{0,61}[a-zA-Z0-9]))*$/
	exports['alpha'] = /^[a-zA-Z]+$/
	exports['alphanumeric'] = /^[a-zA-Z0-9]+$/
	exports['style'] = /\s*(.+?):\s*([^;]+);?/g
	exports['phone'] = /^\+(?:[0-9] ?){6,14}[0-9]$/
	exports['utc-millisec'] = /^[0-9]{1,15}\.?[0-9]{0,15}$/


/***/ },
/* 383 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The event generator for comments.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Check collection of comments to prevent double event for comment as
	 * leading and trailing, then emit event if passing
	 * @param {ASTNode[]} comments - Collection of comment nodes
	 * @param {EventEmitter} emitter - The event emitter which is the destination of events.
	 * @param {Object[]} locs - List of locations of previous comment nodes
	 * @param {string} eventName - Event name postfix
	 * @returns {void}
	 */
	function emitComments(comments, emitter, locs, eventName) {
	    if (comments.length > 0) {
	        comments.forEach(function(node) {
	            const index = locs.indexOf(node.loc);
	
	            if (index >= 0) {
	                locs.splice(index, 1);
	            } else {
	                locs.push(node.loc);
	                emitter.emit(node.type + eventName, node);
	            }
	        });
	    }
	}
	
	/**
	 * Shortcut to check and emit enter of comment nodes
	 * @param {CommentEventGenerator} generator - A generator to emit.
	 * @param {ASTNode[]} comments - Collection of comment nodes
	 * @returns {void}
	 */
	function emitCommentsEnter(generator, comments) {
	    emitComments(
	        comments,
	        generator.emitter,
	        generator.commentLocsEnter,
	        "Comment");
	}
	
	/**
	 * Shortcut to check and emit exit of comment nodes
	 * @param {CommentEventGenerator} generator - A generator to emit.
	 * @param {ASTNode[]} comments Collection of comment nodes
	 * @returns {void}
	 */
	function emitCommentsExit(generator, comments) {
	    emitComments(
	        comments,
	        generator.emitter,
	        generator.commentLocsExit,
	        "Comment:exit");
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * The event generator for comments.
	 * This is the decorator pattern.
	 * This generates events of comments before/after events which are generated the original generator.
	 *
	 * @param {EventGenerator} originalEventGenerator - An event generator which is the decoration target.
	 * @param {SourceCode} sourceCode - A source code which has comments.
	 * @returns {CommentEventGenerator} new instance.
	 */
	function CommentEventGenerator(originalEventGenerator, sourceCode) {
	    this.original = originalEventGenerator;
	    this.emitter = originalEventGenerator.emitter;
	    this.sourceCode = sourceCode;
	    this.commentLocsEnter = [];
	    this.commentLocsExit = [];
	}
	
	CommentEventGenerator.prototype = {
	    constructor: CommentEventGenerator,
	
	    /**
	     * Emits an event of entering comments.
	     * @param {ASTNode} node - A node which was entered.
	     * @returns {void}
	     */
	    enterNode: function enterNode(node) {
	        const comments = this.sourceCode.getComments(node);
	
	        emitCommentsEnter(this, comments.leading);
	        this.original.enterNode(node);
	        emitCommentsEnter(this, comments.trailing);
	    },
	
	    /**
	     * Emits an event of leaving comments.
	     * @param {ASTNode} node - A node which was left.
	     * @returns {void}
	     */
	    leaveNode: function leaveNode(node) {
	        const comments = this.sourceCode.getComments(node);
	
	        emitCommentsExit(this, comments.trailing);
	        this.original.leaveNode(node);
	        emitCommentsExit(this, comments.leading);
	    }
	};
	
	module.exports = CommentEventGenerator;


/***/ },
/* 384 */
/***/ function(module, exports) {

	/**
	 * @fileoverview The event generator for AST nodes.
	 * @author Toru Nagashima
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * The event generator for AST nodes.
	 * This implements below interface.
	 *
	 * ```ts
	 * interface EventGenerator {
	 *     emitter: EventEmitter;
	 *     enterNode(node: ASTNode): void;
	 *     leaveNode(node: ASTNode): void;
	 * }
	 * ```
	 *
	 * @param {EventEmitter} emitter - An event emitter which is the destination of events.
	 * @returns {NodeEventGenerator} new instance.
	 */
	function NodeEventGenerator(emitter) {
	    this.emitter = emitter;
	}
	
	NodeEventGenerator.prototype = {
	    constructor: NodeEventGenerator,
	
	    /**
	     * Emits an event of entering AST node.
	     * @param {ASTNode} node - A node which was entered.
	     * @returns {void}
	     */
	    enterNode: function enterNode(node) {
	        this.emitter.emit(node.type, node);
	    },
	
	    /**
	     * Emits an event of leaving AST node.
	     * @param {ASTNode} node - A node which was left.
	     * @returns {void}
	     */
	    leaveNode: function leaveNode(node) {
	        this.emitter.emit(`${node.type}:exit`, node);
	    }
	};
	
	module.exports = NodeEventGenerator;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Abstraction of JavaScript source code.
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const createTokenStore = __webpack_require__(386),
	    Traverser = __webpack_require__(303);
	
	//------------------------------------------------------------------------------
	// Private
	//------------------------------------------------------------------------------
	
	/**
	 * Validates that the given AST has the required information.
	 * @param {ASTNode} ast The Program node of the AST to check.
	 * @throws {Error} If the AST doesn't contain the correct information.
	 * @returns {void}
	 * @private
	 */
	function validate(ast) {
	
	    if (!ast.tokens) {
	        throw new Error("AST is missing the tokens array.");
	    }
	
	    if (!ast.comments) {
	        throw new Error("AST is missing the comments array.");
	    }
	
	    if (!ast.loc) {
	        throw new Error("AST is missing location information.");
	    }
	
	    if (!ast.range) {
	        throw new Error("AST is missing range information");
	    }
	}
	
	/**
	 * Finds a JSDoc comment node in an array of comment nodes.
	 * @param {ASTNode[]} comments The array of comment nodes to search.
	 * @param {int} line Line number to look around
	 * @returns {ASTNode} The node if found, null if not.
	 * @private
	 */
	function findJSDocComment(comments, line) {
	
	    if (comments) {
	        for (let i = comments.length - 1; i >= 0; i--) {
	            if (comments[i].type === "Block" && comments[i].value.charAt(0) === "*") {
	
	                if (line - comments[i].loc.end.line <= 1) {
	                    return comments[i];
	                } else {
	                    break;
	                }
	            }
	        }
	    }
	
	    return null;
	}
	
	/**
	 * Check to see if its a ES6 export declaration
	 * @param {ASTNode} astNode - any node
	 * @returns {boolean} whether the given node represents a export declaration
	 * @private
	 */
	function looksLikeExport(astNode) {
	    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" ||
	        astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
	}
	
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Represents parsed source code.
	 * @param {string} text - The source code text.
	 * @param {ASTNode} ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.
	 * @constructor
	 */
	function SourceCode(text, ast) {
	    validate(ast);
	
	    /**
	     * The flag to indicate that the source code has Unicode BOM.
	     * @type boolean
	     */
	    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);
	
	    /**
	     * The original text source code.
	     * BOM was stripped from this text.
	     * @type string
	     */
	    this.text = (this.hasBOM ? text.slice(1) : text);
	
	    /**
	     * The parsed AST for the source code.
	     * @type ASTNode
	     */
	    this.ast = ast;
	
	    /**
	     * The source code split into lines according to ECMA-262 specification.
	     * This is done to avoid each rule needing to do so separately.
	     * @type string[]
	     */
	    this.lines = SourceCode.splitLines(this.text);
	
	    this.tokensAndComments = ast.tokens.concat(ast.comments).sort(function(left, right) {
	        return left.range[0] - right.range[0];
	    });
	
	    // create token store methods
	    const tokenStore = createTokenStore(ast.tokens);
	
	    Object.keys(tokenStore).forEach(function(methodName) {
	        this[methodName] = tokenStore[methodName];
	    }, this);
	
	    const tokensAndCommentsStore = createTokenStore(this.tokensAndComments);
	
	    this.getTokenOrCommentBefore = tokensAndCommentsStore.getTokenBefore;
	    this.getTokenOrCommentAfter = tokensAndCommentsStore.getTokenAfter;
	
	    // don't allow modification of this object
	    Object.freeze(this);
	    Object.freeze(this.lines);
	}
	
	/**
	 * Split the source code into multiple lines based on the line delimiters
	 * @param {string} text Source code as a string
	 * @returns {string[]} Array of source code lines
	 * @public
	 */
	SourceCode.splitLines = function(text) {
	    return text.split(/\r\n|\r|\n|\u2028|\u2029/g);
	};
	
	SourceCode.prototype = {
	    constructor: SourceCode,
	
	    /**
	     * Gets the source code for the given node.
	     * @param {ASTNode=} node The AST node to get the text for.
	     * @param {int=} beforeCount The number of characters before the node to retrieve.
	     * @param {int=} afterCount The number of characters after the node to retrieve.
	     * @returns {string} The text representing the AST node.
	     */
	    getText(node, beforeCount, afterCount) {
	        if (node) {
	            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),
	                node.range[1] + (afterCount || 0));
	        } else {
	            return this.text;
	        }
	
	    },
	
	    /**
	     * Gets the entire source text split into an array of lines.
	     * @returns {Array} The source text as an array of lines.
	     */
	    getLines() {
	        return this.lines;
	    },
	
	    /**
	     * Retrieves an array containing all comments in the source code.
	     * @returns {ASTNode[]} An array of comment nodes.
	     */
	    getAllComments() {
	        return this.ast.comments;
	    },
	
	    /**
	     * Gets all comments for the given node.
	     * @param {ASTNode} node The AST node to get the comments for.
	     * @returns {Object} The list of comments indexed by their position.
	     * @public
	     */
	    getComments(node) {
	
	        let leadingComments = node.leadingComments || [];
	        const trailingComments = node.trailingComments || [];
	
	        /*
	         * espree adds a "comments" array on Program nodes rather than
	         * leadingComments/trailingComments. Comments are only left in the
	         * Program node comments array if there is no executable code.
	         */
	        if (node.type === "Program") {
	            if (node.body.length === 0) {
	                leadingComments = node.comments;
	            }
	        }
	
	        return {
	            leading: leadingComments,
	            trailing: trailingComments
	        };
	    },
	
	    /**
	     * Retrieves the JSDoc comment for a given node.
	     * @param {ASTNode} node The AST node to get the comment for.
	     * @returns {ASTNode} The BlockComment node containing the JSDoc for the
	     *      given node or null if not found.
	     * @public
	     */
	    getJSDocComment(node) {
	
	        let parent = node.parent;
	
	        switch (node.type) {
	            case "ClassDeclaration":
	            case "FunctionDeclaration":
	                if (looksLikeExport(parent)) {
	                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);
	                }
	                return findJSDocComment(node.leadingComments, node.loc.start.line);
	
	            case "ClassExpression":
	                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);
	
	            case "ArrowFunctionExpression":
	            case "FunctionExpression":
	
	                if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
	                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
	                        parent = parent.parent;
	                    }
	
	                    return parent && (parent.type !== "FunctionDeclaration") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;
	                } else if (node.leadingComments) {
	                    return findJSDocComment(node.leadingComments, node.loc.start.line);
	                }
	
	            // falls through
	
	            default:
	                return null;
	        }
	    },
	
	    /**
	     * Gets the deepest node containing a range index.
	     * @param {int} index Range index of the desired node.
	     * @returns {ASTNode} The node if found or null if not found.
	     */
	    getNodeByRangeIndex(index) {
	        let result = null,
	            resultParent = null;
	        const traverser = new Traverser();
	
	        traverser.traverse(this.ast, {
	            enter(node, parent) {
	                if (node.range[0] <= index && index < node.range[1]) {
	                    result = node;
	                    resultParent = parent;
	                } else {
	                    this.skip();
	                }
	            },
	            leave(node) {
	                if (node === result) {
	                    this.break();
	                }
	            }
	        });
	
	        return result ? Object.assign({parent: resultParent}, result) : null;
	    },
	
	    /**
	     * Determines if two tokens have at least one whitespace character
	     * between them. This completely disregards comments in making the
	     * determination, so comments count as zero-length substrings.
	     * @param {Token} first The token to check after.
	     * @param {Token} second The token to check before.
	     * @returns {boolean} True if there is only space between tokens, false
	     *  if there is anything other than whitespace between tokens.
	     */
	    isSpaceBetweenTokens(first, second) {
	        const text = this.text.slice(first.range[1], second.range[0]);
	
	        return /\s/.test(text.replace(/\/\*.*?\*\//g, ""));
	    }
	};
	
	
	module.exports = SourceCode;


/***/ },
/* 386 */
/***/ function(module, exports) {

	/**
	 * @fileoverview Object to handle access and retrieval of tokens.
	 * @author Brandon Mills
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Implementation
	//------------------------------------------------------------------------------
	
	module.exports = function(tokens) {
	    const api = {},
	        starts = Object.create(null),
	        ends = Object.create(null),
	        length = tokens.length;
	
	    /**
	     * Gets tokens in a given interval.
	     * @param {int} start Inclusive index of the first token. 0 if negative.
	     * @param {int} end Exclusive index of the last token.
	     * @returns {Token[]} Tokens in the interval.
	     */
	    function get(start, end) {
	        const result = [];
	
	        for (let i = Math.max(0, start); i < end && i < length; i++) {
	            result.push(tokens[i]);
	        }
	
	        return result;
	    }
	
	    /**
	     * Gets the index in the tokens array of the last token belonging to a node.
	     * Usually a node ends exactly at a token, but due to ASI, sometimes a
	     * node's range extends beyond its last token.
	     * @param {ASTNode} node The node for which to find the last token's index.
	     * @returns {int} Index in the tokens array of the node's last token.
	     */
	    function lastTokenIndex(node) {
	        const end = node.range[1];
	        let cursor = ends[end];
	
	        // If the node extends beyond its last token, get the token before the
	        // next token
	        if (typeof cursor === "undefined") {
	            cursor = starts[end] - 1;
	        }
	
	        // If there isn't a next token, the desired token is the last one in the
	        // array
	        if (isNaN(cursor)) {
	            cursor = length - 1;
	        }
	
	        return cursor;
	    }
	
	    // Map tokens' start and end range to the index in the tokens array
	    for (let i = 0; i < length; i++) {
	        const range = tokens[i].range;
	
	        starts[range[0]] = i;
	        ends[range[1]] = i;
	    }
	
	    /**
	     * Gets a number of tokens that precede a given node or token in the token
	     * stream.
	     * @param {(ASTNode|Token)} node The AST node or token.
	     * @param {int} [beforeCount=0] The number of tokens before the node or
	     *     token to retrieve.
	     * @returns {Token[]} Array of objects representing tokens.
	     */
	    api.getTokensBefore = function(node, beforeCount) {
	        const first = starts[node.range[0]];
	
	        return get(first - (beforeCount || 0), first);
	    };
	
	    /**
	     * Gets the token that precedes a given node or token in the token stream.
	     * @param {(ASTNode|Token)} node The AST node or token.
	     * @param {int} [skip=0] A number of tokens to skip before the given node or
	     *     token.
	     * @returns {Token} An object representing the token.
	     */
	    api.getTokenBefore = function(node, skip) {
	        return tokens[starts[node.range[0]] - (skip || 0) - 1];
	    };
	
	    /**
	     * Gets a number of tokens that follow a given node or token in the token
	     * stream.
	     * @param {(ASTNode|Token)} node The AST node or token.
	     * @param {int} [afterCount=0] The number of tokens after the node or token
	     *     to retrieve.
	     * @returns {Token[]} Array of objects representing tokens.
	     */
	    api.getTokensAfter = function(node, afterCount) {
	        const start = lastTokenIndex(node) + 1;
	
	        return get(start, start + (afterCount || 0));
	    };
	
	    /**
	     * Gets the token that follows a given node or token in the token stream.
	     * @param {(ASTNode|Token)} node The AST node or token.
	     * @param {int} [skip=0] A number of tokens to skip after the given node or
	     *     token.
	     * @returns {Token} An object representing the token.
	     */
	    api.getTokenAfter = function(node, skip) {
	        return tokens[lastTokenIndex(node) + (skip || 0) + 1];
	    };
	
	    /**
	     * Gets all tokens that are related to the given node.
	     * @param {ASTNode} node The AST node.
	     * @param {int} [beforeCount=0] The number of tokens before the node to retrieve.
	     * @param {int} [afterCount=0] The number of tokens after the node to retrieve.
	     * @returns {Token[]} Array of objects representing tokens.
	     */
	    api.getTokens = function(node, beforeCount, afterCount) {
	        return get(
	            starts[node.range[0]] - (beforeCount || 0),
	            lastTokenIndex(node) + (afterCount || 0) + 1
	        );
	    };
	
	    /**
	     * Gets the first `count` tokens of the given node's token stream.
	     * @param {ASTNode} node The AST node.
	     * @param {int} [count=0] The number of tokens of the node to retrieve.
	     * @returns {Token[]} Array of objects representing tokens.
	     */
	    api.getFirstTokens = function(node, count) {
	        const first = starts[node.range[0]];
	
	        return get(
	            first,
	            Math.min(lastTokenIndex(node) + 1, first + (count || 0))
	        );
	    };
	
	    /**
	     * Gets the first token of the given node's token stream.
	     * @param {ASTNode} node The AST node.
	     * @param {int} [skip=0] A number of tokens to skip.
	     * @returns {Token} An object representing the token.
	     */
	    api.getFirstToken = function(node, skip) {
	        return tokens[starts[node.range[0]] + (skip || 0)];
	    };
	
	    /**
	     * Gets the last `count` tokens of the given node.
	     * @param {ASTNode} node The AST node.
	     * @param {int} [count=0] The number of tokens of the node to retrieve.
	     * @returns {Token[]} Array of objects representing tokens.
	     */
	    api.getLastTokens = function(node, count) {
	        const last = lastTokenIndex(node) + 1;
	
	        return get(Math.max(starts[node.range[0]], last - (count || 0)), last);
	    };
	
	    /**
	     * Gets the last token of the given node's token stream.
	     * @param {ASTNode} node The AST node.
	     * @param {int} [skip=0] A number of tokens to skip.
	     * @returns {Token} An object representing the token.
	     */
	    api.getLastToken = function(node, skip) {
	        return tokens[lastTokenIndex(node) - (skip || 0)];
	    };
	
	    /**
	     * Gets all of the tokens between two non-overlapping nodes.
	     * @param {ASTNode} left Node before the desired token range.
	     * @param {ASTNode} right Node after the desired token range.
	     * @param {int} [padding=0] Number of extra tokens on either side of center.
	     * @returns {Token[]} Tokens between left and right plus padding.
	     */
	    api.getTokensBetween = function(left, right, padding) {
	        padding = padding || 0;
	        return get(
	            lastTokenIndex(left) + 1 - padding,
	            starts[right.range[0]] + padding
	        );
	    };
	
	    /**
	     * Gets the token starting at the specified index.
	     * @param {int} startIndex Index of the start of the token's range.
	     * @returns {Token} The token starting at index, or null if no such token.
	     */
	    api.getTokenByRangeStart = function(startIndex) {
	        return (tokens[starts[startIndex]] || null);
	    };
	
	    return api;
	};


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview RuleContext utility for rules
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const RuleFixer = __webpack_require__(388);
	
	//------------------------------------------------------------------------------
	// Constants
	//------------------------------------------------------------------------------
	
	const PASSTHROUGHS = [
	    "getAncestors",
	    "getDeclaredVariables",
	    "getFilename",
	    "getScope",
	    "markVariableAsUsed",
	
	    // DEPRECATED
	    "getAllComments",
	    "getComments",
	    "getFirstToken",
	    "getFirstTokens",
	    "getJSDocComment",
	    "getLastToken",
	    "getLastTokens",
	    "getNodeByRangeIndex",
	    "getSource",
	    "getSourceLines",
	    "getTokenAfter",
	    "getTokenBefore",
	    "getTokenByRangeStart",
	    "getTokens",
	    "getTokensAfter",
	    "getTokensBefore",
	    "getTokensBetween"
	];
	
	//------------------------------------------------------------------------------
	// Typedefs
	//------------------------------------------------------------------------------
	
	/**
	 * An error message description
	 * @typedef {Object} MessageDescriptor
	 * @property {string} nodeType The type of node.
	 * @property {Location} loc The location of the problem.
	 * @property {string} message The problem message.
	 * @property {Object} [data] Optional data to use to fill in placeholders in the
	 *      message.
	 * @property {Function} fix The function to call that creates a fix command.
	 */
	
	//------------------------------------------------------------------------------
	// Rule Definition
	//------------------------------------------------------------------------------
	
	/**
	 * Acts as an abstraction layer between rules and the main eslint object.
	 * @constructor
	 * @param {string} ruleId The ID of the rule using this object.
	 * @param {eslint} eslint The eslint object.
	 * @param {number} severity The configured severity level of the rule.
	 * @param {Array} options The configuration information to be added to the rule.
	 * @param {Object} settings The configuration settings passed from the config file.
	 * @param {Object} parserOptions The parserOptions settings passed from the config file.
	 * @param {Object} parserPath The parser setting passed from the config file.
	 * @param {Object} meta The metadata of the rule
	 * @param {Object} parserServices The parser services for the rule.
	 */
	function RuleContext(ruleId, eslint, severity, options, settings, parserOptions, parserPath, meta, parserServices) {
	
	    // public.
	    this.id = ruleId;
	    this.options = options;
	    this.settings = settings;
	    this.parserOptions = parserOptions;
	    this.parserPath = parserPath;
	    this.meta = meta;
	
	    // create a separate copy and freeze it (it's not nice to freeze other people's objects)
	    this.parserServices = Object.freeze(Object.assign({}, parserServices));
	
	    // private.
	    this.eslint = eslint;
	    this.severity = severity;
	
	    Object.freeze(this);
	}
	
	RuleContext.prototype = {
	    constructor: RuleContext,
	
	    /**
	     * Passthrough to eslint.getSourceCode().
	     * @returns {SourceCode} The SourceCode object for the code.
	     */
	    getSourceCode() {
	        return this.eslint.getSourceCode();
	    },
	
	    /**
	     * Passthrough to eslint.report() that automatically assigns the rule ID and severity.
	     * @param {ASTNode|MessageDescriptor} nodeOrDescriptor The AST node related to the message or a message
	     *      descriptor.
	     * @param {Object=} location The location of the error.
	     * @param {string} message The message to display to the user.
	     * @param {Object} opts Optional template data which produces a formatted message
	     *     with symbols being replaced by this object's values.
	     * @returns {void}
	     */
	    report(nodeOrDescriptor, location, message, opts) {
	
	        // check to see if it's a new style call
	        if (arguments.length === 1) {
	            const descriptor = nodeOrDescriptor;
	            let fix = null;
	
	            // if there's a fix specified, get it
	            if (typeof descriptor.fix === "function") {
	                fix = descriptor.fix(new RuleFixer());
	            }
	
	            this.eslint.report(
	                this.id,
	                this.severity,
	                descriptor.node,
	                descriptor.loc || descriptor.node.loc.start,
	                descriptor.message,
	                descriptor.data,
	                fix,
	                this.meta
	            );
	
	            return;
	        }
	
	        // old style call
	        this.eslint.report(
	            this.id,
	            this.severity,
	            nodeOrDescriptor,
	            location,
	            message,
	            opts,
	            this.meta
	        );
	    }
	};
	
	// Copy over passthrough methods. All functions will have 5 or fewer parameters.
	PASSTHROUGHS.forEach(function(name) {
	    this[name] = function(a, b, c, d, e) {
	        return this.eslint[name](a, b, c, d, e);
	    };
	}, RuleContext.prototype);
	
	module.exports = RuleContext;


/***/ },
/* 388 */
/***/ function(module, exports) {

	/**
	 * @fileoverview An object that creates fix commands for rules.
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	// none!
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/**
	 * Creates a fix command that inserts text at the specified index in the source text.
	 * @param {int} index The 0-based index at which to insert the new text.
	 * @param {string} text The text to insert.
	 * @returns {Object} The fix command.
	 * @private
	 */
	function insertTextAt(index, text) {
	    return {
	        range: [index, index],
	        text
	    };
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Creates code fixing commands for rules.
	 * @constructor
	 */
	function RuleFixer() {
	    Object.freeze(this);
	}
	
	RuleFixer.prototype = {
	    constructor: RuleFixer,
	
	    /**
	     * Creates a fix command that inserts text after the given node or token.
	     * The fix is not applied until applyFixes() is called.
	     * @param {ASTNode|Token} nodeOrToken The node or token to insert after.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    insertTextAfter(nodeOrToken, text) {
	        return this.insertTextAfterRange(nodeOrToken.range, text);
	    },
	
	    /**
	     * Creates a fix command that inserts text after the specified range in the source text.
	     * The fix is not applied until applyFixes() is called.
	     * @param {int[]} range The range to replace, first item is start of range, second
	     *      is end of range.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    insertTextAfterRange(range, text) {
	        return insertTextAt(range[1], text);
	    },
	
	    /**
	     * Creates a fix command that inserts text before the given node or token.
	     * The fix is not applied until applyFixes() is called.
	     * @param {ASTNode|Token} nodeOrToken The node or token to insert before.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    insertTextBefore(nodeOrToken, text) {
	        return this.insertTextBeforeRange(nodeOrToken.range, text);
	    },
	
	    /**
	     * Creates a fix command that inserts text before the specified range in the source text.
	     * The fix is not applied until applyFixes() is called.
	     * @param {int[]} range The range to replace, first item is start of range, second
	     *      is end of range.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    insertTextBeforeRange(range, text) {
	        return insertTextAt(range[0], text);
	    },
	
	    /**
	     * Creates a fix command that replaces text at the node or token.
	     * The fix is not applied until applyFixes() is called.
	     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    replaceText(nodeOrToken, text) {
	        return this.replaceTextRange(nodeOrToken.range, text);
	    },
	
	    /**
	     * Creates a fix command that replaces text at the specified range in the source text.
	     * The fix is not applied until applyFixes() is called.
	     * @param {int[]} range The range to replace, first item is start of range, second
	     *      is end of range.
	     * @param {string} text The text to insert.
	     * @returns {Object} The fix command.
	     */
	    replaceTextRange(range, text) {
	        return {
	            range,
	            text
	        };
	    },
	
	    /**
	     * Creates a fix command that removes the node or token from the source.
	     * The fix is not applied until applyFixes() is called.
	     * @param {ASTNode|Token} nodeOrToken The node or token to remove.
	     * @returns {Object} The fix command.
	     */
	    remove(nodeOrToken) {
	        return this.removeRange(nodeOrToken.range);
	    },
	
	    /**
	     * Creates a fix command that removes the specified range of text from the source.
	     * The fix is not applied until applyFixes() is called.
	     * @param {int[]} range The range to remove, first item is start of range, second
	     *      is end of range.
	     * @returns {Object} The fix command.
	     */
	    removeRange(range) {
	        return {
	            range,
	            text: ""
	        };
	    }
	
	};
	
	
	module.exports = RuleFixer;


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * @fileoverview Tracks performance of individual rules.
	 * @author Brandon Mills
	 */
	
	"use strict";
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	/* istanbul ignore next */
	/**
	 * Align the string to left
	 * @param {string} str string to evaluate
	 * @param {int} len length of the string
	 * @param {string} ch delimiter character
	 * @returns {string} modified string
	 * @private
	 */
	function alignLeft(str, len, ch) {
	    return str + new Array(len - str.length + 1).join(ch || " ");
	}
	
	/* istanbul ignore next */
	/**
	 * Align the string to right
	 * @param {string} str string to evaluate
	 * @param {int} len length of the string
	 * @param {string} ch delimiter character
	 * @returns {string} modified string
	 * @private
	 */
	function alignRight(str, len, ch) {
	    return new Array(len - str.length + 1).join(ch || " ") + str;
	}
	
	//------------------------------------------------------------------------------
	// Module definition
	//------------------------------------------------------------------------------
	
	const enabled = !!process.env.TIMING;
	
	const HEADERS = ["Rule", "Time (ms)", "Relative"];
	const ALIGN = [alignLeft, alignRight, alignRight];
	
	/* istanbul ignore next */
	/**
	 * display the data
	 * @param {Object} data Data object to be displayed
	 * @returns {string} modified string
	 * @private
	 */
	function display(data) {
	    let total = 0;
	    const rows = Object.keys(data)
	        .map(function(key) {
	            const time = data[key];
	
	            total += time;
	            return [key, time];
	        })
	        .sort(function(a, b) {
	            return b[1] - a[1];
	        })
	        .slice(0, 10);
	
	    rows.forEach(function(row) {
	        row.push(`${(row[1] * 100 / total).toFixed(1)}%`);
	        row[1] = row[1].toFixed(3);
	    });
	
	    rows.unshift(HEADERS);
	
	    const widths = [];
	
	    rows.forEach(function(row) {
	        const len = row.length;
	
	        for (let i = 0; i < len; i++) {
	            const n = row[i].length;
	
	            if (!widths[i] || n > widths[i]) {
	                widths[i] = n;
	            }
	        }
	    });
	
	    const table = rows.map(function(row) {
	        return row.map(function(cell, index) {
	            return ALIGN[index](cell, widths[index]);
	        }).join(" | ");
	    });
	
	    table.splice(1, 0, widths.map(function(w, index) {
	        if (index !== 0 && index !== widths.length - 1) {
	            w++;
	        }
	
	        return ALIGN[index](":", w + 1, "-");
	    }).join("|"));
	
	    console.log(table.join("\n"));      // eslint-disable-line no-console
	}
	
	/* istanbul ignore next */
	module.exports = (function() {
	
	    const data = Object.create(null);
	
	    /**
	     * Time the run
	     * @param {*} key key from the data object
	     * @param {Function} fn function to be called
	     * @returns {Function} function to be executed
	     * @private
	     */
	    function time(key, fn) {
	        if (typeof data[key] === "undefined") {
	            data[key] = 0;
	        }
	
	        return function() {
	            let t = process.hrtime();
	
	            fn.apply(null, Array.prototype.slice.call(arguments));
	            t = process.hrtime(t);
	            data[key] += t[0] * 1e3 + t[1] / 1e6;
	        };
	    }
	
	    if (enabled) {
	        process.on("exit", function() {
	            display(data);
	        });
	    }
	
	    return {
	        time,
	        enabled
	    };
	
	}());
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 390 */
/***/ function(module, exports) {

	// We use this to replace the CLIEngine module in ESlint.  We don't need a CLI
	// for the web.


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview Mocha test wrapper
	 * @author Ilya Volodin
	 */
	"use strict";
	
	/* global describe, it */
	
	/*
	 * This is a wrapper around mocha to allow for DRY unittests for eslint
	 * Format:
	 * RuleTester.add("{ruleName}", {
	 *      valid: [
	 *          "{code}",
	 *          { code: "{code}", options: {options}, global: {globals}, globals: {globals}, parser: "{parser}", settings: {settings} }
	 *      ],
	 *      invalid: [
	 *          { code: "{code}", errors: {numErrors} },
	 *          { code: "{code}", errors: ["{errorMessage}"] },
	 *          { code: "{code}", options: {options}, global: {globals}, parser: "{parser}", settings: {settings}, errors: [{ message: "{errorMessage}", type: "{errorNodeType}"}] }
	 *      ]
	 *  });
	 *
	 * Variables:
	 * {code} - String that represents the code to be tested
	 * {options} - Arguments that are passed to the configurable rules.
	 * {globals} - An object representing a list of variables that are
	 *             registered as globals
	 * {parser} - String representing the parser to use
	 * {settings} - An object representing global settings for all rules
	 * {numErrors} - If failing case doesn't need to check error message,
	 *               this integer will specify how many errors should be
	 *               received
	 * {errorMessage} - Message that is returned by the rule on failure
	 * {errorNodeType} - AST node type that is returned by they rule as
	 *                   a cause of the failure.
	 */
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const lodash = __webpack_require__(135),
	    assert = __webpack_require__(3),
	    util = __webpack_require__(4),
	    validator = __webpack_require__(119),
	    validate = __webpack_require__(376),
	    eslint = __webpack_require__(2),
	    rules = __webpack_require__(120),
	    metaSchema = __webpack_require__(392),
	    SourceCodeFixer = __webpack_require__(393);
	
	//------------------------------------------------------------------------------
	// Private Members
	//------------------------------------------------------------------------------
	
	/*
	 * testerDefaultConfig must not be modified as it allows to reset the tester to
	 * the initial default configuration
	 */
	const testerDefaultConfig = { rules: {} };
	let defaultConfig = { rules: {} };
	
	/*
	 * List every parameters possible on a test case that are not related to eslint
	 * configuration
	 */
	const RuleTesterParameters = [
	    "code",
	    "filename",
	    "options",
	    "args",
	    "errors"
	];
	
	const validateSchema = validate(metaSchema, { verbose: true });
	
	const hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
	
	/**
	 * Clones a given value deeply.
	 * Note: This ignores `parent` property.
	 *
	 * @param {any} x - A value to clone.
	 * @returns {any} A cloned value.
	 */
	function cloneDeeplyExcludesParent(x) {
	    if (typeof x === "object" && x !== null) {
	        if (Array.isArray(x)) {
	            return x.map(cloneDeeplyExcludesParent);
	        }
	
	        const retv = {};
	
	        for (const key in x) {
	            if (key !== "parent" && hasOwnProperty(x, key)) {
	                retv[key] = cloneDeeplyExcludesParent(x[key]);
	            }
	        }
	
	        return retv;
	    }
	
	    return x;
	}
	
	/**
	 * Freezes a given value deeply.
	 *
	 * @param {any} x - A value to freeze.
	 * @returns {void}
	 */
	function freezeDeeply(x) {
	    if (typeof x === "object" && x !== null) {
	        if (Array.isArray(x)) {
	            x.forEach(freezeDeeply);
	        } else {
	            for (const key in x) {
	                if (key !== "parent" && hasOwnProperty(x, key)) {
	                    freezeDeeply(x[key]);
	                }
	            }
	        }
	        Object.freeze(x);
	    }
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Creates a new instance of RuleTester.
	 * @param {Object} [testerConfig] Optional, extra configuration for the tester
	 * @constructor
	 */
	function RuleTester(testerConfig) {
	
	    /**
	     * The configuration to use for this tester. Combination of the tester
	     * configuration and the default configuration.
	     * @type {Object}
	     */
	    this.testerConfig = lodash.merge(
	
	        // we have to clone because merge uses the first argument for recipient
	        lodash.cloneDeep(defaultConfig),
	        testerConfig
	    );
	}
	
	/**
	 * Set the configuration to use for all future tests
	 * @param {Object} config the configuration to use.
	 * @returns {void}
	 */
	RuleTester.setDefaultConfig = function(config) {
	    if (typeof config !== "object") {
	        throw new Error("RuleTester.setDefaultConfig: config must be an object");
	    }
	    defaultConfig = config;
	
	    // Make sure the rules object exists since it is assumed to exist later
	    defaultConfig.rules = defaultConfig.rules || {};
	};
	
	/**
	 * Get the current configuration used for all tests
	 * @returns {Object} the current configuration
	 */
	RuleTester.getDefaultConfig = function() {
	    return defaultConfig;
	};
	
	/**
	 * Reset the configuration to the initial configuration of the tester removing
	 * any changes made until now.
	 * @returns {void}
	 */
	RuleTester.resetDefaultConfig = function() {
	    defaultConfig = lodash.cloneDeep(testerDefaultConfig);
	};
	
	// default separators for testing
	const DESCRIBE = Symbol("describe");
	const IT = Symbol("it");
	
	RuleTester[DESCRIBE] = RuleTester[IT] = null;
	
	/**
	 * This is `it` or `describe` if those don't exist.
	 * @this {Mocha}
	 * @param {string} text - The description of the test case.
	 * @param {Function} method - The logic of the test case.
	 * @returns {any} Returned value of `method`.
	 */
	function defaultHandler(text, method) {
	    return method.apply(this);
	}
	
	// If people use `mocha test.js --watch` command, `describe` and `it` function
	// instances are different for each execution. So this should get fresh instance
	// always.
	Object.defineProperties(RuleTester, {
	    describe: {
	        get() {
	            return (
	                RuleTester[DESCRIBE] ||
	                (typeof describe === "function" ? describe : defaultHandler)
	            );
	        },
	        set(value) {
	            RuleTester[DESCRIBE] = value;
	        },
	        configurable: true,
	        enumerable: true,
	    },
	    it: {
	        get() {
	            return (
	                RuleTester[IT] ||
	                (typeof it === "function" ? it : defaultHandler)
	            );
	        },
	        set(value) {
	            RuleTester[IT] = value;
	        },
	        configurable: true,
	        enumerable: true,
	    },
	});
	
	RuleTester.prototype = {
	
	    /**
	     * Define a rule for one particular run of tests.
	     * @param {string} name The name of the rule to define.
	     * @param {Function} rule The rule definition.
	     * @returns {void}
	     */
	    defineRule(name, rule) {
	        eslint.defineRule(name, rule);
	    },
	
	    /**
	     * Adds a new rule test to execute.
	     * @param {string} ruleName The name of the rule to run.
	     * @param {Function} rule The rule to test.
	     * @param {Object} test The collection of tests to run.
	     * @returns {void}
	     */
	    run(ruleName, rule, test) {
	
	        const testerConfig = this.testerConfig,
	            result = {};
	
	        /* eslint-disable no-shadow */
	
	        /**
	         * Run the rule for the given item
	         * @param {string} ruleName name of the rule
	         * @param {string|Object} item Item to run the rule against
	         * @returns {Object} Eslint run result
	         * @private
	         */
	        function runRuleForItem(ruleName, item) {
	            let config = lodash.cloneDeep(testerConfig),
	                code, filename, beforeAST, afterAST;
	
	            if (typeof item === "string") {
	                code = item;
	            } else {
	                code = item.code;
	
	                // Assumes everything on the item is a config except for the
	                // parameters used by this tester
	                const itemConfig = lodash.omit(item, RuleTesterParameters);
	
	                // Create the config object from the tester config and this item
	                // specific configurations.
	                config = lodash.merge(
	                    config,
	                    itemConfig
	                );
	            }
	
	            if (item.filename) {
	                filename = item.filename;
	            }
	
	            if (item.options) {
	                const options = item.options.concat();
	
	                options.unshift(1);
	                config.rules[ruleName] = options;
	            } else {
	                config.rules[ruleName] = 1;
	            }
	
	            eslint.defineRule(ruleName, rule);
	
	            const schema = validator.getRuleOptionsSchema(ruleName);
	
	            if (schema) {
	                validateSchema(schema);
	
	                if (validateSchema.errors) {
	                    throw new Error([
	                        `Schema for rule ${ruleName} is invalid:`
	                    ].concat(validateSchema.errors.map(function(error) {
	                        return `\t${error.field}: ${error.message}`;
	                    })).join("\n"));
	                }
	            }
	
	            validator.validate(config, "rule-tester");
	
	            /*
	             * Setup AST getters.
	             * The goal is to check whether or not AST was modified when
	             * running the rule under test.
	             */
	            eslint.reset();
	            eslint.on("Program", function(node) {
	                beforeAST = cloneDeeplyExcludesParent(node);
	
	                eslint.on("Program:exit", function(node) {
	                    afterAST = cloneDeeplyExcludesParent(node);
	                });
	            });
	
	            // Freezes rule-context properties.
	            const originalGet = rules.get;
	
	            try {
	                rules.get = function(ruleId) {
	                    const rule = originalGet(ruleId);
	
	                    if (typeof rule === "function") {
	                        return function(context) {
	                            Object.freeze(context);
	                            freezeDeeply(context.options);
	                            freezeDeeply(context.settings);
	                            freezeDeeply(context.parserOptions);
	
	                            return rule(context);
	                        };
	                    } else {
	                        return {
	                            meta: rule.meta,
	                            create(context) {
	                                Object.freeze(context);
	                                freezeDeeply(context.options);
	                                freezeDeeply(context.settings);
	                                freezeDeeply(context.parserOptions);
	
	                                return rule.create(context);
	                            }
	                        };
	                    }
	                };
	
	                return {
	                    messages: eslint.verify(code, config, filename, true),
	                    beforeAST,
	                    afterAST
	                };
	            } finally {
	                rules.get = originalGet;
	            }
	        }
	
	        /**
	         * Check if the AST was changed
	         * @param {ASTNode} beforeAST AST node before running
	         * @param {ASTNode} afterAST AST node after running
	         * @returns {void}
	         * @private
	         */
	        function assertASTDidntChange(beforeAST, afterAST) {
	            if (!lodash.isEqual(beforeAST, afterAST)) {
	
	                // Not using directly to avoid performance problem in node 6.1.0. See #6111
	                assert.deepEqual(beforeAST, afterAST, "Rule should not modify AST.");
	            }
	        }
	
	        /**
	         * Check if the template is valid or not
	         * all valid cases go through this
	         * @param {string} ruleName name of the rule
	         * @param {string|Object} item Item to run the rule against
	         * @returns {void}
	         * @private
	         */
	        function testValidTemplate(ruleName, item) {
	            const result = runRuleForItem(ruleName, item);
	            const messages = result.messages;
	
	            assert.equal(messages.length, 0, util.format("Should have no errors but had %d: %s",
	                        messages.length, util.inspect(messages)));
	
	            assertASTDidntChange(result.beforeAST, result.afterAST);
	        }
	
	        /**
	         * Check if the template is invalid or not
	         * all invalid cases go through this.
	         * @param {string} ruleName name of the rule
	         * @param {string|Object} item Item to run the rule against
	         * @returns {void}
	         * @private
	         */
	        function testInvalidTemplate(ruleName, item) {
	            assert.ok(item.errors || item.errors === 0,
	                `Did not specify errors for an invalid test of ${ruleName}`);
	
	            const result = runRuleForItem(ruleName, item);
	            const messages = result.messages;
	
	
	
	            if (typeof item.errors === "number") {
	                assert.equal(messages.length, item.errors, util.format("Should have %d error%s but had %d: %s",
	                    item.errors, item.errors === 1 ? "" : "s", messages.length, util.inspect(messages)));
	            } else {
	                assert.equal(messages.length, item.errors.length,
	                    util.format("Should have %d error%s but had %d: %s",
	                    item.errors.length, item.errors.length === 1 ? "" : "s", messages.length, util.inspect(messages)));
	
	                for (let i = 0, l = item.errors.length; i < l; i++) {
	                    assert.ok(!("fatal" in messages[i]), `A fatal parsing error occurred: ${messages[i].message}`);
	                    assert.equal(messages[i].ruleId, ruleName, "Error rule name should be the same as the name of the rule being tested");
	
	                    if (typeof item.errors[i] === "string") {
	
	                        // Just an error message.
	                        assert.equal(messages[i].message, item.errors[i]);
	                    } else if (typeof item.errors[i] === "object") {
	
	                        /*
	                         * Error object.
	                         * This may have a message, node type, line, and/or
	                         * column.
	                         */
	                        if (item.errors[i].message) {
	                            assert.equal(messages[i].message, item.errors[i].message);
	                        }
	
	                        if (item.errors[i].type) {
	                            assert.equal(messages[i].nodeType, item.errors[i].type, `Error type should be ${item.errors[i].type}`);
	                        }
	
	                        if (item.errors[i].hasOwnProperty("line")) {
	                            assert.equal(messages[i].line, item.errors[i].line, `Error line should be ${item.errors[i].line}`);
	                        }
	
	                        if (item.errors[i].hasOwnProperty("column")) {
	                            assert.equal(messages[i].column, item.errors[i].column, `Error column should be ${item.errors[i].column}`);
	                        }
	
	                        if (item.errors[i].hasOwnProperty("endLine")) {
	                            assert.equal(messages[i].endLine, item.errors[i].endLine, `Error endLine should be ${item.errors[i].endLine}`);
	                        }
	
	                        if (item.errors[i].hasOwnProperty("endColumn")) {
	                            assert.equal(messages[i].endColumn, item.errors[i].endColumn, `Error endColumn should be ${item.errors[i].endColumn}`);
	                        }
	                    } else {
	
	                        // Only string or object errors are valid.
	                        assert.fail(messages[i], null, "Error should be a string or object.");
	                    }
	                }
	
	                if (item.hasOwnProperty("output")) {
	                    const fixResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);
	
	                    assert.equal(fixResult.output, item.output, "Output is incorrect.");
	                }
	
	            }
	
	            assertASTDidntChange(result.beforeAST, result.afterAST);
	        }
	
	        /*
	         * This creates a mocha test suite and pipes all supplied info through
	         * one of the templates above.
	         */
	        RuleTester.describe(ruleName, function() {
	            RuleTester.describe("valid", function() {
	                test.valid.forEach(function(valid) {
	                    RuleTester.it(valid.code || valid, function() {
	                        testValidTemplate(ruleName, valid);
	                    });
	                });
	            });
	
	            RuleTester.describe("invalid", function() {
	                test.invalid.forEach(function(invalid) {
	                    RuleTester.it(invalid.code, function() {
	                        testInvalidTemplate(ruleName, invalid);
	                    });
	                });
	            });
	        });
	
	        return result.suite;
	    }
	};
	
	
	module.exports = RuleTester;


/***/ },
/* 392 */
/***/ function(module, exports) {

	module.exports = {
		"id": "http://json-schema.org/draft-04/schema#",
		"$schema": "http://json-schema.org/draft-04/schema#",
		"description": "Core schema meta-schema",
		"definitions": {
			"schemaArray": {
				"type": "array",
				"minItems": 1,
				"items": {
					"$ref": "#"
				}
			},
			"positiveInteger": {
				"type": "integer",
				"minimum": 0
			},
			"positiveIntegerDefault0": {
				"allOf": [
					{
						"$ref": "#/definitions/positiveInteger"
					},
					{
						"default": 0
					}
				]
			},
			"simpleTypes": {
				"enum": [
					"array",
					"boolean",
					"integer",
					"null",
					"number",
					"object",
					"string"
				]
			},
			"stringArray": {
				"type": "array",
				"items": {
					"type": "string"
				},
				"minItems": 1,
				"uniqueItems": true
			}
		},
		"type": "object",
		"properties": {
			"id": {
				"type": "string",
				"format": "uri"
			},
			"$schema": {
				"type": "string",
				"format": "uri"
			},
			"title": {
				"type": "string"
			},
			"description": {
				"type": "string"
			},
			"default": {},
			"multipleOf": {
				"type": "number",
				"minimum": 0,
				"exclusiveMinimum": true
			},
			"maximum": {
				"type": "number"
			},
			"exclusiveMaximum": {
				"type": "boolean",
				"default": false
			},
			"minimum": {
				"type": "number"
			},
			"exclusiveMinimum": {
				"type": "boolean",
				"default": false
			},
			"maxLength": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minLength": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"pattern": {
				"type": "string",
				"format": "regex"
			},
			"additionalItems": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"items": {
				"anyOf": [
					{
						"$ref": "#"
					},
					{
						"$ref": "#/definitions/schemaArray"
					}
				],
				"default": {}
			},
			"maxItems": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minItems": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"uniqueItems": {
				"type": "boolean",
				"default": false
			},
			"maxProperties": {
				"$ref": "#/definitions/positiveInteger"
			},
			"minProperties": {
				"$ref": "#/definitions/positiveIntegerDefault0"
			},
			"required": {
				"$ref": "#/definitions/stringArray"
			},
			"additionalProperties": {
				"anyOf": [
					{
						"type": "boolean"
					},
					{
						"$ref": "#"
					}
				],
				"default": {}
			},
			"definitions": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"properties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"patternProperties": {
				"type": "object",
				"additionalProperties": {
					"$ref": "#"
				},
				"default": {}
			},
			"dependencies": {
				"type": "object",
				"additionalProperties": {
					"anyOf": [
						{
							"$ref": "#"
						},
						{
							"$ref": "#/definitions/stringArray"
						}
					]
				}
			},
			"enum": {
				"type": "array",
				"minItems": 1,
				"uniqueItems": true
			},
			"type": {
				"anyOf": [
					{
						"$ref": "#/definitions/simpleTypes"
					},
					{
						"type": "array",
						"items": {
							"$ref": "#/definitions/simpleTypes"
						},
						"minItems": 1,
						"uniqueItems": true
					}
				]
			},
			"allOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"anyOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"oneOf": {
				"$ref": "#/definitions/schemaArray"
			},
			"not": {
				"$ref": "#"
			}
		},
		"dependencies": {
			"exclusiveMaximum": [
				"maximum"
			],
			"exclusiveMinimum": [
				"minimum"
			]
		},
		"default": {}
	};

/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @fileoverview An object that caches and applies source code fixes.
	 * @author Nicholas C. Zakas
	 */
	"use strict";
	
	//------------------------------------------------------------------------------
	// Requirements
	//------------------------------------------------------------------------------
	
	const debug = __webpack_require__(104)("eslint:text-fixer");
	
	//------------------------------------------------------------------------------
	// Helpers
	//------------------------------------------------------------------------------
	
	const BOM = "\uFEFF";
	
	/**
	 * Compares items in a messages array by line and column.
	 * @param {Message} a The first message.
	 * @param {Message} b The second message.
	 * @returns {int} -1 if a comes before b, 1 if a comes after b, 0 if equal.
	 * @private
	 */
	function compareMessagesByLocation(a, b) {
	    const lineDiff = a.line - b.line;
	
	    if (lineDiff === 0) {
	        return a.column - b.column;
	    } else {
	        return lineDiff;
	    }
	}
	
	//------------------------------------------------------------------------------
	// Public Interface
	//------------------------------------------------------------------------------
	
	/**
	 * Utility for apply fixes to source code.
	 * @constructor
	 */
	function SourceCodeFixer() {
	    Object.freeze(this);
	}
	
	/**
	 * Applies the fixes specified by the messages to the given text. Tries to be
	 * smart about the fixes and won't apply fixes over the same area in the text.
	 * @param {SourceCode} sourceCode The source code to apply the changes to.
	 * @param {Message[]} messages The array of messages reported by ESLint.
	 * @returns {Object} An object containing the fixed text and any unfixed messages.
	 */
	SourceCodeFixer.applyFixes = function(sourceCode, messages) {
	
	    debug("Applying fixes");
	
	    if (!sourceCode) {
	        debug("No source code to fix");
	        return {
	            fixed: false,
	            messages,
	            output: ""
	        };
	    }
	
	    // clone the array
	    const remainingMessages = [],
	        fixes = [],
	        text = sourceCode.text;
	    let lastFixPos = text.length + 1,
	        prefix = (sourceCode.hasBOM ? BOM : "");
	
	    messages.forEach(function(problem) {
	        if (problem.hasOwnProperty("fix")) {
	            fixes.push(problem);
	        } else {
	            remainingMessages.push(problem);
	        }
	    });
	
	    if (fixes.length) {
	        debug("Found fixes to apply");
	
	        // sort in reverse order of occurrence
	        fixes.sort(function(a, b) {
	            return b.fix.range[1] - a.fix.range[1] || b.fix.range[0] - a.fix.range[0];
	        });
	
	        // split into array of characters for easier manipulation
	        const chars = text.split("");
	
	        fixes.forEach(function(problem) {
	            const fix = problem.fix;
	            let start = fix.range[0];
	            const end = fix.range[1];
	            let insertionText = fix.text;
	
	            if (end < lastFixPos) {
	                if (start < 0) {
	
	                    // Remove BOM.
	                    prefix = "";
	                    start = 0;
	                }
	
	                if (start === 0 && insertionText[0] === BOM) {
	
	                    // Set BOM.
	                    prefix = BOM;
	                    insertionText = insertionText.slice(1);
	                }
	
	                chars.splice(start, end - start, insertionText);
	                lastFixPos = start;
	            } else {
	                remainingMessages.push(problem);
	            }
	        });
	
	        return {
	            fixed: true,
	            messages: remainingMessages.sort(compareMessagesByLocation),
	            output: prefix + chars.join("")
	        };
	    } else {
	        debug("No fixes to apply");
	        return {
	            fixed: false,
	            messages,
	            output: prefix + text
	        };
	    }
	};
	
	module.exports = SourceCodeFixer;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';var aa="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){if(c.get||c.set)throw new TypeError("ES3 does not support getters and setters.");a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)},r="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global&&null!=global?global:this;function t(){t=function(){};r.Symbol||(r.Symbol=ba)}var ca=0;function ba(a){return"jscomp_symbol_"+(a||"")+ca++}
	function w(){t();var a=r.Symbol.iterator;a||(a=r.Symbol.iterator=r.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&aa(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return y(this)}});w=function(){}}function y(a){var b=0;return da(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function da(a){w();a={next:a};a[r.Symbol.iterator]=function(){return this};return a};var B="constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");function E(a,b){for(var c,d,h=1;h<arguments.length;h++){d=arguments[h];for(c in d)a[c]=d[c];for(var p=0;p<B.length;p++)c=B[p],Object.prototype.hasOwnProperty.call(d,c)&&(a[c]=d[c])}};var ea=__webpack_require__(395);function fa(a){return function(b){return F(b,a)}}function F(a,b){var c={};return ea(a,b,function(a,b){if("function"===typeof b)return a=b(a),"object"===typeof a&&E(c,a),a})?c:!1}function ga(a){var b;return function(c){var d={},d=(d[a]=c,d);"object"===typeof b&&(b=fa(b));if("function"===typeof b){c=b(c);if("object"===typeof c)return E(d,c),d;if(!c)return!1}return d}}var G=F;function H(a,b){for(a=a.parent;!b(a)&&"Program"!==a.type;)a=a.parent;return b(a)?a:null}function I(a,b){b=void 0===b?"literal":b;return G(a,{type:"Literal",value:function(a){return"string"===typeof a&&ga(b)(a)}})}function K(a,b){return H(a,function(a){return a.type==b})}function L(a){return/^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/.test(a.type)}
	function ha(a){return G(a,{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"goog"},property:{type:"Identifier",name:"require"}},arguments:[function(a){return I(a,"source")}]}})}
	function ia(a){return G(a,{type:"ExpressionStatement",expression:{type:"CallExpression",callee:{type:"MemberExpression",object:{type:"Identifier",name:"goog"},property:{type:"Identifier",name:"provide"}},arguments:[function(a){return I(a,"source")}]}})}function ja(a){return G(a,{type:"ExpressionStatement",expression:function(a){return I(a,"directive")}})};var P={I:"constant",J:"leading",A:"no_underscore",K:"middle",L:"opt_prefix",M:"trailing",N:"var_args"};function ka(a){return""!==a&&a.length?a.toUpperCase()===a?P.I:-1===a.indexOf("_")?P.A:"var_args"===a?P.N:"opt_"===a.substring(0,4)&&"opt_"!=a?P.L:"_"===a[0]?P.J:"_"===a[a.length-1]?P.M:P.K:P.A}function Q(a){return"ClassExpression"===a.type||"ClassDeclaration"===a.type}function R(a){return a.loc.end.line===a.loc.start.line}function S(a,b){return a.loc.start.line===b.loc.start.line};var la={S:!1,P:!1,O:!0,R:!0,C:!0};
	function ma(a,b){function c(a){return Object.assign(p,{message:a})}function d(d,f){return na(d,a,b)?h:c(f)}var h={node:a,message:"",U:!1},p={node:a,message:"",U:!0};switch(ka(a.name)){case P.I:return h;case P.J:return b.O?d(a.name.replace(/^_+/g,"").replace(/_+$/g,""),"Identifier '"+a.name+"' is not in camel case after the leading underscore."):c("Leading underscores are not allowed in '"+a.name+"'.");case P.A:return h;case P.K:return d(a.name,"Identifier '"+a.name+"' is not in camel case.");case P.L:return b.P?
	d(a.name.replace(/^opt_/g,""),"Identifier '"+a.name+"' is not in camel case after the opt_ prefix."):c("The opt_ prefix is not allowed in '"+a.name+"'.");case P.M:return b.R?d(a.name.replace(/^_+/g,"").replace(/_+$/g,""),"Identifier '"+a.name+"' is not in camel case before the trailing underscore."):c("Trailing underscores are not allowed in '"+a.name+"'.");case P.N:return b.S?h:c("The var_args identifier is not allowed.");default:throw Error("Unknown undercore form: "+a.name);}}
	function na(a,b,c){var d=b.parent;if(!(-1<a.indexOf("_")))return!0;switch(d.type){case "MemberExpression":d=b.parent;if(!c.C)return!0;if(d.property===b)return d.parent&&"AssignmentExpression"===d.parent.type?d.parent.right===d:!0;break;case "Property":d=b.parent;if(!c.C||d.parent&&"ObjectPattern"===d.parent.type&&d.key===b&&d.value!==b)return!0;break;case "CallExpression":return!0}return!1};function T(a,b,c,d){a=d?b.getLastToken(a):b.getFirstToken(a);b=b.getText(a,a.loc.start.column).split("");a=b.slice(0,b.findIndex(function(a){return" "!==a&&"\t"!==a}));b=a.filter(function(a){return" "===a}).length;a=a.filter(function(a){return"\t"===a}).length;return{H:b,tab:a,b:"space"===c?b:a,B:"space"===c?a:b}}function U(a,b,c){b=!0===c?b.getLastToken(a,1):b.getTokenBefore(a);return(!0===c?a.loc.end.line:a.loc.start.line)!==(b?b.loc.end.line:-1)}
	function V(a,b){return!!b&&b.parent.loc.start.line===a.loc.start.line&&1<b.parent.declarations.length}function oa(a){if("CallExpression"!==a.parent.type)return!1;a=a.parent;if("MemberExpression"!==a.callee.type)return!1;a=a.callee;if("Identifier"!==a.object.type||"Identifier"!==a.property.type)return!1;var b=a.property;return"goog"===a.object.name&&"scope"===b.name}
	function pa(a){return a.declarations.reduce(function(b,c){var d=b[b.length-1];(c.loc.start.line!==a.loc.start.line&&!d||d&&d.loc.start.line!==c.loc.start.line)&&b.push(c);return b},[])}
	function qa(a){var b={D:4,F:"space",V:{SwitchCase:0,VariableDeclarator:{Y:1,W:1,T:1},l:-1,MemberExpression:-1,FunctionDeclaration:{h:-1,body:1},FunctionExpression:{h:-1,body:1}}},c=b.V;if(a.length&&("tab"===a[0]?(b.D=1,b.F="tab"):"number"===typeof a[0]&&(b.D=a[0],b.F="space"),a[1])){a=a[1];c.SwitchCase=a.SwitchCase||0;if("number"===typeof a.VariableDeclarator){var d=a.VariableDeclarator;c.VariableDeclarator={Y:d,W:d,T:d}}else"object"===typeof a.VariableDeclarator&&Object.assign(c.VariableDeclarator,
	a.VariableDeclarator);"number"===typeof a.l&&(c.l=a.l);"number"===typeof a.MemberExpression&&(c.MemberExpression=a.MemberExpression);"object"===typeof a.FunctionDeclaration&&Object.assign(c.FunctionDeclaration,a.FunctionDeclaration);"object"===typeof a.FunctionExpression&&Object.assign(c.FunctionExpression,a.FunctionExpression)}return b};var W=Array.prototype.indexOf?function(a,b,c){return Array.prototype.indexOf.call(a,b,c)}:function(a,b,c){c=null==c?0:0>c?Math.max(0,a.length+c):c;if("string"==typeof a)return"string"==typeof b&&1==b.length?a.indexOf(b,c):-1;for(;c<a.length;c++)if(c in a&&a[c]===b)return c;return-1};var ra=__webpack_require__(396);
	function X(a,b){b(a);if("NullableLiteral"!==a.type&&"AllLiteral"!==a.type&&"NullLiteral"!==a.type&&"UndefinedLiteral"!==a.type&&"VoidLiteral"!==a.type&&"StringLiteralType"!==a.type&&"NumericLiteralType"!==a.type&&"NameExpression"!==a.type)switch(a.type){case "ArrayType":a.elements.forEach(function(a){return X(a,b)});break;case "RecordType":a.fields.forEach(function(a){return X(a,b)});break;case "FunctionType":a.this&&X(a.this,b);a.params.forEach(function(a){return X(a,b)});a.result&&X(a.result,b);
	break;case "FieldType":a.value&&X(a.value,b);break;case "ParameterType":case "RestType":case "NonNullableType":case "OptionalType":case "NullableType":X(a.expression,b);break;case "TypeApplication":X(a.expression,b);a.applications.forEach(function(a){return X(a,b)});break;case "UnionType":a.elements.forEach(function(a){return X(a,b)});break;default:throw Error("Unrecoginized tag type.");}}function sa(a){return"Block"===a.type&&"*"===a.value.charAt(0)}
	function ta(a){var b=["FunctionExpression","ArrowFunctionExpression","ClassExpression"];return G(a,{type:"VariableDeclaration",declarations:[{type:"VariableDeclarator",init:function(a){return!!a&&-1!==b.indexOf(a.type)}}]})}function Y(a){return a.leadingComments&&a.leadingComments.length&&!ta(a)?a.leadingComments.filter(sa).reduce(function(a,c){return c||a},null):null}
	function ua(a){var b="type typedef record const private package protected public export".split(" ");return a.tags.some(function(a){return 0<=W(b,a.title)})}function va(a){try{return ra.parse(a,{ha:!0,unwrap:!0,sloppy:!0})}catch(b){if(/braces/i.test(b.message))throw Error("JSDoc type missing brace.");throw Error("JSDoc syntax error.");}};var wa=__webpack_require__(396);function xa(a){return null===a.type||a.type.name&&"void"===a.type.name||"UndefinedLiteral"===a.type.type}var ya="string number boolean Object Array Map Set".split(" ");function za(a,b){b.type&&X(b.type,function(b){"NameExpression"===b.type&&(b=b.name,-1!==ya.indexOf(b)||a.markVariableAsUsed(b))})};var Z={rules:{}};Z.rules.camelcase={meta:{docs:{description:"check identifiers for camel case with options for opt_ prefix and var_args identifiers",category:"Stylistic Issues",recommended:!0},schema:[{type:"object",properties:{S:{type:"boolean"},P:{type:"boolean"},O:{type:"boolean"},R:{type:"boolean"},C:{type:"boolean"}},i:!1}]},create:function(a){var b=Object.assign({},la,a.options[0]||{});return{Identifier:function(c){c=ma(c,b);c.U&&a.report({node:c.node,message:c.message})}}}};
	Z.rules.indent={meta:{docs:{description:"enforce consistent indentation",category:"Stylistic Issues",recommended:!1},fixable:"whitespace",schema:[{o:[{g:["tab"]},{type:"integer",c:0}]},{type:"object",properties:{SwitchCase:{type:"integer",c:0},VariableDeclarator:{o:[{type:"integer",c:0},{type:"object",properties:{Y:{type:"integer",c:0},W:{type:"integer",c:0},T:{type:"integer",c:0}}}]},l:{type:"integer",c:0},MemberExpression:{type:"integer",c:0},FunctionDeclaration:{type:"object",properties:{h:{o:[{type:"integer",
	c:0},{g:["first"]}]},body:{type:"integer",c:0}}},FunctionExpression:{type:"object",properties:{h:{o:[{type:"integer",c:0},{g:["first"]}]},body:{type:"integer",c:0}}}},i:!1}]},create:function(a){function b(a,b,c){a=a+" "+e+(1===a?"":"s");var g="space"+(1===b?"":"s"),z="tab"+(1===c?"":"s"),x;0<b&&0<c?x=b+" "+g+" and "+(c+" "+z):0<b?x="space"===e?b:b+" "+g:0<c?x="tab"===e?c:c+" "+z:x="0";return"Expected indentation of "+a+" but"+(" found "+x+".")}function c(g,c,x,d,f,C){var z=("space"===e?" ":"\t").repeat(c),
	l=C?[g.range[1]-x-d-1,g.range[1]-1]:[g.range[0]-x-d,g.range[0]];a.report({node:g,loc:f,message:b(c,x,d),fix:function(a){return a.replaceTextRange(l,z)}})}function d(a,b){var g=T(a,m,e,!1);"ArrayExpression"!==a.type&&"ObjectExpression"!==a.type&&(g.b!==b||g.B)&&U(a,m)&&c(a,b,g.H,g.tab)}function h(a,b){a.forEach(function(a){return d(a,b)})}function p(a,b){var g=m.getLastToken(a),z=T(g,m,e,!0);(z.b!==b||z.B)&&U(a,m,!0)&&c(a,b,z.H,z.tab,{start:{line:g.loc.start.line,column:g.loc.start.column}},!0)}function u(a){var g=
	T(a,m,e).b,b=a.parent;"Property"===b.type||"ArrayExpression"===b.type?g=T(a,m,e,!1).b:"CallExpression"===b.type&&1<=b.arguments.length&&b.arguments[0].loc.end.line>b.arguments[0].loc.start.line&&R(b.callee)&&!U(a,m)&&(g=T(b,m,e).b);return g}function f(a){var b=a.body,g=u(a),c=l,e;if(e=-1!==k.l)if(oa(a))e=!0;else{var d=a.parent;e=d.parent;if("CallExpression"!==d.type||d.callee!==a)e=!1;else{for(;"UnaryExpression"===e.type||"AssignmentExpression"===e.type||"LogicalExpression"===e.type||"SequenceExpression"===
	e.type||"VariableDeclarator"===e.type;)if("UnaryExpression"===e.type)if(d=e,"!"===d.operator||"~"===d.operator||"+"===d.operator||"-"===d.operator)e=e.parent;else break;else e=e.parent;e=("ExpressionStatement"===e.type||"VariableDeclaration"===e.type)&&e.parent&&"Program"===e.parent.type}}e?c=k.l*l:"FunctionExpression"===a.type?c=k.FunctionExpression.body*l:"FunctionDeclaration"===a.type&&(c=k.FunctionDeclaration.body*l);g+=c;(e=K(a,"VariableDeclarator"))&&V(a,e)&&(g+=l*k.VariableDeclarator[e.parent.kind]);
	v(b,g,g-c)}function n(a){if(!R(a)){var b=a.body;a=u(a);v(b,a+l,a)}}function D(a){var b=a.parent,g=K(a,"VariableDeclarator"),d=T(b,m,e).b;if(U(a,m)){if(g)if(b===g)g===g.parent.declarations[0]&&(d+=l*k.VariableDeclarator[g.parent.kind]);else{if("ObjectExpression"===b.type||"ArrayExpression"===b.type||"CallExpression"===b.type||"ArrowFunctionExpression"===b.type||"NewExpression"===b.type||"LogicalExpression"===b.type)d+=l}else("ArrayExpression"!==b.type?0:b.elements[0]&&"ObjectExpression"===b.elements[0].type&&
	b.elements[0].loc.start.line===b.loc.start.line)||"MemberExpression"===b.type||"ExpressionStatement"===b.type||"AssignmentExpression"===b.type||"Property"===b.type||(d+=l);var b=d+l,f=T(a,m,e,!1);(f.b!==d||f.B)&&U(a,m)&&c(a,d,f.H,f.tab,{start:{line:a.loc.start.line,column:a.loc.start.column}})}else d=T(a,m,e).b,b=d+l;V(a,g)&&(b+=l*k.VariableDeclarator[g.parent.kind]);return b}function v(a,b,c){R(a)||(h(a.body,b),p(a,c))}function q(a){var b=T(a,m,e).b,g=b+l;"BlockStatement"===a.body.type?v(a.body,
	g,b):h([a.body],g)}function A(a,b,c){"first"===c&&a.params.length?h(a.params.slice(1),a.params[0].loc.start.column):h(a.params,b*c)}function J(a,b){a="SwitchStatement"===a.type?a:a.parent;if(O[a.loc.start.line])return O[a.loc.start.line];"undefined"===typeof b&&(b=T(a,m,e).b);b=0<a.cases.length&&!k.SwitchCase?b:b+l*k.SwitchCase;return O[a.loc.start.line]=b}var C=qa(a.options),e=C.F,l=C.D,k=C.V,m=a.getSourceCode(),O={};return{Program:function(a){h(a.body,0)},ClassDeclaration:n,ClassExpression:n,BlockStatement:function(a){if(!R(a)&&
	("BlockStatement"==a.parent.type||"Program"==a.parent.type)){var b=T(a,m,e).b;v(a,b+l,b)}},DoWhileStatement:q,ForStatement:q,ForInStatement:q,ForOfStatement:q,WhileStatement:q,WithStatement:q,IfStatement:function(a){var b=T(a,m,e).b,c=b+l;"BlockStatement"!==a.consequent.type?S(a,a.consequent)||d(a.consequent,c):(h(a.consequent.body,c),p(a.consequent,b));if(a.alternate){var g=m.getTokenBefore(a.alternate);d(g,b);"BlockStatement"!==a.alternate.type?S(a.alternate,g)||d(a.alternate,c):(h(a.alternate.body,
	c),p(a.alternate,b))}},VariableDeclaration:function(a){if(!S(a.declarations[0],a.declarations[a.declarations.length-1])){var b=pa(a),c=T(a,m,e).b,g=b[b.length-1],c=c+l*k.VariableDeclarator[a.kind];h(b,c);m.getLastToken(a).loc.end.line<=g.loc.end.line||(b=m.getTokenBefore(g),","===b.value?p(a,T(b,m,e).b):p(a,c-l))}},ObjectExpression:function(a){if(!R(a)){var b=a.properties;if(!(0<b.length&&S(b[0],a))){var c=D(a);h(b,c);p(a,c-l)}}},ArrayExpression:function(a){if(!R(a)){var b=a.elements.filter(function(a){return null!==
	a});if(!(0<b.length&&S(b[0],a))){var c=D(a);h(b,c);p(a,c-l)}}},MemberExpression:function(a){if(-1!==k.MemberExpression&&!R(a)&&!K(a,"VariableDeclarator")&&!K(a,"AssignmentExpression")){var b=T(a,m,e).b+l*k.MemberExpression,c=[a.property];a=m.getTokenBefore(a.property);"Punctuator"===a.type&&"."===a.value&&c.push(a);h(c,b)}},SwitchStatement:function(a){var b=T(a,m,e).b,c=J(a,b);h(a.cases,c);p(a,b)},SwitchCase:function(a){if(!R(a)){var b=J(a);h(a.consequent,b+l)}},ArrowFunctionExpression:function(a){R(a)||
	"BlockStatement"===a.body.type&&f(a)},FunctionDeclaration:function(a){R(a)||(-1!==k.FunctionDeclaration.h&&A(a,l,k.FunctionDeclaration.h),f(a))},FunctionExpression:function(a){R(a)||(-1!==k.FunctionExpression.h&&A(a,l,k.FunctionExpression.h),f(a))}}}};
	Z.rules["inline-comment-spacing"]={meta:{docs:{description:"enforce consistent spacing before the `//` at line end",category:"Stylistic Issues",recommended:!1},fixable:"whitespace",schema:[{type:"integer",c:0,ja:5}]},create:function(a){var b=null==a.options[0]?1:a.options[0];return{LineComment:function(c){var d=a.getSourceCode();d.getComments(c);if((d=d.getTokenBefore(c,1)||d.getTokenOrCommentBefore(c))&&c.loc.end.line===d.loc.start.line){var h=c.start-d.end;h<b&&a.report({node:c,message:"Expected at least "+
	b+" "+(1===b?"space":"spaces")+" before inline comment.",fix:function(a){return a.insertTextBefore(c,Array(b-h+1).join(" "))}})}}}}};
	Z.rules.jsdoc={meta:{docs:{description:"enforce valid JSDoc comments",category:"Possible Errors",recommended:!0},schema:[{type:"object",properties:{aa:{type:"object",i:{type:"string"}},ba:{type:"object",i:{type:"string"}},da:{type:"boolean"},ca:{type:"boolean"},ea:{type:"boolean"},X:{type:"string"},fa:{type:"boolean"}},i:!1}]},create:function(a){function b(a){h.push({G:"ArrowFunctionExpression"===a.type&&"BlockStatement"!==a.body.type||Q(a)})}function c(b,c){X(c,function(c){if("NameExpression"===
	c.type){c=c.name;var e=A[c];e&&a.report({node:b,message:"Use '"+e+"' instead of '"+c+"'."})}})}function d(b){var e=p.getJSDocComment(b),d=h.pop(),k=Object.create(null),m=!1,C=!1,g=!1,A=!1,x=!1,M;if(e){try{M=wa.parse(e.value,{ha:!0,unwrap:!0,sloppy:!0})}catch(Aa){/braces/i.test(Aa.message)?a.report({node:e,message:"JSDoc type missing brace."}):a.report({node:e,message:"JSDoc syntax error."});return}M.tags.forEach(function(b){switch(b.title.toLowerCase()){case "param":case "arg":case "argument":b.type||
	a.report({node:e,message:"Missing JSDoc parameter type for '"+b.name+"'."});!b.description&&D&&a.report({node:e,message:"Missing JSDoc parameter description for "+("'"+b.name+"'.")});k[b.name]?a.report({node:e,message:"Duplicate JSDoc parameter '"+b.name+"'."}):-1===b.name.indexOf(".")&&(k[b.name]=1);break;case "return":case "returns":m=!0;n||d.G||null!==b.type&&xa(b)||x?(q&&!b.type&&a.report({node:e,message:"Missing JSDoc return type."}),xa(b)||b.description||!v||a.report({node:e,message:"Missing JSDoc return description."})):
	a.report({node:e,message:"Unexpected @{{title}} tag; function has no return statement.",data:{title:b.title}});break;case "constructor":case "class":C=!0;break;case "override":case "inheritdoc":A=!0;break;case "abstract":case "virtual":x=!0;break;case "interface":g=!0}f.hasOwnProperty(b.title)&&b.title!==f[b.title]&&a.report({node:e,message:"Use @{{name}} instead.",data:{name:f[b.title]}});za(a,b);J&&b.type&&c(e,b.type)});A||m||C||g||"FunctionExpression"===b.type&&b.parent&&"Property"===b.parent.type&&
	"get"===b.parent.kind||"FunctionExpression"===b.type&&b.parent&&"Property"===b.parent.type&&"set"===b.parent.kind||"FunctionExpression"===b.type&&b.parent&&"MethodDefinition"===b.parent.type&&"constructor"===b.parent.kind||Q(b)||(n||d.G)&&a.report({node:e,message:"Missing JSDoc @{{returns}} for function.",data:{ga:f.ga||"returns"}});var N=Object.keys(k);b.params&&b.params.forEach(function(b,c){"AssignmentPattern"===b.type&&(b=b.left);var d=b.name;"Identifier"===b.type&&(N[c]&&d!==N[c]?a.report({node:e,
	message:"Expected JSDoc for '"+d+"' but found "+("'"+N[c]+"'.")}):k[d]||A||a.report({node:e,message:"Missing JSDoc for parameter '"+d+"'."}))});u.X&&((new RegExp(u.X)).test(M.description)||a.report({node:e,message:"JSDoc description does not satisfy the regex pattern."}))}}var h=[],p=a.getSourceCode(),u=a.options[0]||{},f=u.aa||{},n=!1!==u.da,D=!1!==u.ca,v=!1!==u.ea,q=!1!==u.fa,A=u.ba||{},J=!!Object.keys(A).length;return{ArrowFunctionExpression:b,FunctionExpression:b,FunctionDeclaration:b,ClassExpression:b,
	ClassDeclaration:b,"ArrowFunctionExpression:exit":d,"FunctionExpression:exit":d,"FunctionDeclaration:exit":d,"ClassExpression:exit":d,"ClassDeclaration:exit":d,ReturnStatement:function(a){var b=h[h.length-1];b&&null!==a.argument&&(b.G=!0)},VariableDeclaration:function(b){if(1===b.declarations.length){var c=Y(b);if(c){var d;try{d=va(c.value)}catch(k){return}b=b.declarations[0];"Identifier"===b.id.type&&(b=b.id.name,ua(d)&&a.markVariableAsUsed(b),d.tags.forEach(function(b){za(a,b)}))}}}}}};
	Z.rules["no-undef"]={meta:{docs:{description:"disallow the use of undeclared variables unless mentioned in `/*global */` comments",category:"Variables",recommended:!0},schema:[{type:"object",properties:{ia:{type:"boolean"}},i:!1}]},create:function(a){var b=a.options[0],c=b&&!0===b.ia||!1,d=[],h=[];return{Program:function(a){d=a.body.map(ha).filter(function(a){return!!a}).map(function(a){return a.source});h=a.body.map(ia).filter(function(a){return!!a}).map(function(a){return a.source})},"Program:exit":function(){function b(a){return d.some(function(b){return a.startsWith(b)?
	a===b||"."===a[b.length]:!1})}function u(a){return h.some(function(b){return a.startsWith(b)?a===b||"."===a[b.length]:!1})}a.getScope().through.forEach(function(d){d=d.identifier;for(var f=d.name,h=d;h.parent&&"MemberExpression"==h.parent.type;)h=h.parent,f+="."+h.property.name;(h=c)||(h=d.parent,h=!("UnaryExpression"===h.type&&"typeof"===h.operator));h&&(u(f)||b(f)||a.report({node:d,message:"'"+d.name+"' is not defined."}))})}}}};
	Z.rules["no-unused-expressions"]={meta:{docs:{description:"disallow unused expressions",category:"Best Practices",recommended:!1},schema:[{type:"object",properties:{Z:{type:"boolean"},$:{type:"boolean"}},i:!1}]},create:function(a){function b(a){if(h&&"ConditionalExpression"===a.type)return b(a.consequent)&&b(a.alternate);if(d&&"LogicalExpression"===a.type)return b(a.right);var c=/^(?:Assignment|Call|New|Update|Yield|Await)Expression$/.test(a.type);a="UnaryExpression"===a.type&&0<=["delete","void"].indexOf(a.operator);
	return c||a}var c=a.options[0]||{},d=c.Z||!1,h=c.$||!1;return{ExpressionStatement:function(c){var d;if(!(d=b(c.expression))){var f=a.getAncestors();d=f[f.length-1];f=f[f.length-2];f="BlockStatement"===d.type&&/Function/.test(f.type);if("Program"===d.type||f){a:{d=d.body;for(f=0;f<d.length;++f)if(!ja(d[f])){d=d.slice(0,f);break a}d=d.slice()}d=0<=W(d,c)}else d=!1}if(!d)if(f=Y(c))try{var h=va(f.value);d=ua(h)}catch(D){d=!1}else d=!1;d||a.report({node:c,message:"Expected an assignment or function call and instead saw an expression."})}}}};
	Z.rules["no-unused-vars"]={meta:{docs:{description:"disallow unused variables",category:"Variables",recommended:!0},schema:[{o:[{g:["all","local"]},{type:"object",properties:{m:{g:["all","local"]},v:{type:"string"},j:{g:["all","after-used","none"]},f:{type:"string"},s:{g:["all","none"]},u:{type:"string"},w:{type:"boolean"}}}]}]},create:function(a){function b(a,b){return a.range[0]>=b.range[0]&&a.range[1]<=b.range[1]}function c(a,c){var d=a;for(a=a.parent;a&&b(a,c);){switch(a.type){case "SequenceExpression":var f=
	a;if(f.expressions[f.expressions.length-1]!==d)return!1;break;case "CallExpression":case "NewExpression":return a.callee!==d;case "AssignmentExpression":case "TaggedTemplateExpression":case "YieldExpression":return!0;default:if(D.test(a.type))return!0}d=a;a=a.parent}return!1}function d(a){var d=a.defs.filter(function(a){return"FunctionName"===a.type}).map(function(a){return a.node}),f=0<d.length,h=null;return a.references.some(function(a){var e;e=a.identifier.parent;"VariableDeclarator"===e.type&&
	(e=e.parent.parent);"ForInStatement"!==e.type?e=!1:("BlockStatement"===e.body.type?e=e.body.body[0]:e=e.body,e=e?"ReturnStatement"===e.type:!1);if(e)return!0;e=h;var l=a.identifier,k=l.parent,m=k.parent,v;if(v=a.isRead())!(k="AssignmentExpression"===k.type&&"ExpressionStatement"===m.type&&k.left===l||"UpdateExpression"===k.type&&"ExpressionStatement"===m.type)&&(k=e&&b(l,e))&&(l=H(l,L),k=!(l&&b(l,e)&&c(l,e))),v=k;e=v;l=h;k=a.identifier;m=k.parent;v=m.parent;var g;if(!(g=a.from.variableScope!==a.resolved.scope.variableScope))a:{for(g=
	k;g;){if(/^(?:DoWhile|For|ForIn|ForOf|While)Statement$/.test(g.type)){g=!0;break a}if(L(g))break;g=g.parent}g=!1}h=l&&b(k,l)?l:"AssignmentExpression"!==m.type||"ExpressionStatement"!==v.type||k!==m.left||g?null:m.right;if(e=a.isRead()&&!e){if(e=f)a:{for(a=a.from;a;){if(0<=d.indexOf(a.block)){e=!0;break a}a=a.upper}e=!1}e=!e}return e})}function h(b){var c=b.defs[0];return c.index===c.node.params.length-1||f.f&&(c=a.getDeclaredVariables(c.node),c.slice(c.indexOf(b)+1).every(function(a){return!a.references.length&&
	f.f.test(a.name)}))?!0:!1}function p(a,b){var c=a.variables,v=a.childScopes,q,e;if("TDZ"!==a.type&&("global"!==a.type||"all"===f.m))for(q=0,e=c.length;q<e;++q){var l=c[q];if(!("class"===a.type&&a.block.id===l.identifiers[0]||a.functionExpressionScope||l.o||"function"===a.type&&"arguments"===l.name&&!l.identifiers.length)){var k=l.defs[0];if(k){var m=k.type;if("CatchClause"===m){if("none"===f.s)continue;if(f.u&&f.u.test(k.name.name))continue}if("Parameter"===m){if("Property"===k.node.parent.type&&
	"set"===k.node.parent.kind)continue;if("none"===f.j)continue;if(f.f&&f.f.test(k.name.name))continue;if("after-used"===f.j&&!h(l))continue}else if(f.v&&f.v.test(k.name.name))continue}if(!(k=d(l)))a:if(k=l.defs[0]){m=k.node;if("VariableDeclarator"===m.type)m=m.parent;else if("Parameter"===k.type){k=!1;break a}k=!m.parent.type.indexOf("Export")}else k=!1;k||b.push(l)}}q=0;for(e=v.length;q<e;++q)p(v[q],b);return b}function u(a){var b=a.eslintExplicitGlobalComment,c=b.loc.start;a=new RegExp("[\\s,]"+String(a.name).replace(/[\\^$*+?.()|[\]{}]/g,
	"\\$&")+"(?:$|[\\s,:])","g");a.lastIndex=b.value.indexOf("global")+6;a=(a=a.exec(b.value))?a.index+1:0;var b=b.value.slice(0,a),d=(b.match(/\n/g)||[]).length;a=0<d?a-(1+b.lastIndexOf("\n")):a+(c.column+2);return{start:{line:c.line+d,column:a}}}var f={m:"all",j:"after-used",s:"none",w:!1},n=a.options[0];n&&("string"===typeof n?f.m=n:(f.m=n.m||f.m,f.j=n.j||f.j,f.s=n.s||f.s,n.v&&(f.v=new RegExp(n.v)),n.f&&(f.f=new RegExp(n.f)),n.u&&(f.u=new RegExp(n.u)),n.w&&(f.w=n.w)));var D=/(?:Statement|Declaration)$/;
	return{"Program:exit":function(b){var c=p(a.getScope(),[]);w();for(var d=c[Symbol.iterator],c=d?d.call(c):y(c),d=c.next();!d.done;d=c.next())d=d.value,d.g?a.report({node:b,loc:u(d),message:"'{{name}}' is defined but never used.",data:d}):0<d.defs.length&&a.report({node:d.identifiers[0],message:"'{{name}}' is defined but never used.",data:d})}}}};module.exports=Z;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	
	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;
	
	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';
	
	/** Used to compose bitmasks for comparison styles. */
	var UNORDERED_COMPARE_FLAG = 1,
	    PARTIAL_COMPARE_FLAG = 2;
	
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;
	
	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';
	
	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';
	
	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
	
	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;
	
	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;
	
	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;
	
	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;
	
	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
	
	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();
	
	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
	
	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;
	
	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;
	
	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;
	
	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding('util');
	  } catch (e) {}
	}());
	
	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
	
	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array ? array.length : 0;
	
	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);
	
	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}
	
	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}
	
	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}
	
	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}
	
	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);
	
	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}
	
	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}
	
	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);
	
	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}
	
	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;
	
	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];
	
	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());
	
	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;
	
	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;
	
	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;
	
	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);
	
	/** Built-in value references. */
	var Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;
	
	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);
	
	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');
	
	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);
	
	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
	
	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}
	
	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}
	
	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}
	
	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}
	
	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}
	
	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;
	
	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}
	
	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}
	
	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  return index < 0 ? undefined : data[index][1];
	}
	
	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}
	
	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);
	
	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}
	
	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;
	
	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;
	
	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}
	
	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}
	
	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}
	
	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}
	
	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}
	
	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}
	
	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;
	
	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values ? values.length : 0;
	
	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}
	
	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}
	
	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}
	
	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;
	
	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}
	
	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}
	
	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}
	
	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}
	
	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}
	
	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}
	
	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;
	
	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];
	
	  var length = result.length,
	      skipIndexes = !!length;
	
	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}
	
	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}
	
	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {boolean} [bitmask] The bitmask of comparison flags.
	 *  The bitmask may be composed of the following flags:
	 *     1 - Unordered comparison
	 *     2 - Partial comparison
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, customizer, bitmask, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
	}
	
	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = arrayTag,
	      othTag = arrayTag;
	
	  if (!objIsArr) {
	    objTag = getTag(object);
	    objTag = objTag == argsTag ? objectTag : objTag;
	  }
	  if (!othIsArr) {
	    othTag = getTag(other);
	    othTag = othTag == argsTag ? objectTag : othTag;
	  }
	  var objIsObj = objTag == objectTag && !isHostObject(object),
	      othIsObj = othTag == objectTag && !isHostObject(other),
	      isSameTag = objTag == othTag;
	
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
	      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
	  }
	  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
	
	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;
	
	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
	}
	
	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;
	
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];
	
	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}
	
	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}
	
	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
	}
	
	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      arrLength = array.length,
	      othLength = other.length;
	
	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;
	
	  stack.set(array, other);
	  stack.set(other, array);
	
	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!seen.has(othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
	              return seen.add(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, customizer, bitmask, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;
	
	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;
	
	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);
	
	    case errorTag:
	      return object.name == other.name && object.message == other.message;
	
	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');
	
	    case mapTag:
	      var convert = mapToArray;
	
	    case setTag:
	      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
	      convert || (convert = setToArray);
	
	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= UNORDERED_COMPARE_FLAG;
	
	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
	      stack['delete'](object);
	      return result;
	
	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}
	
	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
	 *  for more details.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
	  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
	      objProps = keys(object),
	      objLength = objProps.length,
	      othProps = keys(other),
	      othLength = othProps.length;
	
	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);
	
	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];
	
	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;
	
	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}
	
	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}
	
	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;
	
	  while (length--) {
	    var key = result[length],
	        value = object[key];
	
	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}
	
	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}
	
	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;
	
	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;
	
	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}
	
	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}
	
	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}
	
	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}
	
	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;
	
	  return value === proto;
	}
	
	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}
	
	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}
	
	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}
	
	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}
	
	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;
	
	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}
	
	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}
	
	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}
	
	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}
	
	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}
	
	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}
	
	/**
	 * This method is like `_.isMatch` except that it accepts `customizer` which
	 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	 * are handled by the method instead. The `customizer` is invoked with five
	 * arguments: (objValue, srcValue, index|key, object, source).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 * @example
	 *
	 * function isGreeting(value) {
	 *   return /^h(?:i|ello)$/.test(value);
	 * }
	 *
	 * function customizer(objValue, srcValue) {
	 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	 *     return true;
	 *   }
	 * }
	 *
	 * var object = { 'greeting': 'hello' };
	 * var source = { 'greeting': 'hi' };
	 *
	 * _.isMatchWith(object, source, customizer);
	 * // => true
	 */
	function isMatchWith(object, source, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseIsMatch(object, source, getMatchData(source), customizer);
	}
	
	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
	
	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}
	
	module.exports = isMatchWith;
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(136)(module)))

/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Main Doctrine object
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 * @author Dan Tao <daniel.tao@gmail.com>
	 * @author Andrew Eisenberg <andrew@eisenberg.as>
	 */
	
	(function () {
	    'use strict';
	
	    var typed,
	        utility,
	        isArray,
	        jsdoc,
	        esutils,
	        hasOwnProperty;
	
	    esutils = __webpack_require__(110);
	    isArray = __webpack_require__(365);
	    typed = __webpack_require__(397);
	    utility = __webpack_require__(398);
	
	    function sliceSource(source, index, last) {
	        return source.slice(index, last);
	    }
	
	    hasOwnProperty = (function () {
	        var func = Object.prototype.hasOwnProperty;
	        return function hasOwnProperty(obj, name) {
	            return func.call(obj, name);
	        };
	    }());
	
	    function shallowCopy(obj) {
	        var ret = {}, key;
	        for (key in obj) {
	            if (obj.hasOwnProperty(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	
	    function isASCIIAlphanumeric(ch) {
	        return (ch >= 0x61  /* 'a' */ && ch <= 0x7A  /* 'z' */) ||
	            (ch >= 0x41  /* 'A' */ && ch <= 0x5A  /* 'Z' */) ||
	            (ch >= 0x30  /* '0' */ && ch <= 0x39  /* '9' */);
	    }
	
	    function isParamTitle(title) {
	        return title === 'param' || title === 'argument' || title === 'arg';
	    }
	
	    function isReturnTitle(title) {
	        return title === 'return' || title === 'returns';
	    }
	
	    function isProperty(title) {
	        return title === 'property' || title === 'prop';
	    }
	
	    function isNameParameterRequired(title) {
	        return isParamTitle(title) || isProperty(title) ||
	            title === 'alias' || title === 'this' || title === 'mixes' || title === 'requires';
	    }
	
	    function isAllowedName(title) {
	        return isNameParameterRequired(title) || title === 'const' || title === 'constant';
	    }
	
	    function isAllowedNested(title) {
	        return isProperty(title) || isParamTitle(title);
	    }
	
	    function isAllowedOptional(title) {
	        return isProperty(title) || isParamTitle(title);
	    }
	
	    function isTypeParameterRequired(title) {
	        return isParamTitle(title) || isReturnTitle(title) ||
	            title === 'define' || title === 'enum' ||
	            title === 'implements' || title === 'this' ||
	            title === 'type' || title === 'typedef' || isProperty(title);
	    }
	
	    // Consider deprecation instead using 'isTypeParameterRequired' and 'Rules' declaration to pick when a type is optional/required
	    // This would require changes to 'parseType'
	    function isAllowedType(title) {
	        return isTypeParameterRequired(title) || title === 'throws' || title === 'const' || title === 'constant' ||
	            title === 'namespace' || title === 'member' || title === 'var' || title === 'module' ||
	            title === 'constructor' || title === 'class' || title === 'extends' || title === 'augments' ||
	            title === 'public' || title === 'private' || title === 'protected';
	    }
	
	    function trim(str) {
	        return str.replace(/^\s+/, '').replace(/\s+$/, '');
	    }
	
	    function unwrapComment(doc) {
	        // JSDoc comment is following form
	        //   /**
	        //    * .......
	        //    */
	        // remove /**, */ and *
	        var BEFORE_STAR = 0,
	            STAR = 1,
	            AFTER_STAR = 2,
	            index,
	            len,
	            mode,
	            result,
	            ch;
	
	        doc = doc.replace(/^\/\*\*?/, '').replace(/\*\/$/, '');
	        index = 0;
	        len = doc.length;
	        mode = BEFORE_STAR;
	        result = '';
	
	        while (index < len) {
	            ch = doc.charCodeAt(index);
	            switch (mode) {
	            case BEFORE_STAR:
	                if (esutils.code.isLineTerminator(ch)) {
	                    result += String.fromCharCode(ch);
	                } else if (ch === 0x2A  /* '*' */) {
	                    mode = STAR;
	                } else if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                    mode = AFTER_STAR;
	                }
	                break;
	
	            case STAR:
	                if (!esutils.code.isWhiteSpace(ch)) {
	                    result += String.fromCharCode(ch);
	                }
	                mode = esutils.code.isLineTerminator(ch) ? BEFORE_STAR : AFTER_STAR;
	                break;
	
	            case AFTER_STAR:
	                result += String.fromCharCode(ch);
	                if (esutils.code.isLineTerminator(ch)) {
	                    mode = BEFORE_STAR;
	                }
	                break;
	            }
	            index += 1;
	        }
	
	        return result.replace(/\s+$/, '');
	    }
	
	    // JSDoc Tag Parser
	
	    (function (exports) {
	        var Rules,
	            index,
	            lineNumber,
	            length,
	            source,
	            recoverable,
	            sloppy,
	            strict;
	
	        function advance() {
	            var ch = source.charCodeAt(index);
	            index += 1;
	            if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(index) === 0x0A  /* '\n' */)) {
	                lineNumber += 1;
	            }
	            return String.fromCharCode(ch);
	        }
	
	        function scanTitle() {
	            var title = '';
	            // waste '@'
	            advance();
	
	            while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
	                title += advance();
	            }
	
	            return title;
	        }
	
	        function seekContent() {
	            var ch, waiting, last = index;
	
	            waiting = false;
	            while (last < length) {
	                ch = source.charCodeAt(last);
	                if (esutils.code.isLineTerminator(ch) && !(ch === 0x0D  /* '\r' */ && source.charCodeAt(last + 1) === 0x0A  /* '\n' */)) {
	                    waiting = true;
	                } else if (waiting) {
	                    if (ch === 0x40  /* '@' */) {
	                        break;
	                    }
	                    if (!esutils.code.isWhiteSpace(ch)) {
	                        waiting = false;
	                    }
	                }
	                last += 1;
	            }
	            return last;
	        }
	
	        // type expression may have nest brace, such as,
	        // { { ok: string } }
	        //
	        // therefore, scanning type expression with balancing braces.
	        function parseType(title, last) {
	            var ch, brace, type, direct = false;
	
	
	            // search '{'
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isWhiteSpace(ch)) {
	                    advance();
	                } else if (ch === 0x7B  /* '{' */) {
	                    advance();
	                    break;
	                } else {
	                    // this is direct pattern
	                    direct = true;
	                    break;
	                }
	            }
	
	
	            if (direct) {
	                return null;
	            }
	
	            // type expression { is found
	            brace = 1;
	            type = '';
	            while (index < last) {
	                ch = source.charCodeAt(index);
	                if (esutils.code.isLineTerminator(ch)) {
	                    advance();
	                } else {
	                    if (ch === 0x7D  /* '}' */) {
	                        brace -= 1;
	                        if (brace === 0) {
	                            advance();
	                            break;
	                        }
	                    } else if (ch === 0x7B  /* '{' */) {
	                        brace += 1;
	                    }
	                    type += advance();
	                }
	            }
	
	            if (brace !== 0) {
	                // braces is not balanced
	                return utility.throwError('Braces are not balanced');
	            }
	
	            if (isAllowedOptional(title)) {
	                return typed.parseParamType(type);
	            }
	
	            return typed.parseType(type);
	        }
	
	        function scanIdentifier(last) {
	            var identifier;
	            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
	                return null;
	            }
	            identifier = advance();
	            while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
	                identifier += advance();
	            }
	            return identifier;
	        }
	
	        function skipWhiteSpace(last) {
	            while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
	                advance();
	            }
	        }
	
	        function parseName(last, allowBrackets, allowNestedParams) {
	            var name = '',
	                useBrackets,
	                insideString;
	
	
	            skipWhiteSpace(last);
	
	            if (index >= last) {
	                return null;
	            }
	
	            if (allowBrackets && source.charCodeAt(index) === 0x5B  /* '[' */) {
	                useBrackets = true;
	                name = advance();
	            }
	
	            if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index))) {
	                return null;
	            }
	
	            name += scanIdentifier(last);
	
	            if (allowNestedParams) {
	                if (source.charCodeAt(index) === 0x3A /* ':' */ && (
	                        name === 'module' ||
	                        name === 'external' ||
	                        name === 'event')) {
	                    name += advance();
	                    name += scanIdentifier(last);
	
	                }
	                if(source.charCodeAt(index) === 0x5B  /* '[' */ && source.charCodeAt(index + 1) === 0x5D  /* ']' */){
	                    name += advance();
	                    name += advance();
	                }
	                while (source.charCodeAt(index) === 0x2E  /* '.' */ ||
	                        source.charCodeAt(index) === 0x2F  /* '/' */ ||
	                        source.charCodeAt(index) === 0x23  /* '#' */ ||
	                        source.charCodeAt(index) === 0x2D  /* '-' */ ||
	                        source.charCodeAt(index) === 0x7E  /* '~' */) {
	                    name += advance();
	                    name += scanIdentifier(last);
	                }
	            }
	
	            if (useBrackets) {
	                skipWhiteSpace(last);
	                // do we have a default value for this?
	                if (source.charCodeAt(index) === 0x3D  /* '=' */) {
	                    // consume the '='' symbol
	                    name += advance();
	                    skipWhiteSpace(last);
	
	                    var ch;
	                    var bracketDepth = 1;
	
	                    // scan in the default value
	                    while (index < last) {
	                        ch = source.charCodeAt(index);
	
	                        if (esutils.code.isWhiteSpace(ch)) {
	                            if (!insideString) {
	                                skipWhiteSpace(last);
	                                ch = source.charCodeAt(index);
	                            }
	                        }
	
	                        if (ch === 0x27 /* ''' */) {
	                            if (!insideString) {
	                                insideString = '\'';
	                            } else {
	                                if (insideString === '\'') {
	                                    insideString = '';
	                                }
	                            }
	                        }
	
	                        if (ch === 0x22 /* '"' */) {
	                            if (!insideString) {
	                                insideString = '"';
	                            } else {
	                                if (insideString === '"') {
	                                    insideString = '';
	                                }
	                            }
	                        }
	
	                        if (ch === 0x5B /* '[' */) {
	                            bracketDepth++;
	                        } else if (ch === 0x5D  /* ']' */ &&
	                            --bracketDepth === 0) {
	                            break;
	                        }
	
	                        name += advance();
	                    }
	                }
	
	                skipWhiteSpace(last);
	
	                if (index >= last || source.charCodeAt(index) !== 0x5D  /* ']' */) {
	                    // we never found a closing ']'
	                    return null;
	                }
	
	                // collect the last ']'
	                name += advance();
	            }
	
	            return name;
	        }
	
	        function skipToTag() {
	            while (index < length && source.charCodeAt(index) !== 0x40  /* '@' */) {
	                advance();
	            }
	            if (index >= length) {
	                return false;
	            }
	            utility.assert(source.charCodeAt(index) === 0x40  /* '@' */);
	            return true;
	        }
	
	        function TagParser(options, title) {
	            this._options = options;
	            this._title = title.toLowerCase();
	            this._tag = {
	                title: title,
	                description: null
	            };
	            if (this._options.lineNumbers) {
	                this._tag.lineNumber = lineNumber;
	            }
	            this._last = 0;
	            // space to save special information for title parsers.
	            this._extra = { };
	        }
	
	        // addError(err, ...)
	        TagParser.prototype.addError = function addError(errorText) {
	            var args = Array.prototype.slice.call(arguments, 1),
	                msg = errorText.replace(
	                    /%(\d)/g,
	                    function (whole, index) {
	                        utility.assert(index < args.length, 'Message reference must be in range');
	                        return args[index];
	                    }
	                );
	
	            if (!this._tag.errors) {
	                this._tag.errors = [];
	            }
	            if (strict) {
	                utility.throwError(msg);
	            }
	            this._tag.errors.push(msg);
	            return recoverable;
	        };
	
	        TagParser.prototype.parseType = function () {
	            // type required titles
	            if (isTypeParameterRequired(this._title)) {
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                    if (!this._tag.type) {
	                        if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
	                            if (!this.addError('Missing or invalid tag type')) {
	                                return false;
	                            }
	                        }
	                    }
	                } catch (error) {
	                    this._tag.type = null;
	                    if (!this.addError(error.message)) {
	                        return false;
	                    }
	                }
	            } else if (isAllowedType(this._title)) {
	                // optional types
	                try {
	                    this._tag.type = parseType(this._title, this._last);
	                } catch (e) {
	                    //For optional types, lets drop the thrown error when we hit the end of the file
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype._parseNamePath = function (optional) {
	            var name;
	            name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
	            if (!name) {
	                if (!optional) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }
	            this._tag.name = name;
	            return true;
	        };
	
	        TagParser.prototype.parseNamePath = function () {
	            return this._parseNamePath(false);
	        };
	
	        TagParser.prototype.parseNamePathOptional = function () {
	            return this._parseNamePath(true);
	        };
	
	
	        TagParser.prototype.parseName = function () {
	            var assign, name;
	
	            // param, property requires name
	            if (isAllowedName(this._title)) {
	                this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
	                if (!this._tag.name) {
	                    if (!isNameParameterRequired(this._title)) {
	                        return true;
	                    }
	
	                    // it's possible the name has already been parsed but interpreted as a type
	                    // it's also possible this is a sloppy declaration, in which case it will be
	                    // fixed at the end
	                    if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
	                        this._extra.name = this._tag.type;
	                        this._tag.name = this._tag.type.name;
	                        this._tag.type = null;
	                    } else {
	                        if (!this.addError('Missing or invalid tag name')) {
	                            return false;
	                        }
	                    }
	                } else {
	                    name = this._tag.name;
	                    if (name.charAt(0) === '[' && name.charAt(name.length - 1) === ']') {
	                        // extract the default value if there is one
	                        // example: @param {string} [somebody=John Doe] description
	                        assign = name.substring(1, name.length - 1).split('=');
	                        if (assign[1]) {
	                            this._tag['default'] = assign[1];
	                        }
	                        this._tag.name = assign[0];
	
	                        // convert to an optional type
	                        if (this._tag.type && this._tag.type.type !== 'OptionalType') {
	                            this._tag.type = {
	                                type: 'OptionalType',
	                                expression: this._tag.type
	                            };
	                        }
	                    }
	                }
	            }
	
	
	            return true;
	        };
	
	        TagParser.prototype.parseDescription = function parseDescription() {
	            var description = trim(sliceSource(source, index, this._last));
	            if (description) {
	                if ((/^-\s+/).test(description)) {
	                    description = description.substring(2);
	                }
	                this._tag.description = description;
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseCaption = function parseDescription() {
	            var description = trim(sliceSource(source, index, this._last));
	            var captionStartTag = '<caption>';
	            var captionEndTag = '</caption>';
	            var captionStart = description.indexOf(captionStartTag);
	            var captionEnd = description.indexOf(captionEndTag);
	            if (captionStart >= 0 && captionEnd >= 0) {
	                this._tag.caption = trim(description.substring(
	                    captionStart + captionStartTag.length, captionEnd));
	                this._tag.description = trim(description.substring(captionEnd + captionEndTag.length));
	            } else {
	                this._tag.description = description;
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseKind = function parseKind() {
	            var kind, kinds;
	            kinds = {
	                'class': true,
	                'constant': true,
	                'event': true,
	                'external': true,
	                'file': true,
	                'function': true,
	                'member': true,
	                'mixin': true,
	                'module': true,
	                'namespace': true,
	                'typedef': true
	            };
	            kind = trim(sliceSource(source, index, this._last));
	            this._tag.kind = kind;
	            if (!hasOwnProperty(kinds, kind)) {
	                if (!this.addError('Invalid kind name \'%0\'', kind)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseAccess = function parseAccess() {
	            var access;
	            access = trim(sliceSource(source, index, this._last));
	            this._tag.access = access;
	            if (access !== 'private' && access !== 'protected' && access !== 'public') {
	                if (!this.addError('Invalid access name \'%0\'', access)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.parseThis = function parseAccess() {
	            // this name may be a name expression (e.g. {foo.bar})
	            // or a name path (e.g. foo.bar)
	            var value = trim(sliceSource(source, index, this._last));
	            if (value && value.charAt(0) === '{') {
	                var gotType = this.parseType();
	                if (gotType && this._tag.type.type === 'NameExpression') {
	                    this._tag.name = this._tag.type.name;
	                    return true;
	                } else {
	                    return this.addError('Invalid name for this');
	                }
	            } else {
	                return this.parseNamePath();
	            }
	        };
	
	        TagParser.prototype.parseVariation = function parseVariation() {
	            var variation, text;
	            text = trim(sliceSource(source, index, this._last));
	            variation = parseFloat(text, 10);
	            this._tag.variation = variation;
	            if (isNaN(variation)) {
	                if (!this.addError('Invalid variation \'%0\'', text)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.ensureEnd = function () {
	            var shouldBeEmpty = trim(sliceSource(source, index, this._last));
	            if (shouldBeEmpty) {
	                if (!this.addError('Unknown content \'%0\'', shouldBeEmpty)) {
	                    return false;
	                }
	            }
	            return true;
	        };
	
	        TagParser.prototype.epilogue = function epilogue() {
	            var description;
	
	            description = this._tag.description;
	            // un-fix potentially sloppy declaration
	            if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === '[') {
	                this._tag.type = this._extra.name;
	                if (!this._tag.name) {
	                    this._tag.name = undefined;
	                }
	
	                if (!sloppy) {
	                    if (!this.addError('Missing or invalid tag name')) {
	                        return false;
	                    }
	                }
	            }
	
	            return true;
	        };
	
	        Rules = {
	            // http://usejsdoc.org/tags-access.html
	            'access': ['parseAccess'],
	            // http://usejsdoc.org/tags-alias.html
	            'alias': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-augments.html
	            'augments': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-constructor.html
	            'constructor': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-constructor.html
	            'class': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-extends.html
	            'extends': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-example.html
	            'example': ['parseCaption'],
	            // http://usejsdoc.org/tags-deprecated.html
	            'deprecated': ['parseDescription'],
	            // http://usejsdoc.org/tags-global.html
	            'global': ['ensureEnd'],
	            // http://usejsdoc.org/tags-inner.html
	            'inner': ['ensureEnd'],
	            // http://usejsdoc.org/tags-instance.html
	            'instance': ['ensureEnd'],
	            // http://usejsdoc.org/tags-kind.html
	            'kind': ['parseKind'],
	            // http://usejsdoc.org/tags-mixes.html
	            'mixes': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-mixin.html
	            'mixin': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-member.html
	            'member': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-method.html
	            'method': ['parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-module.html
	            'module': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'func': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-method.html
	            'function': ['parseNamePathOptional', 'ensureEnd'],
	            // Synonym: http://usejsdoc.org/tags-member.html
	            'var': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-name.html
	            'name': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-namespace.html
	            'namespace': ['parseType', 'parseNamePathOptional', 'ensureEnd'],
	            // http://usejsdoc.org/tags-private.html
	            'private': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-protected.html
	            'protected': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-public.html
	            'public': ['parseType', 'parseDescription'],
	            // http://usejsdoc.org/tags-readonly.html
	            'readonly': ['ensureEnd'],
	            // http://usejsdoc.org/tags-requires.html
	            'requires': ['parseNamePath', 'ensureEnd'],
	            // http://usejsdoc.org/tags-since.html
	            'since': ['parseDescription'],
	            // http://usejsdoc.org/tags-static.html
	            'static': ['ensureEnd'],
	            // http://usejsdoc.org/tags-summary.html
	            'summary': ['parseDescription'],
	            // http://usejsdoc.org/tags-this.html
	            'this': ['parseThis', 'ensureEnd'],
	            // http://usejsdoc.org/tags-todo.html
	            'todo': ['parseDescription'],
	            // http://usejsdoc.org/tags-typedef.html
	            'typedef': ['parseType', 'parseNamePathOptional'],
	            // http://usejsdoc.org/tags-variation.html
	            'variation': ['parseVariation'],
	            // http://usejsdoc.org/tags-version.html
	            'version': ['parseDescription']
	        };
	
	        TagParser.prototype.parse = function parse() {
	            var i, iz, sequences, method;
	
	
	            // empty title
	            if (!this._title) {
	                if (!this.addError('Missing or invalid title')) {
	                    return null;
	                }
	            }
	
	            // Seek to content last index.
	            this._last = seekContent(this._title);
	
	            if (hasOwnProperty(Rules, this._title)) {
	                sequences = Rules[this._title];
	            } else {
	                // default sequences
	                sequences = ['parseType', 'parseName', 'parseDescription', 'epilogue'];
	            }
	
	            for (i = 0, iz = sequences.length; i < iz; ++i) {
	                method = sequences[i];
	                if (!this[method]()) {
	                    return null;
	                }
	            }
	
	            return this._tag;
	        };
	
	        function parseTag(options) {
	            var title, parser, tag;
	
	            // skip to tag
	            if (!skipToTag()) {
	                return null;
	            }
	
	            // scan title
	            title = scanTitle();
	
	            // construct tag parser
	            parser = new TagParser(options, title);
	            tag = parser.parse();
	
	            // Seek global index to end of this tag.
	            while (index < parser._last) {
	                advance();
	            }
	
	            return tag;
	        }
	
	        //
	        // Parse JSDoc
	        //
	
	        function scanJSDocDescription(preserveWhitespace) {
	            var description = '', ch, atAllowed;
	
	            atAllowed = true;
	            while (index < length) {
	                ch = source.charCodeAt(index);
	
	                if (atAllowed && ch === 0x40  /* '@' */) {
	                    break;
	                }
	
	                if (esutils.code.isLineTerminator(ch)) {
	                    atAllowed = true;
	                } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
	                    atAllowed = false;
	                }
	
	                description += advance();
	            }
	
	            return preserveWhitespace ? description : trim(description);
	        }
	
	        function parse(comment, options) {
	            var tags = [], tag, description, interestingTags, i, iz;
	
	            if (options === undefined) {
	                options = {};
	            }
	
	            if (typeof options.unwrap === 'boolean' && options.unwrap) {
	                source = unwrapComment(comment);
	            } else {
	                source = comment;
	            }
	
	            // array of relevant tags
	            if (options.tags) {
	                if (isArray(options.tags)) {
	                    interestingTags = { };
	                    for (i = 0, iz = options.tags.length; i < iz; i++) {
	                        if (typeof options.tags[i] === 'string') {
	                            interestingTags[options.tags[i]] = true;
	                        } else {
	                            utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                        }
	                    }
	                } else {
	                    utility.throwError('Invalid "tags" parameter: ' + options.tags);
	                }
	            }
	
	            length = source.length;
	            index = 0;
	            lineNumber = 0;
	            recoverable = options.recoverable;
	            sloppy = options.sloppy;
	            strict = options.strict;
	
	            description = scanJSDocDescription(options.preserveWhitespace);
	
	            while (true) {
	                tag = parseTag(options);
	                if (!tag) {
	                    break;
	                }
	                if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
	                    tags.push(tag);
	                }
	            }
	
	            return {
	                description: description,
	                tags: tags
	            };
	        }
	        exports.parse = parse;
	    }(jsdoc = {}));
	
	    exports.version = utility.VERSION;
	    exports.parse = jsdoc.parse;
	    exports.parseType = typed.parseType;
	    exports.parseParamType = typed.parseParamType;
	    exports.unwrapComment = unwrapComment;
	    exports.Syntax = shallowCopy(typed.Syntax);
	    exports.Error = utility.DoctrineError;
	    exports.type = {
	        Syntax: exports.Syntax,
	        parseType: typed.parseType,
	        parseParamType: typed.parseParamType,
	        stringify: typed.stringify
	    };
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Type expression parser.
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 * @author Dan Tao <daniel.tao@gmail.com>
	 * @author Andrew Eisenberg <andrew@eisenberg.as>
	 */
	
	// "typed", the Type Expression Parser for doctrine.
	
	(function () {
	    'use strict';
	
	    var Syntax,
	        Token,
	        source,
	        length,
	        index,
	        previous,
	        token,
	        value,
	        esutils,
	        utility;
	
	    esutils = __webpack_require__(110);
	    utility = __webpack_require__(398);
	
	    Syntax = {
	        NullableLiteral: 'NullableLiteral',
	        AllLiteral: 'AllLiteral',
	        NullLiteral: 'NullLiteral',
	        UndefinedLiteral: 'UndefinedLiteral',
	        VoidLiteral: 'VoidLiteral',
	        UnionType: 'UnionType',
	        ArrayType: 'ArrayType',
	        RecordType: 'RecordType',
	        FieldType: 'FieldType',
	        FunctionType: 'FunctionType',
	        ParameterType: 'ParameterType',
	        RestType: 'RestType',
	        NonNullableType: 'NonNullableType',
	        OptionalType: 'OptionalType',
	        NullableType: 'NullableType',
	        NameExpression: 'NameExpression',
	        TypeApplication: 'TypeApplication',
	        StringLiteralType: 'StringLiteralType',
	        NumericLiteralType: 'NumericLiteralType',
	        BooleanLiteralType: 'BooleanLiteralType'
	    };
	
	    Token = {
	        ILLEGAL: 0,    // ILLEGAL
	        DOT_LT: 1,     // .<
	        REST: 2,       // ...
	        LT: 3,         // <
	        GT: 4,         // >
	        LPAREN: 5,     // (
	        RPAREN: 6,     // )
	        LBRACE: 7,     // {
	        RBRACE: 8,     // }
	        LBRACK: 9,    // [
	        RBRACK: 10,    // ]
	        COMMA: 11,     // ,
	        COLON: 12,     // :
	        STAR: 13,      // *
	        PIPE: 14,      // |
	        QUESTION: 15,  // ?
	        BANG: 16,      // !
	        EQUAL: 17,     // =
	        NAME: 18,      // name token
	        STRING: 19,    // string
	        NUMBER: 20,    // number
	        EOF: 21
	    };
	
	    function isTypeName(ch) {
	        return '><(){}[],:*|?!='.indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
	    }
	
	    function Context(previous, index, token, value) {
	        this._previous = previous;
	        this._index = index;
	        this._token = token;
	        this._value = value;
	    }
	
	    Context.prototype.restore = function () {
	        previous = this._previous;
	        index = this._index;
	        token = this._token;
	        value = this._value;
	    };
	
	    Context.save = function () {
	        return new Context(previous, index, token, value);
	    };
	
	    function advance() {
	        var ch = source.charAt(index);
	        index += 1;
	        return ch;
	    }
	
	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;
	
	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
	                ch = advance();
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }
	
	    function scanString() {
	        var str = '', quote, ch, code, unescaped, restore; //TODO review removal octal = false
	        quote = source.charAt(index);
	        ++index;
	
	        while (index < length) {
	            ch = advance();
	
	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = advance();
	                if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        restore = index;
	                        unescaped = scanHexEscape(ch);
	                        if (unescaped) {
	                            str += unescaped;
	                        } else {
	                            index = restore;
	                            str += ch;
	                        }
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\v';
	                        break;
	
	                    default:
	                        if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
	                            code = '01234567'.indexOf(ch);
	
	                            // \0 is not octal escape sequence
	                            // Deprecating unused code. TODO review removal
	                            //if (code !== 0) {
	                            //    octal = true;
	                            //}
	
	                            if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                //TODO Review Removal octal = true;
	                                code = code * 8 + '01234567'.indexOf(advance());
	
	                                // 3 digits are only allowed when string starts
	                                // with 0, 1, 2, 3
	                                if ('0123'.indexOf(ch) >= 0 &&
	                                        index < length &&
	                                        esutils.code.isOctalDigit(source.charCodeAt(index))) {
	                                    code = code * 8 + '01234567'.indexOf(advance());
	                                }
	                            }
	                            str += String.fromCharCode(code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    if (ch ===  '\r' && source.charCodeAt(index) === 0x0A  /* '\n' */) {
	                        ++index;
	                    }
	                }
	            } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }
	
	        if (quote !== '') {
	            utility.throwError('unexpected quote');
	        }
	
	        value = str;
	        return Token.STRING;
	    }
	
	    function scanNumber() {
	        var number, ch;
	
	        number = '';
	        ch = source.charCodeAt(index);
	
	        if (ch !== 0x2E  /* '.' */) {
	            number = advance();
	            ch = source.charCodeAt(index);
	
	            if (number === '0') {
	                if (ch === 0x78  /* 'x' */ || ch === 0x58  /* 'X' */) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isHexDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }
	
	                    if (number.length <= 2) {
	                        // only 0x
	                        utility.throwError('unexpected token');
	                    }
	
	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStartES5(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 16);
	                    return Token.NUMBER;
	                }
	
	                if (esutils.code.isOctalDigit(ch)) {
	                    number += advance();
	                    while (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (!esutils.code.isOctalDigit(ch)) {
	                            break;
	                        }
	                        number += advance();
	                    }
	
	                    if (index < length) {
	                        ch = source.charCodeAt(index);
	                        if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
	                            utility.throwError('unexpected token');
	                        }
	                    }
	                    value = parseInt(number, 8);
	                    return Token.NUMBER;
	                }
	
	                if (esutils.code.isDecimalDigit(ch)) {
	                    utility.throwError('unexpected token');
	                }
	            }
	
	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }
	
	        if (ch === 0x2E  /* '.' */) {
	            number += advance();
	            while (index < length) {
	                ch = source.charCodeAt(index);
	                if (!esutils.code.isDecimalDigit(ch)) {
	                    break;
	                }
	                number += advance();
	            }
	        }
	
	        if (ch === 0x65  /* 'e' */ || ch === 0x45  /* 'E' */) {
	            number += advance();
	
	            ch = source.charCodeAt(index);
	            if (ch === 0x2B  /* '+' */ || ch === 0x2D  /* '-' */) {
	                number += advance();
	            }
	
	            ch = source.charCodeAt(index);
	            if (esutils.code.isDecimalDigit(ch)) {
	                number += advance();
	                while (index < length) {
	                    ch = source.charCodeAt(index);
	                    if (!esutils.code.isDecimalDigit(ch)) {
	                        break;
	                    }
	                    number += advance();
	                }
	            } else {
	                utility.throwError('unexpected token');
	            }
	        }
	
	        if (index < length) {
	            ch = source.charCodeAt(index);
	            if (esutils.code.isIdentifierStartES5(ch)) {
	                utility.throwError('unexpected token');
	            }
	        }
	
	        value = parseFloat(number);
	        return Token.NUMBER;
	    }
	
	
	    function scanTypeName() {
	        var ch, ch2;
	
	        value = advance();
	        while (index < length && isTypeName(source.charCodeAt(index))) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x2E  /* '.' */) {
	                if ((index + 1) >= length) {
	                    return Token.ILLEGAL;
	                }
	                ch2 = source.charCodeAt(index + 1);
	                if (ch2 === 0x3C  /* '<' */) {
	                    break;
	                }
	            }
	            value += advance();
	        }
	        return Token.NAME;
	    }
	
	    function next() {
	        var ch;
	
	        previous = index;
	
	        while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
	            advance();
	        }
	        if (index >= length) {
	            token = Token.EOF;
	            return token;
	        }
	
	        ch = source.charCodeAt(index);
	        switch (ch) {
	        case 0x27:  /* ''' */
	        case 0x22:  /* '"' */
	            token = scanString();
	            return token;
	
	        case 0x3A:  /* ':' */
	            advance();
	            token = Token.COLON;
	            return token;
	
	        case 0x2C:  /* ',' */
	            advance();
	            token = Token.COMMA;
	            return token;
	
	        case 0x28:  /* '(' */
	            advance();
	            token = Token.LPAREN;
	            return token;
	
	        case 0x29:  /* ')' */
	            advance();
	            token = Token.RPAREN;
	            return token;
	
	        case 0x5B:  /* '[' */
	            advance();
	            token = Token.LBRACK;
	            return token;
	
	        case 0x5D:  /* ']' */
	            advance();
	            token = Token.RBRACK;
	            return token;
	
	        case 0x7B:  /* '{' */
	            advance();
	            token = Token.LBRACE;
	            return token;
	
	        case 0x7D:  /* '}' */
	            advance();
	            token = Token.RBRACE;
	            return token;
	
	        case 0x2E:  /* '.' */
	            if (index + 1 < length) {
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x3C  /* '<' */) {
	                    advance();  // '.'
	                    advance();  // '<'
	                    token = Token.DOT_LT;
	                    return token;
	                }
	
	                if (ch === 0x2E  /* '.' */ && index + 2 < length && source.charCodeAt(index + 2) === 0x2E  /* '.' */) {
	                    advance();  // '.'
	                    advance();  // '.'
	                    advance();  // '.'
	                    token = Token.REST;
	                    return token;
	                }
	
	                if (esutils.code.isDecimalDigit(ch)) {
	                    token = scanNumber();
	                    return token;
	                }
	            }
	            token = Token.ILLEGAL;
	            return token;
	
	        case 0x3C:  /* '<' */
	            advance();
	            token = Token.LT;
	            return token;
	
	        case 0x3E:  /* '>' */
	            advance();
	            token = Token.GT;
	            return token;
	
	        case 0x2A:  /* '*' */
	            advance();
	            token = Token.STAR;
	            return token;
	
	        case 0x7C:  /* '|' */
	            advance();
	            token = Token.PIPE;
	            return token;
	
	        case 0x3F:  /* '?' */
	            advance();
	            token = Token.QUESTION;
	            return token;
	
	        case 0x21:  /* '!' */
	            advance();
	            token = Token.BANG;
	            return token;
	
	        case 0x3D:  /* '=' */
	            advance();
	            token = Token.EQUAL;
	            return token;
	
	        case 0x2D: /* '-' */
	            token = scanNumber();
	            return token;
	
	        default:
	            if (esutils.code.isDecimalDigit(ch)) {
	                token = scanNumber();
	                return token;
	            }
	
	            // type string permits following case,
	            //
	            // namespace.module.MyClass
	            //
	            // this reduced 1 token TK_NAME
	            utility.assert(isTypeName(ch));
	            token = scanTypeName();
	            return token;
	        }
	    }
	
	    function consume(target, text) {
	        utility.assert(token === target, text || 'consumed token not matched');
	        next();
	    }
	
	    function expect(target, message) {
	        if (token !== target) {
	            utility.throwError(message || 'unexpected token');
	        }
	        next();
	    }
	
	    // UnionType := '(' TypeUnionList ')'
	    //
	    // TypeUnionList :=
	    //     <<empty>>
	    //   | NonemptyTypeUnionList
	    //
	    // NonemptyTypeUnionList :=
	    //     TypeExpression
	    //   | TypeExpression '|' NonemptyTypeUnionList
	    function parseUnionType() {
	        var elements;
	        consume(Token.LPAREN, 'UnionType should start with (');
	        elements = [];
	        if (token !== Token.RPAREN) {
	            while (true) {
	                elements.push(parseTypeExpression());
	                if (token === Token.RPAREN) {
	                    break;
	                }
	                expect(Token.PIPE);
	            }
	        }
	        consume(Token.RPAREN, 'UnionType should end with )');
	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }
	
	    // ArrayType := '[' ElementTypeList ']'
	    //
	    // ElementTypeList :=
	    //     <<empty>>
	    //  | TypeExpression
	    //  | '...' TypeExpression
	    //  | TypeExpression ',' ElementTypeList
	    function parseArrayType() {
	        var elements;
	        consume(Token.LBRACK, 'ArrayType should start with [');
	        elements = [];
	        while (token !== Token.RBRACK) {
	            if (token === Token.REST) {
	                consume(Token.REST);
	                elements.push({
	                    type: Syntax.RestType,
	                    expression: parseTypeExpression()
	                });
	                break;
	            } else {
	                elements.push(parseTypeExpression());
	            }
	            if (token !== Token.RBRACK) {
	                expect(Token.COMMA);
	            }
	        }
	        expect(Token.RBRACK);
	        return {
	            type: Syntax.ArrayType,
	            elements: elements
	        };
	    }
	
	    function parseFieldName() {
	        var v = value;
	        if (token === Token.NAME || token === Token.STRING) {
	            next();
	            return v;
	        }
	
	        if (token === Token.NUMBER) {
	            consume(Token.NUMBER);
	            return String(v);
	        }
	
	        utility.throwError('unexpected token');
	    }
	
	    // FieldType :=
	    //     FieldName
	    //   | FieldName ':' TypeExpression
	    //
	    // FieldName :=
	    //     NameExpression
	    //   | StringLiteral
	    //   | NumberLiteral
	    //   | ReservedIdentifier
	    function parseFieldType() {
	        var key;
	
	        key = parseFieldName();
	        if (token === Token.COLON) {
	            consume(Token.COLON);
	            return {
	                type: Syntax.FieldType,
	                key: key,
	                value: parseTypeExpression()
	            };
	        }
	        return {
	            type: Syntax.FieldType,
	            key: key,
	            value: null
	        };
	    }
	
	    // RecordType := '{' FieldTypeList '}'
	    //
	    // FieldTypeList :=
	    //     <<empty>>
	    //   | FieldType
	    //   | FieldType ',' FieldTypeList
	    function parseRecordType() {
	        var fields;
	
	        consume(Token.LBRACE, 'RecordType should start with {');
	        fields = [];
	        if (token === Token.COMMA) {
	            consume(Token.COMMA);
	        } else {
	            while (token !== Token.RBRACE) {
	                fields.push(parseFieldType());
	                if (token !== Token.RBRACE) {
	                    expect(Token.COMMA);
	                }
	            }
	        }
	        expect(Token.RBRACE);
	        return {
	            type: Syntax.RecordType,
	            fields: fields
	        };
	    }
	
	    // NameExpression :=
	    //    Identifier
	    //  | TagIdentifier ':' Identifier
	    //
	    // Tag identifier is one of "module", "external" or "event"
	    // Identifier is the same as Token.NAME, including any dots, something like
	    // namespace.module.MyClass
	    function parseNameExpression() {
	        var name = value;
	        expect(Token.NAME);
	
	        if (token === Token.COLON && (
	                name === 'module' ||
	                name === 'external' ||
	                name === 'event')) {
	            consume(Token.COLON);
	            name += ':' + value;
	            expect(Token.NAME);
	        }
	
	        return {
	            type: Syntax.NameExpression,
	            name: name
	        };
	    }
	
	    // TypeExpressionList :=
	    //     TopLevelTypeExpression
	    //   | TopLevelTypeExpression ',' TypeExpressionList
	    function parseTypeExpressionList() {
	        var elements = [];
	
	        elements.push(parseTop());
	        while (token === Token.COMMA) {
	            consume(Token.COMMA);
	            elements.push(parseTop());
	        }
	        return elements;
	    }
	
	    // TypeName :=
	    //     NameExpression
	    //   | NameExpression TypeApplication
	    //
	    // TypeApplication :=
	    //     '.<' TypeExpressionList '>'
	    //   | '<' TypeExpressionList '>'   // this is extension of doctrine
	    function parseTypeName() {
	        var expr, applications;
	
	        expr = parseNameExpression();
	        if (token === Token.DOT_LT || token === Token.LT) {
	            next();
	            applications = parseTypeExpressionList();
	            expect(Token.GT);
	            return {
	                type: Syntax.TypeApplication,
	                expression: expr,
	                applications: applications
	            };
	        }
	        return expr;
	    }
	
	    // ResultType :=
	    //     <<empty>>
	    //   | ':' void
	    //   | ':' TypeExpression
	    //
	    // BNF is above
	    // but, we remove <<empty>> pattern, so token is always TypeToken::COLON
	    function parseResultType() {
	        consume(Token.COLON, 'ResultType should start with :');
	        if (token === Token.NAME && value === 'void') {
	            consume(Token.NAME);
	            return {
	                type: Syntax.VoidLiteral
	            };
	        }
	        return parseTypeExpression();
	    }
	
	    // ParametersType :=
	    //     RestParameterType
	    //   | NonRestParametersType
	    //   | NonRestParametersType ',' RestParameterType
	    //
	    // RestParameterType :=
	    //     '...'
	    //     '...' Identifier
	    //
	    // NonRestParametersType :=
	    //     ParameterType ',' NonRestParametersType
	    //   | ParameterType
	    //   | OptionalParametersType
	    //
	    // OptionalParametersType :=
	    //     OptionalParameterType
	    //   | OptionalParameterType, OptionalParametersType
	    //
	    // OptionalParameterType := ParameterType=
	    //
	    // ParameterType := TypeExpression | Identifier ':' TypeExpression
	    //
	    // Identifier is "new" or "this"
	    function parseParametersType() {
	        var params = [], optionalSequence = false, expr, rest = false;
	
	        while (token !== Token.RPAREN) {
	            if (token === Token.REST) {
	                // RestParameterType
	                consume(Token.REST);
	                rest = true;
	            }
	
	            expr = parseTypeExpression();
	            if (expr.type === Syntax.NameExpression && token === Token.COLON) {
	                // Identifier ':' TypeExpression
	                consume(Token.COLON);
	                expr = {
	                    type: Syntax.ParameterType,
	                    name: expr.name,
	                    expression: parseTypeExpression()
	                };
	            }
	            if (token === Token.EQUAL) {
	                consume(Token.EQUAL);
	                expr = {
	                    type: Syntax.OptionalType,
	                    expression: expr
	                };
	                optionalSequence = true;
	            } else {
	                if (optionalSequence) {
	                    utility.throwError('unexpected token');
	                }
	            }
	            if (rest) {
	                expr = {
	                    type: Syntax.RestType,
	                    expression: expr
	                };
	            }
	            params.push(expr);
	            if (token !== Token.RPAREN) {
	                expect(Token.COMMA);
	            }
	        }
	        return params;
	    }
	
	    // FunctionType := 'function' FunctionSignatureType
	    //
	    // FunctionSignatureType :=
	    //   | TypeParameters '(' ')' ResultType
	    //   | TypeParameters '(' ParametersType ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ')' ResultType
	    //   | TypeParameters '(' 'this' ':' TypeName ',' ParametersType ')' ResultType
	    function parseFunctionType() {
	        var isNew, thisBinding, params, result, fnType;
	        utility.assert(token === Token.NAME && value === 'function', 'FunctionType should start with \'function\'');
	        consume(Token.NAME);
	
	        // Google Closure Compiler is not implementing TypeParameters.
	        // So we do not. if we don't get '(', we see it as error.
	        expect(Token.LPAREN);
	
	        isNew = false;
	        params = [];
	        thisBinding = null;
	        if (token !== Token.RPAREN) {
	            // ParametersType or 'this'
	            if (token === Token.NAME &&
	                    (value === 'this' || value === 'new')) {
	                // 'this' or 'new'
	                // 'new' is Closure Compiler extension
	                isNew = value === 'new';
	                consume(Token.NAME);
	                expect(Token.COLON);
	                thisBinding = parseTypeName();
	                if (token === Token.COMMA) {
	                    consume(Token.COMMA);
	                    params = parseParametersType();
	                }
	            } else {
	                params = parseParametersType();
	            }
	        }
	
	        expect(Token.RPAREN);
	
	        result = null;
	        if (token === Token.COLON) {
	            result = parseResultType();
	        }
	
	        fnType = {
	            type: Syntax.FunctionType,
	            params: params,
	            result: result
	        };
	        if (thisBinding) {
	            // avoid adding null 'new' and 'this' properties
	            fnType['this'] = thisBinding;
	            if (isNew) {
	                fnType['new'] = true;
	            }
	        }
	        return fnType;
	    }
	
	    // BasicTypeExpression :=
	    //     '*'
	    //   | 'null'
	    //   | 'undefined'
	    //   | TypeName
	    //   | FunctionType
	    //   | UnionType
	    //   | RecordType
	    //   | ArrayType
	    function parseBasicTypeExpression() {
	        var context;
	        switch (token) {
	        case Token.STAR:
	            consume(Token.STAR);
	            return {
	                type: Syntax.AllLiteral
	            };
	
	        case Token.LPAREN:
	            return parseUnionType();
	
	        case Token.LBRACK:
	            return parseArrayType();
	
	        case Token.LBRACE:
	            return parseRecordType();
	
	        case Token.NAME:
	            if (value === 'null') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.NullLiteral
	                };
	            }
	
	            if (value === 'undefined') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.UndefinedLiteral
	                };
	            }
	
	            if (value === 'true' || value === 'false') {
	                consume(Token.NAME);
	                return {
	                    type: Syntax.BooleanLiteralType,
	                    value: value === 'true'
	                };
	            }
	
	            context = Context.save();
	            if (value === 'function') {
	                try {
	                    return parseFunctionType();
	                } catch (e) {
	                    context.restore();
	                }
	            }
	
	            return parseTypeName();
	
	        case Token.STRING:
	            next();
	            return {
	                type: Syntax.StringLiteralType,
	                value: value
	            };
	
	        case Token.NUMBER:
	            next();
	            return {
	                type: Syntax.NumericLiteralType,
	                value: value
	            };
	
	        default:
	            utility.throwError('unexpected token');
	        }
	    }
	
	    // TypeExpression :=
	    //     BasicTypeExpression
	    //   | '?' BasicTypeExpression
	    //   | '!' BasicTypeExpression
	    //   | BasicTypeExpression '?'
	    //   | BasicTypeExpression '!'
	    //   | '?'
	    //   | BasicTypeExpression '[]'
	    function parseTypeExpression() {
	        var expr;
	
	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE ||
	                    token === Token.RPAREN || token === Token.PIPE || token === Token.EOF ||
	                    token === Token.RBRACK || token === Token.GT) {
	                return {
	                    type: Syntax.NullableLiteral
	                };
	            }
	            return {
	                type: Syntax.NullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }
	
	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: parseBasicTypeExpression(),
	                prefix: true
	            };
	        }
	
	        expr = parseBasicTypeExpression();
	        if (token === Token.BANG) {
	            consume(Token.BANG);
	            return {
	                type: Syntax.NonNullableType,
	                expression: expr,
	                prefix: false
	            };
	        }
	
	        if (token === Token.QUESTION) {
	            consume(Token.QUESTION);
	            return {
	                type: Syntax.NullableType,
	                expression: expr,
	                prefix: false
	            };
	        }
	
	        if (token === Token.LBRACK) {
	            consume(Token.LBRACK);
	            expect(Token.RBRACK, 'expected an array-style type declaration (' + value + '[])');
	            return {
	                type: Syntax.TypeApplication,
	                expression: {
	                    type: Syntax.NameExpression,
	                    name: 'Array'
	                },
	                applications: [expr]
	            };
	        }
	
	        return expr;
	    }
	
	    // TopLevelTypeExpression :=
	    //      TypeExpression
	    //    | TypeUnionList
	    //
	    // This rule is Google Closure Compiler extension, not ES4
	    // like,
	    //   { number | string }
	    // If strict to ES4, we should write it as
	    //   { (number|string) }
	    function parseTop() {
	        var expr, elements;
	
	        expr = parseTypeExpression();
	        if (token !== Token.PIPE) {
	            return expr;
	        }
	
	        elements = [expr];
	        consume(Token.PIPE);
	        while (true) {
	            elements.push(parseTypeExpression());
	            if (token !== Token.PIPE) {
	                break;
	            }
	            consume(Token.PIPE);
	        }
	
	        return {
	            type: Syntax.UnionType,
	            elements: elements
	        };
	    }
	
	    function parseTopParamType() {
	        var expr;
	
	        if (token === Token.REST) {
	            consume(Token.REST);
	            return {
	                type: Syntax.RestType,
	                expression: parseTop()
	            };
	        }
	
	        expr = parseTop();
	        if (token === Token.EQUAL) {
	            consume(Token.EQUAL);
	            return {
	                type: Syntax.OptionalType,
	                expression: expr
	            };
	        }
	
	        return expr;
	    }
	
	    function parseType(src, opt) {
	        var expr;
	
	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;
	
	        next();
	        expr = parseTop();
	
	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }
	
	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }
	
	        return expr;
	    }
	
	    function parseParamType(src, opt) {
	        var expr;
	
	        source = src;
	        length = source.length;
	        index = 0;
	        previous = 0;
	
	        next();
	        expr = parseTopParamType();
	
	        if (opt && opt.midstream) {
	            return {
	                expression: expr,
	                index: previous
	            };
	        }
	
	        if (token !== Token.EOF) {
	            utility.throwError('not reach to EOF');
	        }
	
	        return expr;
	    }
	
	    function stringifyImpl(node, compact, topLevel) {
	        var result, i, iz;
	
	        switch (node.type) {
	        case Syntax.NullableLiteral:
	            result = '?';
	            break;
	
	        case Syntax.AllLiteral:
	            result = '*';
	            break;
	
	        case Syntax.NullLiteral:
	            result = 'null';
	            break;
	
	        case Syntax.UndefinedLiteral:
	            result = 'undefined';
	            break;
	
	        case Syntax.VoidLiteral:
	            result = 'void';
	            break;
	
	        case Syntax.UnionType:
	            if (!topLevel) {
	                result = '(';
	            } else {
	                result = '';
	            }
	
	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += '|';
	                }
	            }
	
	            if (!topLevel) {
	                result += ')';
	            }
	            break;
	
	        case Syntax.ArrayType:
	            result = '[';
	            for (i = 0, iz = node.elements.length; i < iz; ++i) {
	                result += stringifyImpl(node.elements[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += ']';
	            break;
	
	        case Syntax.RecordType:
	            result = '{';
	            for (i = 0, iz = node.fields.length; i < iz; ++i) {
	                result += stringifyImpl(node.fields[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '}';
	            break;
	
	        case Syntax.FieldType:
	            if (node.value) {
	                result = node.key + (compact ? ':' : ': ') + stringifyImpl(node.value, compact);
	            } else {
	                result = node.key;
	            }
	            break;
	
	        case Syntax.FunctionType:
	            result = compact ? 'function(' : 'function (';
	
	            if (node['this']) {
	                if (node['new']) {
	                    result += (compact ? 'new:' : 'new: ');
	                } else {
	                    result += (compact ? 'this:' : 'this: ');
	                }
	
	                result += stringifyImpl(node['this'], compact);
	
	                if (node.params.length !== 0) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	
	            for (i = 0, iz = node.params.length; i < iz; ++i) {
	                result += stringifyImpl(node.params[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	
	            result += ')';
	
	            if (node.result) {
	                result += (compact ? ':' : ': ') + stringifyImpl(node.result, compact);
	            }
	            break;
	
	        case Syntax.ParameterType:
	            result = node.name + (compact ? ':' : ': ') + stringifyImpl(node.expression, compact);
	            break;
	
	        case Syntax.RestType:
	            result = '...';
	            if (node.expression) {
	                result += stringifyImpl(node.expression, compact);
	            }
	            break;
	
	        case Syntax.NonNullableType:
	            if (node.prefix) {
	                result = '!' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '!';
	            }
	            break;
	
	        case Syntax.OptionalType:
	            result = stringifyImpl(node.expression, compact) + '=';
	            break;
	
	        case Syntax.NullableType:
	            if (node.prefix) {
	                result = '?' + stringifyImpl(node.expression, compact);
	            } else {
	                result = stringifyImpl(node.expression, compact) + '?';
	            }
	            break;
	
	        case Syntax.NameExpression:
	            result = node.name;
	            break;
	
	        case Syntax.TypeApplication:
	            result = stringifyImpl(node.expression, compact) + '.<';
	            for (i = 0, iz = node.applications.length; i < iz; ++i) {
	                result += stringifyImpl(node.applications[i], compact);
	                if ((i + 1) !== iz) {
	                    result += compact ? ',' : ', ';
	                }
	            }
	            result += '>';
	            break;
	
	        case Syntax.StringLiteralType:
	            result = '"' + node.value + '"';
	            break;
	
	        case Syntax.NumericLiteralType:
	            result = String(node.value);
	            break;
	
	        case Syntax.BooleanLiteralType:
	            result = String(node.value);
	            break;
	
	        default:
	            utility.throwError('Unknown type ' + node.type);
	        }
	
	        return result;
	    }
	
	    function stringify(node, options) {
	        if (options == null) {
	            options = {};
	        }
	        return stringifyImpl(node, options.compact, options.topLevel);
	    }
	
	    exports.parseType = parseType;
	    exports.parseParamType = parseParamType;
	    exports.stringify = stringify;
	    exports.Syntax = Syntax;
	}());
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * @fileoverview Utilities for Doctrine
	 * @author Yusuke Suzuki <utatane.tea@gmail.com>
	 */
	
	
	(function () {
	    'use strict';
	
	    var VERSION;
	
	    VERSION = __webpack_require__(399).version;
	    exports.VERSION = VERSION;
	
	    function DoctrineError(message) {
	        this.name = 'DoctrineError';
	        this.message = message;
	    }
	    DoctrineError.prototype = (function () {
	        var Middle = function () { };
	        Middle.prototype = Error.prototype;
	        return new Middle();
	    }());
	    DoctrineError.prototype.constructor = DoctrineError;
	    exports.DoctrineError = DoctrineError;
	
	    function throwError(message) {
	        throw new DoctrineError(message);
	    }
	    exports.throwError = throwError;
	
	    exports.assert = __webpack_require__(3);
	}());
	
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 399 */
/***/ function(module, exports) {

	module.exports = {
		"_args": [
			[
				{
					"raw": "doctrine",
					"scope": null,
					"escapedName": "doctrine",
					"name": "doctrine",
					"rawSpec": "",
					"spec": "latest",
					"type": "tag"
				},
				"/home/joe/prog/googlejs-site"
			]
		],
		"_from": "doctrine@latest",
		"_id": "doctrine@2.0.0",
		"_inCache": true,
		"_location": "/doctrine",
		"_nodeVersion": "4.4.2",
		"_npmOperationalInternal": {
			"host": "packages-12-west.internal.npmjs.com",
			"tmp": "tmp/doctrine-2.0.0.tgz_1479232728285_0.34204454137943685"
		},
		"_npmUser": {
			"name": "nzakas",
			"email": "nicholas@nczconsulting.com"
		},
		"_npmVersion": "2.15.0",
		"_phantomChildren": {},
		"_requested": {
			"raw": "doctrine",
			"scope": null,
			"escapedName": "doctrine",
			"name": "doctrine",
			"rawSpec": "",
			"spec": "latest",
			"type": "tag"
		},
		"_requiredBy": [
			"#USER",
			"/"
		],
		"_resolved": "https://registry.npmjs.org/doctrine/-/doctrine-2.0.0.tgz",
		"_shasum": "c73d8d2909d22291e1a007a395804da8b665fe63",
		"_shrinkwrap": null,
		"_spec": "doctrine",
		"_where": "/home/joe/prog/googlejs-site",
		"bugs": {
			"url": "https://github.com/eslint/doctrine/issues"
		},
		"dependencies": {
			"esutils": "^2.0.2",
			"isarray": "^1.0.0"
		},
		"description": "JSDoc parser",
		"devDependencies": {
			"coveralls": "^2.11.2",
			"dateformat": "^1.0.11",
			"eslint": "^1.10.3",
			"eslint-release": "^0.10.0",
			"istanbul": "^0.4.1",
			"linefix": "^0.1.1",
			"mocha": "^2.3.3",
			"npm-license": "^0.3.1",
			"semver": "^5.0.3",
			"shelljs": "^0.5.3",
			"shelljs-nodecli": "^0.1.1",
			"should": "^5.0.1"
		},
		"directories": {
			"lib": "./lib"
		},
		"dist": {
			"shasum": "c73d8d2909d22291e1a007a395804da8b665fe63",
			"tarball": "https://registry.npmjs.org/doctrine/-/doctrine-2.0.0.tgz"
		},
		"engines": {
			"node": ">=0.10.0"
		},
		"files": [
			"lib",
			"LICENSE.BSD",
			"LICENSE.closure-compiler",
			"LICENSE.esprima",
			"README.md"
		],
		"gitHead": "46c600f27f54b3ab6b0b8a9ac9f97c807ffa95ef",
		"homepage": "https://github.com/eslint/doctrine",
		"license": "Apache-2.0",
		"main": "lib/doctrine.js",
		"maintainers": [
			{
				"name": "constellation",
				"email": "utatane.tea@gmail.com"
			},
			{
				"name": "eslint",
				"email": "nicholas+eslint@nczconsulting.com"
			},
			{
				"name": "nzakas",
				"email": "nicholas@nczconsulting.com"
			}
		],
		"name": "doctrine",
		"optionalDependencies": {},
		"readme": "ERROR: No README data found!",
		"repository": {
			"type": "git",
			"url": "git+https://github.com/eslint/doctrine.git"
		},
		"scripts": {
			"alpharelease": "eslint-prerelease alpha",
			"betarelease": "eslint-prerelease beta",
			"ci-release": "eslint-ci-release",
			"lint": "eslint lib/",
			"release": "eslint-release",
			"test": "npm run lint && node Makefile.js test"
		},
		"version": "2.0.0"
	};

/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	/**
	 * @fileoverview Custom ESLint configuration to adhere to the Google style guide
	 * at https://google.github.io/styleguide/javascriptguide.xml.
	 *
	 * Short link to the Google JS Style Guide: https://git.io/vured
	 * Short link to the Google C++ Style Guide: https://git.io/v6Mp3
	 */
	
	// Named constants for the numbers eslint uses to indicate lint severity.
	var OFF = 0;
	var WARNING = 1;
	var ERROR = 2;
	
	// Possible Errors
	// These rules relate to possible syntax or logic errors in JavaScript code.
	var POSSIBLE_ERROR_RULES = {};
	
	// Best Practices
	// These rules relate to better ways of doing things to help you avoid problems.
	var BEST_PRACTICE_RULES = {};
	
	// Strict Mode
	// These rules relate to strict mode directives.
	var STRICT_MODE_RULES = {};
	
	// Variables
	// These rules relate to variable declarations.
	var VARIABLE_DECLARATION_RULES = {};
	
	// Node.js and CommonJS
	// These rules relate to code running in Node.js, or in browsers with CommonJS.
	var NODEJS_RULES = {};
	
	// Stylistic Issues
	// These rules relate to style guidelines, and are therefore quite subjective.
	var STYLISTIC_RULES = {};
	
	// ECMAScript 6
	// These rules relate to ES6, also known as ES2015.
	var ES6_RULES = {};
	
	// Google Plugin Rules
	// These rules are specific to Google code.  See
	// https://github.com/jschaf/googlejs/packages/eslint-plugin-googlejs
	var GOOGLE_PLUGIN_RULES = {
	  // Allow opt_ prefix and var_args in identifiers.  From
	  // https://git.io/vured#Naming
	  'googlejs/camelcase': [ERROR, {
	    allowVarArgs: true,
	    allowOptPrefix: true,
	    allowLeadingUnderscore: true,
	    allowTrailingUnderscore: true,
	    // Too many warnings, often required for interop with protobufs.
	    checkObjectProperties: false
	  }],
	
	  // The JS style guide 'follows the C++ style guide in spirit'.  The C++ style
	  // guide mandates two spaces before line-end comments.  See the 'Line
	  // Comments' section under
	  // https://git.io/v6Mp3#Implementation_Comments
	  'googlejs/inline-comment-spacing': [ERROR, 2]
	};
	
	// JSDoc Plugin Rules
	// https://github.com/gajus/eslint-plugin-jsdoc
	var JSDOC_PLUGIN_RULES = {};
	
	var GOOGLE_ES5_RULES = {
	
	  extends: [__webpack_require__(401)],
	
	  parserOptions: {
	    ecmaVersion: 6,
	    sourceType: 'script'
	  },
	
	  // The list of rules and options are available at
	  // http://eslint.org/docs/rules/.
	  rules: Object.assign({},
	
	  // ESLint built-in rules.
	  POSSIBLE_ERROR_RULES, BEST_PRACTICE_RULES, STRICT_MODE_RULES, VARIABLE_DECLARATION_RULES, NODEJS_RULES, STYLISTIC_RULES, ES6_RULES,
	
	  // Custom plugin rules.
	  GOOGLE_PLUGIN_RULES, JSDOC_PLUGIN_RULES)
	};
	
	module.exports = GOOGLE_ES5_RULES;

/***/ },
/* 401 */
/***/ function(module, exports) {

	'use strict';
	
	/**
	 * @fileoverview Custom ESLint configuration to adhere to the Google style guide
	 * at https://google.github.io/styleguide/javascriptguide.xml.
	 *
	 * All ESLint rules are listed below.  ESLint recommended rules have an #eslint
	 * tag.  Google JS style guide required rules have a #google tag.  Internal
	 * Google guidelines have a #google3 tag.
	 *
	 * Short link to the Google JS Style Guide: https://git.io/vured
	 * Short link to the Google C++ Style Guide: https://git.io/v6Mp3
	 */
	
	// Named constants for the numbers eslint uses to indicate lint severity.
	var OFF = 0;
	var WARNING = 1;
	var ERROR = 2;
	
	// Private Google JSDoc tags.  #google3
	var GOOGLE_CUSTOM_JSDOC_TAGS = ['abstract', 'copyright', 'disposes', 'externs',
	// Mark function as returning an ID.  The type can be {consistent}, {unique},
	// {stable}, {xid} or empty.
	'idGenerator', 'jaggerInject', 'jaggerModule', 'jaggerProvide', 'jaggerProvidePromise', 'meaning', // Localization helper.
	'modifies', // For externs.
	'ngInject', 'nocollapse', 'nocompile', 'nosideeffects', 'package', // Indicates package-private.,
	'polymerBehavior', 'record', 'struct', 'template', // Generics.
	'unrestricted', // Mark class that's not a @struct or @dict.,
	'visibility', // Control blaze build visibility.
	'wizaction'];
	
	// Pubically released closure JSDoc tags from
	// https://developers.google.com/closure/compiler/docs/js-for-compiler.  #google
	var CLOSURE_JSDOC_TAGS = ['abstract', 'const', 'constructor', 'define', 'deprecated', 'dict', 'enum', 'export', 'extends', 'final', 'implements', 'implicitCast', 'inheritDoc', 'interface', 'lends', 'license', 'preserve', 'nocollapse', 'nosideeffects', 'override', 'package', 'param', 'private', 'protected', 'record', 'return', 'struct', 'template', 'this', 'throws', 'type', 'typedef', 'unrestricted'];
	
	// Possible Errors
	// These rules relate to possible syntax or logic errors in JavaScript code.
	var POSSIBLE_ERROR_RULES = {
	  // Disallow assignment operators in conditional expressions.  #eslint
	  'no-cond-assign': ERROR,
	
	  // Disallow the use of console.  #eslint
	  'no-console': ERROR,
	
	  // Disallow constant expressions in conditions.  #eslint
	  'no-constant-condition': ERROR,
	
	  // Disallow control characters in regular expressions.  #eslint
	  'no-control-regex': ERROR,
	
	  // Disallow the use of debugger.  #eslint
	  'no-debugger': ERROR,
	
	  // Disallow duplicate arguments in function definitions.  #eslint
	  'no-dupe-args': ERROR,
	
	  // Disallow duplicate keys in object literals.  #eslint
	  'no-dupe-keys': ERROR,
	
	  // Disallow duplicate case labels.  #eslint
	  'no-duplicate-case': ERROR,
	
	  // Disallow empty character classes in regular expressions.  #eslint
	  'no-empty-character-class': ERROR,
	
	  // Disallow empty block statements.  #eslint
	  // Google ES6 Section 5.8.2.1
	  'no-empty': ERROR,
	
	  // Disallow reassigning exceptions in catch clauses.  #eslint
	  'no-ex-assign': ERROR,
	
	  // Disallow unnecessary boolean casts.  #eslint
	  // No explicit recommendation in either style guide.
	  'no-extra-boolean-cast': OFF,
	
	  // Disallow unnecessary parentheses.
	  'no-extra-parens': OFF,
	
	  // Disallow unnecessary semicolons.  #eslint
	  'no-extra-semi': ERROR,
	
	  // Disallow reassigning function declarations.  #eslint
	  'no-func-assign': ERROR,
	
	  // Disallow function or var declarations in nested blocks.  #eslint
	  // Google ES5 https://git.io/vured#Nested_functions.
	  'no-inner-declarations': ERROR,
	
	  // Disallow invalid regular expression strings in RegExp constructors.
	  // #eslint
	  'no-invalid-regexp': ERROR,
	
	  // Disallow irregular whitespace outside of strings and comments.  #eslint
	  'no-irregular-whitespace': ERROR,
	
	  // Disallow calling global object properties as functions.  #eslint
	  'no-obj-calls': ERROR,
	
	  // Disallow calling some Object.prototype methods directly on objects.
	  'no-prototype-builtins': OFF,
	
	  // Disallow multiple spaces in regular expressions.  #eslint
	  'no-regex-spaces': ERROR,
	
	  // Disallow sparse arrays.  #eslint
	  'no-sparse-arrays': ERROR,
	
	  // Disallow template literal placeholder syntax in regular strings.
	  'no-template-curly-in-string': OFF,
	
	  // Disallow confusing multiline expressions.  #eslint
	  'no-unexpected-multiline': ERROR,
	
	  // Disallow unreachable code after return, throw, continue, and break
	  // statements.  #eslint
	  'no-unreachable': ERROR,
	
	  // Disallow control flow statements in finally blocks.  #eslint
	  'no-unsafe-finally': ERROR,
	
	  // Disallow negating the left operand of relational operators.
	  'no-unsafe-negation': ERROR,
	
	  // Require calls to isNaN() when checking for NaN.  #eslint
	  'use-isnan': ERROR,
	
	  // Enforce valid JSDoc comments.  Use the jsdoc plugin instead.
	  'valid-jsdoc': OFF,
	
	  // Enforce comparing typeof expressions against valid strings.  #eslint
	  'valid-typeof': ERROR
	};
	
	// Best Practices
	// These rules relate to better ways of doing things to help you avoid problems.
	var BEST_PRACTICE_RULES = {
	  // Enforce getter and setter pairs in objects.
	  'accessor-pairs': OFF,
	
	  // Enforce return statements in callbacks of array methods.
	  'array-callback-return': OFF,
	
	  // Enforce the use of variables within the scope they are defined.
	  'block-scoped-var': OFF,
	
	  // Enforce a maximum cyclomatic complexity allowed in a program.
	  'complexity': OFF,
	
	  // Require return statements to either always or never specify values.
	  'consistent-return': ERROR,
	
	  // Enforce consistent brace style for all control statements.
	
	  // TODO(jschaf): This doesn't quite match Google style guide because it allows
	  // a single statement on the line after a block statement:
	  //
	  // if (foo)
	  //   bar();  // Bad, google style only allows it on the same line like:
	  //
	  // if (foo) bar(); // Good.
	  'curly': [ERROR, 'multi-line'],
	
	  // Require default cases in switch statements.
	  // Google ES6 Section 5.8.3.2
	  'default-case': ERROR,
	
	  // Enforce consistent newlines before and after dots.
	  // Google ES5 https://git.io/vured#Code_formatting
	  // Google ES6 Section 4.5.1
	  'dot-location': [ERROR, 'property'],
	
	  // Enforce dot notation whenever possible.
	  'dot-notation': OFF,
	
	  // Require the use of === and !==.
	  // The style guide says nothing about the great == vs === debate.
	  'eqeqeq': OFF,
	
	  // Require for-in loops to include an if statement.
	  // Google ES6 Section 5.8.1
	  'guard-for-in': ERROR,
	
	  // Disallow the use of alert, confirm, and prompt.
	  'no-alert': OFF,
	
	  // Disallow the use of arguments.caller or arguments.callee.
	  'no-caller': OFF,
	
	  // Disallow lexical declarations in case clauses.  #eslint
	  'no-case-declarations': ERROR,
	
	  // Disallow division operators explicitly at the beginning of regular
	  // expressions.
	  'no-div-regex': OFF,
	
	  // Disallow else blocks after return statements in if statements.
	  'no-else-return': OFF,
	
	  // Disallow empty functions.
	  'no-empty-function': OFF,
	
	  // Disallow empty destructuring patterns.  #eslint
	  'no-empty-pattern': ERROR,
	
	  // Disallow null comparisons without type-checking operators.
	  'no-eq-null': OFF,
	
	  // Disallow the use of eval().
	  // Google ES6 Section 5.10.2
	  'no-eval': ERROR,
	
	  // Disallow extending native types.
	  // Google ES5  https://git.io/vured#Modifying_prototypes_of_builtin_objects
	  // Google ES6 Section 5.10.6
	  'no-extend-native': ERROR,
	
	  // Disallow unnecessary calls to .bind().
	  // Google ES6 Section 5.5.3.  Loosely hinted at, but not specifically
	  // required.
	  'no-extra-bind': WARNING,
	
	  // Disallow unnecessary labels.
	  'no-extra-label': OFF,
	
	  // Disallow fallthrough of case statements.  #eslint
	  // Google ES6 Section 5.8.3.1
	  'no-fallthrough': [ERROR, {
	    commentPattern: '[fF]alls?\\s?[tT]hrough'
	  }],
	
	  // Disallow leading or trailing decimal points in numeric literals.
	  'no-floating-decimal': OFF,
	
	  // Disallow assignments to native objects or read-only global variables.
	  'no-global-assign': OFF,
	
	  // Disallow shorthand type conversions.
	  'no-implicit-coercion': OFF,
	
	  // Disallow var and named function declarations in the global scope.
	  'no-implicit-globals': OFF,
	
	  // Disallow the use of eval()-like methods.
	  'no-implied-eval': OFF,
	
	  // Disallow this keywords outside of classes or class-like objects.
	  'no-invalid-this': OFF,
	
	  // Disallow the use of the __iterator__ property.
	  'no-iterator': OFF,
	
	  // Disallow labeled statements.
	  'no-labels': OFF,
	
	  // Disallow unnecessary nested blocks.
	  'no-lone-blocks': OFF,
	
	  // Disallow function declarations and expressions inside loop statements.
	  'no-loop-func': OFF,
	
	  // Disallow magic numbers.
	  'no-magic-numbers': OFF,
	
	  // Disallow multiple spaces.
	  // Google ES6 Section 4.6.2
	  'no-multi-spaces': ERROR,
	
	  // Disallow multiline strings.
	  // Google ES5 https://git.io/vured#Multiline_string_literals.
	  'no-multi-str': ERROR,
	
	  // Disallow new operators with the Function object.
	  // Google ES6 Section 5.10.2
	  'no-new-func': ERROR,
	
	  // Disallow new operators with the String, Number, and Boolean objects.
	  // Google ES5 https://git.io/vured#Wrapper_objects_for_primitive_types.
	  // Google ES6 Section 5.10.5
	  'no-new-wrappers': ERROR,
	
	  // Disallow new operators outside of assignments or comparisons.
	  'no-new': OFF,
	
	  // Disallow octal escape sequences in string literals.
	  'no-octal-escape': OFF,
	
	  // Disallow octal literals.  #eslint
	  // Google ES6 Section 5.7
	  'no-octal': ERROR,
	
	  // Disallow reassigning function parameters.
	  'no-param-reassign': OFF,
	
	  // Disallow the use of the __proto__ property.
	  'no-proto': OFF,
	
	  // Disallow var redeclaration.  #eslint
	  'no-redeclare': ERROR,
	
	  // Disallow assignment operators in return statements.
	  'no-return-assign': OFF,
	
	  // Disallow javascript: urls.
	  'no-script-url': OFF,
	
	  // Disallow assignments where both sides are exactly the same.  #eslint
	  'no-self-assign': ERROR,
	
	  // Disallow comparisons where both sides are exactly the same.
	  'no-self-compare': OFF,
	
	  // Disallow comma operators.
	  'no-sequences': OFF,
	
	  // Disallow throwing literals as exceptions.
	  'no-throw-literal': OFF,
	
	  // Disallow unmodified loop conditions.
	  'no-unmodified-loop-condition': OFF,
	
	  // Disallow unused expressions.
	  'no-unused-expressions': OFF,
	
	  // Disallow unused labels.  #eslint
	  'no-unused-labels': ERROR,
	
	  // Disallow unnecessary calls to .call() and .apply().
	  'no-useless-call': OFF,
	
	  // Disallow unnecessary concatenation of literals or template literals.
	  'no-useless-concat': OFF,
	
	  // Disallow unnecessary escape characters.
	  'no-useless-escape': OFF,
	
	  // Disallow void operators.
	  'no-void': OFF,
	
	  // Disallow specified warning terms in comments.
	  'no-warning-comments': OFF,
	
	  // Disallow with statements.
	  // Google ES6 Section 5.10.1
	  'no-with': ERROR,
	
	  // Enforce the consistent use of the radix argument when using parseInt().
	  'radix': OFF,
	
	  // Require var declarations be placed at the top of their containing scope.
	  'vars-on-top': OFF,
	
	  // Require parentheses around immediate function invocations.
	  'wrap-iife': OFF,
	
	  // Require or disallow "Yoda" conditions.
	  'yoda': OFF
	};
	
	// Strict Mode
	// These rules relate to strict mode directives.
	var STRICT_MODE_RULES = {
	  // Require or disallow strict mode directives.  The style guide does not
	  // mandate the use of 'use strict'.
	  strict: OFF
	};
	
	// Variables
	// These rules relate to variable declarations.
	var VARIABLE_DECLARATION_RULES = {
	  // Require or disallow initialization in var declarations.
	  'init-declarations': OFF,
	
	  // Disallow catch clause parameters from shadowing variables in the outer
	  // scope.
	  'no-catch-shadow': OFF,
	
	  // Disallow deleting variables.  #eslint
	  'no-delete-var': ERROR,
	
	  // Disallow labels that share a name with a variable.
	  'no-label-var': OFF,
	
	  // Disallow specified global variables.
	  'no-restricted-globals': OFF,
	
	  // Disallow identifiers from shadowing restricted names.
	  'no-shadow-restricted-names': OFF,
	
	  // Disallow var declarations from shadowing variables in the outer scope.
	  'no-shadow': OFF,
	
	  // Disallow initializing variables to undefined.
	  'no-undef-init': OFF,
	
	  // Disallow the use of undeclared variables unless mentioned in /*global */
	  // comments.  #eslint
	  // Disabled for googlejs rule.
	  // 'no-undef': ERROR,
	
	  // Disallow the use of undefined as an identifier.
	  'no-undefined': OFF,
	
	  // Disallow unused variables.  #eslint
	  'no-unused-vars': WARNING,
	
	  // Disallow the use of variables before they are defined.
	  'no-use-before-define': OFF
	};
	
	// Node.js and CommonJS
	// These rules relate to code running in Node.js, or in browsers with CommonJS.
	var NODEJS_RULES = {
	  // Require return statements after callbacks.
	  'callback-return': OFF,
	
	  // Require require() calls to be placed at top-level module scope.
	  'global-require': OFF,
	
	  // Require error handling in callbacks.
	  'handle-callback-err': OFF,
	
	  // Disallow require calls to be mixed with regular var declarations.
	  'no-mixed-requires': OFF,
	
	  // Disallow new operators with calls to require.
	  'no-new-require': OFF,
	
	  // Disallow string concatenation with __dirname and __filename.
	  'no-path-concat': OFF,
	
	  // Disallow the use of process.env.
	  'no-process-env': OFF,
	
	  // Disallow the use of process.exit().
	  'no-process-exit': OFF,
	
	  // Disallow specified modules when loaded by require.
	  'no-restricted-modules': OFF,
	
	  // Disallow synchronous methods.
	  'no-sync': OFF
	};
	
	// Stylistic Issues
	// These rules relate to style guidelines, and are therefore quite subjective.
	var STYLISTIC_RULES = {
	  // Enforce consistent spacing inside array brackets.
	  // Google ES5 https://git.io/vured#Code_formatting
	  'array-bracket-spacing': [ERROR, 'never'],
	
	  // Enforce consistent spacing inside single-line blocks.
	  'block-spacing': OFF,
	
	  // Enforce consistent brace style for blocks.
	  // Google ES5 https://git.io/vured#Code_formatting
	  // Google ES6 Section 4.1.2
	  'brace-style': [ERROR, '1tbs'],
	
	  // Enforce camelcase naming convention.
	  // Google plugin has more applicable rules.
	  'camelcase': OFF,
	
	  // Require or disallow trailing commas.
	  'comma-dangle': OFF,
	
	  // Enforce consistent spacing before and after commas.
	  // Google ES6 Section 4.6.2
	  'comma-spacing': ERROR,
	
	  // Enforce consistent comma style.
	  // Google ES6 Section 4.5.1
	  'comma-style': [ERROR, 'last'],
	
	  // Enforce consistent spacing inside computed property brackets.
	  'computed-property-spacing': OFF,
	
	  // Enforce consistent naming when capturing the current execution context.
	  'consistent-this': OFF,
	
	  // Enforce at least one newline at the end of files.
	  'eol-last': [ERROR, 'unix'],
	
	  // Require or disallow spacing between function identifiers and their
	  // invocations.
	  // Google ES6 Section 4.6.2
	  'func-call-spacing': [ERROR, 'never'],
	
	  // Require or disallow named function expressions.
	  'func-names': OFF,
	
	  // Enforce the consistent use of either function declarations or expressions.
	  'func-style': OFF,
	
	  // Disallow specified identifiers.
	  'id-blacklist': OFF,
	
	  // Enforce minimum and maximum identifier lengths.
	  'id-length': OFF,
	
	  // Require identifiers to match a specified regular expression.
	  'id-match': OFF,
	
	  // Enforce consistent indentation.
	  // Disabled because the googlejs/indent supports goog.scope.
	  'indent': OFF,
	
	  // Enforce the consistent use of either double or single quotes in JSX
	  // attributes.
	  'jsx-quotes': OFF,
	
	  // Enforce consistent spacing between keys and values in object literal
	  // properties.
	  // Google ES6 Section 4.6.2
	  'key-spacing': [WARNING, {
	    beforeColon: false,
	    afterColon: true,
	    mode: 'strict' }],
	
	  // Enforce consistent spacing before and after keywords.
	  // Google ES6 Section 4.6.2
	  'keyword-spacing': ERROR,
	
	  // Enforce consistent linebreak style.
	  'linebreak-style': OFF,
	
	  // Require empty lines around comments.
	  'lines-around-comment': OFF,
	
	  // Enforce a maximum depth that blocks can be nested.
	  'max-depth': OFF,
	
	  // Enforce a maximum line length.
	  // Google ES6 Section 4.4, implied in ES5 guide.
	  'max-len': [ERROR, {
	    code: 80,
	    comments: 80,
	    ignorePattern: '(goog\\.(require|module|provide)|\\brequire)\\(',
	    ignoreComments: false,
	    ignoreUrls: true
	  }],
	
	  // Enforce a maximum number of lines per file.
	  'max-lines': OFF,
	
	  // Enforce a maximum depth that callbacks can be nested.
	  'max-nested-callbacks': OFF,
	
	  // Enforce a maximum number of parameters in function definitions.
	  'max-params': OFF,
	
	  // Enforce a maximum number of statements allowed per line.
	  // Google ES6 Section 4.3.1
	  'max-statements-per-line': [ERROR, { max: 1 }],
	
	  // Enforce a maximum number of statements allowed in function blocks.
	  'max-statements': OFF,
	
	  // Enforce newlines between operands of ternary expressions.
	  'multiline-ternary': OFF,
	
	  // Require constructor function names to begin with a capital letter.
	  'new-cap': OFF,
	
	  // Require parentheses when invoking a constructor with no arguments.
	  'new-parens': ERROR,
	
	  // Require or disallow an empty line after var declarations.
	  'newline-after-var': OFF,
	
	  // Require an empty line before return statements.
	  'newline-before-return': OFF,
	
	  // Require a newline after each call in a method chain.
	  'newline-per-chained-call': OFF,
	
	  // Disallow Array constructors.
	  // Google ES5 https://git.io/vured#Array_and_Object_literals
	  // Google ES6 Section 5.2.2
	  'no-array-constructor': ERROR,
	
	  // Disallow bitwise operators.
	  'no-bitwise': OFF,
	
	  // Disallow continue statements.
	  'no-continue': OFF,
	
	  // Disallow inline comments after code.
	  'no-inline-comments': OFF,
	
	  // Disallow if statements as the only statement in else blocks.
	  'no-lonely-if': OFF,
	
	  // Disallow mixed binary operators.
	  'no-mixed-operators': OFF,
	
	  // Disallow mixed spaces and tabs for indentation.  #eslint
	  'no-mixed-spaces-and-tabs': ERROR,
	
	  // Disallow multiple empty lines.
	  // Google ES6 Section 4.6.1. Allowed.
	  'no-multiple-empty-lines': OFF,
	
	  // Disallow negated conditions.
	  'no-negated-condition': OFF,
	
	  // Disallow nested ternary expressions.
	  'no-nested-ternary': OFF,
	
	  // Disallow Object constructors.
	  // Google ES6 Section 5.3.2
	  'no-new-object': [ERROR],
	
	  // Disallow the unary operators ++ and --.
	  'no-plusplus': OFF,
	
	  // Disallow specified syntax.
	  'no-restricted-syntax': OFF,
	
	  // Disallow tabs in file.
	  'no-tabs': OFF,
	
	  // Disallow ternary operators.
	  'no-ternary': OFF,
	
	  // Disallow trailing whitespace at the end of lines.
	  // Google ES6 Section 4.6.2
	  'no-trailing-spaces': ERROR,
	
	  // Disallow dangling underscores in identifiers.
	  'no-underscore-dangle': OFF,
	
	  // Disallow ternary operators when simpler alternatives exist.
	  'no-unneeded-ternary': OFF,
	
	  // Disallow whitespace before properties.
	  // Google ES6 Section 4.3.2
	  'no-whitespace-before-property': ERROR,
	
	  // Enforce consistent line breaks inside braces.
	  'object-curly-newline': OFF,
	
	  // Enforce consistent spacing inside braces.
	  // Google ES5 https://git.io/vured#Code_formatting
	  // Google ES6 Section 4.2.2
	  'object-curly-spacing': [ERROR, 'never'],
	
	  // Enforce placing object properties on separate lines.
	  'object-property-newline': OFF,
	
	  // Require or disallow newlines around var declarations.
	  'one-var-declaration-per-line': OFF,
	
	  // Enforce variables to be declared either together or separately in
	  // functions.
	  // Google ES5 assumed to follow ES6
	  // Google ES6 Section 5.1.2
	  'one-var': [ERROR, {
	    const: 'never',
	    var: 'never',
	    let: 'never'
	  }],
	
	  // Require or disallow assignment operator shorthand where possible.
	  'operator-assignment': OFF,
	
	  // Enforce consistent linebreak style for operators.
	  // Google ES6 Section 4.5.1
	  'operator-linebreak': [ERROR, 'after'],
	
	  // Require or disallow padding within blocks.
	  'padded-blocks': OFF,
	
	  // Require quotes around object literal property names.
	  // Google ES6 Section 5.3.3
	  'quote-props': [WARNING, 'consistent-as-needed'],
	
	  // Enforce the consistent use of either backticks, double, or single quotes.
	  // Google ES5 https://git.io/vured#Strings
	  // Google ES6 Section 5.6.1, 5.6.2
	  'quotes': [ERROR, 'single', {
	    avoidEscape: true,
	    allowTemplateLiterals: true
	  }],
	
	  // Require JSDoc comments.
	  'require-jsdoc': OFF,
	
	  // Enforce consistent spacing before and after semicolons.
	  'semi-spacing': ERROR,
	
	  // Require or disallow semicolons instead of ASI.
	  // Google ES5 https://git.io/vured#Strings#Semicolons
	  // Google ES6 Section 4.3.2
	  'semi': [ERROR, 'always'],
	
	  // Requires object keys to be sorted.
	  'sort-keys': OFF,
	
	  // Require variables within the same declaration block to be sorted.
	  'sort-vars': OFF,
	
	  // Enforce consistent spacing before blocks.
	  // Google ES6 Section 4.6.2
	  'space-before-blocks': [ERROR, 'always'],
	
	  // Enforce consistent spacing before function definition opening parenthesis.
	  // Google ES6 Section 4.6.2
	  'space-before-function-paren': [ERROR, 'never'],
	
	  // Enforce consistent spacing inside parentheses.
	  // Google ES6 Section 4.6.2
	  'space-in-parens': [ERROR, 'never'],
	
	  // Require spacing around operators.
	  // Google ES6 Section 5.5.5.1
	  'space-infix-ops': [ERROR, { int32Hint: true }],
	
	  // Enforce consistent spacing before or after unary operators.
	  // Google ES6 Section 4.6.2
	  'space-unary-ops': [ERROR, {
	    words: true,
	    nonwords: false
	  }],
	
	  // Enforce consistent spacing after the // or /* in a comment.
	  // Google ES6 Section 4.3.2
	  'spaced-comment': [ERROR, 'always', {
	    block: {
	      balanced: true
	    }
	  }],
	
	  // Require or disallow Unicode byte order mark (BOM).
	  'unicode-bom': OFF,
	
	  // Require parenthesis around regex literals.
	  'wrap-regex': OFF
	};
	
	// ECMAScript 6
	// These rules relate to ES6, also known as ES2015.
	//
	// We apply ES6 rules to the base config to allow code bases to slowly migrate
	// to ES6.  The only rules specified here are those that are legal in both the
	// ES5 and ES6 style guides.
	var ES6_RULES = {
	  // Require braces around arrow function bodies.
	  'arrow-body-style': OFF,
	
	  // Require parentheses around arrow function arguments.
	  'arrow-parens': OFF,
	
	  // Enforce consistent spacing before and after the arrow in arrow functions.
	  // Google ES6 Section ?
	  'arrow-spacing': [WARNING, {
	    before: true,
	    after: true
	  }],
	
	  // Require super() calls in constructors.  #eslint
	  // Google ES6 Section 5.4.1
	  'constructor-super': ERROR,
	
	  // Enforce consistent spacing around * operators in generator functions.
	  // Google ES6 Section 5.5.4
	  'generator-star-spacing': [WARNING, 'after'],
	
	  // Disallow reassigning class members.  #eslint
	  'no-class-assign': ERROR,
	
	  // Disallow arrow functions where they could be confused with comparisons.
	  'no-confusing-arrow': OFF,
	
	  // Disallow reassigning const variables.  #eslint
	  'no-const-assign': ERROR,
	
	  // Disallow duplicate class members.  #eslint
	  'no-dupe-class-members': ERROR,
	
	  // Disallow duplicate module imports.
	  'no-duplicate-imports': OFF,
	
	  // Disallow new operators with the Symbol object.  #eslint
	  'no-new-symbol': ERROR,
	
	  // Disallow specified modules when loaded by import.
	  'no-restricted-imports': OFF,
	
	  // Disallow this/super before calling super() in constructors.  #eslint
	  'no-this-before-super': ERROR,
	
	  // Disallow unnecessary computed property keys in object literals.
	  // Google ES6 Section 5.3.4
	  'no-useless-computed-key': ERROR,
	
	  // Disallow unnecessary constructors.
	  'no-useless-constructor': OFF,
	
	  // Disallow renaming import, export, and destructured assignments to the same
	  // name.
	  'no-useless-rename': OFF,
	
	  // Require let or const instead of var.
	  'no-var': OFF,
	
	  // Require or disallow method and property shorthand syntax for object
	  // literals.
	  'object-shorthand': OFF,
	
	  // Require arrow functions as callbacks.
	  'prefer-arrow-callback': OFF,
	
	  // Require const declarations for variables that are never reassigned after
	  // declared.
	  'prefer-const': OFF,
	
	  // Require Reflect methods where applicable.
	  'prefer-reflect': OFF,
	
	  // Require rest parameters instead of arguments.
	  'prefer-rest-params': OFF,
	
	  // Require spread operators instead of .apply().
	  // Google ES6 Section 5.5.8
	  'prefer-spread': WARNING,
	
	  // Require template literals instead of string concatenation.
	  'prefer-template': OFF,
	
	  // Require generator functions to contain yield.  #eslint
	  'require-yield': ERROR,
	
	  // Enforce spacing between rest and spread operators and their expressions.
	  // Google ES6 Section 5.2.5
	  'rest-spread-spacing': [ERROR, 'never'],
	
	  // Enforce sorted import declarations within modules.
	  'sort-imports': OFF,
	
	  // Require or disallow spacing around embedded expressions of template
	  // strings.
	  'template-curly-spacing': OFF,
	
	  // Require or disallow spacing around the * in yield* expressions.
	  // Google ES6 Section 5.5.4
	  'yield-star-spacing': [WARNING, 'after']
	};
	
	// Google Plugin Rules
	// These rules are specific to Google code.  See
	// https://github.com/jschaf/googlejs/packages/eslint-plugin-googlejs
	var GOOGLE_PLUGIN_RULES = {
	  'googlejs/indent': [WARNING, 2, {
	    // Google ES6 Section 4.2.5
	    SwitchCase: 1,
	    // Google ES6 Section 4.5.1
	    MemberExpression: 2,
	    // Google ES5: Aliasing with goog.scope
	    outerIIFEBody: 0
	  }],
	  'googlejs/jsdoc': [WARNING, {
	    prefer: {
	      returns: 'return',
	      arg: 'param',
	      argument: 'param'
	    },
	    preferType: {
	      String: 'string',
	      Boolean: 'boolean',
	      Number: 'number',
	      Function: 'function'
	
	    },
	    requireReturn: false,
	    requireReturnType: false,
	    matchDescription: undefined,
	    requireParamDescription: false,
	    requireReturnDescription: false
	  }],
	  'googlejs/no-undef': ERROR,
	  'googlejs/no-unused-expressions': ERROR
	};
	
	// JSDoc Plugin Rules
	// https://github.com/gajus/eslint-plugin-jsdoc
	var JSDOC_PLUGIN_RULES = {
	  // Ensures that parameter names in JSDoc match those in the function
	  // declaration.
	  'jsdoc/check-param-names': ERROR,
	
	  // Reports invalid block tag names.
	  // Disabled because it doesn't support custom tags.
	  'jsdoc/check-tag-names': OFF,
	
	  // Disallows object wrapper types.
	  'jsdoc/check-types': ERROR,
	
	  // Enforces a consistent padding of the block description.  Not required by
	  // the style guide.
	  'jsdoc/newline-after-description': OFF,
	
	  // Requires that block description and tag description are written in complete
	  // sentences.
	  // TODO(jschaf): too many spurious warnings.  It doesn't detect HTML tags.
	  'jsdoc/require-description-complete-sentence': OFF,
	
	  // Requires a hyphen before the @param description.  This doesn't match Google
	  // style.
	  'jsdoc/require-hyphen-before-param-description': OFF,
	
	  // Requires that all function parameters are documented.
	  'jsdoc/require-param': ERROR,
	
	  // Requires that @param tag has description value.
	  // Google ES6 Section 7.8 - descriptions may be omitted.
	  'jsdoc/require-param-description': OFF,
	
	  // Requires that @param tag has type value.
	  // Google ES6 Section 7.8 - types must be included.
	  'jsdoc/require-param-type': ERROR,
	
	  // Requires that @returns tag has description value.
	  // Google ES6 Section 7.8 - descriptions may be omitted.
	  'jsdoc/require-returns-description': OFF,
	
	  // Requires that @returns tag has type value.
	  'jsdoc/require-returns-type': ERROR
	};
	
	// ESLint configuration object.  Options are described at
	// http://eslint.org/docs/user-guide/configuring.
	var ESLINT_CONFIG = {
	
	  parserOptions: {
	    ecmaVersion: 5,
	    sourceType: 'script'
	  },
	
	  parser: 'espree',
	
	  // An environment defines global variables that are predefined.
	  env: {
	    browser: true
	  },
	
	  globals: {
	    goog: true
	  },
	
	  plugins: [
	  // https://github.com/gajus/eslint-plugin-jsdoc
	  'jsdoc',
	  // https://github.com/jschaf/eslint-config-google
	  'googlejs'],
	
	  // The list of rules and options are available at
	  // http://eslint.org/docs/rules/.
	  rules: Object.assign({},
	
	  // ESLint built-in rules.
	  POSSIBLE_ERROR_RULES, BEST_PRACTICE_RULES, STRICT_MODE_RULES, VARIABLE_DECLARATION_RULES, NODEJS_RULES, STYLISTIC_RULES, ES6_RULES,
	
	  // Custom plugin rules.
	  GOOGLE_PLUGIN_RULES),
	
	  // ESLint supports adding shared settings into configuration file.  The
	  // settings object will be supplied to every rule that will be executed.
	  settings: {
	    jsdoc: {
	      additionalTagNames: {
	        customTags: GOOGLE_CUSTOM_JSDOC_TAGS.concat(CLOSURE_JSDOC_TAGS)
	      },
	      tagNamePreference: {
	        returns: 'return'
	      }
	    }
	  }
	};
	
	module.exports = ESLINT_CONFIG;

/***/ }
/******/ ]);
//# sourceMappingURL=app.bundle.js.map